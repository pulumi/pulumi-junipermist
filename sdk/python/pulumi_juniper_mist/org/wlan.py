# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['WlanArgs', 'Wlan']

@pulumi.input_type
class WlanArgs:
    def __init__(__self__, *,
                 org_id: pulumi.Input[builtins.str],
                 ssid: pulumi.Input[builtins.str],
                 template_id: pulumi.Input[builtins.str],
                 acct_immediate_update: Optional[pulumi.Input[builtins.bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[builtins.int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]] = None,
                 airwatch: Optional[pulumi.Input['WlanAirwatchArgs']] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_mdns: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[builtins.bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 app_limit: Optional[pulumi.Input['WlanAppLimitArgs']] = None,
                 app_qos: Optional[pulumi.Input['WlanAppQosArgs']] = None,
                 apply_to: Optional[pulumi.Input[builtins.str]] = None,
                 arp_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 auth: Optional[pulumi.Input['WlanAuthArgs']] = None,
                 auth_server_selection: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[builtins.int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 band_steer: Optional[pulumi.Input[builtins.bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[builtins.bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[builtins.bool]] = None,
                 bonjour: Optional[pulumi.Input['WlanBonjourArgs']] = None,
                 cisco_cwa: Optional[pulumi.Input['WlanCiscoCwaArgs']] = None,
                 client_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 client_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]] = None,
                 disable11ax: Optional[pulumi.Input[builtins.bool]] = None,
                 disable11be: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_gateway_unreachable: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_mxtunnel_down: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_wmm: Optional[pulumi.Input[builtins.bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input['WlanDnsServerRewriteArgs']] = None,
                 dtim: Optional[pulumi.Input[builtins.int]] = None,
                 dynamic_psk: Optional[pulumi.Input['WlanDynamicPskArgs']] = None,
                 dynamic_vlan: Optional[pulumi.Input['WlanDynamicVlanArgs']] = None,
                 enable_local_keycaching: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[builtins.bool]] = None,
                 hide_ssid: Optional[pulumi.Input[builtins.bool]] = None,
                 hostname_ie: Optional[pulumi.Input[builtins.bool]] = None,
                 hotspot20: Optional[pulumi.Input['WlanHotspot20Args']] = None,
                 inject_dhcp_option82: Optional[pulumi.Input['WlanInjectDhcpOption82Args']] = None,
                 interface: Optional[pulumi.Input[builtins.str]] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 l2_isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 legacy_overds: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_bcast: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[builtins.bool]] = None,
                 max_idletime: Optional[pulumi.Input[builtins.int]] = None,
                 max_num_clients: Optional[pulumi.Input[builtins.int]] = None,
                 mist_nac: Optional[pulumi.Input['WlanMistNacArgs']] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[builtins.bool]] = None,
                 no_static_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 portal: Optional[pulumi.Input['WlanPortalArgs']] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 qos: Optional[pulumi.Input['WlanQosArgs']] = None,
                 radsec: Optional[pulumi.Input['WlanRadsecArgs']] = None,
                 rateset: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]]] = None,
                 reconnect_clients_when_roaming_mxcluster: Optional[pulumi.Input[builtins.bool]] = None,
                 roam_mode: Optional[pulumi.Input[builtins.str]] = None,
                 schedule: Optional[pulumi.Input['WlanScheduleArgs']] = None,
                 sle_excluded: Optional[pulumi.Input[builtins.bool]] = None,
                 use_eapol_v1: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[builtins.str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The set of arguments for constructing a Wlan resource.
        :param pulumi.Input[builtins.str] ssid: Name of the SSID
        :param pulumi.Input[builtins.bool] acct_immediate_update: Enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[builtins.int] acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]] acct_servers: List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input['WlanAirwatchArgs'] airwatch: Airwatch wlan settings
        :param pulumi.Input[builtins.bool] allow_ipv6_ndp: Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[builtins.bool] allow_mdns: Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[builtins.bool] allow_ssdp: Only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ap_ids: List of device ids
        :param pulumi.Input['WlanAppLimitArgs'] app_limit: Bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input['WlanAppQosArgs'] app_qos: APp qos wlan settings
        :param pulumi.Input[builtins.str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[builtins.bool] arp_filter: Whether to enable smart arp filter
        :param pulumi.Input['WlanAuthArgs'] auth: Authentication wlan settings
        :param pulumi.Input[builtins.str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]] auth_servers: List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[builtins.str] auth_servers_nas_id: Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[builtins.str] auth_servers_nas_ip: Optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[builtins.int] auth_servers_retries: Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
               to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
               value to 3.
        :param pulumi.Input[builtins.int] auth_servers_timeout: Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
               and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
               setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[builtins.bool] band_steer: Whether to enable band_steering, this works only when band==both
        :param pulumi.Input[builtins.bool] band_steer_force_band5: Force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] block_blacklist_clients: Whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input['WlanBonjourArgs'] bonjour: Bonjour gateway wlan settings
        :param pulumi.Input['WlanCiscoCwaArgs'] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[builtins.bool] client_limit_down_enabled: If downlink limiting per-client is enabled
        :param pulumi.Input[builtins.bool] client_limit_up_enabled: If uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]] coa_servers: List of COA (change of authorization) servers, optional
        :param pulumi.Input[builtins.bool] disable11ax: Some old WLAN drivers may not be compatible
        :param pulumi.Input[builtins.bool] disable11be: To disable Wi-Fi 7 EHT IEs
        :param pulumi.Input[builtins.bool] disable_ht_vht_rates: To disable ht or vht rates
        :param pulumi.Input[builtins.bool] disable_uapsd: Whether to disable U-APSD
        :param pulumi.Input[builtins.bool] disable_v1_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_v2_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_when_gateway_unreachable: When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
               reach default gateway
        :param pulumi.Input[builtins.bool] disable_wmm: Whether to disable WMM
        :param pulumi.Input['WlanDnsServerRewriteArgs'] dns_server_rewrite: For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input['WlanDynamicPskArgs'] dynamic_psk: For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input['WlanDynamicVlanArgs'] dynamic_vlan: For 802.1x
        :param pulumi.Input[builtins.bool] enable_local_keycaching: Enable AP-AP keycaching via multicast
        :param pulumi.Input[builtins.bool] enable_wireless_bridging: By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        :param pulumi.Input[builtins.bool] enable_wireless_bridging_dhcp_tracking: If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[builtins.bool] enabled: If this wlan is enabled
        :param pulumi.Input[builtins.bool] fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[builtins.bool] hide_ssid: Whether to hide SSID in beacon
        :param pulumi.Input[builtins.bool] hostname_ie: Include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input['WlanHotspot20Args'] hotspot20: Hostspot 2.0 wlan settings
        :param pulumi.Input[builtins.str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[builtins.bool] isolation: Whether to stop clients to talk to each other
        :param pulumi.Input[builtins.bool] l2_isolation: If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[builtins.bool] legacy_overds: Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[builtins.bool] limit_bcast: Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[builtins.bool] limit_probe_response: Limit probe response base on some heuristic rules
        :param pulumi.Input[builtins.int] max_idletime: Max idle time in seconds
        :param pulumi.Input[builtins.int] max_num_clients: Maximum number of client connected to the SSID. `0` means unlimited
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_ids: When `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_names: When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[builtins.bool] no_static_dns: Whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[builtins.bool] no_static_ip: Whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input['WlanPortalArgs'] portal: Portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_subnets: List of CIDRs
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_denied_hostnames: List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input['WlanRadsecArgs'] radsec: RadSec settings
        :param pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]] rateset: Property key is the RF band. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] reconnect_clients_when_roaming_mxcluster: When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        :param pulumi.Input[builtins.str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input['WlanScheduleArgs'] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[builtins.bool] sle_excluded: Whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[builtins.bool] use_eapol_v1: If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[builtins.bool] vlan_enabled: If vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vlan_ids: if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        :param pulumi.Input[builtins.bool] vlan_pooling: Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
               deterministic algorithm
        :param pulumi.Input[builtins.bool] wlan_limit_down_enabled: If downlink limiting for whole wlan is enabled
        :param pulumi.Input[builtins.bool] wlan_limit_up_enabled: If uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wxtag_ids: List of wxtag_ids
        :param pulumi.Input[builtins.str] wxtunnel_id: When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[builtins.str] wxtunnel_remote_id: When `interface`=`wxtunnel`, remote tunnel identifier
        """
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "ssid", ssid)
        pulumi.set(__self__, "template_id", template_id)
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if airwatch is not None:
            pulumi.set(__self__, "airwatch", airwatch)
        if allow_ipv6_ndp is not None:
            pulumi.set(__self__, "allow_ipv6_ndp", allow_ipv6_ndp)
        if allow_mdns is not None:
            pulumi.set(__self__, "allow_mdns", allow_mdns)
        if allow_ssdp is not None:
            pulumi.set(__self__, "allow_ssdp", allow_ssdp)
        if ap_ids is not None:
            pulumi.set(__self__, "ap_ids", ap_ids)
        if app_limit is not None:
            pulumi.set(__self__, "app_limit", app_limit)
        if app_qos is not None:
            pulumi.set(__self__, "app_qos", app_qos)
        if apply_to is not None:
            pulumi.set(__self__, "apply_to", apply_to)
        if arp_filter is not None:
            pulumi.set(__self__, "arp_filter", arp_filter)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_nas_id is not None:
            pulumi.set(__self__, "auth_servers_nas_id", auth_servers_nas_id)
        if auth_servers_nas_ip is not None:
            pulumi.set(__self__, "auth_servers_nas_ip", auth_servers_nas_ip)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if band_steer is not None:
            pulumi.set(__self__, "band_steer", band_steer)
        if band_steer_force_band5 is not None:
            pulumi.set(__self__, "band_steer_force_band5", band_steer_force_band5)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if block_blacklist_clients is not None:
            pulumi.set(__self__, "block_blacklist_clients", block_blacklist_clients)
        if bonjour is not None:
            pulumi.set(__self__, "bonjour", bonjour)
        if cisco_cwa is not None:
            pulumi.set(__self__, "cisco_cwa", cisco_cwa)
        if client_limit_down is not None:
            pulumi.set(__self__, "client_limit_down", client_limit_down)
        if client_limit_down_enabled is not None:
            pulumi.set(__self__, "client_limit_down_enabled", client_limit_down_enabled)
        if client_limit_up is not None:
            pulumi.set(__self__, "client_limit_up", client_limit_up)
        if client_limit_up_enabled is not None:
            pulumi.set(__self__, "client_limit_up_enabled", client_limit_up_enabled)
        if coa_servers is not None:
            pulumi.set(__self__, "coa_servers", coa_servers)
        if disable11ax is not None:
            pulumi.set(__self__, "disable11ax", disable11ax)
        if disable11be is not None:
            pulumi.set(__self__, "disable11be", disable11be)
        if disable_ht_vht_rates is not None:
            pulumi.set(__self__, "disable_ht_vht_rates", disable_ht_vht_rates)
        if disable_uapsd is not None:
            pulumi.set(__self__, "disable_uapsd", disable_uapsd)
        if disable_v1_roam_notify is not None:
            pulumi.set(__self__, "disable_v1_roam_notify", disable_v1_roam_notify)
        if disable_v2_roam_notify is not None:
            pulumi.set(__self__, "disable_v2_roam_notify", disable_v2_roam_notify)
        if disable_when_gateway_unreachable is not None:
            pulumi.set(__self__, "disable_when_gateway_unreachable", disable_when_gateway_unreachable)
        if disable_when_mxtunnel_down is not None:
            pulumi.set(__self__, "disable_when_mxtunnel_down", disable_when_mxtunnel_down)
        if disable_wmm is not None:
            pulumi.set(__self__, "disable_wmm", disable_wmm)
        if dns_server_rewrite is not None:
            pulumi.set(__self__, "dns_server_rewrite", dns_server_rewrite)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if dynamic_psk is not None:
            pulumi.set(__self__, "dynamic_psk", dynamic_psk)
        if dynamic_vlan is not None:
            pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        if enable_local_keycaching is not None:
            pulumi.set(__self__, "enable_local_keycaching", enable_local_keycaching)
        if enable_wireless_bridging is not None:
            pulumi.set(__self__, "enable_wireless_bridging", enable_wireless_bridging)
        if enable_wireless_bridging_dhcp_tracking is not None:
            pulumi.set(__self__, "enable_wireless_bridging_dhcp_tracking", enable_wireless_bridging_dhcp_tracking)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if hide_ssid is not None:
            pulumi.set(__self__, "hide_ssid", hide_ssid)
        if hostname_ie is not None:
            pulumi.set(__self__, "hostname_ie", hostname_ie)
        if hotspot20 is not None:
            pulumi.set(__self__, "hotspot20", hotspot20)
        if inject_dhcp_option82 is not None:
            pulumi.set(__self__, "inject_dhcp_option82", inject_dhcp_option82)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if l2_isolation is not None:
            pulumi.set(__self__, "l2_isolation", l2_isolation)
        if legacy_overds is not None:
            pulumi.set(__self__, "legacy_overds", legacy_overds)
        if limit_bcast is not None:
            pulumi.set(__self__, "limit_bcast", limit_bcast)
        if limit_probe_response is not None:
            pulumi.set(__self__, "limit_probe_response", limit_probe_response)
        if max_idletime is not None:
            pulumi.set(__self__, "max_idletime", max_idletime)
        if max_num_clients is not None:
            pulumi.set(__self__, "max_num_clients", max_num_clients)
        if mist_nac is not None:
            pulumi.set(__self__, "mist_nac", mist_nac)
        if mxtunnel_ids is not None:
            pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        if mxtunnel_names is not None:
            pulumi.set(__self__, "mxtunnel_names", mxtunnel_names)
        if no_static_dns is not None:
            pulumi.set(__self__, "no_static_dns", no_static_dns)
        if no_static_ip is not None:
            pulumi.set(__self__, "no_static_ip", no_static_ip)
        if portal is not None:
            pulumi.set(__self__, "portal", portal)
        if portal_allowed_hostnames is not None:
            pulumi.set(__self__, "portal_allowed_hostnames", portal_allowed_hostnames)
        if portal_allowed_subnets is not None:
            pulumi.set(__self__, "portal_allowed_subnets", portal_allowed_subnets)
        if portal_denied_hostnames is not None:
            pulumi.set(__self__, "portal_denied_hostnames", portal_denied_hostnames)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if radsec is not None:
            pulumi.set(__self__, "radsec", radsec)
        if rateset is not None:
            pulumi.set(__self__, "rateset", rateset)
        if reconnect_clients_when_roaming_mxcluster is not None:
            pulumi.set(__self__, "reconnect_clients_when_roaming_mxcluster", reconnect_clients_when_roaming_mxcluster)
        if roam_mode is not None:
            pulumi.set(__self__, "roam_mode", roam_mode)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if sle_excluded is not None:
            pulumi.set(__self__, "sle_excluded", sle_excluded)
        if use_eapol_v1 is not None:
            pulumi.set(__self__, "use_eapol_v1", use_eapol_v1)
        if vlan_enabled is not None:
            pulumi.set(__self__, "vlan_enabled", vlan_enabled)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)
        if vlan_pooling is not None:
            pulumi.set(__self__, "vlan_pooling", vlan_pooling)
        if wlan_limit_down is not None:
            pulumi.set(__self__, "wlan_limit_down", wlan_limit_down)
        if wlan_limit_down_enabled is not None:
            pulumi.set(__self__, "wlan_limit_down_enabled", wlan_limit_down_enabled)
        if wlan_limit_up is not None:
            pulumi.set(__self__, "wlan_limit_up", wlan_limit_up)
        if wlan_limit_up_enabled is not None:
            pulumi.set(__self__, "wlan_limit_up_enabled", wlan_limit_up_enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)
        if wxtunnel_id is not None:
            pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        if wxtunnel_remote_id is not None:
            pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def ssid(self) -> pulumi.Input[builtins.str]:
        """
        Name of the SSID
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssid", value)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "template_id", value)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @acct_immediate_update.setter
    def acct_immediate_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "acct_immediate_update", value)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]:
        """
        List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter
    def airwatch(self) -> Optional[pulumi.Input['WlanAirwatchArgs']]:
        """
        Airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @airwatch.setter
    def airwatch(self, value: Optional[pulumi.Input['WlanAirwatchArgs']]):
        pulumi.set(self, "airwatch", value)

    @property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @allow_ipv6_ndp.setter
    def allow_ipv6_ndp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ipv6_ndp", value)

    @property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @allow_mdns.setter
    def allow_mdns(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_mdns", value)

    @property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @allow_ssdp.setter
    def allow_ssdp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ssdp", value)

    @property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of device ids
        """
        return pulumi.get(self, "ap_ids")

    @ap_ids.setter
    def ap_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ap_ids", value)

    @property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> Optional[pulumi.Input['WlanAppLimitArgs']]:
        """
        Bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @app_limit.setter
    def app_limit(self, value: Optional[pulumi.Input['WlanAppLimitArgs']]):
        pulumi.set(self, "app_limit", value)

    @property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> Optional[pulumi.Input['WlanAppQosArgs']]:
        """
        APp qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @app_qos.setter
    def app_qos(self, value: Optional[pulumi.Input['WlanAppQosArgs']]):
        pulumi.set(self, "app_qos", value)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @apply_to.setter
    def apply_to(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "apply_to", value)

    @property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @arp_filter.setter
    def arp_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "arp_filter", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['WlanAuthArgs']]:
        """
        Authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['WlanAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @auth_server_selection.setter
    def auth_server_selection(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_server_selection", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]:
        """
        List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @auth_servers_nas_id.setter
    def auth_servers_nas_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_servers_nas_id", value)

    @property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @auth_servers_nas_ip.setter
    def auth_servers_nas_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_servers_nas_ip", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
        to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
        value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
        and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
        setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @band_steer.setter
    def band_steer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "band_steer", value)

    @property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @band_steer_force_band5.setter
    def band_steer_force_band5(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "band_steer_force_band5", value)

    @property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "bands", value)

    @property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @block_blacklist_clients.setter
    def block_blacklist_clients(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_blacklist_clients", value)

    @property
    @pulumi.getter
    def bonjour(self) -> Optional[pulumi.Input['WlanBonjourArgs']]:
        """
        Bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @bonjour.setter
    def bonjour(self, value: Optional[pulumi.Input['WlanBonjourArgs']]):
        pulumi.set(self, "bonjour", value)

    @property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> Optional[pulumi.Input['WlanCiscoCwaArgs']]:
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @cisco_cwa.setter
    def cisco_cwa(self, value: Optional[pulumi.Input['WlanCiscoCwaArgs']]):
        pulumi.set(self, "cisco_cwa", value)

    @property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_limit_down")

    @client_limit_down.setter
    def client_limit_down(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_limit_down", value)

    @property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @client_limit_down_enabled.setter
    def client_limit_down_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "client_limit_down_enabled", value)

    @property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_limit_up")

    @client_limit_up.setter
    def client_limit_up(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_limit_up", value)

    @property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @client_limit_up_enabled.setter
    def client_limit_up_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "client_limit_up_enabled", value)

    @property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]:
        """
        List of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @coa_servers.setter
    def coa_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]):
        pulumi.set(self, "coa_servers", value)

    @property
    @pulumi.getter
    def disable11ax(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @disable11ax.setter
    def disable11ax(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable11ax", value)

    @property
    @pulumi.getter
    def disable11be(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To disable Wi-Fi 7 EHT IEs
        """
        return pulumi.get(self, "disable11be")

    @disable11be.setter
    def disable11be(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable11be", value)

    @property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @disable_ht_vht_rates.setter
    def disable_ht_vht_rates(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_ht_vht_rates", value)

    @property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @disable_uapsd.setter
    def disable_uapsd(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_uapsd", value)

    @property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @disable_v1_roam_notify.setter
    def disable_v1_roam_notify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_v1_roam_notify", value)

    @property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @disable_v2_roam_notify.setter
    def disable_v2_roam_notify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_v2_roam_notify", value)

    @property
    @pulumi.getter(name="disableWhenGatewayUnreachable")
    def disable_when_gateway_unreachable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
        reach default gateway
        """
        return pulumi.get(self, "disable_when_gateway_unreachable")

    @disable_when_gateway_unreachable.setter
    def disable_when_gateway_unreachable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_when_gateway_unreachable", value)

    @property
    @pulumi.getter(name="disableWhenMxtunnelDown")
    def disable_when_mxtunnel_down(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disable_when_mxtunnel_down")

    @disable_when_mxtunnel_down.setter
    def disable_when_mxtunnel_down(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_when_mxtunnel_down", value)

    @property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @disable_wmm.setter
    def disable_wmm(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_wmm", value)

    @property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> Optional[pulumi.Input['WlanDnsServerRewriteArgs']]:
        """
        For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @dns_server_rewrite.setter
    def dns_server_rewrite(self, value: Optional[pulumi.Input['WlanDnsServerRewriteArgs']]):
        pulumi.set(self, "dns_server_rewrite", value)

    @property
    @pulumi.getter
    def dtim(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "dtim")

    @dtim.setter
    def dtim(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dtim", value)

    @property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> Optional[pulumi.Input['WlanDynamicPskArgs']]:
        """
        For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @dynamic_psk.setter
    def dynamic_psk(self, value: Optional[pulumi.Input['WlanDynamicPskArgs']]):
        pulumi.set(self, "dynamic_psk", value)

    @property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> Optional[pulumi.Input['WlanDynamicVlanArgs']]:
        """
        For 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @dynamic_vlan.setter
    def dynamic_vlan(self, value: Optional[pulumi.Input['WlanDynamicVlanArgs']]):
        pulumi.set(self, "dynamic_vlan", value)

    @property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @enable_local_keycaching.setter
    def enable_local_keycaching(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_local_keycaching", value)

    @property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @enable_wireless_bridging.setter
    def enable_wireless_bridging(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_wireless_bridging", value)

    @property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @enable_wireless_bridging_dhcp_tracking.setter
    def enable_wireless_bridging_dhcp_tracking(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_wireless_bridging_dhcp_tracking", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @fast_dot1x_timers.setter
    def fast_dot1x_timers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fast_dot1x_timers", value)

    @property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @hide_ssid.setter
    def hide_ssid(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hide_ssid", value)

    @property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @hostname_ie.setter
    def hostname_ie(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hostname_ie", value)

    @property
    @pulumi.getter
    def hotspot20(self) -> Optional[pulumi.Input['WlanHotspot20Args']]:
        """
        Hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @hotspot20.setter
    def hotspot20(self, value: Optional[pulumi.Input['WlanHotspot20Args']]):
        pulumi.set(self, "hotspot20", value)

    @property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> Optional[pulumi.Input['WlanInjectDhcpOption82Args']]:
        return pulumi.get(self, "inject_dhcp_option82")

    @inject_dhcp_option82.setter
    def inject_dhcp_option82(self, value: Optional[pulumi.Input['WlanInjectDhcpOption82Args']]):
        pulumi.set(self, "inject_dhcp_option82", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @l2_isolation.setter
    def l2_isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "l2_isolation", value)

    @property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @legacy_overds.setter
    def legacy_overds(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "legacy_overds", value)

    @property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @limit_bcast.setter
    def limit_bcast(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "limit_bcast", value)

    @property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @limit_probe_response.setter
    def limit_probe_response(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "limit_probe_response", value)

    @property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @max_idletime.setter
    def max_idletime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_idletime", value)

    @property
    @pulumi.getter(name="maxNumClients")
    def max_num_clients(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of client connected to the SSID. `0` means unlimited
        """
        return pulumi.get(self, "max_num_clients")

    @max_num_clients.setter
    def max_num_clients(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_num_clients", value)

    @property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> Optional[pulumi.Input['WlanMistNacArgs']]:
        return pulumi.get(self, "mist_nac")

    @mist_nac.setter
    def mist_nac(self, value: Optional[pulumi.Input['WlanMistNacArgs']]):
        pulumi.set(self, "mist_nac", value)

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @mxtunnel_ids.setter
    def mxtunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mxtunnel_ids", value)

    @property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @mxtunnel_names.setter
    def mxtunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mxtunnel_names", value)

    @property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @no_static_dns.setter
    def no_static_dns(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_static_dns", value)

    @property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @no_static_ip.setter
    def no_static_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_static_ip", value)

    @property
    @pulumi.getter
    def portal(self) -> Optional[pulumi.Input['WlanPortalArgs']]:
        """
        Portal wlan settings
        """
        return pulumi.get(self, "portal")

    @portal.setter
    def portal(self, value: Optional[pulumi.Input['WlanPortalArgs']]):
        pulumi.set(self, "portal", value)

    @property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @portal_allowed_hostnames.setter
    def portal_allowed_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "portal_allowed_hostnames", value)

    @property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @portal_allowed_subnets.setter
    def portal_allowed_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "portal_allowed_subnets", value)

    @property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @portal_denied_hostnames.setter
    def portal_denied_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "portal_denied_hostnames", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input['WlanQosArgs']]:
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input['WlanQosArgs']]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter
    def radsec(self) -> Optional[pulumi.Input['WlanRadsecArgs']]:
        """
        RadSec settings
        """
        return pulumi.get(self, "radsec")

    @radsec.setter
    def radsec(self, value: Optional[pulumi.Input['WlanRadsecArgs']]):
        pulumi.set(self, "radsec", value)

    @property
    @pulumi.getter
    def rateset(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]]]:
        """
        Property key is the RF band. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "rateset")

    @rateset.setter
    def rateset(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]]]):
        pulumi.set(self, "rateset", value)

    @property
    @pulumi.getter(name="reconnectClientsWhenRoamingMxcluster")
    def reconnect_clients_when_roaming_mxcluster(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        """
        return pulumi.get(self, "reconnect_clients_when_roaming_mxcluster")

    @reconnect_clients_when_roaming_mxcluster.setter
    def reconnect_clients_when_roaming_mxcluster(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "reconnect_clients_when_roaming_mxcluster", value)

    @property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @roam_mode.setter
    def roam_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "roam_mode", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['WlanScheduleArgs']]:
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['WlanScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @sle_excluded.setter
    def sle_excluded(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sle_excluded", value)

    @property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @use_eapol_v1.setter
    def use_eapol_v1(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_eapol_v1", value)

    @property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @vlan_enabled.setter
    def vlan_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "vlan_enabled", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        """
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vlan_ids", value)

    @property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
        deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @vlan_pooling.setter
    def vlan_pooling(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "vlan_pooling", value)

    @property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "wlan_limit_down")

    @wlan_limit_down.setter
    def wlan_limit_down(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wlan_limit_down", value)

    @property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @wlan_limit_down_enabled.setter
    def wlan_limit_down_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wlan_limit_down_enabled", value)

    @property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "wlan_limit_up")

    @wlan_limit_up.setter
    def wlan_limit_up(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wlan_limit_up", value)

    @property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @wlan_limit_up_enabled.setter
    def wlan_limit_up_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wlan_limit_up_enabled", value)

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @wxtag_ids.setter
    def wxtag_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wxtag_ids", value)

    @property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @wxtunnel_id.setter
    def wxtunnel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wxtunnel_id", value)

    @property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")

    @wxtunnel_remote_id.setter
    def wxtunnel_remote_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wxtunnel_remote_id", value)


@pulumi.input_type
class _WlanState:
    def __init__(__self__, *,
                 acct_immediate_update: Optional[pulumi.Input[builtins.bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[builtins.int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]] = None,
                 airwatch: Optional[pulumi.Input['WlanAirwatchArgs']] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_mdns: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[builtins.bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 app_limit: Optional[pulumi.Input['WlanAppLimitArgs']] = None,
                 app_qos: Optional[pulumi.Input['WlanAppQosArgs']] = None,
                 apply_to: Optional[pulumi.Input[builtins.str]] = None,
                 arp_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 auth: Optional[pulumi.Input['WlanAuthArgs']] = None,
                 auth_server_selection: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[builtins.int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 band_steer: Optional[pulumi.Input[builtins.bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[builtins.bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[builtins.bool]] = None,
                 bonjour: Optional[pulumi.Input['WlanBonjourArgs']] = None,
                 cisco_cwa: Optional[pulumi.Input['WlanCiscoCwaArgs']] = None,
                 client_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 client_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]] = None,
                 disable11ax: Optional[pulumi.Input[builtins.bool]] = None,
                 disable11be: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_gateway_unreachable: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_mxtunnel_down: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_wmm: Optional[pulumi.Input[builtins.bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input['WlanDnsServerRewriteArgs']] = None,
                 dtim: Optional[pulumi.Input[builtins.int]] = None,
                 dynamic_psk: Optional[pulumi.Input['WlanDynamicPskArgs']] = None,
                 dynamic_vlan: Optional[pulumi.Input['WlanDynamicVlanArgs']] = None,
                 enable_local_keycaching: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[builtins.bool]] = None,
                 hide_ssid: Optional[pulumi.Input[builtins.bool]] = None,
                 hostname_ie: Optional[pulumi.Input[builtins.bool]] = None,
                 hotspot20: Optional[pulumi.Input['WlanHotspot20Args']] = None,
                 inject_dhcp_option82: Optional[pulumi.Input['WlanInjectDhcpOption82Args']] = None,
                 interface: Optional[pulumi.Input[builtins.str]] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 l2_isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 legacy_overds: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_bcast: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[builtins.bool]] = None,
                 max_idletime: Optional[pulumi.Input[builtins.int]] = None,
                 max_num_clients: Optional[pulumi.Input[builtins.int]] = None,
                 mist_nac: Optional[pulumi.Input['WlanMistNacArgs']] = None,
                 msp_id: Optional[pulumi.Input[builtins.str]] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[builtins.bool]] = None,
                 no_static_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 portal: Optional[pulumi.Input['WlanPortalArgs']] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_api_secret: Optional[pulumi.Input[builtins.str]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_image: Optional[pulumi.Input[builtins.str]] = None,
                 portal_sso_url: Optional[pulumi.Input[builtins.str]] = None,
                 qos: Optional[pulumi.Input['WlanQosArgs']] = None,
                 radsec: Optional[pulumi.Input['WlanRadsecArgs']] = None,
                 rateset: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]]] = None,
                 reconnect_clients_when_roaming_mxcluster: Optional[pulumi.Input[builtins.bool]] = None,
                 roam_mode: Optional[pulumi.Input[builtins.str]] = None,
                 schedule: Optional[pulumi.Input['WlanScheduleArgs']] = None,
                 sle_excluded: Optional[pulumi.Input[builtins.bool]] = None,
                 ssid: Optional[pulumi.Input[builtins.str]] = None,
                 template_id: Optional[pulumi.Input[builtins.str]] = None,
                 use_eapol_v1: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[builtins.str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Input properties used for looking up and filtering Wlan resources.
        :param pulumi.Input[builtins.bool] acct_immediate_update: Enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[builtins.int] acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]] acct_servers: List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input['WlanAirwatchArgs'] airwatch: Airwatch wlan settings
        :param pulumi.Input[builtins.bool] allow_ipv6_ndp: Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[builtins.bool] allow_mdns: Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[builtins.bool] allow_ssdp: Only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ap_ids: List of device ids
        :param pulumi.Input['WlanAppLimitArgs'] app_limit: Bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input['WlanAppQosArgs'] app_qos: APp qos wlan settings
        :param pulumi.Input[builtins.str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[builtins.bool] arp_filter: Whether to enable smart arp filter
        :param pulumi.Input['WlanAuthArgs'] auth: Authentication wlan settings
        :param pulumi.Input[builtins.str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]] auth_servers: List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[builtins.str] auth_servers_nas_id: Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[builtins.str] auth_servers_nas_ip: Optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[builtins.int] auth_servers_retries: Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
               to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
               value to 3.
        :param pulumi.Input[builtins.int] auth_servers_timeout: Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
               and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
               setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[builtins.bool] band_steer: Whether to enable band_steering, this works only when band==both
        :param pulumi.Input[builtins.bool] band_steer_force_band5: Force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] block_blacklist_clients: Whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input['WlanBonjourArgs'] bonjour: Bonjour gateway wlan settings
        :param pulumi.Input['WlanCiscoCwaArgs'] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[builtins.bool] client_limit_down_enabled: If downlink limiting per-client is enabled
        :param pulumi.Input[builtins.bool] client_limit_up_enabled: If uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]] coa_servers: List of COA (change of authorization) servers, optional
        :param pulumi.Input[builtins.bool] disable11ax: Some old WLAN drivers may not be compatible
        :param pulumi.Input[builtins.bool] disable11be: To disable Wi-Fi 7 EHT IEs
        :param pulumi.Input[builtins.bool] disable_ht_vht_rates: To disable ht or vht rates
        :param pulumi.Input[builtins.bool] disable_uapsd: Whether to disable U-APSD
        :param pulumi.Input[builtins.bool] disable_v1_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_v2_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_when_gateway_unreachable: When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
               reach default gateway
        :param pulumi.Input[builtins.bool] disable_wmm: Whether to disable WMM
        :param pulumi.Input['WlanDnsServerRewriteArgs'] dns_server_rewrite: For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input['WlanDynamicPskArgs'] dynamic_psk: For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input['WlanDynamicVlanArgs'] dynamic_vlan: For 802.1x
        :param pulumi.Input[builtins.bool] enable_local_keycaching: Enable AP-AP keycaching via multicast
        :param pulumi.Input[builtins.bool] enable_wireless_bridging: By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        :param pulumi.Input[builtins.bool] enable_wireless_bridging_dhcp_tracking: If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[builtins.bool] enabled: If this wlan is enabled
        :param pulumi.Input[builtins.bool] fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[builtins.bool] hide_ssid: Whether to hide SSID in beacon
        :param pulumi.Input[builtins.bool] hostname_ie: Include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input['WlanHotspot20Args'] hotspot20: Hostspot 2.0 wlan settings
        :param pulumi.Input[builtins.str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[builtins.bool] isolation: Whether to stop clients to talk to each other
        :param pulumi.Input[builtins.bool] l2_isolation: If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[builtins.bool] legacy_overds: Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[builtins.bool] limit_bcast: Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[builtins.bool] limit_probe_response: Limit probe response base on some heuristic rules
        :param pulumi.Input[builtins.int] max_idletime: Max idle time in seconds
        :param pulumi.Input[builtins.int] max_num_clients: Maximum number of client connected to the SSID. `0` means unlimited
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_ids: When `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_names: When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[builtins.bool] no_static_dns: Whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[builtins.bool] no_static_ip: Whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input['WlanPortalArgs'] portal: Portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_subnets: List of CIDRs
        :param pulumi.Input[builtins.str] portal_api_secret: APi secret (auto-generated) that can be used to sign guest authorization requests
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_denied_hostnames: List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input[builtins.str] portal_image: Url of portal background image
        :param pulumi.Input['WlanRadsecArgs'] radsec: RadSec settings
        :param pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]] rateset: Property key is the RF band. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] reconnect_clients_when_roaming_mxcluster: When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        :param pulumi.Input[builtins.str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input['WlanScheduleArgs'] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[builtins.bool] sle_excluded: Whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[builtins.str] ssid: Name of the SSID
        :param pulumi.Input[builtins.bool] use_eapol_v1: If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[builtins.bool] vlan_enabled: If vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vlan_ids: if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        :param pulumi.Input[builtins.bool] vlan_pooling: Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
               deterministic algorithm
        :param pulumi.Input[builtins.bool] wlan_limit_down_enabled: If downlink limiting for whole wlan is enabled
        :param pulumi.Input[builtins.bool] wlan_limit_up_enabled: If uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wxtag_ids: List of wxtag_ids
        :param pulumi.Input[builtins.str] wxtunnel_id: When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[builtins.str] wxtunnel_remote_id: When `interface`=`wxtunnel`, remote tunnel identifier
        """
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if airwatch is not None:
            pulumi.set(__self__, "airwatch", airwatch)
        if allow_ipv6_ndp is not None:
            pulumi.set(__self__, "allow_ipv6_ndp", allow_ipv6_ndp)
        if allow_mdns is not None:
            pulumi.set(__self__, "allow_mdns", allow_mdns)
        if allow_ssdp is not None:
            pulumi.set(__self__, "allow_ssdp", allow_ssdp)
        if ap_ids is not None:
            pulumi.set(__self__, "ap_ids", ap_ids)
        if app_limit is not None:
            pulumi.set(__self__, "app_limit", app_limit)
        if app_qos is not None:
            pulumi.set(__self__, "app_qos", app_qos)
        if apply_to is not None:
            pulumi.set(__self__, "apply_to", apply_to)
        if arp_filter is not None:
            pulumi.set(__self__, "arp_filter", arp_filter)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_nas_id is not None:
            pulumi.set(__self__, "auth_servers_nas_id", auth_servers_nas_id)
        if auth_servers_nas_ip is not None:
            pulumi.set(__self__, "auth_servers_nas_ip", auth_servers_nas_ip)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if band_steer is not None:
            pulumi.set(__self__, "band_steer", band_steer)
        if band_steer_force_band5 is not None:
            pulumi.set(__self__, "band_steer_force_band5", band_steer_force_band5)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if block_blacklist_clients is not None:
            pulumi.set(__self__, "block_blacklist_clients", block_blacklist_clients)
        if bonjour is not None:
            pulumi.set(__self__, "bonjour", bonjour)
        if cisco_cwa is not None:
            pulumi.set(__self__, "cisco_cwa", cisco_cwa)
        if client_limit_down is not None:
            pulumi.set(__self__, "client_limit_down", client_limit_down)
        if client_limit_down_enabled is not None:
            pulumi.set(__self__, "client_limit_down_enabled", client_limit_down_enabled)
        if client_limit_up is not None:
            pulumi.set(__self__, "client_limit_up", client_limit_up)
        if client_limit_up_enabled is not None:
            pulumi.set(__self__, "client_limit_up_enabled", client_limit_up_enabled)
        if coa_servers is not None:
            pulumi.set(__self__, "coa_servers", coa_servers)
        if disable11ax is not None:
            pulumi.set(__self__, "disable11ax", disable11ax)
        if disable11be is not None:
            pulumi.set(__self__, "disable11be", disable11be)
        if disable_ht_vht_rates is not None:
            pulumi.set(__self__, "disable_ht_vht_rates", disable_ht_vht_rates)
        if disable_uapsd is not None:
            pulumi.set(__self__, "disable_uapsd", disable_uapsd)
        if disable_v1_roam_notify is not None:
            pulumi.set(__self__, "disable_v1_roam_notify", disable_v1_roam_notify)
        if disable_v2_roam_notify is not None:
            pulumi.set(__self__, "disable_v2_roam_notify", disable_v2_roam_notify)
        if disable_when_gateway_unreachable is not None:
            pulumi.set(__self__, "disable_when_gateway_unreachable", disable_when_gateway_unreachable)
        if disable_when_mxtunnel_down is not None:
            pulumi.set(__self__, "disable_when_mxtunnel_down", disable_when_mxtunnel_down)
        if disable_wmm is not None:
            pulumi.set(__self__, "disable_wmm", disable_wmm)
        if dns_server_rewrite is not None:
            pulumi.set(__self__, "dns_server_rewrite", dns_server_rewrite)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if dynamic_psk is not None:
            pulumi.set(__self__, "dynamic_psk", dynamic_psk)
        if dynamic_vlan is not None:
            pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        if enable_local_keycaching is not None:
            pulumi.set(__self__, "enable_local_keycaching", enable_local_keycaching)
        if enable_wireless_bridging is not None:
            pulumi.set(__self__, "enable_wireless_bridging", enable_wireless_bridging)
        if enable_wireless_bridging_dhcp_tracking is not None:
            pulumi.set(__self__, "enable_wireless_bridging_dhcp_tracking", enable_wireless_bridging_dhcp_tracking)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if hide_ssid is not None:
            pulumi.set(__self__, "hide_ssid", hide_ssid)
        if hostname_ie is not None:
            pulumi.set(__self__, "hostname_ie", hostname_ie)
        if hotspot20 is not None:
            pulumi.set(__self__, "hotspot20", hotspot20)
        if inject_dhcp_option82 is not None:
            pulumi.set(__self__, "inject_dhcp_option82", inject_dhcp_option82)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if l2_isolation is not None:
            pulumi.set(__self__, "l2_isolation", l2_isolation)
        if legacy_overds is not None:
            pulumi.set(__self__, "legacy_overds", legacy_overds)
        if limit_bcast is not None:
            pulumi.set(__self__, "limit_bcast", limit_bcast)
        if limit_probe_response is not None:
            pulumi.set(__self__, "limit_probe_response", limit_probe_response)
        if max_idletime is not None:
            pulumi.set(__self__, "max_idletime", max_idletime)
        if max_num_clients is not None:
            pulumi.set(__self__, "max_num_clients", max_num_clients)
        if mist_nac is not None:
            pulumi.set(__self__, "mist_nac", mist_nac)
        if msp_id is not None:
            pulumi.set(__self__, "msp_id", msp_id)
        if mxtunnel_ids is not None:
            pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        if mxtunnel_names is not None:
            pulumi.set(__self__, "mxtunnel_names", mxtunnel_names)
        if no_static_dns is not None:
            pulumi.set(__self__, "no_static_dns", no_static_dns)
        if no_static_ip is not None:
            pulumi.set(__self__, "no_static_ip", no_static_ip)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if portal is not None:
            pulumi.set(__self__, "portal", portal)
        if portal_allowed_hostnames is not None:
            pulumi.set(__self__, "portal_allowed_hostnames", portal_allowed_hostnames)
        if portal_allowed_subnets is not None:
            pulumi.set(__self__, "portal_allowed_subnets", portal_allowed_subnets)
        if portal_api_secret is not None:
            pulumi.set(__self__, "portal_api_secret", portal_api_secret)
        if portal_denied_hostnames is not None:
            pulumi.set(__self__, "portal_denied_hostnames", portal_denied_hostnames)
        if portal_image is not None:
            pulumi.set(__self__, "portal_image", portal_image)
        if portal_sso_url is not None:
            pulumi.set(__self__, "portal_sso_url", portal_sso_url)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if radsec is not None:
            pulumi.set(__self__, "radsec", radsec)
        if rateset is not None:
            pulumi.set(__self__, "rateset", rateset)
        if reconnect_clients_when_roaming_mxcluster is not None:
            pulumi.set(__self__, "reconnect_clients_when_roaming_mxcluster", reconnect_clients_when_roaming_mxcluster)
        if roam_mode is not None:
            pulumi.set(__self__, "roam_mode", roam_mode)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if sle_excluded is not None:
            pulumi.set(__self__, "sle_excluded", sle_excluded)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if use_eapol_v1 is not None:
            pulumi.set(__self__, "use_eapol_v1", use_eapol_v1)
        if vlan_enabled is not None:
            pulumi.set(__self__, "vlan_enabled", vlan_enabled)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)
        if vlan_pooling is not None:
            pulumi.set(__self__, "vlan_pooling", vlan_pooling)
        if wlan_limit_down is not None:
            pulumi.set(__self__, "wlan_limit_down", wlan_limit_down)
        if wlan_limit_down_enabled is not None:
            pulumi.set(__self__, "wlan_limit_down_enabled", wlan_limit_down_enabled)
        if wlan_limit_up is not None:
            pulumi.set(__self__, "wlan_limit_up", wlan_limit_up)
        if wlan_limit_up_enabled is not None:
            pulumi.set(__self__, "wlan_limit_up_enabled", wlan_limit_up_enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)
        if wxtunnel_id is not None:
            pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        if wxtunnel_remote_id is not None:
            pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @acct_immediate_update.setter
    def acct_immediate_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "acct_immediate_update", value)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]:
        """
        List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter
    def airwatch(self) -> Optional[pulumi.Input['WlanAirwatchArgs']]:
        """
        Airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @airwatch.setter
    def airwatch(self, value: Optional[pulumi.Input['WlanAirwatchArgs']]):
        pulumi.set(self, "airwatch", value)

    @property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @allow_ipv6_ndp.setter
    def allow_ipv6_ndp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ipv6_ndp", value)

    @property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @allow_mdns.setter
    def allow_mdns(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_mdns", value)

    @property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @allow_ssdp.setter
    def allow_ssdp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ssdp", value)

    @property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of device ids
        """
        return pulumi.get(self, "ap_ids")

    @ap_ids.setter
    def ap_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ap_ids", value)

    @property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> Optional[pulumi.Input['WlanAppLimitArgs']]:
        """
        Bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @app_limit.setter
    def app_limit(self, value: Optional[pulumi.Input['WlanAppLimitArgs']]):
        pulumi.set(self, "app_limit", value)

    @property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> Optional[pulumi.Input['WlanAppQosArgs']]:
        """
        APp qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @app_qos.setter
    def app_qos(self, value: Optional[pulumi.Input['WlanAppQosArgs']]):
        pulumi.set(self, "app_qos", value)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @apply_to.setter
    def apply_to(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "apply_to", value)

    @property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @arp_filter.setter
    def arp_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "arp_filter", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['WlanAuthArgs']]:
        """
        Authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['WlanAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @auth_server_selection.setter
    def auth_server_selection(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_server_selection", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]:
        """
        List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @auth_servers_nas_id.setter
    def auth_servers_nas_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_servers_nas_id", value)

    @property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @auth_servers_nas_ip.setter
    def auth_servers_nas_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_servers_nas_ip", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
        to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
        value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
        and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
        setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @band_steer.setter
    def band_steer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "band_steer", value)

    @property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @band_steer_force_band5.setter
    def band_steer_force_band5(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "band_steer_force_band5", value)

    @property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "bands", value)

    @property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @block_blacklist_clients.setter
    def block_blacklist_clients(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_blacklist_clients", value)

    @property
    @pulumi.getter
    def bonjour(self) -> Optional[pulumi.Input['WlanBonjourArgs']]:
        """
        Bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @bonjour.setter
    def bonjour(self, value: Optional[pulumi.Input['WlanBonjourArgs']]):
        pulumi.set(self, "bonjour", value)

    @property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> Optional[pulumi.Input['WlanCiscoCwaArgs']]:
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @cisco_cwa.setter
    def cisco_cwa(self, value: Optional[pulumi.Input['WlanCiscoCwaArgs']]):
        pulumi.set(self, "cisco_cwa", value)

    @property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_limit_down")

    @client_limit_down.setter
    def client_limit_down(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_limit_down", value)

    @property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @client_limit_down_enabled.setter
    def client_limit_down_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "client_limit_down_enabled", value)

    @property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_limit_up")

    @client_limit_up.setter
    def client_limit_up(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_limit_up", value)

    @property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @client_limit_up_enabled.setter
    def client_limit_up_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "client_limit_up_enabled", value)

    @property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]:
        """
        List of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @coa_servers.setter
    def coa_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]):
        pulumi.set(self, "coa_servers", value)

    @property
    @pulumi.getter
    def disable11ax(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @disable11ax.setter
    def disable11ax(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable11ax", value)

    @property
    @pulumi.getter
    def disable11be(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To disable Wi-Fi 7 EHT IEs
        """
        return pulumi.get(self, "disable11be")

    @disable11be.setter
    def disable11be(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable11be", value)

    @property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @disable_ht_vht_rates.setter
    def disable_ht_vht_rates(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_ht_vht_rates", value)

    @property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @disable_uapsd.setter
    def disable_uapsd(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_uapsd", value)

    @property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @disable_v1_roam_notify.setter
    def disable_v1_roam_notify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_v1_roam_notify", value)

    @property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @disable_v2_roam_notify.setter
    def disable_v2_roam_notify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_v2_roam_notify", value)

    @property
    @pulumi.getter(name="disableWhenGatewayUnreachable")
    def disable_when_gateway_unreachable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
        reach default gateway
        """
        return pulumi.get(self, "disable_when_gateway_unreachable")

    @disable_when_gateway_unreachable.setter
    def disable_when_gateway_unreachable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_when_gateway_unreachable", value)

    @property
    @pulumi.getter(name="disableWhenMxtunnelDown")
    def disable_when_mxtunnel_down(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disable_when_mxtunnel_down")

    @disable_when_mxtunnel_down.setter
    def disable_when_mxtunnel_down(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_when_mxtunnel_down", value)

    @property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @disable_wmm.setter
    def disable_wmm(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_wmm", value)

    @property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> Optional[pulumi.Input['WlanDnsServerRewriteArgs']]:
        """
        For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @dns_server_rewrite.setter
    def dns_server_rewrite(self, value: Optional[pulumi.Input['WlanDnsServerRewriteArgs']]):
        pulumi.set(self, "dns_server_rewrite", value)

    @property
    @pulumi.getter
    def dtim(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "dtim")

    @dtim.setter
    def dtim(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dtim", value)

    @property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> Optional[pulumi.Input['WlanDynamicPskArgs']]:
        """
        For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @dynamic_psk.setter
    def dynamic_psk(self, value: Optional[pulumi.Input['WlanDynamicPskArgs']]):
        pulumi.set(self, "dynamic_psk", value)

    @property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> Optional[pulumi.Input['WlanDynamicVlanArgs']]:
        """
        For 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @dynamic_vlan.setter
    def dynamic_vlan(self, value: Optional[pulumi.Input['WlanDynamicVlanArgs']]):
        pulumi.set(self, "dynamic_vlan", value)

    @property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @enable_local_keycaching.setter
    def enable_local_keycaching(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_local_keycaching", value)

    @property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @enable_wireless_bridging.setter
    def enable_wireless_bridging(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_wireless_bridging", value)

    @property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @enable_wireless_bridging_dhcp_tracking.setter
    def enable_wireless_bridging_dhcp_tracking(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_wireless_bridging_dhcp_tracking", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @fast_dot1x_timers.setter
    def fast_dot1x_timers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fast_dot1x_timers", value)

    @property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @hide_ssid.setter
    def hide_ssid(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hide_ssid", value)

    @property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @hostname_ie.setter
    def hostname_ie(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hostname_ie", value)

    @property
    @pulumi.getter
    def hotspot20(self) -> Optional[pulumi.Input['WlanHotspot20Args']]:
        """
        Hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @hotspot20.setter
    def hotspot20(self, value: Optional[pulumi.Input['WlanHotspot20Args']]):
        pulumi.set(self, "hotspot20", value)

    @property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> Optional[pulumi.Input['WlanInjectDhcpOption82Args']]:
        return pulumi.get(self, "inject_dhcp_option82")

    @inject_dhcp_option82.setter
    def inject_dhcp_option82(self, value: Optional[pulumi.Input['WlanInjectDhcpOption82Args']]):
        pulumi.set(self, "inject_dhcp_option82", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @l2_isolation.setter
    def l2_isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "l2_isolation", value)

    @property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @legacy_overds.setter
    def legacy_overds(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "legacy_overds", value)

    @property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @limit_bcast.setter
    def limit_bcast(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "limit_bcast", value)

    @property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @limit_probe_response.setter
    def limit_probe_response(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "limit_probe_response", value)

    @property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @max_idletime.setter
    def max_idletime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_idletime", value)

    @property
    @pulumi.getter(name="maxNumClients")
    def max_num_clients(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of client connected to the SSID. `0` means unlimited
        """
        return pulumi.get(self, "max_num_clients")

    @max_num_clients.setter
    def max_num_clients(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_num_clients", value)

    @property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> Optional[pulumi.Input['WlanMistNacArgs']]:
        return pulumi.get(self, "mist_nac")

    @mist_nac.setter
    def mist_nac(self, value: Optional[pulumi.Input['WlanMistNacArgs']]):
        pulumi.set(self, "mist_nac", value)

    @property
    @pulumi.getter(name="mspId")
    def msp_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "msp_id")

    @msp_id.setter
    def msp_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "msp_id", value)

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @mxtunnel_ids.setter
    def mxtunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mxtunnel_ids", value)

    @property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @mxtunnel_names.setter
    def mxtunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mxtunnel_names", value)

    @property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @no_static_dns.setter
    def no_static_dns(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_static_dns", value)

    @property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @no_static_ip.setter
    def no_static_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_static_ip", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def portal(self) -> Optional[pulumi.Input['WlanPortalArgs']]:
        """
        Portal wlan settings
        """
        return pulumi.get(self, "portal")

    @portal.setter
    def portal(self, value: Optional[pulumi.Input['WlanPortalArgs']]):
        pulumi.set(self, "portal", value)

    @property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @portal_allowed_hostnames.setter
    def portal_allowed_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "portal_allowed_hostnames", value)

    @property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @portal_allowed_subnets.setter
    def portal_allowed_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "portal_allowed_subnets", value)

    @property
    @pulumi.getter(name="portalApiSecret")
    def portal_api_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        APi secret (auto-generated) that can be used to sign guest authorization requests
        """
        return pulumi.get(self, "portal_api_secret")

    @portal_api_secret.setter
    def portal_api_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "portal_api_secret", value)

    @property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @portal_denied_hostnames.setter
    def portal_denied_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "portal_denied_hostnames", value)

    @property
    @pulumi.getter(name="portalImage")
    def portal_image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Url of portal background image
        """
        return pulumi.get(self, "portal_image")

    @portal_image.setter
    def portal_image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "portal_image", value)

    @property
    @pulumi.getter(name="portalSsoUrl")
    def portal_sso_url(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "portal_sso_url")

    @portal_sso_url.setter
    def portal_sso_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "portal_sso_url", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input['WlanQosArgs']]:
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input['WlanQosArgs']]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter
    def radsec(self) -> Optional[pulumi.Input['WlanRadsecArgs']]:
        """
        RadSec settings
        """
        return pulumi.get(self, "radsec")

    @radsec.setter
    def radsec(self, value: Optional[pulumi.Input['WlanRadsecArgs']]):
        pulumi.set(self, "radsec", value)

    @property
    @pulumi.getter
    def rateset(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]]]:
        """
        Property key is the RF band. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "rateset")

    @rateset.setter
    def rateset(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanRatesetArgs']]]]):
        pulumi.set(self, "rateset", value)

    @property
    @pulumi.getter(name="reconnectClientsWhenRoamingMxcluster")
    def reconnect_clients_when_roaming_mxcluster(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        """
        return pulumi.get(self, "reconnect_clients_when_roaming_mxcluster")

    @reconnect_clients_when_roaming_mxcluster.setter
    def reconnect_clients_when_roaming_mxcluster(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "reconnect_clients_when_roaming_mxcluster", value)

    @property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @roam_mode.setter
    def roam_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "roam_mode", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['WlanScheduleArgs']]:
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['WlanScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @sle_excluded.setter
    def sle_excluded(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sle_excluded", value)

    @property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the SSID
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssid", value)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_id", value)

    @property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @use_eapol_v1.setter
    def use_eapol_v1(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_eapol_v1", value)

    @property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @vlan_enabled.setter
    def vlan_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "vlan_enabled", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        """
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vlan_ids", value)

    @property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
        deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @vlan_pooling.setter
    def vlan_pooling(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "vlan_pooling", value)

    @property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "wlan_limit_down")

    @wlan_limit_down.setter
    def wlan_limit_down(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wlan_limit_down", value)

    @property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @wlan_limit_down_enabled.setter
    def wlan_limit_down_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wlan_limit_down_enabled", value)

    @property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "wlan_limit_up")

    @wlan_limit_up.setter
    def wlan_limit_up(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wlan_limit_up", value)

    @property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @wlan_limit_up_enabled.setter
    def wlan_limit_up_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wlan_limit_up_enabled", value)

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @wxtag_ids.setter
    def wxtag_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wxtag_ids", value)

    @property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @wxtunnel_id.setter
    def wxtunnel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wxtunnel_id", value)

    @property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")

    @wxtunnel_remote_id.setter
    def wxtunnel_remote_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wxtunnel_remote_id", value)


class Wlan(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 acct_immediate_update: Optional[pulumi.Input[builtins.bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[builtins.int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]]] = None,
                 airwatch: Optional[pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']]] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_mdns: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[builtins.bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 app_limit: Optional[pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']]] = None,
                 app_qos: Optional[pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']]] = None,
                 apply_to: Optional[pulumi.Input[builtins.str]] = None,
                 arp_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 auth: Optional[pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']]] = None,
                 auth_server_selection: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[builtins.int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 band_steer: Optional[pulumi.Input[builtins.bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[builtins.bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[builtins.bool]] = None,
                 bonjour: Optional[pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']]] = None,
                 cisco_cwa: Optional[pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']]] = None,
                 client_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 client_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]]] = None,
                 disable11ax: Optional[pulumi.Input[builtins.bool]] = None,
                 disable11be: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_gateway_unreachable: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_mxtunnel_down: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_wmm: Optional[pulumi.Input[builtins.bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']]] = None,
                 dtim: Optional[pulumi.Input[builtins.int]] = None,
                 dynamic_psk: Optional[pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']]] = None,
                 dynamic_vlan: Optional[pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']]] = None,
                 enable_local_keycaching: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[builtins.bool]] = None,
                 hide_ssid: Optional[pulumi.Input[builtins.bool]] = None,
                 hostname_ie: Optional[pulumi.Input[builtins.bool]] = None,
                 hotspot20: Optional[pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']]] = None,
                 inject_dhcp_option82: Optional[pulumi.Input[Union['WlanInjectDhcpOption82Args', 'WlanInjectDhcpOption82ArgsDict']]] = None,
                 interface: Optional[pulumi.Input[builtins.str]] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 l2_isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 legacy_overds: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_bcast: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[builtins.bool]] = None,
                 max_idletime: Optional[pulumi.Input[builtins.int]] = None,
                 max_num_clients: Optional[pulumi.Input[builtins.int]] = None,
                 mist_nac: Optional[pulumi.Input[Union['WlanMistNacArgs', 'WlanMistNacArgsDict']]] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[builtins.bool]] = None,
                 no_static_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 portal: Optional[pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']]] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 qos: Optional[pulumi.Input[Union['WlanQosArgs', 'WlanQosArgsDict']]] = None,
                 radsec: Optional[pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']]] = None,
                 rateset: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['WlanRatesetArgs', 'WlanRatesetArgsDict']]]]] = None,
                 reconnect_clients_when_roaming_mxcluster: Optional[pulumi.Input[builtins.bool]] = None,
                 roam_mode: Optional[pulumi.Input[builtins.str]] = None,
                 schedule: Optional[pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']]] = None,
                 sle_excluded: Optional[pulumi.Input[builtins.bool]] = None,
                 ssid: Optional[pulumi.Input[builtins.str]] = None,
                 template_id: Optional[pulumi.Input[builtins.str]] = None,
                 use_eapol_v1: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[builtins.str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[builtins.str]] = None,
                 __props__=None):
        """
        This resource manages the Org Wlans.

        The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)

        ## Example Usage

        ```python
        import pulumi
        import pulumi_juniper_mist as junipermist

        wlan_one = junipermist.org.Wlan("wlan_one",
            ssid="wlan_one",
            org_id=terraform_test["id"],
            template_id=test101["id"],
            bands=[
                "5",
                "6",
            ],
            vlan_enabled=True,
            vlan_id="143",
            wlan_limit_up="10000",
            wlan_limit_down="20000",
            client_limit_up="512",
            client_limit_down="1000",
            auth={
                "type": "psk",
                "psk": "secretpsk",
            },
            interface="all")
        ```

        ## Import

        Using `pulumi import`, import `mist_org_wlan` with:

        Org WLAN can be imported by specifying the org_id and the wlan_id

        ```sh
        $ pulumi import junipermist:org/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] acct_immediate_update: Enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[builtins.int] acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]] acct_servers: List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']] airwatch: Airwatch wlan settings
        :param pulumi.Input[builtins.bool] allow_ipv6_ndp: Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[builtins.bool] allow_mdns: Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[builtins.bool] allow_ssdp: Only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ap_ids: List of device ids
        :param pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']] app_limit: Bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']] app_qos: APp qos wlan settings
        :param pulumi.Input[builtins.str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[builtins.bool] arp_filter: Whether to enable smart arp filter
        :param pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']] auth: Authentication wlan settings
        :param pulumi.Input[builtins.str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]] auth_servers: List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[builtins.str] auth_servers_nas_id: Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[builtins.str] auth_servers_nas_ip: Optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[builtins.int] auth_servers_retries: Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
               to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
               value to 3.
        :param pulumi.Input[builtins.int] auth_servers_timeout: Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
               and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
               setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[builtins.bool] band_steer: Whether to enable band_steering, this works only when band==both
        :param pulumi.Input[builtins.bool] band_steer_force_band5: Force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] block_blacklist_clients: Whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']] bonjour: Bonjour gateway wlan settings
        :param pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[builtins.bool] client_limit_down_enabled: If downlink limiting per-client is enabled
        :param pulumi.Input[builtins.bool] client_limit_up_enabled: If uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]] coa_servers: List of COA (change of authorization) servers, optional
        :param pulumi.Input[builtins.bool] disable11ax: Some old WLAN drivers may not be compatible
        :param pulumi.Input[builtins.bool] disable11be: To disable Wi-Fi 7 EHT IEs
        :param pulumi.Input[builtins.bool] disable_ht_vht_rates: To disable ht or vht rates
        :param pulumi.Input[builtins.bool] disable_uapsd: Whether to disable U-APSD
        :param pulumi.Input[builtins.bool] disable_v1_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_v2_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_when_gateway_unreachable: When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
               reach default gateway
        :param pulumi.Input[builtins.bool] disable_wmm: Whether to disable WMM
        :param pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']] dns_server_rewrite: For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']] dynamic_psk: For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']] dynamic_vlan: For 802.1x
        :param pulumi.Input[builtins.bool] enable_local_keycaching: Enable AP-AP keycaching via multicast
        :param pulumi.Input[builtins.bool] enable_wireless_bridging: By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        :param pulumi.Input[builtins.bool] enable_wireless_bridging_dhcp_tracking: If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[builtins.bool] enabled: If this wlan is enabled
        :param pulumi.Input[builtins.bool] fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[builtins.bool] hide_ssid: Whether to hide SSID in beacon
        :param pulumi.Input[builtins.bool] hostname_ie: Include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']] hotspot20: Hostspot 2.0 wlan settings
        :param pulumi.Input[builtins.str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[builtins.bool] isolation: Whether to stop clients to talk to each other
        :param pulumi.Input[builtins.bool] l2_isolation: If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[builtins.bool] legacy_overds: Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[builtins.bool] limit_bcast: Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[builtins.bool] limit_probe_response: Limit probe response base on some heuristic rules
        :param pulumi.Input[builtins.int] max_idletime: Max idle time in seconds
        :param pulumi.Input[builtins.int] max_num_clients: Maximum number of client connected to the SSID. `0` means unlimited
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_ids: When `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_names: When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[builtins.bool] no_static_dns: Whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[builtins.bool] no_static_ip: Whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']] portal: Portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_subnets: List of CIDRs
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_denied_hostnames: List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']] radsec: RadSec settings
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['WlanRatesetArgs', 'WlanRatesetArgsDict']]]] rateset: Property key is the RF band. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] reconnect_clients_when_roaming_mxcluster: When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        :param pulumi.Input[builtins.str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[builtins.bool] sle_excluded: Whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[builtins.str] ssid: Name of the SSID
        :param pulumi.Input[builtins.bool] use_eapol_v1: If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[builtins.bool] vlan_enabled: If vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vlan_ids: if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        :param pulumi.Input[builtins.bool] vlan_pooling: Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
               deterministic algorithm
        :param pulumi.Input[builtins.bool] wlan_limit_down_enabled: If downlink limiting for whole wlan is enabled
        :param pulumi.Input[builtins.bool] wlan_limit_up_enabled: If uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wxtag_ids: List of wxtag_ids
        :param pulumi.Input[builtins.str] wxtunnel_id: When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[builtins.str] wxtunnel_remote_id: When `interface`=`wxtunnel`, remote tunnel identifier
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: WlanArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        This resource manages the Org Wlans.

        The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)

        ## Example Usage

        ```python
        import pulumi
        import pulumi_juniper_mist as junipermist

        wlan_one = junipermist.org.Wlan("wlan_one",
            ssid="wlan_one",
            org_id=terraform_test["id"],
            template_id=test101["id"],
            bands=[
                "5",
                "6",
            ],
            vlan_enabled=True,
            vlan_id="143",
            wlan_limit_up="10000",
            wlan_limit_down="20000",
            client_limit_up="512",
            client_limit_down="1000",
            auth={
                "type": "psk",
                "psk": "secretpsk",
            },
            interface="all")
        ```

        ## Import

        Using `pulumi import`, import `mist_org_wlan` with:

        Org WLAN can be imported by specifying the org_id and the wlan_id

        ```sh
        $ pulumi import junipermist:org/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param WlanArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(WlanArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 acct_immediate_update: Optional[pulumi.Input[builtins.bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[builtins.int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]]] = None,
                 airwatch: Optional[pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']]] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_mdns: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[builtins.bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 app_limit: Optional[pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']]] = None,
                 app_qos: Optional[pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']]] = None,
                 apply_to: Optional[pulumi.Input[builtins.str]] = None,
                 arp_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 auth: Optional[pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']]] = None,
                 auth_server_selection: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[builtins.int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 band_steer: Optional[pulumi.Input[builtins.bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[builtins.bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[builtins.bool]] = None,
                 bonjour: Optional[pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']]] = None,
                 cisco_cwa: Optional[pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']]] = None,
                 client_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 client_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]]] = None,
                 disable11ax: Optional[pulumi.Input[builtins.bool]] = None,
                 disable11be: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_gateway_unreachable: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_when_mxtunnel_down: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_wmm: Optional[pulumi.Input[builtins.bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']]] = None,
                 dtim: Optional[pulumi.Input[builtins.int]] = None,
                 dynamic_psk: Optional[pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']]] = None,
                 dynamic_vlan: Optional[pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']]] = None,
                 enable_local_keycaching: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[builtins.bool]] = None,
                 hide_ssid: Optional[pulumi.Input[builtins.bool]] = None,
                 hostname_ie: Optional[pulumi.Input[builtins.bool]] = None,
                 hotspot20: Optional[pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']]] = None,
                 inject_dhcp_option82: Optional[pulumi.Input[Union['WlanInjectDhcpOption82Args', 'WlanInjectDhcpOption82ArgsDict']]] = None,
                 interface: Optional[pulumi.Input[builtins.str]] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 l2_isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 legacy_overds: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_bcast: Optional[pulumi.Input[builtins.bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[builtins.bool]] = None,
                 max_idletime: Optional[pulumi.Input[builtins.int]] = None,
                 max_num_clients: Optional[pulumi.Input[builtins.int]] = None,
                 mist_nac: Optional[pulumi.Input[Union['WlanMistNacArgs', 'WlanMistNacArgsDict']]] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[builtins.bool]] = None,
                 no_static_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 portal: Optional[pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']]] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 qos: Optional[pulumi.Input[Union['WlanQosArgs', 'WlanQosArgsDict']]] = None,
                 radsec: Optional[pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']]] = None,
                 rateset: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['WlanRatesetArgs', 'WlanRatesetArgsDict']]]]] = None,
                 reconnect_clients_when_roaming_mxcluster: Optional[pulumi.Input[builtins.bool]] = None,
                 roam_mode: Optional[pulumi.Input[builtins.str]] = None,
                 schedule: Optional[pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']]] = None,
                 sle_excluded: Optional[pulumi.Input[builtins.bool]] = None,
                 ssid: Optional[pulumi.Input[builtins.str]] = None,
                 template_id: Optional[pulumi.Input[builtins.str]] = None,
                 use_eapol_v1: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[builtins.str]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[builtins.str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = WlanArgs.__new__(WlanArgs)

            __props__.__dict__["acct_immediate_update"] = acct_immediate_update
            __props__.__dict__["acct_interim_interval"] = acct_interim_interval
            __props__.__dict__["acct_servers"] = acct_servers
            __props__.__dict__["airwatch"] = airwatch
            __props__.__dict__["allow_ipv6_ndp"] = allow_ipv6_ndp
            __props__.__dict__["allow_mdns"] = allow_mdns
            __props__.__dict__["allow_ssdp"] = allow_ssdp
            __props__.__dict__["ap_ids"] = ap_ids
            __props__.__dict__["app_limit"] = app_limit
            __props__.__dict__["app_qos"] = app_qos
            __props__.__dict__["apply_to"] = apply_to
            __props__.__dict__["arp_filter"] = arp_filter
            __props__.__dict__["auth"] = auth
            __props__.__dict__["auth_server_selection"] = auth_server_selection
            __props__.__dict__["auth_servers"] = auth_servers
            __props__.__dict__["auth_servers_nas_id"] = auth_servers_nas_id
            __props__.__dict__["auth_servers_nas_ip"] = auth_servers_nas_ip
            __props__.__dict__["auth_servers_retries"] = auth_servers_retries
            __props__.__dict__["auth_servers_timeout"] = auth_servers_timeout
            __props__.__dict__["band_steer"] = band_steer
            __props__.__dict__["band_steer_force_band5"] = band_steer_force_band5
            __props__.__dict__["bands"] = bands
            __props__.__dict__["block_blacklist_clients"] = block_blacklist_clients
            __props__.__dict__["bonjour"] = bonjour
            __props__.__dict__["cisco_cwa"] = cisco_cwa
            __props__.__dict__["client_limit_down"] = client_limit_down
            __props__.__dict__["client_limit_down_enabled"] = client_limit_down_enabled
            __props__.__dict__["client_limit_up"] = client_limit_up
            __props__.__dict__["client_limit_up_enabled"] = client_limit_up_enabled
            __props__.__dict__["coa_servers"] = coa_servers
            __props__.__dict__["disable11ax"] = disable11ax
            __props__.__dict__["disable11be"] = disable11be
            __props__.__dict__["disable_ht_vht_rates"] = disable_ht_vht_rates
            __props__.__dict__["disable_uapsd"] = disable_uapsd
            __props__.__dict__["disable_v1_roam_notify"] = disable_v1_roam_notify
            __props__.__dict__["disable_v2_roam_notify"] = disable_v2_roam_notify
            __props__.__dict__["disable_when_gateway_unreachable"] = disable_when_gateway_unreachable
            __props__.__dict__["disable_when_mxtunnel_down"] = disable_when_mxtunnel_down
            __props__.__dict__["disable_wmm"] = disable_wmm
            __props__.__dict__["dns_server_rewrite"] = dns_server_rewrite
            __props__.__dict__["dtim"] = dtim
            __props__.__dict__["dynamic_psk"] = dynamic_psk
            __props__.__dict__["dynamic_vlan"] = dynamic_vlan
            __props__.__dict__["enable_local_keycaching"] = enable_local_keycaching
            __props__.__dict__["enable_wireless_bridging"] = enable_wireless_bridging
            __props__.__dict__["enable_wireless_bridging_dhcp_tracking"] = enable_wireless_bridging_dhcp_tracking
            __props__.__dict__["enabled"] = enabled
            __props__.__dict__["fast_dot1x_timers"] = fast_dot1x_timers
            __props__.__dict__["hide_ssid"] = hide_ssid
            __props__.__dict__["hostname_ie"] = hostname_ie
            __props__.__dict__["hotspot20"] = hotspot20
            __props__.__dict__["inject_dhcp_option82"] = inject_dhcp_option82
            __props__.__dict__["interface"] = interface
            __props__.__dict__["isolation"] = isolation
            __props__.__dict__["l2_isolation"] = l2_isolation
            __props__.__dict__["legacy_overds"] = legacy_overds
            __props__.__dict__["limit_bcast"] = limit_bcast
            __props__.__dict__["limit_probe_response"] = limit_probe_response
            __props__.__dict__["max_idletime"] = max_idletime
            __props__.__dict__["max_num_clients"] = max_num_clients
            __props__.__dict__["mist_nac"] = mist_nac
            __props__.__dict__["mxtunnel_ids"] = mxtunnel_ids
            __props__.__dict__["mxtunnel_names"] = mxtunnel_names
            __props__.__dict__["no_static_dns"] = no_static_dns
            __props__.__dict__["no_static_ip"] = no_static_ip
            if org_id is None and not opts.urn:
                raise TypeError("Missing required property 'org_id'")
            __props__.__dict__["org_id"] = org_id
            __props__.__dict__["portal"] = portal
            __props__.__dict__["portal_allowed_hostnames"] = portal_allowed_hostnames
            __props__.__dict__["portal_allowed_subnets"] = portal_allowed_subnets
            __props__.__dict__["portal_denied_hostnames"] = portal_denied_hostnames
            __props__.__dict__["qos"] = qos
            __props__.__dict__["radsec"] = radsec
            __props__.__dict__["rateset"] = rateset
            __props__.__dict__["reconnect_clients_when_roaming_mxcluster"] = reconnect_clients_when_roaming_mxcluster
            __props__.__dict__["roam_mode"] = roam_mode
            __props__.__dict__["schedule"] = schedule
            __props__.__dict__["sle_excluded"] = sle_excluded
            if ssid is None and not opts.urn:
                raise TypeError("Missing required property 'ssid'")
            __props__.__dict__["ssid"] = ssid
            if template_id is None and not opts.urn:
                raise TypeError("Missing required property 'template_id'")
            __props__.__dict__["template_id"] = template_id
            __props__.__dict__["use_eapol_v1"] = use_eapol_v1
            __props__.__dict__["vlan_enabled"] = vlan_enabled
            __props__.__dict__["vlan_id"] = vlan_id
            __props__.__dict__["vlan_ids"] = vlan_ids
            __props__.__dict__["vlan_pooling"] = vlan_pooling
            __props__.__dict__["wlan_limit_down"] = wlan_limit_down
            __props__.__dict__["wlan_limit_down_enabled"] = wlan_limit_down_enabled
            __props__.__dict__["wlan_limit_up"] = wlan_limit_up
            __props__.__dict__["wlan_limit_up_enabled"] = wlan_limit_up_enabled
            __props__.__dict__["wxtag_ids"] = wxtag_ids
            __props__.__dict__["wxtunnel_id"] = wxtunnel_id
            __props__.__dict__["wxtunnel_remote_id"] = wxtunnel_remote_id
            __props__.__dict__["msp_id"] = None
            __props__.__dict__["portal_api_secret"] = None
            __props__.__dict__["portal_image"] = None
            __props__.__dict__["portal_sso_url"] = None
        super(Wlan, __self__).__init__(
            'junipermist:org/wlan:Wlan',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            acct_immediate_update: Optional[pulumi.Input[builtins.bool]] = None,
            acct_interim_interval: Optional[pulumi.Input[builtins.int]] = None,
            acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]]] = None,
            airwatch: Optional[pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']]] = None,
            allow_ipv6_ndp: Optional[pulumi.Input[builtins.bool]] = None,
            allow_mdns: Optional[pulumi.Input[builtins.bool]] = None,
            allow_ssdp: Optional[pulumi.Input[builtins.bool]] = None,
            ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            app_limit: Optional[pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']]] = None,
            app_qos: Optional[pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']]] = None,
            apply_to: Optional[pulumi.Input[builtins.str]] = None,
            arp_filter: Optional[pulumi.Input[builtins.bool]] = None,
            auth: Optional[pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']]] = None,
            auth_server_selection: Optional[pulumi.Input[builtins.str]] = None,
            auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]]] = None,
            auth_servers_nas_id: Optional[pulumi.Input[builtins.str]] = None,
            auth_servers_nas_ip: Optional[pulumi.Input[builtins.str]] = None,
            auth_servers_retries: Optional[pulumi.Input[builtins.int]] = None,
            auth_servers_timeout: Optional[pulumi.Input[builtins.int]] = None,
            band_steer: Optional[pulumi.Input[builtins.bool]] = None,
            band_steer_force_band5: Optional[pulumi.Input[builtins.bool]] = None,
            bands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            block_blacklist_clients: Optional[pulumi.Input[builtins.bool]] = None,
            bonjour: Optional[pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']]] = None,
            cisco_cwa: Optional[pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']]] = None,
            client_limit_down: Optional[pulumi.Input[builtins.str]] = None,
            client_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            client_limit_up: Optional[pulumi.Input[builtins.str]] = None,
            client_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]]] = None,
            disable11ax: Optional[pulumi.Input[builtins.bool]] = None,
            disable11be: Optional[pulumi.Input[builtins.bool]] = None,
            disable_ht_vht_rates: Optional[pulumi.Input[builtins.bool]] = None,
            disable_uapsd: Optional[pulumi.Input[builtins.bool]] = None,
            disable_v1_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
            disable_v2_roam_notify: Optional[pulumi.Input[builtins.bool]] = None,
            disable_when_gateway_unreachable: Optional[pulumi.Input[builtins.bool]] = None,
            disable_when_mxtunnel_down: Optional[pulumi.Input[builtins.bool]] = None,
            disable_wmm: Optional[pulumi.Input[builtins.bool]] = None,
            dns_server_rewrite: Optional[pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']]] = None,
            dtim: Optional[pulumi.Input[builtins.int]] = None,
            dynamic_psk: Optional[pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']]] = None,
            dynamic_vlan: Optional[pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']]] = None,
            enable_local_keycaching: Optional[pulumi.Input[builtins.bool]] = None,
            enable_wireless_bridging: Optional[pulumi.Input[builtins.bool]] = None,
            enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[builtins.bool]] = None,
            enabled: Optional[pulumi.Input[builtins.bool]] = None,
            fast_dot1x_timers: Optional[pulumi.Input[builtins.bool]] = None,
            hide_ssid: Optional[pulumi.Input[builtins.bool]] = None,
            hostname_ie: Optional[pulumi.Input[builtins.bool]] = None,
            hotspot20: Optional[pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']]] = None,
            inject_dhcp_option82: Optional[pulumi.Input[Union['WlanInjectDhcpOption82Args', 'WlanInjectDhcpOption82ArgsDict']]] = None,
            interface: Optional[pulumi.Input[builtins.str]] = None,
            isolation: Optional[pulumi.Input[builtins.bool]] = None,
            l2_isolation: Optional[pulumi.Input[builtins.bool]] = None,
            legacy_overds: Optional[pulumi.Input[builtins.bool]] = None,
            limit_bcast: Optional[pulumi.Input[builtins.bool]] = None,
            limit_probe_response: Optional[pulumi.Input[builtins.bool]] = None,
            max_idletime: Optional[pulumi.Input[builtins.int]] = None,
            max_num_clients: Optional[pulumi.Input[builtins.int]] = None,
            mist_nac: Optional[pulumi.Input[Union['WlanMistNacArgs', 'WlanMistNacArgsDict']]] = None,
            msp_id: Optional[pulumi.Input[builtins.str]] = None,
            mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            no_static_dns: Optional[pulumi.Input[builtins.bool]] = None,
            no_static_ip: Optional[pulumi.Input[builtins.bool]] = None,
            org_id: Optional[pulumi.Input[builtins.str]] = None,
            portal: Optional[pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']]] = None,
            portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            portal_api_secret: Optional[pulumi.Input[builtins.str]] = None,
            portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            portal_image: Optional[pulumi.Input[builtins.str]] = None,
            portal_sso_url: Optional[pulumi.Input[builtins.str]] = None,
            qos: Optional[pulumi.Input[Union['WlanQosArgs', 'WlanQosArgsDict']]] = None,
            radsec: Optional[pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']]] = None,
            rateset: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['WlanRatesetArgs', 'WlanRatesetArgsDict']]]]] = None,
            reconnect_clients_when_roaming_mxcluster: Optional[pulumi.Input[builtins.bool]] = None,
            roam_mode: Optional[pulumi.Input[builtins.str]] = None,
            schedule: Optional[pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']]] = None,
            sle_excluded: Optional[pulumi.Input[builtins.bool]] = None,
            ssid: Optional[pulumi.Input[builtins.str]] = None,
            template_id: Optional[pulumi.Input[builtins.str]] = None,
            use_eapol_v1: Optional[pulumi.Input[builtins.bool]] = None,
            vlan_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            vlan_id: Optional[pulumi.Input[builtins.str]] = None,
            vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            vlan_pooling: Optional[pulumi.Input[builtins.bool]] = None,
            wlan_limit_down: Optional[pulumi.Input[builtins.str]] = None,
            wlan_limit_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            wlan_limit_up: Optional[pulumi.Input[builtins.str]] = None,
            wlan_limit_up_enabled: Optional[pulumi.Input[builtins.bool]] = None,
            wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            wxtunnel_id: Optional[pulumi.Input[builtins.str]] = None,
            wxtunnel_remote_id: Optional[pulumi.Input[builtins.str]] = None) -> 'Wlan':
        """
        Get an existing Wlan resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] acct_immediate_update: Enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[builtins.int] acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]] acct_servers: List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']] airwatch: Airwatch wlan settings
        :param pulumi.Input[builtins.bool] allow_ipv6_ndp: Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[builtins.bool] allow_mdns: Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[builtins.bool] allow_ssdp: Only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ap_ids: List of device ids
        :param pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']] app_limit: Bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']] app_qos: APp qos wlan settings
        :param pulumi.Input[builtins.str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[builtins.bool] arp_filter: Whether to enable smart arp filter
        :param pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']] auth: Authentication wlan settings
        :param pulumi.Input[builtins.str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]] auth_servers: List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[builtins.str] auth_servers_nas_id: Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[builtins.str] auth_servers_nas_ip: Optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[builtins.int] auth_servers_retries: Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
               to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
               value to 3.
        :param pulumi.Input[builtins.int] auth_servers_timeout: Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
               and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
               setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[builtins.bool] band_steer: Whether to enable band_steering, this works only when band==both
        :param pulumi.Input[builtins.bool] band_steer_force_band5: Force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] block_blacklist_clients: Whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']] bonjour: Bonjour gateway wlan settings
        :param pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[builtins.bool] client_limit_down_enabled: If downlink limiting per-client is enabled
        :param pulumi.Input[builtins.bool] client_limit_up_enabled: If uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]] coa_servers: List of COA (change of authorization) servers, optional
        :param pulumi.Input[builtins.bool] disable11ax: Some old WLAN drivers may not be compatible
        :param pulumi.Input[builtins.bool] disable11be: To disable Wi-Fi 7 EHT IEs
        :param pulumi.Input[builtins.bool] disable_ht_vht_rates: To disable ht or vht rates
        :param pulumi.Input[builtins.bool] disable_uapsd: Whether to disable U-APSD
        :param pulumi.Input[builtins.bool] disable_v1_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_v2_roam_notify: Disable sending v2 roam notification messages
        :param pulumi.Input[builtins.bool] disable_when_gateway_unreachable: When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
               reach default gateway
        :param pulumi.Input[builtins.bool] disable_wmm: Whether to disable WMM
        :param pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']] dns_server_rewrite: For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']] dynamic_psk: For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']] dynamic_vlan: For 802.1x
        :param pulumi.Input[builtins.bool] enable_local_keycaching: Enable AP-AP keycaching via multicast
        :param pulumi.Input[builtins.bool] enable_wireless_bridging: By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        :param pulumi.Input[builtins.bool] enable_wireless_bridging_dhcp_tracking: If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[builtins.bool] enabled: If this wlan is enabled
        :param pulumi.Input[builtins.bool] fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[builtins.bool] hide_ssid: Whether to hide SSID in beacon
        :param pulumi.Input[builtins.bool] hostname_ie: Include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']] hotspot20: Hostspot 2.0 wlan settings
        :param pulumi.Input[builtins.str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[builtins.bool] isolation: Whether to stop clients to talk to each other
        :param pulumi.Input[builtins.bool] l2_isolation: If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[builtins.bool] legacy_overds: Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[builtins.bool] limit_bcast: Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[builtins.bool] limit_probe_response: Limit probe response base on some heuristic rules
        :param pulumi.Input[builtins.int] max_idletime: Max idle time in seconds
        :param pulumi.Input[builtins.int] max_num_clients: Maximum number of client connected to the SSID. `0` means unlimited
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_ids: When `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_names: When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[builtins.bool] no_static_dns: Whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[builtins.bool] no_static_ip: Whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']] portal: Portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_allowed_subnets: List of CIDRs
        :param pulumi.Input[builtins.str] portal_api_secret: APi secret (auto-generated) that can be used to sign guest authorization requests
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] portal_denied_hostnames: List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input[builtins.str] portal_image: Url of portal background image
        :param pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']] radsec: RadSec settings
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['WlanRatesetArgs', 'WlanRatesetArgsDict']]]] rateset: Property key is the RF band. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] reconnect_clients_when_roaming_mxcluster: When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        :param pulumi.Input[builtins.str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[builtins.bool] sle_excluded: Whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[builtins.str] ssid: Name of the SSID
        :param pulumi.Input[builtins.bool] use_eapol_v1: If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[builtins.bool] vlan_enabled: If vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vlan_ids: if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        :param pulumi.Input[builtins.bool] vlan_pooling: Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
               deterministic algorithm
        :param pulumi.Input[builtins.bool] wlan_limit_down_enabled: If downlink limiting for whole wlan is enabled
        :param pulumi.Input[builtins.bool] wlan_limit_up_enabled: If uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wxtag_ids: List of wxtag_ids
        :param pulumi.Input[builtins.str] wxtunnel_id: When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[builtins.str] wxtunnel_remote_id: When `interface`=`wxtunnel`, remote tunnel identifier
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _WlanState.__new__(_WlanState)

        __props__.__dict__["acct_immediate_update"] = acct_immediate_update
        __props__.__dict__["acct_interim_interval"] = acct_interim_interval
        __props__.__dict__["acct_servers"] = acct_servers
        __props__.__dict__["airwatch"] = airwatch
        __props__.__dict__["allow_ipv6_ndp"] = allow_ipv6_ndp
        __props__.__dict__["allow_mdns"] = allow_mdns
        __props__.__dict__["allow_ssdp"] = allow_ssdp
        __props__.__dict__["ap_ids"] = ap_ids
        __props__.__dict__["app_limit"] = app_limit
        __props__.__dict__["app_qos"] = app_qos
        __props__.__dict__["apply_to"] = apply_to
        __props__.__dict__["arp_filter"] = arp_filter
        __props__.__dict__["auth"] = auth
        __props__.__dict__["auth_server_selection"] = auth_server_selection
        __props__.__dict__["auth_servers"] = auth_servers
        __props__.__dict__["auth_servers_nas_id"] = auth_servers_nas_id
        __props__.__dict__["auth_servers_nas_ip"] = auth_servers_nas_ip
        __props__.__dict__["auth_servers_retries"] = auth_servers_retries
        __props__.__dict__["auth_servers_timeout"] = auth_servers_timeout
        __props__.__dict__["band_steer"] = band_steer
        __props__.__dict__["band_steer_force_band5"] = band_steer_force_band5
        __props__.__dict__["bands"] = bands
        __props__.__dict__["block_blacklist_clients"] = block_blacklist_clients
        __props__.__dict__["bonjour"] = bonjour
        __props__.__dict__["cisco_cwa"] = cisco_cwa
        __props__.__dict__["client_limit_down"] = client_limit_down
        __props__.__dict__["client_limit_down_enabled"] = client_limit_down_enabled
        __props__.__dict__["client_limit_up"] = client_limit_up
        __props__.__dict__["client_limit_up_enabled"] = client_limit_up_enabled
        __props__.__dict__["coa_servers"] = coa_servers
        __props__.__dict__["disable11ax"] = disable11ax
        __props__.__dict__["disable11be"] = disable11be
        __props__.__dict__["disable_ht_vht_rates"] = disable_ht_vht_rates
        __props__.__dict__["disable_uapsd"] = disable_uapsd
        __props__.__dict__["disable_v1_roam_notify"] = disable_v1_roam_notify
        __props__.__dict__["disable_v2_roam_notify"] = disable_v2_roam_notify
        __props__.__dict__["disable_when_gateway_unreachable"] = disable_when_gateway_unreachable
        __props__.__dict__["disable_when_mxtunnel_down"] = disable_when_mxtunnel_down
        __props__.__dict__["disable_wmm"] = disable_wmm
        __props__.__dict__["dns_server_rewrite"] = dns_server_rewrite
        __props__.__dict__["dtim"] = dtim
        __props__.__dict__["dynamic_psk"] = dynamic_psk
        __props__.__dict__["dynamic_vlan"] = dynamic_vlan
        __props__.__dict__["enable_local_keycaching"] = enable_local_keycaching
        __props__.__dict__["enable_wireless_bridging"] = enable_wireless_bridging
        __props__.__dict__["enable_wireless_bridging_dhcp_tracking"] = enable_wireless_bridging_dhcp_tracking
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["fast_dot1x_timers"] = fast_dot1x_timers
        __props__.__dict__["hide_ssid"] = hide_ssid
        __props__.__dict__["hostname_ie"] = hostname_ie
        __props__.__dict__["hotspot20"] = hotspot20
        __props__.__dict__["inject_dhcp_option82"] = inject_dhcp_option82
        __props__.__dict__["interface"] = interface
        __props__.__dict__["isolation"] = isolation
        __props__.__dict__["l2_isolation"] = l2_isolation
        __props__.__dict__["legacy_overds"] = legacy_overds
        __props__.__dict__["limit_bcast"] = limit_bcast
        __props__.__dict__["limit_probe_response"] = limit_probe_response
        __props__.__dict__["max_idletime"] = max_idletime
        __props__.__dict__["max_num_clients"] = max_num_clients
        __props__.__dict__["mist_nac"] = mist_nac
        __props__.__dict__["msp_id"] = msp_id
        __props__.__dict__["mxtunnel_ids"] = mxtunnel_ids
        __props__.__dict__["mxtunnel_names"] = mxtunnel_names
        __props__.__dict__["no_static_dns"] = no_static_dns
        __props__.__dict__["no_static_ip"] = no_static_ip
        __props__.__dict__["org_id"] = org_id
        __props__.__dict__["portal"] = portal
        __props__.__dict__["portal_allowed_hostnames"] = portal_allowed_hostnames
        __props__.__dict__["portal_allowed_subnets"] = portal_allowed_subnets
        __props__.__dict__["portal_api_secret"] = portal_api_secret
        __props__.__dict__["portal_denied_hostnames"] = portal_denied_hostnames
        __props__.__dict__["portal_image"] = portal_image
        __props__.__dict__["portal_sso_url"] = portal_sso_url
        __props__.__dict__["qos"] = qos
        __props__.__dict__["radsec"] = radsec
        __props__.__dict__["rateset"] = rateset
        __props__.__dict__["reconnect_clients_when_roaming_mxcluster"] = reconnect_clients_when_roaming_mxcluster
        __props__.__dict__["roam_mode"] = roam_mode
        __props__.__dict__["schedule"] = schedule
        __props__.__dict__["sle_excluded"] = sle_excluded
        __props__.__dict__["ssid"] = ssid
        __props__.__dict__["template_id"] = template_id
        __props__.__dict__["use_eapol_v1"] = use_eapol_v1
        __props__.__dict__["vlan_enabled"] = vlan_enabled
        __props__.__dict__["vlan_id"] = vlan_id
        __props__.__dict__["vlan_ids"] = vlan_ids
        __props__.__dict__["vlan_pooling"] = vlan_pooling
        __props__.__dict__["wlan_limit_down"] = wlan_limit_down
        __props__.__dict__["wlan_limit_down_enabled"] = wlan_limit_down_enabled
        __props__.__dict__["wlan_limit_up"] = wlan_limit_up
        __props__.__dict__["wlan_limit_up_enabled"] = wlan_limit_up_enabled
        __props__.__dict__["wxtag_ids"] = wxtag_ids
        __props__.__dict__["wxtunnel_id"] = wxtunnel_id
        __props__.__dict__["wxtunnel_remote_id"] = wxtunnel_remote_id
        return Wlan(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> pulumi.Output[builtins.bool]:
        """
        Enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> pulumi.Output[builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> pulumi.Output[Sequence['outputs.WlanAcctServer']]:
        """
        List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @property
    @pulumi.getter
    def airwatch(self) -> pulumi.Output['outputs.WlanAirwatch']:
        """
        Airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> pulumi.Output[builtins.bool]:
        """
        Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> pulumi.Output[builtins.bool]:
        """
        Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> pulumi.Output[builtins.bool]:
        """
        Only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        List of device ids
        """
        return pulumi.get(self, "ap_ids")

    @property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> pulumi.Output[Optional['outputs.WlanAppLimit']]:
        """
        Bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> pulumi.Output['outputs.WlanAppQos']:
        """
        APp qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> pulumi.Output[builtins.str]:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @property
    @pulumi.getter
    def auth(self) -> pulumi.Output[Optional['outputs.WlanAuth']]:
        """
        Authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> pulumi.Output[builtins.str]:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> pulumi.Output[Sequence['outputs.WlanAuthServer']]:
        """
        List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> pulumi.Output[builtins.str]:
        """
        Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> pulumi.Output[builtins.str]:
        """
        Optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’ are set
        to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
        value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’
        and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
        setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @property
    @pulumi.getter
    def bands(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @property
    @pulumi.getter
    def bonjour(self) -> pulumi.Output[Optional['outputs.WlanBonjour']]:
        """
        Bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> pulumi.Output['outputs.WlanCiscoCwa']:
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "client_limit_down")

    @property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "client_limit_up")

    @property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> pulumi.Output[Optional[Sequence['outputs.WlanCoaServer']]]:
        """
        List of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @property
    @pulumi.getter
    def disable11ax(self) -> pulumi.Output[builtins.bool]:
        """
        Some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @property
    @pulumi.getter
    def disable11be(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        To disable Wi-Fi 7 EHT IEs
        """
        return pulumi.get(self, "disable11be")

    @property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        To disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @property
    @pulumi.getter(name="disableWhenGatewayUnreachable")
    def disable_when_gateway_unreachable(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
        reach default gateway
        """
        return pulumi.get(self, "disable_when_gateway_unreachable")

    @property
    @pulumi.getter(name="disableWhenMxtunnelDown")
    def disable_when_mxtunnel_down(self) -> pulumi.Output[Optional[builtins.bool]]:
        return pulumi.get(self, "disable_when_mxtunnel_down")

    @property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> pulumi.Output[Optional['outputs.WlanDnsServerRewrite']]:
        """
        For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @property
    @pulumi.getter
    def dtim(self) -> pulumi.Output[builtins.int]:
        return pulumi.get(self, "dtim")

    @property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> pulumi.Output[Optional['outputs.WlanDynamicPsk']]:
        """
        For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> pulumi.Output[Optional['outputs.WlanDynamicVlan']]:
        """
        For 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[builtins.bool]:
        """
        If this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> pulumi.Output[builtins.bool]:
        """
        Include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @property
    @pulumi.getter
    def hotspot20(self) -> pulumi.Output[Optional['outputs.WlanHotspot20']]:
        """
        Hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> pulumi.Output[Optional['outputs.WlanInjectDhcpOption82']]:
        return pulumi.get(self, "inject_dhcp_option82")

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Output[builtins.str]:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def isolation(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> pulumi.Output[builtins.bool]:
        """
        Limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> pulumi.Output[builtins.int]:
        """
        Max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @property
    @pulumi.getter(name="maxNumClients")
    def max_num_clients(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        Maximum number of client connected to the SSID. `0` means unlimited
        """
        return pulumi.get(self, "max_num_clients")

    @property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> pulumi.Output['outputs.WlanMistNac']:
        return pulumi.get(self, "mist_nac")

    @property
    @pulumi.getter(name="mspId")
    def msp_id(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "msp_id")

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        When `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> pulumi.Output[builtins.bool]:
        """
        Whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def portal(self) -> pulumi.Output['outputs.WlanPortal']:
        """
        Portal wlan settings
        """
        return pulumi.get(self, "portal")

    @property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @property
    @pulumi.getter(name="portalApiSecret")
    def portal_api_secret(self) -> pulumi.Output[builtins.str]:
        """
        APi secret (auto-generated) that can be used to sign guest authorization requests
        """
        return pulumi.get(self, "portal_api_secret")

    @property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @property
    @pulumi.getter(name="portalImage")
    def portal_image(self) -> pulumi.Output[builtins.str]:
        """
        Url of portal background image
        """
        return pulumi.get(self, "portal_image")

    @property
    @pulumi.getter(name="portalSsoUrl")
    def portal_sso_url(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "portal_sso_url")

    @property
    @pulumi.getter
    def qos(self) -> pulumi.Output['outputs.WlanQos']:
        return pulumi.get(self, "qos")

    @property
    @pulumi.getter
    def radsec(self) -> pulumi.Output['outputs.WlanRadsec']:
        """
        RadSec settings
        """
        return pulumi.get(self, "radsec")

    @property
    @pulumi.getter
    def rateset(self) -> pulumi.Output[Mapping[str, 'outputs.WlanRateset']]:
        """
        Property key is the RF band. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "rateset")

    @property
    @pulumi.getter(name="reconnectClientsWhenRoamingMxcluster")
    def reconnect_clients_when_roaming_mxcluster(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        """
        return pulumi.get(self, "reconnect_clients_when_roaming_mxcluster")

    @property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Output['outputs.WlanSchedule']:
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @property
    @pulumi.getter
    def ssid(self) -> pulumi.Output[builtins.str]:
        """
        Name of the SSID
        """
        return pulumi.get(self, "ssid")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> pulumi.Output[builtins.bool]:
        """
        If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> pulumi.Output[builtins.bool]:
        """
        If vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Output[Optional[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        """
        return pulumi.get(self, "vlan_ids")

    @property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> pulumi.Output[builtins.bool]:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
        deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "wlan_limit_down")

    @property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "wlan_limit_up")

    @property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        If uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        List of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> pulumi.Output[builtins.str]:
        """
        When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> pulumi.Output[builtins.str]:
        """
        When `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")

