# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlarmtemplateDeliveryArgs',
    'AlarmtemplateDeliveryArgsDict',
    'AlarmtemplateRulesArgs',
    'AlarmtemplateRulesArgsDict',
    'AlarmtemplateRulesDeliveryArgs',
    'AlarmtemplateRulesDeliveryArgsDict',
    'ApitokenPrivilegeArgs',
    'ApitokenPrivilegeArgsDict',
    'DeviceprofileApAeroscoutArgs',
    'DeviceprofileApAeroscoutArgsDict',
    'DeviceprofileApBleConfigArgs',
    'DeviceprofileApBleConfigArgsDict',
    'DeviceprofileApEslConfigArgs',
    'DeviceprofileApEslConfigArgsDict',
    'DeviceprofileApIpConfigArgs',
    'DeviceprofileApIpConfigArgsDict',
    'DeviceprofileApLacpConfigArgs',
    'DeviceprofileApLacpConfigArgsDict',
    'DeviceprofileApLedArgs',
    'DeviceprofileApLedArgsDict',
    'DeviceprofileApMeshArgs',
    'DeviceprofileApMeshArgsDict',
    'DeviceprofileApPwrConfigArgs',
    'DeviceprofileApPwrConfigArgsDict',
    'DeviceprofileApRadioConfigArgs',
    'DeviceprofileApRadioConfigArgsDict',
    'DeviceprofileApRadioConfigBand24Args',
    'DeviceprofileApRadioConfigBand24ArgsDict',
    'DeviceprofileApRadioConfigBand5Args',
    'DeviceprofileApRadioConfigBand5ArgsDict',
    'DeviceprofileApRadioConfigBand5On24RadioArgs',
    'DeviceprofileApRadioConfigBand5On24RadioArgsDict',
    'DeviceprofileApRadioConfigBand6Args',
    'DeviceprofileApRadioConfigBand6ArgsDict',
    'DeviceprofileApUplinkPortConfigArgs',
    'DeviceprofileApUplinkPortConfigArgsDict',
    'DeviceprofileApUsbConfigArgs',
    'DeviceprofileApUsbConfigArgsDict',
    'DeviceprofileGatewayBgpConfigArgs',
    'DeviceprofileGatewayBgpConfigArgsDict',
    'DeviceprofileGatewayBgpConfigNeighborsArgs',
    'DeviceprofileGatewayBgpConfigNeighborsArgsDict',
    'DeviceprofileGatewayDhcpdConfigArgs',
    'DeviceprofileGatewayDhcpdConfigArgsDict',
    'DeviceprofileGatewayDhcpdConfigConfigArgs',
    'DeviceprofileGatewayDhcpdConfigConfigArgsDict',
    'DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs',
    'DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgsDict',
    'DeviceprofileGatewayDhcpdConfigConfigOptionsArgs',
    'DeviceprofileGatewayDhcpdConfigConfigOptionsArgsDict',
    'DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs',
    'DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgsDict',
    'DeviceprofileGatewayExtraRoutes6Args',
    'DeviceprofileGatewayExtraRoutes6ArgsDict',
    'DeviceprofileGatewayExtraRoutesArgs',
    'DeviceprofileGatewayExtraRoutesArgsDict',
    'DeviceprofileGatewayIdpProfilesArgs',
    'DeviceprofileGatewayIdpProfilesArgsDict',
    'DeviceprofileGatewayIdpProfilesOverwriteArgs',
    'DeviceprofileGatewayIdpProfilesOverwriteArgsDict',
    'DeviceprofileGatewayIdpProfilesOverwriteMatchingArgs',
    'DeviceprofileGatewayIdpProfilesOverwriteMatchingArgsDict',
    'DeviceprofileGatewayIpConfigsArgs',
    'DeviceprofileGatewayIpConfigsArgsDict',
    'DeviceprofileGatewayNetworkArgs',
    'DeviceprofileGatewayNetworkArgsDict',
    'DeviceprofileGatewayNetworkInternalAccessArgs',
    'DeviceprofileGatewayNetworkInternalAccessArgsDict',
    'DeviceprofileGatewayNetworkInternetAccessArgs',
    'DeviceprofileGatewayNetworkInternetAccessArgsDict',
    'DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs',
    'DeviceprofileGatewayNetworkInternetAccessDestinationNatArgsDict',
    'DeviceprofileGatewayNetworkInternetAccessStaticNatArgs',
    'DeviceprofileGatewayNetworkInternetAccessStaticNatArgsDict',
    'DeviceprofileGatewayNetworkMulticastArgs',
    'DeviceprofileGatewayNetworkMulticastArgsDict',
    'DeviceprofileGatewayNetworkMulticastGroupsArgs',
    'DeviceprofileGatewayNetworkMulticastGroupsArgsDict',
    'DeviceprofileGatewayNetworkTenantsArgs',
    'DeviceprofileGatewayNetworkTenantsArgsDict',
    'DeviceprofileGatewayNetworkVpnAccessArgs',
    'DeviceprofileGatewayNetworkVpnAccessArgsDict',
    'DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs',
    'DeviceprofileGatewayNetworkVpnAccessDestinationNatArgsDict',
    'DeviceprofileGatewayNetworkVpnAccessSourceNatArgs',
    'DeviceprofileGatewayNetworkVpnAccessSourceNatArgsDict',
    'DeviceprofileGatewayNetworkVpnAccessStaticNatArgs',
    'DeviceprofileGatewayNetworkVpnAccessStaticNatArgsDict',
    'DeviceprofileGatewayOobIpConfigArgs',
    'DeviceprofileGatewayOobIpConfigArgsDict',
    'DeviceprofileGatewayOobIpConfigNode1Args',
    'DeviceprofileGatewayOobIpConfigNode1ArgsDict',
    'DeviceprofileGatewayPathPreferencesArgs',
    'DeviceprofileGatewayPathPreferencesArgsDict',
    'DeviceprofileGatewayPathPreferencesPathArgs',
    'DeviceprofileGatewayPathPreferencesPathArgsDict',
    'DeviceprofileGatewayPortConfigArgs',
    'DeviceprofileGatewayPortConfigArgsDict',
    'DeviceprofileGatewayPortConfigIpConfigArgs',
    'DeviceprofileGatewayPortConfigIpConfigArgsDict',
    'DeviceprofileGatewayPortConfigTrafficShapingArgs',
    'DeviceprofileGatewayPortConfigTrafficShapingArgsDict',
    'DeviceprofileGatewayPortConfigVpnPathsArgs',
    'DeviceprofileGatewayPortConfigVpnPathsArgsDict',
    'DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgs',
    'DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgsDict',
    'DeviceprofileGatewayPortConfigWanExtraRoutesArgs',
    'DeviceprofileGatewayPortConfigWanExtraRoutesArgsDict',
    'DeviceprofileGatewayPortConfigWanProbeOverrideArgs',
    'DeviceprofileGatewayPortConfigWanProbeOverrideArgsDict',
    'DeviceprofileGatewayPortConfigWanSourceNatArgs',
    'DeviceprofileGatewayPortConfigWanSourceNatArgsDict',
    'DeviceprofileGatewayRoutingPoliciesArgs',
    'DeviceprofileGatewayRoutingPoliciesArgsDict',
    'DeviceprofileGatewayRoutingPoliciesTermArgs',
    'DeviceprofileGatewayRoutingPoliciesTermArgsDict',
    'DeviceprofileGatewayRoutingPoliciesTermActionArgs',
    'DeviceprofileGatewayRoutingPoliciesTermActionArgsDict',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingArgs',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingArgsDict',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgs',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgsDict',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgs',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict',
    'DeviceprofileGatewayServicePolicyArgs',
    'DeviceprofileGatewayServicePolicyArgsDict',
    'DeviceprofileGatewayServicePolicyAntivirusArgs',
    'DeviceprofileGatewayServicePolicyAntivirusArgsDict',
    'DeviceprofileGatewayServicePolicyAppqoeArgs',
    'DeviceprofileGatewayServicePolicyAppqoeArgsDict',
    'DeviceprofileGatewayServicePolicyEwfArgs',
    'DeviceprofileGatewayServicePolicyEwfArgsDict',
    'DeviceprofileGatewayServicePolicyIdpArgs',
    'DeviceprofileGatewayServicePolicyIdpArgsDict',
    'DeviceprofileGatewayServicePolicySslProxyArgs',
    'DeviceprofileGatewayServicePolicySslProxyArgsDict',
    'DeviceprofileGatewayTunnelConfigsArgs',
    'DeviceprofileGatewayTunnelConfigsArgsDict',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionArgs',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionArgsDict',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgsDict',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgs',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgsDict',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgs',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgsDict',
    'DeviceprofileGatewayTunnelConfigsIkeProposalArgs',
    'DeviceprofileGatewayTunnelConfigsIkeProposalArgsDict',
    'DeviceprofileGatewayTunnelConfigsIpsecProposalArgs',
    'DeviceprofileGatewayTunnelConfigsIpsecProposalArgsDict',
    'DeviceprofileGatewayTunnelConfigsPrimaryArgs',
    'DeviceprofileGatewayTunnelConfigsPrimaryArgsDict',
    'DeviceprofileGatewayTunnelConfigsProbeArgs',
    'DeviceprofileGatewayTunnelConfigsProbeArgsDict',
    'DeviceprofileGatewayTunnelConfigsSecondaryArgs',
    'DeviceprofileGatewayTunnelConfigsSecondaryArgsDict',
    'DeviceprofileGatewayTunnelProviderOptionsArgs',
    'DeviceprofileGatewayTunnelProviderOptionsArgsDict',
    'DeviceprofileGatewayTunnelProviderOptionsJseArgs',
    'DeviceprofileGatewayTunnelProviderOptionsJseArgsDict',
    'DeviceprofileGatewayTunnelProviderOptionsZscalerArgs',
    'DeviceprofileGatewayTunnelProviderOptionsZscalerArgsDict',
    'DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs',
    'DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgsDict',
    'DeviceprofileGatewayVrfConfigArgs',
    'DeviceprofileGatewayVrfConfigArgsDict',
    'DeviceprofileGatewayVrfInstancesArgs',
    'DeviceprofileGatewayVrfInstancesArgsDict',
    'EvpnTopologyEvpnOptionsArgs',
    'EvpnTopologyEvpnOptionsArgsDict',
    'EvpnTopologyEvpnOptionsOverlayArgs',
    'EvpnTopologyEvpnOptionsOverlayArgsDict',
    'EvpnTopologyEvpnOptionsUnderlayArgs',
    'EvpnTopologyEvpnOptionsUnderlayArgsDict',
    'EvpnTopologyEvpnOptionsVsInstancesArgs',
    'EvpnTopologyEvpnOptionsVsInstancesArgsDict',
    'EvpnTopologySwitchesArgs',
    'EvpnTopologySwitchesArgsDict',
    'GatewaytemplateBgpConfigArgs',
    'GatewaytemplateBgpConfigArgsDict',
    'GatewaytemplateBgpConfigNeighborsArgs',
    'GatewaytemplateBgpConfigNeighborsArgsDict',
    'GatewaytemplateDhcpdConfigArgs',
    'GatewaytemplateDhcpdConfigArgsDict',
    'GatewaytemplateDhcpdConfigConfigArgs',
    'GatewaytemplateDhcpdConfigConfigArgsDict',
    'GatewaytemplateDhcpdConfigConfigFixedBindingsArgs',
    'GatewaytemplateDhcpdConfigConfigFixedBindingsArgsDict',
    'GatewaytemplateDhcpdConfigConfigOptionsArgs',
    'GatewaytemplateDhcpdConfigConfigOptionsArgsDict',
    'GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs',
    'GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgsDict',
    'GatewaytemplateExtraRoutes6Args',
    'GatewaytemplateExtraRoutes6ArgsDict',
    'GatewaytemplateExtraRoutesArgs',
    'GatewaytemplateExtraRoutesArgsDict',
    'GatewaytemplateIdpProfilesArgs',
    'GatewaytemplateIdpProfilesArgsDict',
    'GatewaytemplateIdpProfilesOverwriteArgs',
    'GatewaytemplateIdpProfilesOverwriteArgsDict',
    'GatewaytemplateIdpProfilesOverwriteMatchingArgs',
    'GatewaytemplateIdpProfilesOverwriteMatchingArgsDict',
    'GatewaytemplateIpConfigsArgs',
    'GatewaytemplateIpConfigsArgsDict',
    'GatewaytemplateNetworkArgs',
    'GatewaytemplateNetworkArgsDict',
    'GatewaytemplateNetworkInternalAccessArgs',
    'GatewaytemplateNetworkInternalAccessArgsDict',
    'GatewaytemplateNetworkInternetAccessArgs',
    'GatewaytemplateNetworkInternetAccessArgsDict',
    'GatewaytemplateNetworkInternetAccessDestinationNatArgs',
    'GatewaytemplateNetworkInternetAccessDestinationNatArgsDict',
    'GatewaytemplateNetworkInternetAccessStaticNatArgs',
    'GatewaytemplateNetworkInternetAccessStaticNatArgsDict',
    'GatewaytemplateNetworkMulticastArgs',
    'GatewaytemplateNetworkMulticastArgsDict',
    'GatewaytemplateNetworkMulticastGroupsArgs',
    'GatewaytemplateNetworkMulticastGroupsArgsDict',
    'GatewaytemplateNetworkTenantsArgs',
    'GatewaytemplateNetworkTenantsArgsDict',
    'GatewaytemplateNetworkVpnAccessArgs',
    'GatewaytemplateNetworkVpnAccessArgsDict',
    'GatewaytemplateNetworkVpnAccessDestinationNatArgs',
    'GatewaytemplateNetworkVpnAccessDestinationNatArgsDict',
    'GatewaytemplateNetworkVpnAccessSourceNatArgs',
    'GatewaytemplateNetworkVpnAccessSourceNatArgsDict',
    'GatewaytemplateNetworkVpnAccessStaticNatArgs',
    'GatewaytemplateNetworkVpnAccessStaticNatArgsDict',
    'GatewaytemplateOobIpConfigArgs',
    'GatewaytemplateOobIpConfigArgsDict',
    'GatewaytemplateOobIpConfigNode1Args',
    'GatewaytemplateOobIpConfigNode1ArgsDict',
    'GatewaytemplatePathPreferencesArgs',
    'GatewaytemplatePathPreferencesArgsDict',
    'GatewaytemplatePathPreferencesPathArgs',
    'GatewaytemplatePathPreferencesPathArgsDict',
    'GatewaytemplatePortConfigArgs',
    'GatewaytemplatePortConfigArgsDict',
    'GatewaytemplatePortConfigIpConfigArgs',
    'GatewaytemplatePortConfigIpConfigArgsDict',
    'GatewaytemplatePortConfigTrafficShapingArgs',
    'GatewaytemplatePortConfigTrafficShapingArgsDict',
    'GatewaytemplatePortConfigVpnPathsArgs',
    'GatewaytemplatePortConfigVpnPathsArgsDict',
    'GatewaytemplatePortConfigVpnPathsTrafficShapingArgs',
    'GatewaytemplatePortConfigVpnPathsTrafficShapingArgsDict',
    'GatewaytemplatePortConfigWanExtraRoutesArgs',
    'GatewaytemplatePortConfigWanExtraRoutesArgsDict',
    'GatewaytemplatePortConfigWanProbeOverrideArgs',
    'GatewaytemplatePortConfigWanProbeOverrideArgsDict',
    'GatewaytemplatePortConfigWanSourceNatArgs',
    'GatewaytemplatePortConfigWanSourceNatArgsDict',
    'GatewaytemplateRoutingPoliciesArgs',
    'GatewaytemplateRoutingPoliciesArgsDict',
    'GatewaytemplateRoutingPoliciesTermArgs',
    'GatewaytemplateRoutingPoliciesTermArgsDict',
    'GatewaytemplateRoutingPoliciesTermActionArgs',
    'GatewaytemplateRoutingPoliciesTermActionArgsDict',
    'GatewaytemplateRoutingPoliciesTermMatchingArgs',
    'GatewaytemplateRoutingPoliciesTermMatchingArgsDict',
    'GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgs',
    'GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgsDict',
    'GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgs',
    'GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgsDict',
    'GatewaytemplateServicePolicyArgs',
    'GatewaytemplateServicePolicyArgsDict',
    'GatewaytemplateServicePolicyAntivirusArgs',
    'GatewaytemplateServicePolicyAntivirusArgsDict',
    'GatewaytemplateServicePolicyAppqoeArgs',
    'GatewaytemplateServicePolicyAppqoeArgsDict',
    'GatewaytemplateServicePolicyEwfArgs',
    'GatewaytemplateServicePolicyEwfArgsDict',
    'GatewaytemplateServicePolicyIdpArgs',
    'GatewaytemplateServicePolicyIdpArgsDict',
    'GatewaytemplateServicePolicySslProxyArgs',
    'GatewaytemplateServicePolicySslProxyArgsDict',
    'GatewaytemplateTunnelConfigsArgs',
    'GatewaytemplateTunnelConfigsArgsDict',
    'GatewaytemplateTunnelConfigsAutoProvisionArgs',
    'GatewaytemplateTunnelConfigsAutoProvisionArgsDict',
    'GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs',
    'GatewaytemplateTunnelConfigsAutoProvisionLatlngArgsDict',
    'GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgs',
    'GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgsDict',
    'GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgs',
    'GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgsDict',
    'GatewaytemplateTunnelConfigsIkeProposalArgs',
    'GatewaytemplateTunnelConfigsIkeProposalArgsDict',
    'GatewaytemplateTunnelConfigsIpsecProposalArgs',
    'GatewaytemplateTunnelConfigsIpsecProposalArgsDict',
    'GatewaytemplateTunnelConfigsPrimaryArgs',
    'GatewaytemplateTunnelConfigsPrimaryArgsDict',
    'GatewaytemplateTunnelConfigsProbeArgs',
    'GatewaytemplateTunnelConfigsProbeArgsDict',
    'GatewaytemplateTunnelConfigsSecondaryArgs',
    'GatewaytemplateTunnelConfigsSecondaryArgsDict',
    'GatewaytemplateTunnelProviderOptionsArgs',
    'GatewaytemplateTunnelProviderOptionsArgsDict',
    'GatewaytemplateTunnelProviderOptionsJseArgs',
    'GatewaytemplateTunnelProviderOptionsJseArgsDict',
    'GatewaytemplateTunnelProviderOptionsZscalerArgs',
    'GatewaytemplateTunnelProviderOptionsZscalerArgsDict',
    'GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs',
    'GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgsDict',
    'GatewaytemplateVrfConfigArgs',
    'GatewaytemplateVrfConfigArgsDict',
    'GatewaytemplateVrfInstancesArgs',
    'GatewaytemplateVrfInstancesArgsDict',
    'IdpprofileOverwriteArgs',
    'IdpprofileOverwriteArgsDict',
    'IdpprofileOverwriteMatchingArgs',
    'IdpprofileOverwriteMatchingArgsDict',
    'InventoryInventoryArgs',
    'InventoryInventoryArgsDict',
    'NacruleMatchingArgs',
    'NacruleMatchingArgsDict',
    'NacruleNotMatchingArgs',
    'NacruleNotMatchingArgsDict',
    'NetworkInternalAccessArgs',
    'NetworkInternalAccessArgsDict',
    'NetworkInternetAccessArgs',
    'NetworkInternetAccessArgsDict',
    'NetworkInternetAccessDestinationNatArgs',
    'NetworkInternetAccessDestinationNatArgsDict',
    'NetworkInternetAccessStaticNatArgs',
    'NetworkInternetAccessStaticNatArgsDict',
    'NetworkMulticastArgs',
    'NetworkMulticastArgsDict',
    'NetworkMulticastGroupsArgs',
    'NetworkMulticastGroupsArgsDict',
    'NetworkTenantsArgs',
    'NetworkTenantsArgsDict',
    'NetworkVpnAccessArgs',
    'NetworkVpnAccessArgsDict',
    'NetworkVpnAccessDestinationNatArgs',
    'NetworkVpnAccessDestinationNatArgsDict',
    'NetworkVpnAccessSourceNatArgs',
    'NetworkVpnAccessSourceNatArgsDict',
    'NetworkVpnAccessStaticNatArgs',
    'NetworkVpnAccessStaticNatArgsDict',
    'NetworktemplateAclPolicyArgs',
    'NetworktemplateAclPolicyArgsDict',
    'NetworktemplateAclPolicyActionArgs',
    'NetworktemplateAclPolicyActionArgsDict',
    'NetworktemplateAclTagsArgs',
    'NetworktemplateAclTagsArgsDict',
    'NetworktemplateAclTagsSpecArgs',
    'NetworktemplateAclTagsSpecArgsDict',
    'NetworktemplateDhcpSnoopingArgs',
    'NetworktemplateDhcpSnoopingArgsDict',
    'NetworktemplateExtraRoutes6Args',
    'NetworktemplateExtraRoutes6ArgsDict',
    'NetworktemplateExtraRoutes6NextQualifiedArgs',
    'NetworktemplateExtraRoutes6NextQualifiedArgsDict',
    'NetworktemplateExtraRoutesArgs',
    'NetworktemplateExtraRoutesArgsDict',
    'NetworktemplateExtraRoutesNextQualifiedArgs',
    'NetworktemplateExtraRoutesNextQualifiedArgsDict',
    'NetworktemplateMistNacArgs',
    'NetworktemplateMistNacArgsDict',
    'NetworktemplateNetworksArgs',
    'NetworktemplateNetworksArgsDict',
    'NetworktemplateOspfAreasArgs',
    'NetworktemplateOspfAreasArgsDict',
    'NetworktemplateOspfAreasNetworksArgs',
    'NetworktemplateOspfAreasNetworksArgsDict',
    'NetworktemplatePortMirroringArgs',
    'NetworktemplatePortMirroringArgsDict',
    'NetworktemplatePortUsagesArgs',
    'NetworktemplatePortUsagesArgsDict',
    'NetworktemplatePortUsagesRuleArgs',
    'NetworktemplatePortUsagesRuleArgsDict',
    'NetworktemplatePortUsagesStormControlArgs',
    'NetworktemplatePortUsagesStormControlArgsDict',
    'NetworktemplateRadiusConfigArgs',
    'NetworktemplateRadiusConfigArgsDict',
    'NetworktemplateRadiusConfigAcctServerArgs',
    'NetworktemplateRadiusConfigAcctServerArgsDict',
    'NetworktemplateRadiusConfigAuthServerArgs',
    'NetworktemplateRadiusConfigAuthServerArgsDict',
    'NetworktemplateRemoteSyslogArgs',
    'NetworktemplateRemoteSyslogArgsDict',
    'NetworktemplateRemoteSyslogArchiveArgs',
    'NetworktemplateRemoteSyslogArchiveArgsDict',
    'NetworktemplateRemoteSyslogConsoleArgs',
    'NetworktemplateRemoteSyslogConsoleArgsDict',
    'NetworktemplateRemoteSyslogConsoleContentArgs',
    'NetworktemplateRemoteSyslogConsoleContentArgsDict',
    'NetworktemplateRemoteSyslogFileArgs',
    'NetworktemplateRemoteSyslogFileArgsDict',
    'NetworktemplateRemoteSyslogFileArchiveArgs',
    'NetworktemplateRemoteSyslogFileArchiveArgsDict',
    'NetworktemplateRemoteSyslogFileContentArgs',
    'NetworktemplateRemoteSyslogFileContentArgsDict',
    'NetworktemplateRemoteSyslogServerArgs',
    'NetworktemplateRemoteSyslogServerArgsDict',
    'NetworktemplateRemoteSyslogServerContentArgs',
    'NetworktemplateRemoteSyslogServerContentArgsDict',
    'NetworktemplateRemoteSyslogUserArgs',
    'NetworktemplateRemoteSyslogUserArgsDict',
    'NetworktemplateRemoteSyslogUserContentArgs',
    'NetworktemplateRemoteSyslogUserContentArgsDict',
    'NetworktemplateSnmpConfigArgs',
    'NetworktemplateSnmpConfigArgsDict',
    'NetworktemplateSnmpConfigClientListArgs',
    'NetworktemplateSnmpConfigClientListArgsDict',
    'NetworktemplateSnmpConfigTrapGroupArgs',
    'NetworktemplateSnmpConfigTrapGroupArgsDict',
    'NetworktemplateSnmpConfigV2cConfigArgs',
    'NetworktemplateSnmpConfigV2cConfigArgsDict',
    'NetworktemplateSnmpConfigV3ConfigArgs',
    'NetworktemplateSnmpConfigV3ConfigArgsDict',
    'NetworktemplateSnmpConfigV3ConfigNotifyArgs',
    'NetworktemplateSnmpConfigV3ConfigNotifyArgsDict',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterArgsDict',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgsDict',
    'NetworktemplateSnmpConfigV3ConfigTargetAddressArgs',
    'NetworktemplateSnmpConfigV3ConfigTargetAddressArgsDict',
    'NetworktemplateSnmpConfigV3ConfigTargetParameterArgs',
    'NetworktemplateSnmpConfigV3ConfigTargetParameterArgsDict',
    'NetworktemplateSnmpConfigV3ConfigUsmArgs',
    'NetworktemplateSnmpConfigV3ConfigUsmArgsDict',
    'NetworktemplateSnmpConfigV3ConfigUsmUserArgs',
    'NetworktemplateSnmpConfigV3ConfigUsmUserArgsDict',
    'NetworktemplateSnmpConfigV3ConfigVacmArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmArgsDict',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessArgsDict',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgsDict',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgsDict',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict',
    'NetworktemplateSnmpConfigViewArgs',
    'NetworktemplateSnmpConfigViewArgsDict',
    'NetworktemplateSwitchMatchingArgs',
    'NetworktemplateSwitchMatchingArgsDict',
    'NetworktemplateSwitchMatchingRuleArgs',
    'NetworktemplateSwitchMatchingRuleArgsDict',
    'NetworktemplateSwitchMatchingRuleIpConfigArgs',
    'NetworktemplateSwitchMatchingRuleIpConfigArgsDict',
    'NetworktemplateSwitchMatchingRuleOobIpConfigArgs',
    'NetworktemplateSwitchMatchingRuleOobIpConfigArgsDict',
    'NetworktemplateSwitchMatchingRulePortConfigArgs',
    'NetworktemplateSwitchMatchingRulePortConfigArgsDict',
    'NetworktemplateSwitchMatchingRulePortMirroringArgs',
    'NetworktemplateSwitchMatchingRulePortMirroringArgsDict',
    'NetworktemplateSwitchMgmtArgs',
    'NetworktemplateSwitchMgmtArgsDict',
    'NetworktemplateSwitchMgmtLocalAccountsArgs',
    'NetworktemplateSwitchMgmtLocalAccountsArgsDict',
    'NetworktemplateSwitchMgmtProtectReArgs',
    'NetworktemplateSwitchMgmtProtectReArgsDict',
    'NetworktemplateSwitchMgmtProtectReCustomArgs',
    'NetworktemplateSwitchMgmtProtectReCustomArgsDict',
    'NetworktemplateSwitchMgmtTacacsArgs',
    'NetworktemplateSwitchMgmtTacacsArgsDict',
    'NetworktemplateSwitchMgmtTacacsAcctServerArgs',
    'NetworktemplateSwitchMgmtTacacsAcctServerArgsDict',
    'NetworktemplateSwitchMgmtTacacsTacplusServerArgs',
    'NetworktemplateSwitchMgmtTacacsTacplusServerArgsDict',
    'NetworktemplateVrfConfigArgs',
    'NetworktemplateVrfConfigArgsDict',
    'NetworktemplateVrfInstancesArgs',
    'NetworktemplateVrfInstancesArgsDict',
    'NetworktemplateVrfInstancesExtraRoutes6Args',
    'NetworktemplateVrfInstancesExtraRoutes6ArgsDict',
    'NetworktemplateVrfInstancesExtraRoutesArgs',
    'NetworktemplateVrfInstancesExtraRoutesArgsDict',
    'RftemplateBand24Args',
    'RftemplateBand24ArgsDict',
    'RftemplateBand5Args',
    'RftemplateBand5ArgsDict',
    'RftemplateBand5On24RadioArgs',
    'RftemplateBand5On24RadioArgsDict',
    'RftemplateBand6Args',
    'RftemplateBand6ArgsDict',
    'RftemplateModelSpecificArgs',
    'RftemplateModelSpecificArgsDict',
    'RftemplateModelSpecificBand24Args',
    'RftemplateModelSpecificBand24ArgsDict',
    'RftemplateModelSpecificBand5Args',
    'RftemplateModelSpecificBand5ArgsDict',
    'RftemplateModelSpecificBand5On24RadioArgs',
    'RftemplateModelSpecificBand5On24RadioArgsDict',
    'RftemplateModelSpecificBand6Args',
    'RftemplateModelSpecificBand6ArgsDict',
    'ServiceSpecArgs',
    'ServiceSpecArgsDict',
    'ServicepolicyAamwArgs',
    'ServicepolicyAamwArgsDict',
    'ServicepolicyAntivirusArgs',
    'ServicepolicyAntivirusArgsDict',
    'ServicepolicyAppqoeArgs',
    'ServicepolicyAppqoeArgsDict',
    'ServicepolicyEwfArgs',
    'ServicepolicyEwfArgsDict',
    'ServicepolicyIdpArgs',
    'ServicepolicyIdpArgsDict',
    'ServicepolicySslProxyArgs',
    'ServicepolicySslProxyArgsDict',
    'SettingApiPolicyArgs',
    'SettingApiPolicyArgsDict',
    'SettingCelonaArgs',
    'SettingCelonaArgsDict',
    'SettingCloudsharkArgs',
    'SettingCloudsharkArgsDict',
    'SettingCradlepointArgs',
    'SettingCradlepointArgsDict',
    'SettingDeviceCertArgs',
    'SettingDeviceCertArgsDict',
    'SettingInstallerArgs',
    'SettingInstallerArgsDict',
    'SettingJcloudArgs',
    'SettingJcloudArgsDict',
    'SettingJcloudRaArgs',
    'SettingJcloudRaArgsDict',
    'SettingJuniperArgs',
    'SettingJuniperArgsDict',
    'SettingJuniperAccountArgs',
    'SettingJuniperAccountArgsDict',
    'SettingJunosShellAccessArgs',
    'SettingJunosShellAccessArgsDict',
    'SettingMgmtArgs',
    'SettingMgmtArgsDict',
    'SettingMistNacArgs',
    'SettingMistNacArgsDict',
    'SettingMistNacIdpArgs',
    'SettingMistNacIdpArgsDict',
    'SettingMistNacServerCertArgs',
    'SettingMistNacServerCertArgsDict',
    'SettingMxedgeMgmtArgs',
    'SettingMxedgeMgmtArgsDict',
    'SettingOpticPortConfigArgs',
    'SettingOpticPortConfigArgsDict',
    'SettingPasswordPolicyArgs',
    'SettingPasswordPolicyArgsDict',
    'SettingPcapArgs',
    'SettingPcapArgsDict',
    'SettingSecurityArgs',
    'SettingSecurityArgsDict',
    'SettingSwitchMgmtArgs',
    'SettingSwitchMgmtArgsDict',
    'SettingSyntheticTestArgs',
    'SettingSyntheticTestArgsDict',
    'SettingSyntheticTestVlanArgs',
    'SettingSyntheticTestVlanArgsDict',
    'SettingSyntheticTestWanSpeedtestArgs',
    'SettingSyntheticTestWanSpeedtestArgsDict',
    'SettingVpnOptionsArgs',
    'SettingVpnOptionsArgsDict',
    'SettingWanPmaArgs',
    'SettingWanPmaArgsDict',
    'SettingWiredPmaArgs',
    'SettingWiredPmaArgsDict',
    'SettingWirelessPmaArgs',
    'SettingWirelessPmaArgsDict',
    'SsoRolePrivilegeArgs',
    'SsoRolePrivilegeArgsDict',
    'VpnPathSelectionArgs',
    'VpnPathSelectionArgsDict',
    'VpnPathsArgs',
    'VpnPathsArgsDict',
    'VpnPathsPeerPathsArgs',
    'VpnPathsPeerPathsArgsDict',
    'VpnPathsTrafficShapingArgs',
    'VpnPathsTrafficShapingArgsDict',
    'WlanAcctServerArgs',
    'WlanAcctServerArgsDict',
    'WlanAirwatchArgs',
    'WlanAirwatchArgsDict',
    'WlanAppLimitArgs',
    'WlanAppLimitArgsDict',
    'WlanAppQosArgs',
    'WlanAppQosArgsDict',
    'WlanAppQosAppsArgs',
    'WlanAppQosAppsArgsDict',
    'WlanAppQosOtherArgs',
    'WlanAppQosOtherArgsDict',
    'WlanAuthArgs',
    'WlanAuthArgsDict',
    'WlanAuthServerArgs',
    'WlanAuthServerArgsDict',
    'WlanBonjourArgs',
    'WlanBonjourArgsDict',
    'WlanBonjourServicesArgs',
    'WlanBonjourServicesArgsDict',
    'WlanCiscoCwaArgs',
    'WlanCiscoCwaArgsDict',
    'WlanCoaServerArgs',
    'WlanCoaServerArgsDict',
    'WlanDnsServerRewriteArgs',
    'WlanDnsServerRewriteArgsDict',
    'WlanDynamicPskArgs',
    'WlanDynamicPskArgsDict',
    'WlanDynamicVlanArgs',
    'WlanDynamicVlanArgsDict',
    'WlanHotspot20Args',
    'WlanHotspot20ArgsDict',
    'WlanInjectDhcpOption82Args',
    'WlanInjectDhcpOption82ArgsDict',
    'WlanMistNacArgs',
    'WlanMistNacArgsDict',
    'WlanPortalArgs',
    'WlanPortalArgsDict',
    'WlanPortalTemplatePortalTemplateArgs',
    'WlanPortalTemplatePortalTemplateArgsDict',
    'WlanPortalTemplatePortalTemplateLocalesArgs',
    'WlanPortalTemplatePortalTemplateLocalesArgsDict',
    'WlanQosArgs',
    'WlanQosArgsDict',
    'WlanRadsecArgs',
    'WlanRadsecArgsDict',
    'WlanRadsecServerArgs',
    'WlanRadsecServerArgsDict',
    'WlanRatesetArgs',
    'WlanRatesetArgsDict',
    'WlanScheduleArgs',
    'WlanScheduleArgsDict',
    'WlanScheduleHoursArgs',
    'WlanScheduleHoursArgsDict',
    'WlantemplateAppliesArgs',
    'WlantemplateAppliesArgsDict',
    'WlantemplateExceptionsArgs',
    'WlantemplateExceptionsArgsDict',
    'WxtagSpecArgs',
    'WxtagSpecArgsDict',
]

MYPY = False

if not MYPY:
    class AlarmtemplateDeliveryArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether to enable the alarm delivery via emails or not
        """
        additional_emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of additional email string to deliver the alarms via emails
        """
        to_org_admins: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        to_site_admins: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
elif False:
    AlarmtemplateDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmtemplateDeliveryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 additional_emails: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 to_org_admins: Optional[pulumi.Input[builtins.bool]] = None,
                 to_site_admins: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable the alarm delivery via emails or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] additional_emails: List of additional email string to deliver the alarms via emails
        :param pulumi.Input[builtins.bool] to_org_admins: Whether to deliver the alarms via emails to Org admins or not
        :param pulumi.Input[builtins.bool] to_site_admins: Whether to deliver the alarms via emails to Site admins or not
        """
        pulumi.set(__self__, "enabled", enabled)
        if additional_emails is not None:
            pulumi.set(__self__, "additional_emails", additional_emails)
        if to_org_admins is not None:
            pulumi.set(__self__, "to_org_admins", to_org_admins)
        if to_site_admins is not None:
            pulumi.set(__self__, "to_site_admins", to_site_admins)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether to enable the alarm delivery via emails or not
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="additionalEmails")
    def additional_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of additional email string to deliver the alarms via emails
        """
        return pulumi.get(self, "additional_emails")

    @additional_emails.setter
    def additional_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "additional_emails", value)

    @property
    @pulumi.getter(name="toOrgAdmins")
    def to_org_admins(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        return pulumi.get(self, "to_org_admins")

    @to_org_admins.setter
    def to_org_admins(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "to_org_admins", value)

    @property
    @pulumi.getter(name="toSiteAdmins")
    def to_site_admins(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
        return pulumi.get(self, "to_site_admins")

    @to_site_admins.setter
    def to_site_admins(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "to_site_admins", value)


if not MYPY:
    class AlarmtemplateRulesArgsDict(TypedDict):
        delivery: NotRequired[pulumi.Input['AlarmtemplateRulesDeliveryArgsDict']]
        """
        Delivery object to configure the alarm delivery
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    AlarmtemplateRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmtemplateRulesArgs:
    def __init__(__self__, *,
                 delivery: Optional[pulumi.Input['AlarmtemplateRulesDeliveryArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input['AlarmtemplateRulesDeliveryArgs'] delivery: Delivery object to configure the alarm delivery
        """
        if delivery is not None:
            pulumi.set(__self__, "delivery", delivery)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def delivery(self) -> Optional[pulumi.Input['AlarmtemplateRulesDeliveryArgs']]:
        """
        Delivery object to configure the alarm delivery
        """
        return pulumi.get(self, "delivery")

    @delivery.setter
    def delivery(self, value: Optional[pulumi.Input['AlarmtemplateRulesDeliveryArgs']]):
        pulumi.set(self, "delivery", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AlarmtemplateRulesDeliveryArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Whether to enable the alarm delivery via emails or not
        """
        additional_emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of additional email string to deliver the alarms via emails
        """
        to_org_admins: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        to_site_admins: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
elif False:
    AlarmtemplateRulesDeliveryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmtemplateRulesDeliveryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 additional_emails: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 to_org_admins: Optional[pulumi.Input[builtins.bool]] = None,
                 to_site_admins: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable the alarm delivery via emails or not
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] additional_emails: List of additional email string to deliver the alarms via emails
        :param pulumi.Input[builtins.bool] to_org_admins: Whether to deliver the alarms via emails to Org admins or not
        :param pulumi.Input[builtins.bool] to_site_admins: Whether to deliver the alarms via emails to Site admins or not
        """
        pulumi.set(__self__, "enabled", enabled)
        if additional_emails is not None:
            pulumi.set(__self__, "additional_emails", additional_emails)
        if to_org_admins is not None:
            pulumi.set(__self__, "to_org_admins", to_org_admins)
        if to_site_admins is not None:
            pulumi.set(__self__, "to_site_admins", to_site_admins)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Whether to enable the alarm delivery via emails or not
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="additionalEmails")
    def additional_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of additional email string to deliver the alarms via emails
        """
        return pulumi.get(self, "additional_emails")

    @additional_emails.setter
    def additional_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "additional_emails", value)

    @property
    @pulumi.getter(name="toOrgAdmins")
    def to_org_admins(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        return pulumi.get(self, "to_org_admins")

    @to_org_admins.setter
    def to_org_admins(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "to_org_admins", value)

    @property
    @pulumi.getter(name="toSiteAdmins")
    def to_site_admins(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
        return pulumi.get(self, "to_site_admins")

    @to_site_admins.setter
    def to_site_admins(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "to_site_admins", value)


if not MYPY:
    class ApitokenPrivilegeArgsDict(TypedDict):
        role: pulumi.Input[builtins.str]
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        scope: pulumi.Input[builtins.str]
        """
        enum: `org`, `site`, `sitegroup`
        """
        site_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `scope`==`site`
        """
        sitegroup_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `scope`==`sitegroup`
        """
elif False:
    ApitokenPrivilegeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApitokenPrivilegeArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[builtins.str],
                 scope: pulumi.Input[builtins.str],
                 site_id: Optional[pulumi.Input[builtins.str]] = None,
                 sitegroup_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] role: access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        :param pulumi.Input[builtins.str] scope: enum: `org`, `site`, `sitegroup`
        :param pulumi.Input[builtins.str] site_id: Required if `scope`==`site`
        :param pulumi.Input[builtins.str] sitegroup_id: Required if `scope`==`sitegroup`
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "scope", scope)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if sitegroup_id is not None:
            pulumi.set(__self__, "sitegroup_id", sitegroup_id)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[builtins.str]:
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[builtins.str]:
        """
        enum: `org`, `site`, `sitegroup`
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `scope`==`site`
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter(name="sitegroupId")
    def sitegroup_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `scope`==`sitegroup`
        """
        return pulumi.get(self, "sitegroup_id")

    @sitegroup_id.setter
    def sitegroup_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sitegroup_id", value)


if not MYPY:
    class DeviceprofileApAeroscoutArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable aeroscout config
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if enabled, aeroscout server host
        """
        locate_connected: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        port: NotRequired[pulumi.Input[builtins.int]]
elif False:
    DeviceprofileApAeroscoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApAeroscoutArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 locate_connected: Optional[pulumi.Input[builtins.bool]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable aeroscout config
        :param pulumi.Input[builtins.str] host: Required if enabled, aeroscout server host
        :param pulumi.Input[builtins.bool] locate_connected: Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if locate_connected is not None:
            pulumi.set(__self__, "locate_connected", locate_connected)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable aeroscout config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if enabled, aeroscout server host
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="locateConnected")
    def locate_connected(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        return pulumi.get(self, "locate_connected")

    @locate_connected.setter
    def locate_connected(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "locate_connected", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DeviceprofileApBleConfigArgsDict(TypedDict):
        beacon_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether Mist beacons is enabled
        """
        beacon_rate: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        beacon_rate_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `custom`, `default`
        """
        beam_disableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        custom_ble_packet_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        custom_ble_packet_frame: NotRequired[pulumi.Input[builtins.str]]
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        custom_ble_packet_freq_msec: NotRequired[pulumi.Input[builtins.int]]
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        eddystone_uid_adv_power: NotRequired[pulumi.Input[builtins.int]]
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        eddystone_uid_beams: NotRequired[pulumi.Input[builtins.str]]
        eddystone_uid_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        eddystone_uid_freq_msec: NotRequired[pulumi.Input[builtins.int]]
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        eddystone_uid_instance: NotRequired[pulumi.Input[builtins.str]]
        """
        Eddystone-UID instance for the device
        """
        eddystone_uid_namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Eddystone-UID namespace
        """
        eddystone_url_adv_power: NotRequired[pulumi.Input[builtins.int]]
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        eddystone_url_beams: NotRequired[pulumi.Input[builtins.str]]
        eddystone_url_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        eddystone_url_freq_msec: NotRequired[pulumi.Input[builtins.int]]
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        eddystone_url_url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL pointed by Eddystone-URL beacon
        """
        ibeacon_adv_power: NotRequired[pulumi.Input[builtins.int]]
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        ibeacon_beams: NotRequired[pulumi.Input[builtins.str]]
        ibeacon_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        ibeacon_freq_msec: NotRequired[pulumi.Input[builtins.int]]
        """
        Frequency (msec) of data emmit for iBeacon
        """
        ibeacon_major: NotRequired[pulumi.Input[builtins.int]]
        """
        Major number for iBeacon
        """
        ibeacon_minor: NotRequired[pulumi.Input[builtins.int]]
        """
        Minor number for iBeacon
        """
        ibeacon_uuid: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, if not specified, the same UUID as the beacon will be used
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `power_mode`==`custom`; else use `power_mode` as default
        """
        power_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `custom`, `default`
        """
elif False:
    DeviceprofileApBleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApBleConfigArgs:
    def __init__(__self__, *,
                 beacon_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 beacon_rate: Optional[pulumi.Input[builtins.int]] = None,
                 beacon_rate_mode: Optional[pulumi.Input[builtins.str]] = None,
                 beam_disableds: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 custom_ble_packet_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 custom_ble_packet_frame: Optional[pulumi.Input[builtins.str]] = None,
                 custom_ble_packet_freq_msec: Optional[pulumi.Input[builtins.int]] = None,
                 eddystone_uid_adv_power: Optional[pulumi.Input[builtins.int]] = None,
                 eddystone_uid_beams: Optional[pulumi.Input[builtins.str]] = None,
                 eddystone_uid_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 eddystone_uid_freq_msec: Optional[pulumi.Input[builtins.int]] = None,
                 eddystone_uid_instance: Optional[pulumi.Input[builtins.str]] = None,
                 eddystone_uid_namespace: Optional[pulumi.Input[builtins.str]] = None,
                 eddystone_url_adv_power: Optional[pulumi.Input[builtins.int]] = None,
                 eddystone_url_beams: Optional[pulumi.Input[builtins.str]] = None,
                 eddystone_url_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 eddystone_url_freq_msec: Optional[pulumi.Input[builtins.int]] = None,
                 eddystone_url_url: Optional[pulumi.Input[builtins.str]] = None,
                 ibeacon_adv_power: Optional[pulumi.Input[builtins.int]] = None,
                 ibeacon_beams: Optional[pulumi.Input[builtins.str]] = None,
                 ibeacon_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 ibeacon_freq_msec: Optional[pulumi.Input[builtins.int]] = None,
                 ibeacon_major: Optional[pulumi.Input[builtins.int]] = None,
                 ibeacon_minor: Optional[pulumi.Input[builtins.int]] = None,
                 ibeacon_uuid: Optional[pulumi.Input[builtins.str]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] beacon_enabled: Whether Mist beacons is enabled
        :param pulumi.Input[builtins.int] beacon_rate: Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        :param pulumi.Input[builtins.str] beacon_rate_mode: enum: `custom`, `default`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] beam_disableds: List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        :param pulumi.Input[builtins.bool] custom_ble_packet_enabled: Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        :param pulumi.Input[builtins.str] custom_ble_packet_frame: The custom frame to be sent out in this beacon. The frame must be a hexstring
        :param pulumi.Input[builtins.int] custom_ble_packet_freq_msec: Frequency (msec) of data emitted by custom ble beacon
        :param pulumi.Input[builtins.int] eddystone_uid_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[builtins.bool] eddystone_uid_enabled: Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        :param pulumi.Input[builtins.int] eddystone_uid_freq_msec: Frequency (msec) of data emmit by Eddystone-UID beacon
        :param pulumi.Input[builtins.str] eddystone_uid_instance: Eddystone-UID instance for the device
        :param pulumi.Input[builtins.str] eddystone_uid_namespace: Eddystone-UID namespace
        :param pulumi.Input[builtins.int] eddystone_url_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[builtins.bool] eddystone_url_enabled: Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        :param pulumi.Input[builtins.int] eddystone_url_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param pulumi.Input[builtins.str] eddystone_url_url: URL pointed by Eddystone-URL beacon
        :param pulumi.Input[builtins.int] ibeacon_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[builtins.bool] ibeacon_enabled: Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        :param pulumi.Input[builtins.int] ibeacon_freq_msec: Frequency (msec) of data emmit for iBeacon
        :param pulumi.Input[builtins.int] ibeacon_major: Major number for iBeacon
        :param pulumi.Input[builtins.int] ibeacon_minor: Minor number for iBeacon
        :param pulumi.Input[builtins.str] ibeacon_uuid: Optional, if not specified, the same UUID as the beacon will be used
        :param pulumi.Input[builtins.int] power: Required if `power_mode`==`custom`; else use `power_mode` as default
        :param pulumi.Input[builtins.str] power_mode: enum: `custom`, `default`
        """
        if beacon_enabled is not None:
            pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        if beacon_rate is not None:
            pulumi.set(__self__, "beacon_rate", beacon_rate)
        if beacon_rate_mode is not None:
            pulumi.set(__self__, "beacon_rate_mode", beacon_rate_mode)
        if beam_disableds is not None:
            pulumi.set(__self__, "beam_disableds", beam_disableds)
        if custom_ble_packet_enabled is not None:
            pulumi.set(__self__, "custom_ble_packet_enabled", custom_ble_packet_enabled)
        if custom_ble_packet_frame is not None:
            pulumi.set(__self__, "custom_ble_packet_frame", custom_ble_packet_frame)
        if custom_ble_packet_freq_msec is not None:
            pulumi.set(__self__, "custom_ble_packet_freq_msec", custom_ble_packet_freq_msec)
        if eddystone_uid_adv_power is not None:
            pulumi.set(__self__, "eddystone_uid_adv_power", eddystone_uid_adv_power)
        if eddystone_uid_beams is not None:
            pulumi.set(__self__, "eddystone_uid_beams", eddystone_uid_beams)
        if eddystone_uid_enabled is not None:
            pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        if eddystone_uid_freq_msec is not None:
            pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        if eddystone_uid_instance is not None:
            pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        if eddystone_uid_namespace is not None:
            pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        if eddystone_url_adv_power is not None:
            pulumi.set(__self__, "eddystone_url_adv_power", eddystone_url_adv_power)
        if eddystone_url_beams is not None:
            pulumi.set(__self__, "eddystone_url_beams", eddystone_url_beams)
        if eddystone_url_enabled is not None:
            pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        if eddystone_url_freq_msec is not None:
            pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        if eddystone_url_url is not None:
            pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        if ibeacon_adv_power is not None:
            pulumi.set(__self__, "ibeacon_adv_power", ibeacon_adv_power)
        if ibeacon_beams is not None:
            pulumi.set(__self__, "ibeacon_beams", ibeacon_beams)
        if ibeacon_enabled is not None:
            pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        if ibeacon_freq_msec is not None:
            pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        if ibeacon_major is not None:
            pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        if ibeacon_minor is not None:
            pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        if ibeacon_uuid is not None:
            pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)

    @property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Mist beacons is enabled
        """
        return pulumi.get(self, "beacon_enabled")

    @beacon_enabled.setter
    def beacon_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "beacon_enabled", value)

    @property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        return pulumi.get(self, "beacon_rate")

    @beacon_rate.setter
    def beacon_rate(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "beacon_rate", value)

    @property
    @pulumi.getter(name="beaconRateMode")
    def beacon_rate_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "beacon_rate_mode")

    @beacon_rate_mode.setter
    def beacon_rate_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "beacon_rate_mode", value)

    @property
    @pulumi.getter(name="beamDisableds")
    def beam_disableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        return pulumi.get(self, "beam_disableds")

    @beam_disableds.setter
    def beam_disableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "beam_disableds", value)

    @property
    @pulumi.getter(name="customBlePacketEnabled")
    def custom_ble_packet_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        return pulumi.get(self, "custom_ble_packet_enabled")

    @custom_ble_packet_enabled.setter
    def custom_ble_packet_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "custom_ble_packet_enabled", value)

    @property
    @pulumi.getter(name="customBlePacketFrame")
    def custom_ble_packet_frame(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        return pulumi.get(self, "custom_ble_packet_frame")

    @custom_ble_packet_frame.setter
    def custom_ble_packet_frame(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_ble_packet_frame", value)

    @property
    @pulumi.getter(name="customBlePacketFreqMsec")
    def custom_ble_packet_freq_msec(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        return pulumi.get(self, "custom_ble_packet_freq_msec")

    @custom_ble_packet_freq_msec.setter
    def custom_ble_packet_freq_msec(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "custom_ble_packet_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUidAdvPower")
    def eddystone_uid_adv_power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_uid_adv_power")

    @eddystone_uid_adv_power.setter
    def eddystone_uid_adv_power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "eddystone_uid_adv_power", value)

    @property
    @pulumi.getter(name="eddystoneUidBeams")
    def eddystone_uid_beams(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "eddystone_uid_beams")

    @eddystone_uid_beams.setter
    def eddystone_uid_beams(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eddystone_uid_beams", value)

    @property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        return pulumi.get(self, "eddystone_uid_enabled")

    @eddystone_uid_enabled.setter
    def eddystone_uid_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "eddystone_uid_enabled", value)

    @property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @eddystone_uid_freq_msec.setter
    def eddystone_uid_freq_msec(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "eddystone_uid_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Eddystone-UID instance for the device
        """
        return pulumi.get(self, "eddystone_uid_instance")

    @eddystone_uid_instance.setter
    def eddystone_uid_instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eddystone_uid_instance", value)

    @property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Eddystone-UID namespace
        """
        return pulumi.get(self, "eddystone_uid_namespace")

    @eddystone_uid_namespace.setter
    def eddystone_uid_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eddystone_uid_namespace", value)

    @property
    @pulumi.getter(name="eddystoneUrlAdvPower")
    def eddystone_url_adv_power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_url_adv_power")

    @eddystone_url_adv_power.setter
    def eddystone_url_adv_power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "eddystone_url_adv_power", value)

    @property
    @pulumi.getter(name="eddystoneUrlBeams")
    def eddystone_url_beams(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "eddystone_url_beams")

    @eddystone_url_beams.setter
    def eddystone_url_beams(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eddystone_url_beams", value)

    @property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        return pulumi.get(self, "eddystone_url_enabled")

    @eddystone_url_enabled.setter
    def eddystone_url_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "eddystone_url_enabled", value)

    @property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @eddystone_url_freq_msec.setter
    def eddystone_url_freq_msec(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "eddystone_url_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL pointed by Eddystone-URL beacon
        """
        return pulumi.get(self, "eddystone_url_url")

    @eddystone_url_url.setter
    def eddystone_url_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eddystone_url_url", value)

    @property
    @pulumi.getter(name="ibeaconAdvPower")
    def ibeacon_adv_power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "ibeacon_adv_power")

    @ibeacon_adv_power.setter
    def ibeacon_adv_power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ibeacon_adv_power", value)

    @property
    @pulumi.getter(name="ibeaconBeams")
    def ibeacon_beams(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ibeacon_beams")

    @ibeacon_beams.setter
    def ibeacon_beams(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ibeacon_beams", value)

    @property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        return pulumi.get(self, "ibeacon_enabled")

    @ibeacon_enabled.setter
    def ibeacon_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ibeacon_enabled", value)

    @property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Frequency (msec) of data emmit for iBeacon
        """
        return pulumi.get(self, "ibeacon_freq_msec")

    @ibeacon_freq_msec.setter
    def ibeacon_freq_msec(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ibeacon_freq_msec", value)

    @property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Major number for iBeacon
        """
        return pulumi.get(self, "ibeacon_major")

    @ibeacon_major.setter
    def ibeacon_major(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ibeacon_major", value)

    @property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minor number for iBeacon
        """
        return pulumi.get(self, "ibeacon_minor")

    @ibeacon_minor.setter
    def ibeacon_minor(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ibeacon_minor", value)

    @property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, if not specified, the same UUID as the beacon will be used
        """
        return pulumi.get(self, "ibeacon_uuid")

    @ibeacon_uuid.setter
    def ibeacon_uuid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ibeacon_uuid", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `power_mode`==`custom`; else use `power_mode` as default
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "power_mode")

    @power_mode.setter
    def power_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "power_mode", value)


if not MYPY:
    class DeviceprofileApEslConfigArgsDict(TypedDict):
        cacert: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        channel: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        usb_config is ignored if esl_config enabled
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        """
        verify_cert: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        vlan_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
elif False:
    DeviceprofileApEslConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApEslConfigArgs:
    def __init__(__self__, *,
                 cacert: Optional[pulumi.Input[builtins.str]] = None,
                 channel: Optional[pulumi.Input[builtins.int]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 verify_cert: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] cacert: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[builtins.int] channel: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[builtins.bool] enabled: usb_config is ignored if esl_config enabled
        :param pulumi.Input[builtins.str] host: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[builtins.int] port: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[builtins.str] type: note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        :param pulumi.Input[builtins.bool] verify_cert: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[builtins.int] vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cacert", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        usb_config is ignored if esl_config enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "verify_cert")

    @verify_cert.setter
    def verify_cert(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verify_cert", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class DeviceprofileApIpConfigArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`static`
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required if `type`==`static`
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `type`==`static`
        """
        gateway6: NotRequired[pulumi.Input[builtins.str]]
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `type`==`static`
        """
        ip6: NotRequired[pulumi.Input[builtins.str]]
        mtu: NotRequired[pulumi.Input[builtins.int]]
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `type`==`static`
        """
        netmask6: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
        type6: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        vlan_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Management VLAN id, default is 1 (untagged)
        """
elif False:
    DeviceprofileApIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApIpConfigArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 gateway6: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 ip6: Optional[pulumi.Input[builtins.str]] = None,
                 mtu: Optional[pulumi.Input[builtins.int]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 netmask6: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 type6: Optional[pulumi.Input[builtins.str]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns: If `type`==`static`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_suffixes: Required if `type`==`static`
        :param pulumi.Input[builtins.str] gateway: Required if `type`==`static`
        :param pulumi.Input[builtins.str] ip: Required if `type`==`static`
        :param pulumi.Input[builtins.str] netmask: Required if `type`==`static`
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        :param pulumi.Input[builtins.str] type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        :param pulumi.Input[builtins.int] vlan_id: Management VLAN id, default is 1 (untagged)
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def gateway6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gateway6")

    @gateway6.setter
    def gateway6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway6", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def ip6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip6")

    @ip6.setter
    def ip6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip6", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def netmask6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "netmask6")

    @netmask6.setter
    def netmask6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask6", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type6", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Management VLAN id, default is 1 (untagged)
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class DeviceprofileApLacpConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DeviceprofileApLacpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApLacpConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileApLedArgsDict(TypedDict):
        brightness: NotRequired[pulumi.Input[builtins.int]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DeviceprofileApLedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApLedArgs:
    def __init__(__self__, *,
                 brightness: Optional[pulumi.Input[builtins.int]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def brightness(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "brightness")

    @brightness.setter
    def brightness(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "brightness", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileApMeshArgsDict(TypedDict):
        bands: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether mesh is enabled on this AP
        """
        group: NotRequired[pulumi.Input[builtins.int]]
        """
        Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `base`, `remote`
        """
elif False:
    DeviceprofileApMeshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApMeshArgs:
    def __init__(__self__, *,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 group: Optional[pulumi.Input[builtins.int]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] bands: List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        :param pulumi.Input[builtins.bool] enabled: Whether mesh is enabled on this AP
        :param pulumi.Input[builtins.int] group: Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        :param pulumi.Input[builtins.str] role: enum: `base`, `remote`
        """
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "bands", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether mesh is enabled on this AP
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `base`, `remote`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class DeviceprofileApPwrConfigArgsDict(TypedDict):
        base: NotRequired[pulumi.Input[builtins.int]]
        """
        Additional power to request during negotiating with PSE over PoE, in mW
        """
        prefer_usb_over_wifi: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
elif False:
    DeviceprofileApPwrConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApPwrConfigArgs:
    def __init__(__self__, *,
                 base: Optional[pulumi.Input[builtins.int]] = None,
                 prefer_usb_over_wifi: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] base: Additional power to request during negotiating with PSE over PoE, in mW
        :param pulumi.Input[builtins.bool] prefer_usb_over_wifi: Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
        if base is not None:
            pulumi.set(__self__, "base", base)
        if prefer_usb_over_wifi is not None:
            pulumi.set(__self__, "prefer_usb_over_wifi", prefer_usb_over_wifi)

    @property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Additional power to request during negotiating with PSE over PoE, in mW
        """
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "base", value)

    @property
    @pulumi.getter(name="preferUsbOverWifi")
    def prefer_usb_over_wifi(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
        return pulumi.get(self, "prefer_usb_over_wifi")

    @prefer_usb_over_wifi.setter
    def prefer_usb_over_wifi(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "prefer_usb_over_wifi", value)


if not MYPY:
    class DeviceprofileApRadioConfigArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain24: NotRequired[pulumi.Input[builtins.int]]
        """
        Antenna gain for 2.4G - for models with external antenna only
        """
        ant_gain5: NotRequired[pulumi.Input[builtins.int]]
        """
        Antenna gain for 5G - for models with external antenna only
        """
        ant_gain6: NotRequired[pulumi.Input[builtins.int]]
        """
        Antenna gain for 6G - for models with external antenna only
        """
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        band24: NotRequired[pulumi.Input['DeviceprofileApRadioConfigBand24ArgsDict']]
        """
        Radio Band AP settings
        """
        band24_usage: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `24`, `5`, `6`, `auto`
        """
        band5: NotRequired[pulumi.Input['DeviceprofileApRadioConfigBand5ArgsDict']]
        """
        Radio Band AP settings
        """
        band5_on24_radio: NotRequired[pulumi.Input['DeviceprofileApRadioConfigBand5On24RadioArgsDict']]
        """
        Radio Band AP settings
        """
        band6: NotRequired[pulumi.Input['DeviceprofileApRadioConfigBand6ArgsDict']]
        """
        Radio Band AP settings
        """
        indoor_use: NotRequired[pulumi.Input[builtins.bool]]
        """
        To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        """
        scanning_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether scanning radio is enabled
        """
elif False:
    DeviceprofileApRadioConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApRadioConfigArgs:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain24: Optional[pulumi.Input[builtins.int]] = None,
                 ant_gain5: Optional[pulumi.Input[builtins.int]] = None,
                 ant_gain6: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 band24: Optional[pulumi.Input['DeviceprofileApRadioConfigBand24Args']] = None,
                 band24_usage: Optional[pulumi.Input[builtins.str]] = None,
                 band5: Optional[pulumi.Input['DeviceprofileApRadioConfigBand5Args']] = None,
                 band5_on24_radio: Optional[pulumi.Input['DeviceprofileApRadioConfigBand5On24RadioArgs']] = None,
                 band6: Optional[pulumi.Input['DeviceprofileApRadioConfigBand6Args']] = None,
                 indoor_use: Optional[pulumi.Input[builtins.bool]] = None,
                 scanning_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] ant_gain24: Antenna gain for 2.4G - for models with external antenna only
        :param pulumi.Input[builtins.int] ant_gain5: Antenna gain for 5G - for models with external antenna only
        :param pulumi.Input[builtins.int] ant_gain6: Antenna gain for 6G - for models with external antenna only
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input['DeviceprofileApRadioConfigBand24Args'] band24: Radio Band AP settings
        :param pulumi.Input[builtins.str] band24_usage: enum: `24`, `5`, `6`, `auto`
        :param pulumi.Input['DeviceprofileApRadioConfigBand5Args'] band5: Radio Band AP settings
        :param pulumi.Input['DeviceprofileApRadioConfigBand5On24RadioArgs'] band5_on24_radio: Radio Band AP settings
        :param pulumi.Input['DeviceprofileApRadioConfigBand6Args'] band6: Radio Band AP settings
        :param pulumi.Input[builtins.bool] indoor_use: To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        :param pulumi.Input[builtins.bool] scanning_enabled: Whether scanning radio is enabled
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain24 is not None:
            pulumi.set(__self__, "ant_gain24", ant_gain24)
        if ant_gain5 is not None:
            pulumi.set(__self__, "ant_gain5", ant_gain5)
        if ant_gain6 is not None:
            pulumi.set(__self__, "ant_gain6", ant_gain6)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if band24 is not None:
            pulumi.set(__self__, "band24", band24)
        if band24_usage is not None:
            pulumi.set(__self__, "band24_usage", band24_usage)
        if band5 is not None:
            pulumi.set(__self__, "band5", band5)
        if band5_on24_radio is not None:
            pulumi.set(__self__, "band5_on24_radio", band5_on24_radio)
        if band6 is not None:
            pulumi.set(__self__, "band6", band6)
        if indoor_use is not None:
            pulumi.set(__self__, "indoor_use", indoor_use)
        if scanning_enabled is not None:
            pulumi.set(__self__, "scanning_enabled", scanning_enabled)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain24")
    def ant_gain24(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Antenna gain for 2.4G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain24")

    @ant_gain24.setter
    def ant_gain24(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain24", value)

    @property
    @pulumi.getter(name="antGain5")
    def ant_gain5(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Antenna gain for 5G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain5")

    @ant_gain5.setter
    def ant_gain5(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain5", value)

    @property
    @pulumi.getter(name="antGain6")
    def ant_gain6(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Antenna gain for 6G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain6")

    @ant_gain6.setter
    def ant_gain6(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain6", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def band24(self) -> Optional[pulumi.Input['DeviceprofileApRadioConfigBand24Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band24")

    @band24.setter
    def band24(self, value: Optional[pulumi.Input['DeviceprofileApRadioConfigBand24Args']]):
        pulumi.set(self, "band24", value)

    @property
    @pulumi.getter(name="band24Usage")
    def band24_usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `24`, `5`, `6`, `auto`
        """
        return pulumi.get(self, "band24_usage")

    @band24_usage.setter
    def band24_usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "band24_usage", value)

    @property
    @pulumi.getter
    def band5(self) -> Optional[pulumi.Input['DeviceprofileApRadioConfigBand5Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5")

    @band5.setter
    def band5(self, value: Optional[pulumi.Input['DeviceprofileApRadioConfigBand5Args']]):
        pulumi.set(self, "band5", value)

    @property
    @pulumi.getter(name="band5On24Radio")
    def band5_on24_radio(self) -> Optional[pulumi.Input['DeviceprofileApRadioConfigBand5On24RadioArgs']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5_on24_radio")

    @band5_on24_radio.setter
    def band5_on24_radio(self, value: Optional[pulumi.Input['DeviceprofileApRadioConfigBand5On24RadioArgs']]):
        pulumi.set(self, "band5_on24_radio", value)

    @property
    @pulumi.getter
    def band6(self) -> Optional[pulumi.Input['DeviceprofileApRadioConfigBand6Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band6")

    @band6.setter
    def band6(self, value: Optional[pulumi.Input['DeviceprofileApRadioConfigBand6Args']]):
        pulumi.set(self, "band6", value)

    @property
    @pulumi.getter(name="indoorUse")
    def indoor_use(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        """
        return pulumi.get(self, "indoor_use")

    @indoor_use.setter
    def indoor_use(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "indoor_use", value)

    @property
    @pulumi.getter(name="scanningEnabled")
    def scanning_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether scanning radio is enabled
        """
        return pulumi.get(self, "scanning_enabled")

    @scanning_enabled.setter
    def scanning_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "scanning_enabled", value)


if not MYPY:
    class DeviceprofileApRadioConfigBand24ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        channel: NotRequired[pulumi.Input[builtins.int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    DeviceprofileApRadioConfigBand24ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApRadioConfigBand24Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channel: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param pulumi.Input[builtins.int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class DeviceprofileApRadioConfigBand5ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channel: NotRequired[pulumi.Input[builtins.int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    DeviceprofileApRadioConfigBand5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApRadioConfigBand5Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channel: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[builtins.int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class DeviceprofileApRadioConfigBand5On24RadioArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channel: NotRequired[pulumi.Input[builtins.int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    DeviceprofileApRadioConfigBand5On24RadioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApRadioConfigBand5On24RadioArgs:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channel: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[builtins.int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class DeviceprofileApRadioConfigBand6ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        channel: NotRequired[pulumi.Input[builtins.int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
        standard_power: NotRequired[pulumi.Input[builtins.bool]]
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
elif False:
    DeviceprofileApRadioConfigBand6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApRadioConfigBand6Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channel: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None,
                 standard_power: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param pulumi.Input[builtins.int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        :param pulumi.Input[builtins.bool] standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)

    @property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")

    @standard_power.setter
    def standard_power(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "standard_power", value)


if not MYPY:
    class DeviceprofileApUplinkPortConfigArgsDict(TypedDict):
        dot1x: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        keep_wlans_up_if_down: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
elif False:
    DeviceprofileApUplinkPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApUplinkPortConfigArgs:
    def __init__(__self__, *,
                 dot1x: Optional[pulumi.Input[builtins.bool]] = None,
                 keep_wlans_up_if_down: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] dot1x: Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param pulumi.Input[builtins.bool] keep_wlans_up_if_down: By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @property
    @pulumi.getter
    def dot1x(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @dot1x.setter
    def dot1x(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dot1x", value)

    @property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")

    @keep_wlans_up_if_down.setter
    def keep_wlans_up_if_down(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keep_wlans_up_if_down", value)


if not MYPY:
    class DeviceprofileApUsbConfigArgsDict(TypedDict):
        cacert: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `type`==`imagotag`
        """
        channel: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable any usb config
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `type`==`imagotag`
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `type`==`imagotag`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        usb config type. enum: `hanshow`, `imagotag`, `solum`
        """
        verify_cert: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `type`==`imagotag`, whether to turn on SSL verification
        """
        vlan_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
elif False:
    DeviceprofileApUsbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileApUsbConfigArgs:
    def __init__(__self__, *,
                 cacert: Optional[pulumi.Input[builtins.str]] = None,
                 channel: Optional[pulumi.Input[builtins.int]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 verify_cert: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] cacert: Only if `type`==`imagotag`
        :param pulumi.Input[builtins.int] channel: Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        :param pulumi.Input[builtins.bool] enabled: Whether to enable any usb config
        :param pulumi.Input[builtins.str] host: Only if `type`==`imagotag`
        :param pulumi.Input[builtins.int] port: Only if `type`==`imagotag`
        :param pulumi.Input[builtins.str] type: usb config type. enum: `hanshow`, `imagotag`, `solum`
        :param pulumi.Input[builtins.bool] verify_cert: Only if `type`==`imagotag`, whether to turn on SSL verification
        :param pulumi.Input[builtins.int] vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cacert", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable any usb config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        usb config type. enum: `hanshow`, `imagotag`, `solum`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `type`==`imagotag`, whether to turn on SSL verification
        """
        return pulumi.get(self, "verify_cert")

    @verify_cert.setter
    def verify_cert(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "verify_cert", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class DeviceprofileGatewayBgpConfigArgsDict(TypedDict):
        auth_key: NotRequired[pulumi.Input[builtins.str]]
        bfd_minimum_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        When bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        bfd_multiplier: NotRequired[pulumi.Input[builtins.int]]
        """
        When bfd_minimum_interval_is_configured alone
        """
        disable_bfd: NotRequired[pulumi.Input[builtins.bool]]
        """
        BFD provides faster path failure detection and is enabled by default
        """
        export: NotRequired[pulumi.Input[builtins.str]]
        export_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Default export policies if no per-neighbor policies defined
        """
        extended_v4_nexthop: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        graceful_restart_time: NotRequired[pulumi.Input[builtins.int]]
        """
        `0` means disable
        """
        hold_time: NotRequired[pulumi.Input[builtins.int]]
        import_: NotRequired[pulumi.Input[builtins.str]]
        import_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Default import policies if no per-neighbor policies defined
        """
        local_as: NotRequired[pulumi.Input[builtins.str]]
        """
        Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        neighbor_as: NotRequired[pulumi.Input[builtins.str]]
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        neighbors: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayBgpConfigNeighborsArgsDict']]]]
        """
        If per-neighbor as is desired. Property key is the neighbor address
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        """
        no_private_as: NotRequired[pulumi.Input[builtins.bool]]
        no_readvertise_to_overlay: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, we'll re-advertise all learned BGP routers toward overlay
        """
        tunnel_name: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`tunnel`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `external`, `internal`
        """
        via: NotRequired[pulumi.Input[builtins.str]]
        """
        network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        vpn_name: NotRequired[pulumi.Input[builtins.str]]
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        If `via`==`wan`
        """
elif False:
    DeviceprofileGatewayBgpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayBgpConfigArgs:
    def __init__(__self__, *,
                 auth_key: Optional[pulumi.Input[builtins.str]] = None,
                 bfd_minimum_interval: Optional[pulumi.Input[builtins.int]] = None,
                 bfd_multiplier: Optional[pulumi.Input[builtins.int]] = None,
                 disable_bfd: Optional[pulumi.Input[builtins.bool]] = None,
                 export: Optional[pulumi.Input[builtins.str]] = None,
                 export_policy: Optional[pulumi.Input[builtins.str]] = None,
                 extended_v4_nexthop: Optional[pulumi.Input[builtins.bool]] = None,
                 graceful_restart_time: Optional[pulumi.Input[builtins.int]] = None,
                 hold_time: Optional[pulumi.Input[builtins.int]] = None,
                 import_: Optional[pulumi.Input[builtins.str]] = None,
                 import_policy: Optional[pulumi.Input[builtins.str]] = None,
                 local_as: Optional[pulumi.Input[builtins.str]] = None,
                 neighbor_as: Optional[pulumi.Input[builtins.str]] = None,
                 neighbors: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayBgpConfigNeighborsArgs']]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 no_private_as: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[builtins.bool]] = None,
                 tunnel_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 via: Optional[pulumi.Input[builtins.str]] = None,
                 vpn_name: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] bfd_minimum_interval: When bfd_multiplier is configured alone. Default:
                 * 1000 if `type`==`external`
                 * 350 `type`==`internal`
        :param pulumi.Input[builtins.int] bfd_multiplier: When bfd_minimum_interval_is_configured alone
        :param pulumi.Input[builtins.bool] disable_bfd: BFD provides faster path failure detection and is enabled by default
        :param pulumi.Input[builtins.str] export_policy: Default export policies if no per-neighbor policies defined
        :param pulumi.Input[builtins.bool] extended_v4_nexthop: By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        :param pulumi.Input[builtins.int] graceful_restart_time: `0` means disable
        :param pulumi.Input[builtins.str] import_policy: Default import policies if no per-neighbor policies defined
        :param pulumi.Input[builtins.str] local_as: Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param pulumi.Input[builtins.str] neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayBgpConfigNeighborsArgs']]] neighbors: If per-neighbor as is desired. Property key is the neighbor address
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        :param pulumi.Input[builtins.bool] no_readvertise_to_overlay: By default, we'll re-advertise all learned BGP routers toward overlay
        :param pulumi.Input[builtins.str] tunnel_name: If `type`==`tunnel`
        :param pulumi.Input[builtins.str] type: enum: `external`, `internal`
        :param pulumi.Input[builtins.str] via: network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        :param pulumi.Input[builtins.str] wan_name: If `via`==`wan`
        """
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if bfd_multiplier is not None:
            pulumi.set(__self__, "bfd_multiplier", bfd_multiplier)
        if disable_bfd is not None:
            pulumi.set(__self__, "disable_bfd", disable_bfd)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if extended_v4_nexthop is not None:
            pulumi.set(__self__, "extended_v4_nexthop", extended_v4_nexthop)
        if graceful_restart_time is not None:
            pulumi.set(__self__, "graceful_restart_time", graceful_restart_time)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if no_private_as is not None:
            pulumi.set(__self__, "no_private_as", no_private_as)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if tunnel_name is not None:
            pulumi.set(__self__, "tunnel_name", tunnel_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if via is not None:
            pulumi.set(__self__, "via", via)
        if vpn_name is not None:
            pulumi.set(__self__, "vpn_name", vpn_name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "auth_key")

    @auth_key.setter
    def auth_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_key", value)

    @property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        return pulumi.get(self, "bfd_minimum_interval")

    @bfd_minimum_interval.setter
    def bfd_minimum_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bfd_minimum_interval", value)

    @property
    @pulumi.getter(name="bfdMultiplier")
    def bfd_multiplier(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When bfd_minimum_interval_is_configured alone
        """
        return pulumi.get(self, "bfd_multiplier")

    @bfd_multiplier.setter
    def bfd_multiplier(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bfd_multiplier", value)

    @property
    @pulumi.getter(name="disableBfd")
    def disable_bfd(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        BFD provides faster path failure detection and is enabled by default
        """
        return pulumi.get(self, "disable_bfd")

    @disable_bfd.setter
    def disable_bfd(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_bfd", value)

    @property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default export policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="extendedV4Nexthop")
    def extended_v4_nexthop(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        return pulumi.get(self, "extended_v4_nexthop")

    @extended_v4_nexthop.setter
    def extended_v4_nexthop(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "extended_v4_nexthop", value)

    @property
    @pulumi.getter(name="gracefulRestartTime")
    def graceful_restart_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        `0` means disable
        """
        return pulumi.get(self, "graceful_restart_time")

    @graceful_restart_time.setter
    def graceful_restart_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "graceful_restart_time", value)

    @property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hold_time", value)

    @property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "import_")

    @import_.setter
    def import_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default import policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "local_as")

    @local_as.setter
    def local_as(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_as", value)

    @property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @neighbor_as.setter
    def neighbor_as(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "neighbor_as", value)

    @property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayBgpConfigNeighborsArgs']]]]:
        """
        If per-neighbor as is desired. Property key is the neighbor address
        """
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayBgpConfigNeighborsArgs']]]]):
        pulumi.set(self, "neighbors", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="noPrivateAs")
    def no_private_as(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "no_private_as")

    @no_private_as.setter
    def no_private_as(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_private_as", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, we'll re-advertise all learned BGP routers toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`tunnel`
        """
        return pulumi.get(self, "tunnel_name")

    @tunnel_name.setter
    def tunnel_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tunnel_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `external`, `internal`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter(name="vpnName")
    def vpn_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vpn_name")

    @vpn_name.setter
    def vpn_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpn_name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `via`==`wan`
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class DeviceprofileGatewayBgpConfigNeighborsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        export_policy: NotRequired[pulumi.Input[builtins.str]]
        hold_time: NotRequired[pulumi.Input[builtins.int]]
        import_policy: NotRequired[pulumi.Input[builtins.str]]
        multihop_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Assuming BGP neighbor is directly connected
        """
        neighbor_as: NotRequired[pulumi.Input[builtins.str]]
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
elif False:
    DeviceprofileGatewayBgpConfigNeighborsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayBgpConfigNeighborsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 export_policy: Optional[pulumi.Input[builtins.str]] = None,
                 hold_time: Optional[pulumi.Input[builtins.int]] = None,
                 import_policy: Optional[pulumi.Input[builtins.str]] = None,
                 multihop_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 neighbor_as: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: If true, the BGP session to this neighbor will be administratively disabled/shutdown
        :param pulumi.Input[builtins.int] multihop_ttl: Assuming BGP neighbor is directly connected
        :param pulumi.Input[builtins.str] neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if multihop_ttl is not None:
            pulumi.set(__self__, "multihop_ttl", multihop_ttl)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hold_time", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="multihopTtl")
    def multihop_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Assuming BGP neighbor is directly connected
        """
        return pulumi.get(self, "multihop_ttl")

    @multihop_ttl.setter
    def multihop_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "multihop_ttl", value)

    @property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @neighbor_as.setter
    def neighbor_as(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "neighbor_as", value)


if not MYPY:
    class DeviceprofileGatewayDhcpdConfigArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigArgsDict']]]]
        """
        Property key is the network name
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set to `false`, disable the DHCP server
        """
elif False:
    DeviceprofileGatewayDhcpdConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayDhcpdConfigArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigArgs']]] config: Property key is the network name
        :param pulumi.Input[builtins.bool] enabled: If set to `false`, disable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigArgs']]]]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigArgs']]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to `false`, disable the DHCP server
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileGatewayDhcpdConfigConfigArgsDict(TypedDict):
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        fixed_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgsDict']]]]
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        ip_end: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`local`
        """
        ip_end6: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type6`==`local`
        """
        ip_start: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`local`
        """
        ip_start6: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type6`==`local`
        """
        lease_time: NotRequired[pulumi.Input[builtins.int]]
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigOptionsArgsDict']]]]
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        server_id_override: NotRequired[pulumi.Input[builtins.bool]]
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`relay`
        """
        servers6s: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type6`==`relay`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        type6: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        vendor_encapsulated: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgsDict']]]]
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
elif False:
    DeviceprofileGatewayDhcpdConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayDhcpdConfigConfigArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 fixed_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs']]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip_end: Optional[pulumi.Input[builtins.str]] = None,
                 ip_end6: Optional[pulumi.Input[builtins.str]] = None,
                 ip_start: Optional[pulumi.Input[builtins.str]] = None,
                 ip_start6: Optional[pulumi.Input[builtins.str]] = None,
                 lease_time: Optional[pulumi.Input[builtins.int]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigOptionsArgs']]]] = None,
                 server_id_override: Optional[pulumi.Input[builtins.bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 servers6s: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 type6: Optional[pulumi.Input[builtins.str]] = None,
                 vendor_encapsulated: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_suffixes: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs']]] fixed_bindings: If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        :param pulumi.Input[builtins.str] gateway: If `type`==`local` - optional, `ip` will be used if not provided
        :param pulumi.Input[builtins.str] ip_end: If `type`==`local`
        :param pulumi.Input[builtins.str] ip_end6: If `type6`==`local`
        :param pulumi.Input[builtins.str] ip_start: If `type`==`local`
        :param pulumi.Input[builtins.str] ip_start6: If `type6`==`local`
        :param pulumi.Input[builtins.int] lease_time: In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigOptionsArgs']]] options: If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        :param pulumi.Input[builtins.bool] server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] servers: If `type`==`relay`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] servers6s: If `type6`==`relay`
        :param pulumi.Input[builtins.str] type: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param pulumi.Input[builtins.str] type6: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs']]] vendor_encapsulated: If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_end6 is not None:
            pulumi.set(__self__, "ip_end6", ip_end6)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if ip_start6 is not None:
            pulumi.set(__self__, "ip_start6", ip_start6)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if servers6s is not None:
            pulumi.set(__self__, "servers6s", servers6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapsulated is not None:
            pulumi.set(__self__, "vendor_encapsulated", vendor_encapsulated)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs']]]]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @fixed_bindings.setter
    def fixed_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs']]]]):
        pulumi.set(self, "fixed_bindings", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_end")

    @ip_end.setter
    def ip_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_end", value)

    @property
    @pulumi.getter(name="ipEnd6")
    def ip_end6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip_end6")

    @ip_end6.setter
    def ip_end6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_end6", value)

    @property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_start")

    @ip_start.setter
    def ip_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_start", value)

    @property
    @pulumi.getter(name="ipStart6")
    def ip_start6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip_start6")

    @ip_start6.setter
    def ip_start6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_start6", value)

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @lease_time.setter
    def lease_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "lease_time", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigOptionsArgs']]]]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigOptionsArgs']]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @server_id_override.setter
    def server_id_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "server_id_override", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter
    def servers6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type6`==`relay`
        """
        return pulumi.get(self, "servers6s")

    @servers6s.setter
    def servers6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "servers6s", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type6", value)

    @property
    @pulumi.getter(name="vendorEncapsulated")
    def vendor_encapsulated(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs']]]]:
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
        return pulumi.get(self, "vendor_encapsulated")

    @vendor_encapsulated.setter
    def vendor_encapsulated(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs']]]]):
        pulumi.set(self, "vendor_encapsulated", value)


if not MYPY:
    class DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgsDict(TypedDict):
        ip: pulumi.Input[builtins.str]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeviceprofileGatewayDhcpdConfigConfigOptionsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayDhcpdConfigConfigOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayDhcpdConfigConfigOptionsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeviceprofileGatewayExtraRoutes6ArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
elif False:
    DeviceprofileGatewayExtraRoutes6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayExtraRoutes6Args:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class DeviceprofileGatewayExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
elif False:
    DeviceprofileGatewayExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class DeviceprofileGatewayIdpProfilesArgsDict(TypedDict):
        base_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `critical`, `standard`, `strict`
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        org_id: NotRequired[pulumi.Input[builtins.str]]
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteArgsDict']]]]
elif False:
    DeviceprofileGatewayIdpProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayIdpProfilesArgs:
    def __init__(__self__, *,
                 base_profile: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] base_profile: enum: `critical`, `standard`, `strict`
        """
        if base_profile is not None:
            pulumi.set(__self__, "base_profile", base_profile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)

    @property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @base_profile.setter
    def base_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_profile", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteArgs']]]]:
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteArgs']]]]):
        pulumi.set(self, "overwrites", value)


if not MYPY:
    class DeviceprofileGatewayIdpProfilesOverwriteArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        matching: NotRequired[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteMatchingArgsDict']]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayIdpProfilesOverwriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayIdpProfilesOverwriteArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 matching: Optional[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteMatchingArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteMatchingArgs']]:
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['DeviceprofileGatewayIdpProfilesOverwriteMatchingArgs']]):
        pulumi.set(self, "matching", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeviceprofileGatewayIdpProfilesOverwriteMatchingArgsDict(TypedDict):
        attack_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        dst_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    DeviceprofileGatewayIdpProfilesOverwriteMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayIdpProfilesOverwriteMatchingArgs:
    def __init__(__self__, *,
                 attack_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dst_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "attack_names")

    @attack_names.setter
    def attack_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attack_names", value)

    @property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "dst_subnets")

    @dst_subnets.setter
    def dst_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dst_subnets", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "severities", value)


if not MYPY:
    class DeviceprofileGatewayIpConfigsArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[builtins.str]]
        netmask: NotRequired[pulumi.Input[builtins.str]]
        secondary_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional list of secondary IPs in CIDR format
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
elif False:
    DeviceprofileGatewayIpConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayIpConfigsArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] secondary_ips: Optional list of secondary IPs in CIDR format
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if secondary_ips is not None:
            pulumi.set(__self__, "secondary_ips", secondary_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="secondaryIps")
    def secondary_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional list of secondary IPs in CIDR format
        """
        return pulumi.get(self, "secondary_ips")

    @secondary_ips.setter
    def secondary_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "secondary_ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeviceprofileGatewayNetworkArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        subnet: pulumi.Input[builtins.str]
        disallow_mist_services: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disallow Mist Devices in the network
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        gateway6: NotRequired[pulumi.Input[builtins.str]]
        internal_access: NotRequired[pulumi.Input['DeviceprofileGatewayNetworkInternalAccessArgsDict']]
        internet_access: NotRequired[pulumi.Input['DeviceprofileGatewayNetworkInternetAccessArgsDict']]
        """
        Whether this network has direct internet access
        """
        isolation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow clients in the network to talk to each other
        """
        multicast: NotRequired[pulumi.Input['DeviceprofileGatewayNetworkMulticastArgsDict']]
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        routed_for_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        subnet6: NotRequired[pulumi.Input[builtins.str]]
        tenants: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkTenantsArgsDict']]]]
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
        vpn_access: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessArgsDict']]]]
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
elif False:
    DeviceprofileGatewayNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 subnet: pulumi.Input[builtins.str],
                 disallow_mist_services: Optional[pulumi.Input[builtins.bool]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 gateway6: Optional[pulumi.Input[builtins.str]] = None,
                 internal_access: Optional[pulumi.Input['DeviceprofileGatewayNetworkInternalAccessArgs']] = None,
                 internet_access: Optional[pulumi.Input['DeviceprofileGatewayNetworkInternetAccessArgs']] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 multicast: Optional[pulumi.Input['DeviceprofileGatewayNetworkMulticastArgs']] = None,
                 routed_for_networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subnet6: Optional[pulumi.Input[builtins.str]] = None,
                 tenants: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkTenantsArgs']]]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vpn_access: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] disallow_mist_services: Whether to disallow Mist Devices in the network
        :param pulumi.Input['DeviceprofileGatewayNetworkInternetAccessArgs'] internet_access: Whether this network has direct internet access
        :param pulumi.Input[builtins.bool] isolation: Whether to allow clients in the network to talk to each other
        :param pulumi.Input['DeviceprofileGatewayNetworkMulticastArgs'] multicast: Whether to enable multicast support (only PIM-sparse mode is supported)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] routed_for_networks: For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkTenantsArgs']]] tenants: Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessArgs']]] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        if disallow_mist_services is not None:
            pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if internal_access is not None:
            pulumi.set(__self__, "internal_access", internal_access)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if routed_for_networks is not None:
            pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_access is not None:
            pulumi.set(__self__, "vpn_access", vpn_access)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @disallow_mist_services.setter
    def disallow_mist_services(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disallow_mist_services", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def gateway6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gateway6")

    @gateway6.setter
    def gateway6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway6", value)

    @property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> Optional[pulumi.Input['DeviceprofileGatewayNetworkInternalAccessArgs']]:
        return pulumi.get(self, "internal_access")

    @internal_access.setter
    def internal_access(self, value: Optional[pulumi.Input['DeviceprofileGatewayNetworkInternalAccessArgs']]):
        pulumi.set(self, "internal_access", value)

    @property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[pulumi.Input['DeviceprofileGatewayNetworkInternetAccessArgs']]:
        """
        Whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @internet_access.setter
    def internet_access(self, value: Optional[pulumi.Input['DeviceprofileGatewayNetworkInternetAccessArgs']]):
        pulumi.set(self, "internet_access", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['DeviceprofileGatewayNetworkMulticastArgs']]:
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['DeviceprofileGatewayNetworkMulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @routed_for_networks.setter
    def routed_for_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "routed_for_networks", value)

    @property
    @pulumi.getter
    def subnet6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "subnet6")

    @subnet6.setter
    def subnet6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet6", value)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkTenantsArgs']]]]:
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkTenantsArgs']]]]):
        pulumi.set(self, "tenants", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessArgs']]]]:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")

    @vpn_access.setter
    def vpn_access(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessArgs']]]]):
        pulumi.set(self, "vpn_access", value)


if not MYPY:
    class DeviceprofileGatewayNetworkInternalAccessArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DeviceprofileGatewayNetworkInternalAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkInternalAccessArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileGatewayNetworkInternetAccessArgsDict(TypedDict):
        create_simple_service_policy: NotRequired[pulumi.Input[builtins.bool]]
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessDestinationNatArgsDict']]]]
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        restricted: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessStaticNatArgsDict']]]]
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
elif False:
    DeviceprofileGatewayNetworkInternetAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkInternetAccessArgs:
    def __init__(__self__, *,
                 create_simple_service_policy: Optional[pulumi.Input[builtins.bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 restricted: Optional[pulumi.Input[builtins.bool]] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessStaticNatArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs']]] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param pulumi.Input[builtins.bool] restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessStaticNatArgs']]] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "create_simple_service_policy")

    @create_simple_service_policy.setter
    def create_simple_service_policy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create_simple_service_policy", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs']]]]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def restricted(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @restricted.setter
    def restricted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restricted", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessStaticNatArgs']]]]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkInternetAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)


if not MYPY:
    class DeviceprofileGatewayNetworkInternetAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
elif False:
    DeviceprofileGatewayNetworkInternetAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class DeviceprofileGatewayNetworkInternetAccessStaticNatArgsDict(TypedDict):
        internal_ip: pulumi.Input[builtins.str]
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        name: pulumi.Input[builtins.str]
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
elif False:
    DeviceprofileGatewayNetworkInternetAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkInternetAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> pulumi.Input[builtins.str]:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class DeviceprofileGatewayNetworkMulticastArgsDict(TypedDict):
        disable_igmp: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        groups: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkMulticastGroupsArgsDict']]]]
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
elif False:
    DeviceprofileGatewayNetworkMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkMulticastArgs:
    def __init__(__self__, *,
                 disable_igmp: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkMulticastGroupsArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkMulticastGroupsArgs']]] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @disable_igmp.setter
    def disable_igmp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_igmp", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkMulticastGroupsArgs']]]]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkMulticastGroupsArgs']]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class DeviceprofileGatewayNetworkMulticastGroupsArgsDict(TypedDict):
        rp_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        RP (rendezvous point) IP Address
        """
elif False:
    DeviceprofileGatewayNetworkMulticastGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkMulticastGroupsArgs:
    def __init__(__self__, *,
                 rp_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")

    @rp_ip.setter
    def rp_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rp_ip", value)


if not MYPY:
    class DeviceprofileGatewayNetworkTenantsArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    DeviceprofileGatewayNetworkTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkTenantsArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class DeviceprofileGatewayNetworkVpnAccessArgsDict(TypedDict):
        advertised_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        allow_ping: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow ping from vpn into this routed network
        """
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessDestinationNatArgsDict']]]]
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        nat_pool: NotRequired[pulumi.Input[builtins.str]]
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        no_readvertise_to_lan_bgp: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward LAN-side BGP peers
        """
        no_readvertise_to_lan_ospf: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward LAN-side OSPF peers
        """
        no_readvertise_to_overlay: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        other_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        routed: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether this network is routable
        """
        source_nat: NotRequired[pulumi.Input['DeviceprofileGatewayNetworkVpnAccessSourceNatArgsDict']]
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessStaticNatArgsDict']]]]
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        summarized_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        summarized_subnet_to_lan_bgp: NotRequired[pulumi.Input[builtins.str]]
        """
        toward LAN-side BGP peers
        """
        summarized_subnet_to_lan_ospf: NotRequired[pulumi.Input[builtins.str]]
        """
        toward LAN-side OSPF peers
        """
elif False:
    DeviceprofileGatewayNetworkVpnAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkVpnAccessArgs:
    def __init__(__self__, *,
                 advertised_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 allow_ping: Optional[pulumi.Input[builtins.bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs']]]] = None,
                 nat_pool: Optional[pulumi.Input[builtins.str]] = None,
                 no_readvertise_to_lan_bgp: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_lan_ospf: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[builtins.bool]] = None,
                 other_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 routed: Optional[pulumi.Input[builtins.bool]] = None,
                 source_nat: Optional[pulumi.Input['DeviceprofileGatewayNetworkVpnAccessSourceNatArgs']] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessStaticNatArgs']]]] = None,
                 summarized_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 summarized_subnet_to_lan_bgp: Optional[pulumi.Input[builtins.str]] = None,
                 summarized_subnet_to_lan_ospf: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param pulumi.Input[builtins.bool] allow_ping: Whether to allow ping from vpn into this routed network
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs']]] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param pulumi.Input[builtins.str] nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param pulumi.Input[builtins.bool] no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[builtins.bool] no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param pulumi.Input[builtins.bool] no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param pulumi.Input[builtins.bool] routed: Whether this network is routable
        :param pulumi.Input['DeviceprofileGatewayNetworkVpnAccessSourceNatArgs'] source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessStaticNatArgs']]] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param pulumi.Input[builtins.str] summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[builtins.str] summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @advertised_subnet.setter
    def advertised_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "advertised_subnet", value)

    @property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @allow_ping.setter
    def allow_ping(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ping", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs']]]]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nat_pool", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @no_readvertise_to_lan_bgp.setter
    def no_readvertise_to_lan_bgp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_lan_bgp", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @no_readvertise_to_lan_ospf.setter
    def no_readvertise_to_lan_ospf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_lan_ospf", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @other_vrfs.setter
    def other_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "other_vrfs", value)

    @property
    @pulumi.getter
    def routed(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @routed.setter
    def routed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "routed", value)

    @property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional[pulumi.Input['DeviceprofileGatewayNetworkVpnAccessSourceNatArgs']]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @source_nat.setter
    def source_nat(self, value: Optional[pulumi.Input['DeviceprofileGatewayNetworkVpnAccessSourceNatArgs']]):
        pulumi.set(self, "source_nat", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessStaticNatArgs']]]]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayNetworkVpnAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)

    @property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @summarized_subnet.setter
    def summarized_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @summarized_subnet_to_lan_bgp.setter
    def summarized_subnet_to_lan_bgp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet_to_lan_bgp", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")

    @summarized_subnet_to_lan_ospf.setter
    def summarized_subnet_to_lan_ospf(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet_to_lan_ospf", value)


if not MYPY:
    class DeviceprofileGatewayNetworkVpnAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayNetworkVpnAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DeviceprofileGatewayNetworkVpnAccessSourceNatArgsDict(TypedDict):
        external_ip: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayNetworkVpnAccessSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkVpnAccessSourceNatArgs:
    def __init__(__self__, *,
                 external_ip: Optional[pulumi.Input[builtins.str]] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_ip")

    @external_ip.setter
    def external_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_ip", value)


if not MYPY:
    class DeviceprofileGatewayNetworkVpnAccessStaticNatArgsDict(TypedDict):
        internal_ip: pulumi.Input[builtins.str]
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        name: pulumi.Input[builtins.str]
elif False:
    DeviceprofileGatewayNetworkVpnAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayNetworkVpnAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> pulumi.Input[builtins.str]:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeviceprofileGatewayOobIpConfigArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        node1: NotRequired[pulumi.Input['DeviceprofileGatewayOobIpConfigNode1ArgsDict']]
        """
        For HA Cluster, node1 can have different IP Config
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[builtins.bool]]
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[builtins.bool]]
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayOobIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayOobIpConfigArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 node1: Optional[pulumi.Input['DeviceprofileGatewayOobIpConfigNode1Args']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[builtins.bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gateway: If `type`==`static`
        :param pulumi.Input[builtins.str] ip: If `type`==`static`
        :param pulumi.Input[builtins.str] netmask: If `type`==`static`
        :param pulumi.Input['DeviceprofileGatewayOobIpConfigNode1Args'] node1: For HA Cluster, node1 can have different IP Config
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        :param pulumi.Input[builtins.bool] use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[builtins.bool] use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if node1 is not None:
            pulumi.set(__self__, "node1", node1)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def node1(self) -> Optional[pulumi.Input['DeviceprofileGatewayOobIpConfigNode1Args']]:
        """
        For HA Cluster, node1 can have different IP Config
        """
        return pulumi.get(self, "node1")

    @node1.setter
    def node1(self, value: Optional[pulumi.Input['DeviceprofileGatewayOobIpConfigNode1Args']]):
        pulumi.set(self, "node1", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class DeviceprofileGatewayOobIpConfigNode1ArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        Used only if `subnet` is not specified in `networks`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[builtins.bool]]
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayOobIpConfigNode1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayOobIpConfigNode1Args:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[builtins.bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gateway: If `type`==`static`
        :param pulumi.Input[builtins.str] netmask: Used only if `subnet` is not specified in `networks`
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        :param pulumi.Input[builtins.bool] use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[builtins.bool] use_mgmt_vrf_for_host_out: Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class DeviceprofileGatewayPathPreferencesArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayPathPreferencesPathArgsDict']]]]
        strategy: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
elif False:
    DeviceprofileGatewayPathPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPathPreferencesArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayPathPreferencesPathArgs']]]] = None,
                 strategy: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] strategy: enum: `ecmp`, `ordered`, `weighted`
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayPathPreferencesPathArgs']]]]:
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayPathPreferencesPathArgs']]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class DeviceprofileGatewayPathPreferencesPathArgsDict(TypedDict):
        cost: NotRequired[pulumi.Input[builtins.int]]
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        gateway_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        internet_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required when `type`==`local`
        """
        target_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `type`==`vpn`
        """
elif False:
    DeviceprofileGatewayPathPreferencesPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPathPreferencesPathArgs:
    def __init__(__self__, *,
                 cost: Optional[pulumi.Input[builtins.int]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 gateway_ip: Optional[pulumi.Input[builtins.str]] = None,
                 internet_access: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: For SSR Only. `true`, if this specific path is undesired
        :param pulumi.Input[builtins.str] gateway_ip: Only if `type`==`local`, if a different gateway is desired
        :param pulumi.Input[builtins.bool] internet_access: Only if `type`==`vpn`, if this vpn path can be used for internet
        :param pulumi.Input[builtins.str] name: Required when 
                 * `type`==`vpn`: the name of the VPN Path to use 
                 * `type`==`wan`: the name of the WAN interface to use
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: Required when `type`==`local`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_ips: If `type`==`local`, if destination IP is to be replaced
        :param pulumi.Input[builtins.str] type: enum: `local`, `tunnel`, `vpn`, `wan`
        :param pulumi.Input[builtins.str] wan_name: Optional if `type`==`vpn`
        """
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cost", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway_ip", value)

    @property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        return pulumi.get(self, "internet_access")

    @internet_access.setter
    def internet_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "internet_access", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required when `type`==`local`
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        return pulumi.get(self, "target_ips")

    @target_ips.setter
    def target_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `type`==`vpn`
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigArgsDict(TypedDict):
        usage: pulumi.Input[builtins.str]
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        ae_disable_lacp: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        ae_idx: NotRequired[pulumi.Input[builtins.str]]
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        ae_lacp_force_up: NotRequired[pulumi.Input[builtins.bool]]
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        aggregated: NotRequired[pulumi.Input[builtins.bool]]
        critical: NotRequired[pulumi.Input[builtins.bool]]
        """
        To generate port up/down alarm, set it to true
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        disable_autoneg: NotRequired[pulumi.Input[builtins.bool]]
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Port admin up (true) / down (false)
        """
        dsl_type: NotRequired[pulumi.Input[builtins.str]]
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        dsl_vci: NotRequired[pulumi.Input[builtins.int]]
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        dsl_vpi: NotRequired[pulumi.Input[builtins.int]]
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        duplex: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `full`, `half`
        """
        ip_config: NotRequired[pulumi.Input['DeviceprofileGatewayPortConfigIpConfigArgsDict']]
        """
        Junos IP Config
        """
        lte_apn: NotRequired[pulumi.Input[builtins.str]]
        """
        If `wan_type`==`lte`
        """
        lte_auth: NotRequired[pulumi.Input[builtins.str]]
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        lte_backup: NotRequired[pulumi.Input[builtins.bool]]
        lte_password: NotRequired[pulumi.Input[builtins.str]]
        """
        If `wan_type`==`lte`
        """
        lte_username: NotRequired[pulumi.Input[builtins.str]]
        """
        If `wan_type`==`lte`
        """
        mtu: NotRequired[pulumi.Input[builtins.int]]
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name that we'll use to derive config
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        outer_vlan_id: NotRequired[pulumi.Input[builtins.int]]
        """
        For Q-in-Q
        """
        poe_disabled: NotRequired[pulumi.Input[builtins.bool]]
        port_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        preserve_dscp: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        redundant: NotRequired[pulumi.Input[builtins.bool]]
        """
        If HA mode
        """
        redundant_group: NotRequired[pulumi.Input[builtins.int]]
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        reth_idx: NotRequired[pulumi.Input[builtins.str]]
        """
        For SRX only and if HA Mode
        """
        reth_node: NotRequired[pulumi.Input[builtins.str]]
        """
        If HA mode
        """
        reth_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        speed: NotRequired[pulumi.Input[builtins.str]]
        ssr_no_virtual_mac: NotRequired[pulumi.Input[builtins.bool]]
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        svr_port_range: NotRequired[pulumi.Input[builtins.str]]
        """
        For SSR only
        """
        traffic_shaping: NotRequired[pulumi.Input['DeviceprofileGatewayPortConfigTrafficShapingArgsDict']]
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
        vpn_paths: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsArgsDict']]]]
        """
        Property key is the VPN name
        """
        wan_arp_policer: NotRequired[pulumi.Input[builtins.str]]
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        wan_ext_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        wan_extra_routes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigWanExtraRoutesArgsDict']]]]
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        wan_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        wan_probe_override: NotRequired[pulumi.Input['DeviceprofileGatewayPortConfigWanProbeOverrideArgsDict']]
        """
        Only if `usage`==`wan`
        """
        wan_source_nat: NotRequired[pulumi.Input['DeviceprofileGatewayPortConfigWanSourceNatArgsDict']]
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        wan_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
elif False:
    DeviceprofileGatewayPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[builtins.str],
                 ae_disable_lacp: Optional[pulumi.Input[builtins.bool]] = None,
                 ae_idx: Optional[pulumi.Input[builtins.str]] = None,
                 ae_lacp_force_up: Optional[pulumi.Input[builtins.bool]] = None,
                 aggregated: Optional[pulumi.Input[builtins.bool]] = None,
                 critical: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disable_autoneg: Optional[pulumi.Input[builtins.bool]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dsl_type: Optional[pulumi.Input[builtins.str]] = None,
                 dsl_vci: Optional[pulumi.Input[builtins.int]] = None,
                 dsl_vpi: Optional[pulumi.Input[builtins.int]] = None,
                 duplex: Optional[pulumi.Input[builtins.str]] = None,
                 ip_config: Optional[pulumi.Input['DeviceprofileGatewayPortConfigIpConfigArgs']] = None,
                 lte_apn: Optional[pulumi.Input[builtins.str]] = None,
                 lte_auth: Optional[pulumi.Input[builtins.str]] = None,
                 lte_backup: Optional[pulumi.Input[builtins.bool]] = None,
                 lte_password: Optional[pulumi.Input[builtins.str]] = None,
                 lte_username: Optional[pulumi.Input[builtins.str]] = None,
                 mtu: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 outer_vlan_id: Optional[pulumi.Input[builtins.int]] = None,
                 poe_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 port_network: Optional[pulumi.Input[builtins.str]] = None,
                 preserve_dscp: Optional[pulumi.Input[builtins.bool]] = None,
                 redundant: Optional[pulumi.Input[builtins.bool]] = None,
                 redundant_group: Optional[pulumi.Input[builtins.int]] = None,
                 reth_idx: Optional[pulumi.Input[builtins.str]] = None,
                 reth_node: Optional[pulumi.Input[builtins.str]] = None,
                 reth_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 speed: Optional[pulumi.Input[builtins.str]] = None,
                 ssr_no_virtual_mac: Optional[pulumi.Input[builtins.bool]] = None,
                 svr_port_range: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_shaping: Optional[pulumi.Input['DeviceprofileGatewayPortConfigTrafficShapingArgs']] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vpn_paths: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsArgs']]]] = None,
                 wan_arp_policer: Optional[pulumi.Input[builtins.str]] = None,
                 wan_ext_ip: Optional[pulumi.Input[builtins.str]] = None,
                 wan_extra_routes: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigWanExtraRoutesArgs']]]] = None,
                 wan_networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wan_probe_override: Optional[pulumi.Input['DeviceprofileGatewayPortConfigWanProbeOverrideArgs']] = None,
                 wan_source_nat: Optional[pulumi.Input['DeviceprofileGatewayPortConfigWanSourceNatArgs']] = None,
                 wan_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] usage: port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        :param pulumi.Input[builtins.bool] ae_disable_lacp: If `aggregated`==`true`. To disable LCP support for the AE interface
        :param pulumi.Input[builtins.str] ae_idx: If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        :param pulumi.Input[builtins.bool] ae_lacp_force_up: For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        :param pulumi.Input[builtins.bool] critical: To generate port up/down alarm, set it to true
        :param pulumi.Input[builtins.str] description: Interface Description. Can be a variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.bool] disabled: Port admin up (true) / down (false)
        :param pulumi.Input[builtins.str] dsl_type: if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        :param pulumi.Input[builtins.int] dsl_vci: If `wan_type`==`dsl`, 16 bit int
        :param pulumi.Input[builtins.int] dsl_vpi: If `wan_type`==`dsl`, 8 bit int
        :param pulumi.Input[builtins.str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input['DeviceprofileGatewayPortConfigIpConfigArgs'] ip_config: Junos IP Config
        :param pulumi.Input[builtins.str] lte_apn: If `wan_type`==`lte`
        :param pulumi.Input[builtins.str] lte_auth: if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        :param pulumi.Input[builtins.str] lte_password: If `wan_type`==`lte`
        :param pulumi.Input[builtins.str] lte_username: If `wan_type`==`lte`
        :param pulumi.Input[builtins.str] name: Name that we'll use to derive config
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: if `usage`==`lan`, name of the `org.Network` resource
        :param pulumi.Input[builtins.int] outer_vlan_id: For Q-in-Q
        :param pulumi.Input[builtins.str] port_network: Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        :param pulumi.Input[builtins.bool] preserve_dscp: Whether to preserve dscp when sending traffic over VPN (SSR-only)
        :param pulumi.Input[builtins.bool] redundant: If HA mode
        :param pulumi.Input[builtins.int] redundant_group: If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        :param pulumi.Input[builtins.str] reth_idx: For SRX only and if HA Mode
        :param pulumi.Input[builtins.str] reth_node: If HA mode
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] reth_nodes: SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        :param pulumi.Input[builtins.bool] ssr_no_virtual_mac: When SSR is running as VM, this is required on certain hosting platforms
        :param pulumi.Input[builtins.str] svr_port_range: For SSR only
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsArgs']]] vpn_paths: Property key is the VPN name
        :param pulumi.Input[builtins.str] wan_arp_policer: Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        :param pulumi.Input[builtins.str] wan_ext_ip: Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigWanExtraRoutesArgs']]] wan_extra_routes: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wan_networks: Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        :param pulumi.Input['DeviceprofileGatewayPortConfigWanProbeOverrideArgs'] wan_probe_override: Only if `usage`==`wan`
        :param pulumi.Input['DeviceprofileGatewayPortConfigWanSourceNatArgs'] wan_source_nat: Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        :param pulumi.Input[builtins.str] wan_type: Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_force_up is not None:
            pulumi.set(__self__, "ae_lacp_force_up", ae_lacp_force_up)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dsl_type is not None:
            pulumi.set(__self__, "dsl_type", dsl_type)
        if dsl_vci is not None:
            pulumi.set(__self__, "dsl_vci", dsl_vci)
        if dsl_vpi is not None:
            pulumi.set(__self__, "dsl_vpi", dsl_vpi)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if lte_apn is not None:
            pulumi.set(__self__, "lte_apn", lte_apn)
        if lte_auth is not None:
            pulumi.set(__self__, "lte_auth", lte_auth)
        if lte_backup is not None:
            pulumi.set(__self__, "lte_backup", lte_backup)
        if lte_password is not None:
            pulumi.set(__self__, "lte_password", lte_password)
        if lte_username is not None:
            pulumi.set(__self__, "lte_username", lte_username)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if outer_vlan_id is not None:
            pulumi.set(__self__, "outer_vlan_id", outer_vlan_id)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if preserve_dscp is not None:
            pulumi.set(__self__, "preserve_dscp", preserve_dscp)
        if redundant is not None:
            pulumi.set(__self__, "redundant", redundant)
        if redundant_group is not None:
            pulumi.set(__self__, "redundant_group", redundant_group)
        if reth_idx is not None:
            pulumi.set(__self__, "reth_idx", reth_idx)
        if reth_node is not None:
            pulumi.set(__self__, "reth_node", reth_node)
        if reth_nodes is not None:
            pulumi.set(__self__, "reth_nodes", reth_nodes)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssr_no_virtual_mac is not None:
            pulumi.set(__self__, "ssr_no_virtual_mac", ssr_no_virtual_mac)
        if svr_port_range is not None:
            pulumi.set(__self__, "svr_port_range", svr_port_range)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)
        if wan_arp_policer is not None:
            pulumi.set(__self__, "wan_arp_policer", wan_arp_policer)
        if wan_ext_ip is not None:
            pulumi.set(__self__, "wan_ext_ip", wan_ext_ip)
        if wan_extra_routes is not None:
            pulumi.set(__self__, "wan_extra_routes", wan_extra_routes)
        if wan_networks is not None:
            pulumi.set(__self__, "wan_networks", wan_networks)
        if wan_probe_override is not None:
            pulumi.set(__self__, "wan_probe_override", wan_probe_override)
        if wan_source_nat is not None:
            pulumi.set(__self__, "wan_source_nat", wan_source_nat)
        if wan_type is not None:
            pulumi.set(__self__, "wan_type", wan_type)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[builtins.str]:
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @ae_disable_lacp.setter
    def ae_disable_lacp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ae_disable_lacp", value)

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        return pulumi.get(self, "ae_idx")

    @ae_idx.setter
    def ae_idx(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ae_idx", value)

    @property
    @pulumi.getter(name="aeLacpForceUp")
    def ae_lacp_force_up(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        return pulumi.get(self, "ae_lacp_force_up")

    @ae_lacp_force_up.setter
    def ae_lacp_force_up(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ae_lacp_force_up", value)

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aggregated")

    @aggregated.setter
    def aggregated(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aggregated", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To generate port up/down alarm, set it to true
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Port admin up (true) / down (false)
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="dslType")
    def dsl_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        return pulumi.get(self, "dsl_type")

    @dsl_type.setter
    def dsl_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dsl_type", value)

    @property
    @pulumi.getter(name="dslVci")
    def dsl_vci(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        return pulumi.get(self, "dsl_vci")

    @dsl_vci.setter
    def dsl_vci(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dsl_vci", value)

    @property
    @pulumi.getter(name="dslVpi")
    def dsl_vpi(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        return pulumi.get(self, "dsl_vpi")

    @dsl_vpi.setter
    def dsl_vpi(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dsl_vpi", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional[pulumi.Input['DeviceprofileGatewayPortConfigIpConfigArgs']]:
        """
        Junos IP Config
        """
        return pulumi.get(self, "ip_config")

    @ip_config.setter
    def ip_config(self, value: Optional[pulumi.Input['DeviceprofileGatewayPortConfigIpConfigArgs']]):
        pulumi.set(self, "ip_config", value)

    @property
    @pulumi.getter(name="lteApn")
    def lte_apn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_apn")

    @lte_apn.setter
    def lte_apn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_apn", value)

    @property
    @pulumi.getter(name="lteAuth")
    def lte_auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "lte_auth")

    @lte_auth.setter
    def lte_auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_auth", value)

    @property
    @pulumi.getter(name="lteBackup")
    def lte_backup(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "lte_backup")

    @lte_backup.setter
    def lte_backup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "lte_backup", value)

    @property
    @pulumi.getter(name="ltePassword")
    def lte_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_password")

    @lte_password.setter
    def lte_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_password", value)

    @property
    @pulumi.getter(name="lteUsername")
    def lte_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_username")

    @lte_username.setter
    def lte_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_username", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name that we'll use to derive config
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="outerVlanId")
    def outer_vlan_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        For Q-in-Q
        """
        return pulumi.get(self, "outer_vlan_id")

    @outer_vlan_id.setter
    def outer_vlan_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "outer_vlan_id", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        return pulumi.get(self, "port_network")

    @port_network.setter
    def port_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_network", value)

    @property
    @pulumi.getter(name="preserveDscp")
    def preserve_dscp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        return pulumi.get(self, "preserve_dscp")

    @preserve_dscp.setter
    def preserve_dscp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "preserve_dscp", value)

    @property
    @pulumi.getter
    def redundant(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If HA mode
        """
        return pulumi.get(self, "redundant")

    @redundant.setter
    def redundant(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "redundant", value)

    @property
    @pulumi.getter(name="redundantGroup")
    def redundant_group(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        return pulumi.get(self, "redundant_group")

    @redundant_group.setter
    def redundant_group(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redundant_group", value)

    @property
    @pulumi.getter(name="rethIdx")
    def reth_idx(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For SRX only and if HA Mode
        """
        return pulumi.get(self, "reth_idx")

    @reth_idx.setter
    def reth_idx(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reth_idx", value)

    @property
    @pulumi.getter(name="rethNode")
    def reth_node(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If HA mode
        """
        return pulumi.get(self, "reth_node")

    @reth_node.setter
    def reth_node(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reth_node", value)

    @property
    @pulumi.getter(name="rethNodes")
    def reth_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        return pulumi.get(self, "reth_nodes")

    @reth_nodes.setter
    def reth_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "reth_nodes", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="ssrNoVirtualMac")
    def ssr_no_virtual_mac(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        return pulumi.get(self, "ssr_no_virtual_mac")

    @ssr_no_virtual_mac.setter
    def ssr_no_virtual_mac(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssr_no_virtual_mac", value)

    @property
    @pulumi.getter(name="svrPortRange")
    def svr_port_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For SSR only
        """
        return pulumi.get(self, "svr_port_range")

    @svr_port_range.setter
    def svr_port_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "svr_port_range", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['DeviceprofileGatewayPortConfigTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['DeviceprofileGatewayPortConfigTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsArgs']]]]:
        """
        Property key is the VPN name
        """
        return pulumi.get(self, "vpn_paths")

    @vpn_paths.setter
    def vpn_paths(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsArgs']]]]):
        pulumi.set(self, "vpn_paths", value)

    @property
    @pulumi.getter(name="wanArpPolicer")
    def wan_arp_policer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        return pulumi.get(self, "wan_arp_policer")

    @wan_arp_policer.setter
    def wan_arp_policer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_arp_policer", value)

    @property
    @pulumi.getter(name="wanExtIp")
    def wan_ext_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        return pulumi.get(self, "wan_ext_ip")

    @wan_ext_ip.setter
    def wan_ext_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_ext_ip", value)

    @property
    @pulumi.getter(name="wanExtraRoutes")
    def wan_extra_routes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigWanExtraRoutesArgs']]]]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        return pulumi.get(self, "wan_extra_routes")

    @wan_extra_routes.setter
    def wan_extra_routes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceprofileGatewayPortConfigWanExtraRoutesArgs']]]]):
        pulumi.set(self, "wan_extra_routes", value)

    @property
    @pulumi.getter(name="wanNetworks")
    def wan_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        return pulumi.get(self, "wan_networks")

    @wan_networks.setter
    def wan_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wan_networks", value)

    @property
    @pulumi.getter(name="wanProbeOverride")
    def wan_probe_override(self) -> Optional[pulumi.Input['DeviceprofileGatewayPortConfigWanProbeOverrideArgs']]:
        """
        Only if `usage`==`wan`
        """
        return pulumi.get(self, "wan_probe_override")

    @wan_probe_override.setter
    def wan_probe_override(self, value: Optional[pulumi.Input['DeviceprofileGatewayPortConfigWanProbeOverrideArgs']]):
        pulumi.set(self, "wan_probe_override", value)

    @property
    @pulumi.getter(name="wanSourceNat")
    def wan_source_nat(self) -> Optional[pulumi.Input['DeviceprofileGatewayPortConfigWanSourceNatArgs']]:
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        return pulumi.get(self, "wan_source_nat")

    @wan_source_nat.setter
    def wan_source_nat(self, value: Optional[pulumi.Input['DeviceprofileGatewayPortConfigWanSourceNatArgs']]):
        pulumi.set(self, "wan_source_nat", value)

    @property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        return pulumi.get(self, "wan_type")

    @wan_type.setter
    def wan_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_type", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigIpConfigArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, the network to be used for mgmt
        """
        poser_password: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`pppoe`
        """
        pppoe_auth: NotRequired[pulumi.Input[builtins.str]]
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        pppoe_username: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`pppoe`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `pppoe`, `static`
        """
elif False:
    DeviceprofileGatewayPortConfigIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigIpConfigArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 poser_password: Optional[pulumi.Input[builtins.str]] = None,
                 pppoe_auth: Optional[pulumi.Input[builtins.str]] = None,
                 pppoe_username: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns: Except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_suffixes: Except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[builtins.str] gateway: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] ip: Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] netmask: Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] network: Optional, the network to be used for mgmt
        :param pulumi.Input[builtins.str] poser_password: If `type`==`pppoe`
        :param pulumi.Input[builtins.str] pppoe_auth: if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        :param pulumi.Input[builtins.str] pppoe_username: If `type`==`pppoe`
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `pppoe`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if poser_password is not None:
            pulumi.set(__self__, "poser_password", poser_password)
        if pppoe_auth is not None:
            pulumi.set(__self__, "pppoe_auth", pppoe_auth)
        if pppoe_username is not None:
            pulumi.set(__self__, "pppoe_username", pppoe_username)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="poserPassword")
    def poser_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "poser_password")

    @poser_password.setter
    def poser_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "poser_password", value)

    @property
    @pulumi.getter(name="pppoeAuth")
    def pppoe_auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "pppoe_auth")

    @pppoe_auth.setter
    def pppoe_auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pppoe_auth", value)

    @property
    @pulumi.getter(name="pppoeUsername")
    def pppoe_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "pppoe_username")

    @pppoe_username.setter
    def pppoe_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pppoe_username", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `pppoe`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_tx_kbps: NotRequired[pulumi.Input[builtins.int]]
        """
        Interface Transmit Cap in kbps
        """
elif False:
    DeviceprofileGatewayPortConfigTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_tx_kbps: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param pulumi.Input[builtins.int] max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")

    @max_tx_kbps.setter
    def max_tx_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tx_kbps", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigVpnPathsArgsDict(TypedDict):
        bfd_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        bfd_use_tunnel_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        preference: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        traffic_shaping: NotRequired[pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgsDict']]
elif False:
    DeviceprofileGatewayPortConfigVpnPathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigVpnPathsArgs:
    def __init__(__self__, *,
                 bfd_profile: Optional[pulumi.Input[builtins.str]] = None,
                 bfd_use_tunnel_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 preference: Optional[pulumi.Input[builtins.int]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_shaping: Optional[pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] bfd_profile: Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        :param pulumi.Input[builtins.bool] bfd_use_tunnel_mode: Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        :param pulumi.Input[builtins.int] preference: Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        :param pulumi.Input[builtins.str] role: If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @bfd_profile.setter
    def bfd_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bfd_profile", value)

    @property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @bfd_use_tunnel_mode.setter
    def bfd_use_tunnel_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bfd_use_tunnel_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_tx_kbps: NotRequired[pulumi.Input[builtins.int]]
        """
        Interface Transmit Cap in kbps
        """
elif False:
    DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigVpnPathsTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_tx_kbps: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param pulumi.Input[builtins.int] max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")

    @max_tx_kbps.setter
    def max_tx_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tx_kbps", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigWanExtraRoutesArgsDict(TypedDict):
        via: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DeviceprofileGatewayPortConfigWanExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigWanExtraRoutesArgs:
    def __init__(__self__, *,
                 via: Optional[pulumi.Input[builtins.str]] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "via", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigWanProbeOverrideArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        probe_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `broadband`, `lte`
        """
elif False:
    DeviceprofileGatewayPortConfigWanProbeOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigWanProbeOverrideArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 probe_profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] probe_profile: enum: `broadband`, `lte`
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if probe_profile is not None:
            pulumi.set(__self__, "probe_profile", probe_profile)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="probeProfile")
    def probe_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "probe_profile")

    @probe_profile.setter
    def probe_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "probe_profile", value)


if not MYPY:
    class DeviceprofileGatewayPortConfigWanSourceNatArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Or to disable the source-nat
        """
        nat_pool: NotRequired[pulumi.Input[builtins.str]]
        """
        If alternative nat_pool is desired
        """
elif False:
    DeviceprofileGatewayPortConfigWanSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayPortConfigWanSourceNatArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 nat_pool: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Or to disable the source-nat
        :param pulumi.Input[builtins.str] nat_pool: If alternative nat_pool is desired
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Or to disable the source-nat
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If alternative nat_pool is desired
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nat_pool", value)


if not MYPY:
    class DeviceprofileGatewayRoutingPoliciesArgsDict(TypedDict):
        terms: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermArgsDict']]]]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
elif False:
    DeviceprofileGatewayRoutingPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayRoutingPoliciesArgs:
    def __init__(__self__, *,
                 terms: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermArgs']]] terms: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @property
    @pulumi.getter
    def terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermArgs']]]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "terms")

    @terms.setter
    def terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermArgs']]]]):
        pulumi.set(self, "terms", value)


if not MYPY:
    class DeviceprofileGatewayRoutingPoliciesTermArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermActionArgsDict']]
        """
        When used as import policy
        """
        matching: NotRequired[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingArgsDict']]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
elif False:
    DeviceprofileGatewayRoutingPoliciesTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayRoutingPoliciesTermArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermActionArgs']] = None,
                 matching: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingArgs']] = None):
        """
        :param pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermActionArgs'] action: When used as import policy
        :param pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingArgs'] matching: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermActionArgs']]:
        """
        When used as import policy
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingArgs']]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingArgs']]):
        pulumi.set(self, "matching", value)


if not MYPY:
    class DeviceprofileGatewayRoutingPoliciesTermActionArgsDict(TypedDict):
        accept: NotRequired[pulumi.Input[builtins.bool]]
        add_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        add_target_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional
        """
        exclude_as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional. To exclude certain AS
        """
        exclude_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        export_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional
        """
        local_preference: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, for an import policy, local_preference can be changed
        """
        prepend_as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
elif False:
    DeviceprofileGatewayRoutingPoliciesTermActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayRoutingPoliciesTermActionArgs:
    def __init__(__self__, *,
                 accept: Optional[pulumi.Input[builtins.bool]] = None,
                 add_communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 add_target_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 exclude_as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 exclude_communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 export_communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 local_preference: Optional[pulumi.Input[builtins.str]] = None,
                 prepend_as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] add_target_vrfs: For SSR, hub decides how VRF routes are leaked on spoke
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] communities: When used as export policy, optional
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exclude_as_paths: When used as export policy, optional. To exclude certain AS
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] export_communities: When used as export policy, optional
        :param pulumi.Input[builtins.str] local_preference: Optional, for an import policy, local_preference can be changed
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prepend_as_paths: When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if add_communities is not None:
            pulumi.set(__self__, "add_communities", add_communities)
        if add_target_vrfs is not None:
            pulumi.set(__self__, "add_target_vrfs", add_target_vrfs)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if exclude_as_paths is not None:
            pulumi.set(__self__, "exclude_as_paths", exclude_as_paths)
        if exclude_communities is not None:
            pulumi.set(__self__, "exclude_communities", exclude_communities)
        if export_communities is not None:
            pulumi.set(__self__, "export_communities", export_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if prepend_as_paths is not None:
            pulumi.set(__self__, "prepend_as_paths", prepend_as_paths)

    @property
    @pulumi.getter
    def accept(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "accept")

    @accept.setter
    def accept(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "accept", value)

    @property
    @pulumi.getter(name="addCommunities")
    def add_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "add_communities")

    @add_communities.setter
    def add_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "add_communities", value)

    @property
    @pulumi.getter(name="addTargetVrfs")
    def add_target_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        return pulumi.get(self, "add_target_vrfs")

    @add_target_vrfs.setter
    def add_target_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "add_target_vrfs", value)

    @property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "communities", value)

    @property
    @pulumi.getter(name="excludeAsPaths")
    def exclude_as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional. To exclude certain AS
        """
        return pulumi.get(self, "exclude_as_paths")

    @exclude_as_paths.setter
    def exclude_as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_as_paths", value)

    @property
    @pulumi.getter(name="excludeCommunities")
    def exclude_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "exclude_communities")

    @exclude_communities.setter
    def exclude_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_communities", value)

    @property
    @pulumi.getter(name="exportCommunities")
    def export_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "export_communities")

    @export_communities.setter
    def export_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "export_communities", value)

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, for an import policy, local_preference can be changed
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_preference", value)

    @property
    @pulumi.getter(name="prependAsPaths")
    def prepend_as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        return pulumi.get(self, "prepend_as_paths")

    @prepend_as_paths.setter
    def prepend_as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prepend_as_paths", value)


if not MYPY:
    class DeviceprofileGatewayRoutingPoliciesTermMatchingArgsDict(TypedDict):
        as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        takes regular expression
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        route_exists: NotRequired[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgsDict']]
        vpn_neighbor_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        vpn_path_sla: NotRequired[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict']]
        vpn_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
elif False:
    DeviceprofileGatewayRoutingPoliciesTermMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayRoutingPoliciesTermMatchingArgs:
    def __init__(__self__, *,
                 as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 route_exists: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgs']] = None,
                 vpn_neighbor_macs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vpn_path_sla: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgs']] = None,
                 vpn_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] as_paths: takes regular expression
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prefixes: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: `direct`, `bgp`, `osp`, `static`, `aggregate`...
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vpn_neighbor_macs: overlay-facing criteria (used for bgp_config where via=vpn)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vpn_paths: overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_exists is not None:
            pulumi.set(__self__, "route_exists", route_exists)
        if vpn_neighbor_macs is not None:
            pulumi.set(__self__, "vpn_neighbor_macs", vpn_neighbor_macs)
        if vpn_path_sla is not None:
            pulumi.set(__self__, "vpn_path_sla", vpn_path_sla)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)

    @property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        takes regular expression
        """
        return pulumi.get(self, "as_paths")

    @as_paths.setter
    def as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "as_paths", value)

    @property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "communities", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="routeExists")
    def route_exists(self) -> Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgs']]:
        return pulumi.get(self, "route_exists")

    @route_exists.setter
    def route_exists(self, value: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgs']]):
        pulumi.set(self, "route_exists", value)

    @property
    @pulumi.getter(name="vpnNeighborMacs")
    def vpn_neighbor_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        return pulumi.get(self, "vpn_neighbor_macs")

    @vpn_neighbor_macs.setter
    def vpn_neighbor_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vpn_neighbor_macs", value)

    @property
    @pulumi.getter(name="vpnPathSla")
    def vpn_path_sla(self) -> Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgs']]:
        return pulumi.get(self, "vpn_path_sla")

    @vpn_path_sla.setter
    def vpn_path_sla(self, value: Optional[pulumi.Input['DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgs']]):
        pulumi.set(self, "vpn_path_sla", value)

    @property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        return pulumi.get(self, "vpn_paths")

    @vpn_paths.setter
    def vpn_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vpn_paths", value)


if not MYPY:
    class DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgsDict(TypedDict):
        route: NotRequired[pulumi.Input[builtins.str]]
        vrf_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
elif False:
    DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExistsArgs:
    def __init__(__self__, *,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 vrf_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] vrf_name: Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        if route is not None:
            pulumi.set(__self__, "route", route)
        if vrf_name is not None:
            pulumi.set(__self__, "vrf_name", vrf_name)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        return pulumi.get(self, "vrf_name")

    @vrf_name.setter
    def vrf_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vrf_name", value)


if not MYPY:
    class DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict(TypedDict):
        max_jitter: NotRequired[pulumi.Input[builtins.int]]
        max_latency: NotRequired[pulumi.Input[builtins.int]]
        max_loss: NotRequired[pulumi.Input[builtins.int]]
elif False:
    DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSlaArgs:
    def __init__(__self__, *,
                 max_jitter: Optional[pulumi.Input[builtins.int]] = None,
                 max_latency: Optional[pulumi.Input[builtins.int]] = None,
                 max_loss: Optional[pulumi.Input[builtins.int]] = None):
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)

    @property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_jitter")

    @max_jitter.setter
    def max_jitter(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_jitter", value)

    @property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_latency", value)

    @property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_loss")

    @max_loss.setter
    def max_loss(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_loss", value)


if not MYPY:
    class DeviceprofileGatewayServicePolicyArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        antivirus: NotRequired[pulumi.Input['DeviceprofileGatewayServicePolicyAntivirusArgsDict']]
        """
        For SRX-only
        """
        appqoe: NotRequired[pulumi.Input['DeviceprofileGatewayServicePolicyAppqoeArgsDict']]
        """
        For SRX Only
        """
        ewfs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayServicePolicyEwfArgsDict']]]]
        idp: NotRequired[pulumi.Input['DeviceprofileGatewayServicePolicyIdpArgsDict']]
        local_routing: NotRequired[pulumi.Input[builtins.bool]]
        """
        access within the same VRF
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        path_preference: NotRequired[pulumi.Input[builtins.str]]
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        servicepolicy_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        ssl_proxy: NotRequired[pulumi.Input['DeviceprofileGatewayServicePolicySslProxyArgsDict']]
        """
        For SRX-only
        """
        tenants: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
elif False:
    DeviceprofileGatewayServicePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayServicePolicyArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 antivirus: Optional[pulumi.Input['DeviceprofileGatewayServicePolicyAntivirusArgs']] = None,
                 appqoe: Optional[pulumi.Input['DeviceprofileGatewayServicePolicyAppqoeArgs']] = None,
                 ewfs: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayServicePolicyEwfArgs']]]] = None,
                 idp: Optional[pulumi.Input['DeviceprofileGatewayServicePolicyIdpArgs']] = None,
                 local_routing: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 path_preference: Optional[pulumi.Input[builtins.str]] = None,
                 servicepolicy_id: Optional[pulumi.Input[builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ssl_proxy: Optional[pulumi.Input['DeviceprofileGatewayServicePolicySslProxyArgs']] = None,
                 tenants: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] action: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        :param pulumi.Input['DeviceprofileGatewayServicePolicyAntivirusArgs'] antivirus: For SRX-only
        :param pulumi.Input['DeviceprofileGatewayServicePolicyAppqoeArgs'] appqoe: For SRX Only
        :param pulumi.Input[builtins.bool] local_routing: access within the same VRF
        :param pulumi.Input[builtins.str] name: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        :param pulumi.Input[builtins.str] path_preference: By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        :param pulumi.Input[builtins.str] servicepolicy_id: Used to link servicepolicy defined at org level and overwrite some attributes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] services: Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        :param pulumi.Input['DeviceprofileGatewayServicePolicySslProxyArgs'] ssl_proxy: For SRX-only
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tenants: Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if appqoe is not None:
            pulumi.set(__self__, "appqoe", appqoe)
        if ewfs is not None:
            pulumi.set(__self__, "ewfs", ewfs)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if local_routing is not None:
            pulumi.set(__self__, "local_routing", local_routing)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_preference is not None:
            pulumi.set(__self__, "path_preference", path_preference)
        if servicepolicy_id is not None:
            pulumi.set(__self__, "servicepolicy_id", servicepolicy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssl_proxy is not None:
            pulumi.set(__self__, "ssl_proxy", ssl_proxy)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def antivirus(self) -> Optional[pulumi.Input['DeviceprofileGatewayServicePolicyAntivirusArgs']]:
        """
        For SRX-only
        """
        return pulumi.get(self, "antivirus")

    @antivirus.setter
    def antivirus(self, value: Optional[pulumi.Input['DeviceprofileGatewayServicePolicyAntivirusArgs']]):
        pulumi.set(self, "antivirus", value)

    @property
    @pulumi.getter
    def appqoe(self) -> Optional[pulumi.Input['DeviceprofileGatewayServicePolicyAppqoeArgs']]:
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @appqoe.setter
    def appqoe(self, value: Optional[pulumi.Input['DeviceprofileGatewayServicePolicyAppqoeArgs']]):
        pulumi.set(self, "appqoe", value)

    @property
    @pulumi.getter
    def ewfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayServicePolicyEwfArgs']]]]:
        return pulumi.get(self, "ewfs")

    @ewfs.setter
    def ewfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayServicePolicyEwfArgs']]]]):
        pulumi.set(self, "ewfs", value)

    @property
    @pulumi.getter
    def idp(self) -> Optional[pulumi.Input['DeviceprofileGatewayServicePolicyIdpArgs']]:
        return pulumi.get(self, "idp")

    @idp.setter
    def idp(self, value: Optional[pulumi.Input['DeviceprofileGatewayServicePolicyIdpArgs']]):
        pulumi.set(self, "idp", value)

    @property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @local_routing.setter
    def local_routing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "local_routing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @path_preference.setter
    def path_preference(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path_preference", value)

    @property
    @pulumi.getter(name="servicepolicyId")
    def servicepolicy_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        return pulumi.get(self, "servicepolicy_id")

    @servicepolicy_id.setter
    def servicepolicy_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "servicepolicy_id", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="sslProxy")
    def ssl_proxy(self) -> Optional[pulumi.Input['DeviceprofileGatewayServicePolicySslProxyArgs']]:
        """
        For SRX-only
        """
        return pulumi.get(self, "ssl_proxy")

    @ssl_proxy.setter
    def ssl_proxy(self, value: Optional[pulumi.Input['DeviceprofileGatewayServicePolicySslProxyArgs']]):
        pulumi.set(self, "ssl_proxy", value)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tenants", value)


if not MYPY:
    class DeviceprofileGatewayServicePolicyAntivirusArgsDict(TypedDict):
        avprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        Default / noftp / httponly / or keys from av_profiles
        """
elif False:
    DeviceprofileGatewayServicePolicyAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayServicePolicyAntivirusArgs:
    def __init__(__self__, *,
                 avprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param pulumi.Input[builtins.str] profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @avprofile_id.setter
    def avprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "avprofile_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class DeviceprofileGatewayServicePolicyAppqoeArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DeviceprofileGatewayServicePolicyAppqoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayServicePolicyAppqoeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileGatewayServicePolicyEwfArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[builtins.bool]]
        block_message: NotRequired[pulumi.Input[builtins.str]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `critical`, `standard`, `strict`
        """
elif False:
    DeviceprofileGatewayServicePolicyEwfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayServicePolicyEwfArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[builtins.bool]] = None,
                 block_message: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "block_message")

    @block_message.setter
    def block_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "block_message", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class DeviceprofileGatewayServicePolicyIdpArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[builtins.bool]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        idpprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
elif False:
    DeviceprofileGatewayServicePolicyIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayServicePolicyIdpArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 idpprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param pulumi.Input[builtins.str] profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @idpprofile_id.setter
    def idpprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idpprofile_id", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class DeviceprofileGatewayServicePolicySslProxyArgsDict(TypedDict):
        ciphers_category: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `medium`, `strong`, `weak`
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DeviceprofileGatewayServicePolicySslProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayServicePolicySslProxyArgs:
    def __init__(__self__, *,
                 ciphers_category: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @ciphers_category.setter
    def ciphers_category(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ciphers_category", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsArgsDict(TypedDict):
        auto_provision: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionArgsDict']]
        ike_lifetime: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        ike_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        ike_proposals: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIkeProposalArgsDict']]]]
        """
        If `provider`==`custom-ipsec`
        """
        ipsec_lifetime: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        ipsec_proposals: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIpsecProposalArgsDict']]]]
        """
        Only if  `provider`==`custom-ipsec`
        """
        local_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `provider`==`custom-ipsec`, networks reachable via this tunnel
        """
        primary: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsPrimaryArgsDict']]
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        probe: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsProbeArgsDict']]
        """
        Only if `provider`==`custom-ipsec`
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        provider: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        psk: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        secondary: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsSecondaryArgsDict']]
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsArgs:
    def __init__(__self__, *,
                 auto_provision: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionArgs']] = None,
                 ike_lifetime: Optional[pulumi.Input[builtins.int]] = None,
                 ike_mode: Optional[pulumi.Input[builtins.str]] = None,
                 ike_proposals: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIkeProposalArgs']]]] = None,
                 ipsec_lifetime: Optional[pulumi.Input[builtins.int]] = None,
                 ipsec_proposals: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIpsecProposalArgs']]]] = None,
                 local_id: Optional[pulumi.Input[builtins.str]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 primary: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsPrimaryArgs']] = None,
                 probe: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsProbeArgs']] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 provider: Optional[pulumi.Input[builtins.str]] = None,
                 psk: Optional[pulumi.Input[builtins.str]] = None,
                 secondary: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsSecondaryArgs']] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] ike_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param pulumi.Input[builtins.str] ike_mode: Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        :param pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIkeProposalArgs']]] ike_proposals: If `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.int] ipsec_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIpsecProposalArgs']]] ipsec_proposals: Only if  `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] local_id: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] mode: Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: If `provider`==`custom-ipsec`, networks reachable via this tunnel
        :param pulumi.Input['DeviceprofileGatewayTunnelConfigsPrimaryArgs'] primary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input['DeviceprofileGatewayTunnelConfigsProbeArgs'] probe: Only if `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] protocol: Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        :param pulumi.Input[builtins.str] provider: Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        :param pulumi.Input[builtins.str] psk: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input['DeviceprofileGatewayTunnelConfigsSecondaryArgs'] secondary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] version: Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        if auto_provision is not None:
            pulumi.set(__self__, "auto_provision", auto_provision)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_mode is not None:
            pulumi.set(__self__, "ike_mode", ike_mode)
        if ike_proposals is not None:
            pulumi.set(__self__, "ike_proposals", ike_proposals)
        if ipsec_lifetime is not None:
            pulumi.set(__self__, "ipsec_lifetime", ipsec_lifetime)
        if ipsec_proposals is not None:
            pulumi.set(__self__, "ipsec_proposals", ipsec_proposals)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if probe is not None:
            pulumi.set(__self__, "probe", probe)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionArgs']]:
        return pulumi.get(self, "auto_provision")

    @auto_provision.setter
    def auto_provision(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionArgs']]):
        pulumi.set(self, "auto_provision", value)

    @property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ike_lifetime", value)

    @property
    @pulumi.getter(name="ikeMode")
    def ike_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        return pulumi.get(self, "ike_mode")

    @ike_mode.setter
    def ike_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ike_mode", value)

    @property
    @pulumi.getter(name="ikeProposals")
    def ike_proposals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIkeProposalArgs']]]]:
        """
        If `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ike_proposals")

    @ike_proposals.setter
    def ike_proposals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIkeProposalArgs']]]]):
        pulumi.set(self, "ike_proposals", value)

    @property
    @pulumi.getter(name="ipsecLifetime")
    def ipsec_lifetime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ipsec_lifetime")

    @ipsec_lifetime.setter
    def ipsec_lifetime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ipsec_lifetime", value)

    @property
    @pulumi.getter(name="ipsecProposals")
    def ipsec_proposals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIpsecProposalArgs']]]]:
        """
        Only if  `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ipsec_proposals")

    @ipsec_proposals.setter
    def ipsec_proposals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelConfigsIpsecProposalArgs']]]]):
        pulumi.set(self, "ipsec_proposals", value)

    @property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_id", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `provider`==`custom-ipsec`, networks reachable via this tunnel
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsPrimaryArgs']]:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsPrimaryArgs']]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def probe(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsProbeArgs']]:
        """
        Only if `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "probe")

    @probe.setter
    def probe(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsProbeArgs']]):
        pulumi.set(self, "probe", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psk", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsSecondaryArgs']]:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsSecondaryArgs']]):
        pulumi.set(self, "secondary", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsAutoProvisionArgsDict(TypedDict):
        provider: pulumi.Input[builtins.str]
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        latlng: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgsDict']]
        """
        API override for POP selection
        """
        primary: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgsDict']]
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        API override for POP selection
        """
        secondary: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgsDict']]
elif False:
    DeviceprofileGatewayTunnelConfigsAutoProvisionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionArgs:
    def __init__(__self__, *,
                 provider: pulumi.Input[builtins.str],
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 latlng: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs']] = None,
                 primary: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgs']] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 secondary: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgs']] = None):
        """
        :param pulumi.Input[builtins.str] provider: enum: `jse-ipsec`, `zscaler-ipsec`
        :param pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs'] latlng: API override for POP selection
        :param pulumi.Input[builtins.str] region: API override for POP selection
        """
        pulumi.set(__self__, "provider", provider)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if latlng is not None:
            pulumi.set(__self__, "latlng", latlng)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[builtins.str]:
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def latlng(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs']]:
        """
        API override for POP selection
        """
        return pulumi.get(self, "latlng")

    @latlng.setter
    def latlng(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs']]):
        pulumi.set(self, "latlng", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgs']]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgs']]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        API override for POP selection
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgs']]:
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgs']]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgsDict(TypedDict):
        lat: pulumi.Input[builtins.float]
        lng: pulumi.Input[builtins.float]
elif False:
    DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs:
    def __init__(__self__, *,
                 lat: pulumi.Input[builtins.float],
                 lng: pulumi.Input[builtins.float]):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @property
    @pulumi.getter
    def lat(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "lat", value)

    @property
    @pulumi.getter
    def lng(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgsDict(TypedDict):
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional, only needed if `vars_only`==`false`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionPrimaryArgs:
    def __init__(__self__, *,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgsDict(TypedDict):
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional, only needed if `vars_only`==`false`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionSecondaryArgs:
    def __init__(__self__, *,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsIkeProposalArgsDict(TypedDict):
        auth_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `md5`, `sha1`, `sha2`
        """
        dh_group: NotRequired[pulumi.Input[builtins.str]]
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        enc_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsIkeProposalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsIkeProposalArgs:
    def __init__(__self__, *,
                 auth_algo: Optional[pulumi.Input[builtins.str]] = None,
                 dh_group: Optional[pulumi.Input[builtins.str]] = None,
                 enc_algo: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_algo: enum: `md5`, `sha1`, `sha2`
        :param pulumi.Input[builtins.str] dh_group: enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param pulumi.Input[builtins.str] enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @auth_algo.setter
    def auth_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_algo", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")

    @enc_algo.setter
    def enc_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_algo", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsIpsecProposalArgsDict(TypedDict):
        auth_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `md5`, `sha1`, `sha2`
        """
        dh_group: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        enc_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsIpsecProposalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsIpsecProposalArgs:
    def __init__(__self__, *,
                 auth_algo: Optional[pulumi.Input[builtins.str]] = None,
                 dh_group: Optional[pulumi.Input[builtins.str]] = None,
                 enc_algo: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_algo: enum: `md5`, `sha1`, `sha2`
        :param pulumi.Input[builtins.str] dh_group: Only if `provider`==`custom-ipsec`. enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param pulumi.Input[builtins.str] enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @auth_algo.setter
    def auth_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_algo", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")

    @enc_algo.setter
    def enc_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_algo", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsPrimaryArgsDict(TypedDict):
        hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        internal_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        remote_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsPrimaryArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 internal_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 remote_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "wan_names", value)

    @property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @internal_ips.setter
    def internal_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "internal_ips", value)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")

    @remote_ids.setter
    def remote_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "remote_ids", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsProbeArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[builtins.int]]
        """
        How often to trigger the probe
        """
        threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of consecutive misses before declaring the tunnel down
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Time within which to complete the connectivity check
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `http`, `icmp`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsProbeArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[builtins.int]] = None,
                 threshold: Optional[pulumi.Input[builtins.int]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] interval: How often to trigger the probe
        :param pulumi.Input[builtins.int] threshold: Number of consecutive misses before declaring the tunnel down
        :param pulumi.Input[builtins.int] timeout: Time within which to complete the connectivity check
        :param pulumi.Input[builtins.str] type: enum: `http`, `icmp`
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How often to trigger the probe
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of consecutive misses before declaring the tunnel down
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time within which to complete the connectivity check
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeviceprofileGatewayTunnelConfigsSecondaryArgsDict(TypedDict):
        hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        internal_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        remote_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
elif False:
    DeviceprofileGatewayTunnelConfigsSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelConfigsSecondaryArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 internal_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 remote_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "wan_names", value)

    @property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @internal_ips.setter
    def internal_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "internal_ips", value)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")

    @remote_ids.setter
    def remote_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "remote_ids", value)


if not MYPY:
    class DeviceprofileGatewayTunnelProviderOptionsArgsDict(TypedDict):
        jse: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsJseArgsDict']]
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        zscaler: NotRequired[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerArgsDict']]
        """
        For zscaler-ipsec and zscaler-gre
        """
elif False:
    DeviceprofileGatewayTunnelProviderOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelProviderOptionsArgs:
    def __init__(__self__, *,
                 jse: Optional[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsJseArgs']] = None,
                 zscaler: Optional[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerArgs']] = None):
        """
        :param pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsJseArgs'] jse: For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        :param pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerArgs'] zscaler: For zscaler-ipsec and zscaler-gre
        """
        if jse is not None:
            pulumi.set(__self__, "jse", jse)
        if zscaler is not None:
            pulumi.set(__self__, "zscaler", zscaler)

    @property
    @pulumi.getter
    def jse(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsJseArgs']]:
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        return pulumi.get(self, "jse")

    @jse.setter
    def jse(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsJseArgs']]):
        pulumi.set(self, "jse", value)

    @property
    @pulumi.getter
    def zscaler(self) -> Optional[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerArgs']]:
        """
        For zscaler-ipsec and zscaler-gre
        """
        return pulumi.get(self, "zscaler")

    @zscaler.setter
    def zscaler(self, value: Optional[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerArgs']]):
        pulumi.set(self, "zscaler", value)


if not MYPY:
    class DeviceprofileGatewayTunnelProviderOptionsJseArgsDict(TypedDict):
        num_users: NotRequired[pulumi.Input[builtins.int]]
        org_name: NotRequired[pulumi.Input[builtins.str]]
        """
        JSE Organization name
        """
elif False:
    DeviceprofileGatewayTunnelProviderOptionsJseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelProviderOptionsJseArgs:
    def __init__(__self__, *,
                 num_users: Optional[pulumi.Input[builtins.int]] = None,
                 org_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] org_name: JSE Organization name
        """
        if num_users is not None:
            pulumi.set(__self__, "num_users", num_users)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)

    @property
    @pulumi.getter(name="numUsers")
    def num_users(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "num_users")

    @num_users.setter
    def num_users(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "num_users", value)

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JSE Organization name
        """
        return pulumi.get(self, "org_name")

    @org_name.setter
    def org_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_name", value)


if not MYPY:
    class DeviceprofileGatewayTunnelProviderOptionsZscalerArgsDict(TypedDict):
        aup_block_internet_until_accepted: NotRequired[pulumi.Input[builtins.bool]]
        aup_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        aup_force_ssl_inspection: NotRequired[pulumi.Input[builtins.bool]]
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        aup_timeout_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        auth_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable this option to enforce user authentication
        """
        caution_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        dn_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        idle_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        ofw_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `true`, enable the firewall control option
        """
        sub_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgsDict']]]]
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        surrogate_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        surrogate_ip_enforced_for_known_browsers: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        surrogate_refresh_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        up_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        xff_forward_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Location uses proxy chaining to forward traffic
        """
elif False:
    DeviceprofileGatewayTunnelProviderOptionsZscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelProviderOptionsZscalerArgs:
    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_force_ssl_inspection: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_timeout_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 auth_required: Optional[pulumi.Input[builtins.bool]] = None,
                 caution_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dn_bandwidth: Optional[pulumi.Input[builtins.float]] = None,
                 idle_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 ofw_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 sub_locations: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs']]]] = None,
                 surrogate_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_refresh_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 up_bandwidth: Optional[pulumi.Input[builtins.float]] = None,
                 xff_forward_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param pulumi.Input[builtins.bool] aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param pulumi.Input[builtins.int] aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param pulumi.Input[builtins.bool] auth_required: Enable this option to enforce user authentication
        :param pulumi.Input[builtins.bool] caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param pulumi.Input[builtins.float] dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param pulumi.Input[builtins.int] idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param pulumi.Input[builtins.bool] ofw_enabled: If `true`, enable the firewall control option
        :param pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs']]] sub_locations: `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        :param pulumi.Input[builtins.bool] surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param pulumi.Input[builtins.bool] surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param pulumi.Input[builtins.int] surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param pulumi.Input[builtins.float] up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param pulumi.Input[builtins.bool] xff_forward_enabled: Location uses proxy chaining to forward traffic
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if sub_locations is not None:
            pulumi.set(__self__, "sub_locations", sub_locations)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)
        if xff_forward_enabled is not None:
            pulumi.set(__self__, "xff_forward_enabled", xff_forward_enabled)

    @property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @aup_block_internet_until_accepted.setter
    def aup_block_internet_until_accepted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_block_internet_until_accepted", value)

    @property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @aup_enabled.setter
    def aup_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_enabled", value)

    @property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @aup_force_ssl_inspection.setter
    def aup_force_ssl_inspection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_force_ssl_inspection", value)

    @property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @aup_timeout_in_days.setter
    def aup_timeout_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "aup_timeout_in_days", value)

    @property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable this option to enforce user authentication
        """
        return pulumi.get(self, "auth_required")

    @auth_required.setter
    def auth_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auth_required", value)

    @property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @caution_enabled.setter
    def caution_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "caution_enabled", value)

    @property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @dn_bandwidth.setter
    def dn_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "dn_bandwidth", value)

    @property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @idle_time_in_minutes.setter
    def idle_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idle_time_in_minutes", value)

    @property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @ofw_enabled.setter
    def ofw_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ofw_enabled", value)

    @property
    @pulumi.getter(name="subLocations")
    def sub_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs']]]]:
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        return pulumi.get(self, "sub_locations")

    @sub_locations.setter
    def sub_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs']]]]):
        pulumi.set(self, "sub_locations", value)

    @property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @surrogate_ip.setter
    def surrogate_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip", value)

    @property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @surrogate_ip_enforced_for_known_browsers.setter
    def surrogate_ip_enforced_for_known_browsers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip_enforced_for_known_browsers", value)

    @property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @surrogate_refresh_time_in_minutes.setter
    def surrogate_refresh_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "surrogate_refresh_time_in_minutes", value)

    @property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @up_bandwidth.setter
    def up_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "up_bandwidth", value)

    @property
    @pulumi.getter(name="xffForwardEnabled")
    def xff_forward_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Location uses proxy chaining to forward traffic
        """
        return pulumi.get(self, "xff_forward_enabled")

    @xff_forward_enabled.setter
    def xff_forward_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "xff_forward_enabled", value)


if not MYPY:
    class DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgsDict(TypedDict):
        aup_block_internet_until_accepted: NotRequired[pulumi.Input[builtins.bool]]
        aup_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        aup_force_ssl_inspection: NotRequired[pulumi.Input[builtins.bool]]
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        aup_timeout_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        auth_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable this option to authenticate users
        """
        caution_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        dn_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        idle_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Network name
        """
        ofw_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `true`, enable the firewall control option
        """
        surrogate_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        surrogate_ip_enforced_for_known_browsers: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        surrogate_refresh_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        up_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
elif False:
    DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs:
    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_force_ssl_inspection: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_timeout_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 auth_required: Optional[pulumi.Input[builtins.bool]] = None,
                 caution_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dn_bandwidth: Optional[pulumi.Input[builtins.float]] = None,
                 idle_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 ofw_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_refresh_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 up_bandwidth: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.bool] aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param pulumi.Input[builtins.bool] aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param pulumi.Input[builtins.int] aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param pulumi.Input[builtins.bool] auth_required: Enable this option to authenticate users
        :param pulumi.Input[builtins.bool] caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param pulumi.Input[builtins.float] dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param pulumi.Input[builtins.int] idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param pulumi.Input[builtins.str] name: Network name
        :param pulumi.Input[builtins.bool] ofw_enabled: If `true`, enable the firewall control option
        :param pulumi.Input[builtins.bool] surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param pulumi.Input[builtins.bool] surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param pulumi.Input[builtins.int] surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param pulumi.Input[builtins.float] up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)

    @property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @aup_block_internet_until_accepted.setter
    def aup_block_internet_until_accepted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_block_internet_until_accepted", value)

    @property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @aup_enabled.setter
    def aup_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_enabled", value)

    @property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @aup_force_ssl_inspection.setter
    def aup_force_ssl_inspection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_force_ssl_inspection", value)

    @property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @aup_timeout_in_days.setter
    def aup_timeout_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "aup_timeout_in_days", value)

    @property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable this option to authenticate users
        """
        return pulumi.get(self, "auth_required")

    @auth_required.setter
    def auth_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auth_required", value)

    @property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @caution_enabled.setter
    def caution_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "caution_enabled", value)

    @property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @dn_bandwidth.setter
    def dn_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "dn_bandwidth", value)

    @property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @idle_time_in_minutes.setter
    def idle_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idle_time_in_minutes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @ofw_enabled.setter
    def ofw_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ofw_enabled", value)

    @property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @surrogate_ip.setter
    def surrogate_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip", value)

    @property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @surrogate_ip_enforced_for_known_browsers.setter
    def surrogate_ip_enforced_for_known_browsers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip_enforced_for_known_browsers", value)

    @property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @surrogate_refresh_time_in_minutes.setter
    def surrogate_refresh_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "surrogate_refresh_time_in_minutes", value)

    @property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @up_bandwidth.setter
    def up_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "up_bandwidth", value)


if not MYPY:
    class DeviceprofileGatewayVrfConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable VRF (when supported on the device)
        """
elif False:
    DeviceprofileGatewayVrfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayVrfConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DeviceprofileGatewayVrfInstancesArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    DeviceprofileGatewayVrfInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceprofileGatewayVrfInstancesArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class EvpnTopologyEvpnOptionsArgsDict(TypedDict):
        auto_loopback_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        """
        auto_loopback_subnet6: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        """
        auto_router_id_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        auto_router_id_subnet6: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        core_as_border: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        """
        overlay: NotRequired[pulumi.Input['EvpnTopologyEvpnOptionsOverlayArgsDict']]
        per_vlan_vga_v4_mac: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        """
        per_vlan_vga_v6_mac: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        """
        routed_at: NotRequired[pulumi.Input[builtins.str]]
        """
        optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        """
        underlay: NotRequired[pulumi.Input['EvpnTopologyEvpnOptionsUnderlayArgsDict']]
        vs_instances: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['EvpnTopologyEvpnOptionsVsInstancesArgsDict']]]]
        """
        Optional, for EX9200 only to segregate virtual-switches
        """
elif False:
    EvpnTopologyEvpnOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvpnTopologyEvpnOptionsArgs:
    def __init__(__self__, *,
                 auto_loopback_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 auto_loopback_subnet6: Optional[pulumi.Input[builtins.str]] = None,
                 auto_router_id_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 auto_router_id_subnet6: Optional[pulumi.Input[builtins.str]] = None,
                 core_as_border: Optional[pulumi.Input[builtins.bool]] = None,
                 overlay: Optional[pulumi.Input['EvpnTopologyEvpnOptionsOverlayArgs']] = None,
                 per_vlan_vga_v4_mac: Optional[pulumi.Input[builtins.bool]] = None,
                 per_vlan_vga_v6_mac: Optional[pulumi.Input[builtins.bool]] = None,
                 routed_at: Optional[pulumi.Input[builtins.str]] = None,
                 underlay: Optional[pulumi.Input['EvpnTopologyEvpnOptionsUnderlayArgs']] = None,
                 vs_instances: Optional[pulumi.Input[Mapping[str, pulumi.Input['EvpnTopologyEvpnOptionsVsInstancesArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] auto_loopback_subnet: Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        :param pulumi.Input[builtins.str] auto_loopback_subnet6: Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        :param pulumi.Input[builtins.str] auto_router_id_subnet: Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        :param pulumi.Input[builtins.str] auto_router_id_subnet6: Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        :param pulumi.Input[builtins.bool] core_as_border: Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        :param pulumi.Input[builtins.bool] per_vlan_vga_v4_mac: Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        :param pulumi.Input[builtins.bool] per_vlan_vga_v6_mac: Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        :param pulumi.Input[builtins.str] routed_at: optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        :param pulumi.Input[Mapping[str, pulumi.Input['EvpnTopologyEvpnOptionsVsInstancesArgs']]] vs_instances: Optional, for EX9200 only to segregate virtual-switches
        """
        if auto_loopback_subnet is not None:
            pulumi.set(__self__, "auto_loopback_subnet", auto_loopback_subnet)
        if auto_loopback_subnet6 is not None:
            pulumi.set(__self__, "auto_loopback_subnet6", auto_loopback_subnet6)
        if auto_router_id_subnet is not None:
            pulumi.set(__self__, "auto_router_id_subnet", auto_router_id_subnet)
        if auto_router_id_subnet6 is not None:
            pulumi.set(__self__, "auto_router_id_subnet6", auto_router_id_subnet6)
        if core_as_border is not None:
            pulumi.set(__self__, "core_as_border", core_as_border)
        if overlay is not None:
            pulumi.set(__self__, "overlay", overlay)
        if per_vlan_vga_v4_mac is not None:
            pulumi.set(__self__, "per_vlan_vga_v4_mac", per_vlan_vga_v4_mac)
        if per_vlan_vga_v6_mac is not None:
            pulumi.set(__self__, "per_vlan_vga_v6_mac", per_vlan_vga_v6_mac)
        if routed_at is not None:
            pulumi.set(__self__, "routed_at", routed_at)
        if underlay is not None:
            pulumi.set(__self__, "underlay", underlay)
        if vs_instances is not None:
            pulumi.set(__self__, "vs_instances", vs_instances)

    @property
    @pulumi.getter(name="autoLoopbackSubnet")
    def auto_loopback_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        """
        return pulumi.get(self, "auto_loopback_subnet")

    @auto_loopback_subnet.setter
    def auto_loopback_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auto_loopback_subnet", value)

    @property
    @pulumi.getter(name="autoLoopbackSubnet6")
    def auto_loopback_subnet6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        """
        return pulumi.get(self, "auto_loopback_subnet6")

    @auto_loopback_subnet6.setter
    def auto_loopback_subnet6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auto_loopback_subnet6", value)

    @property
    @pulumi.getter(name="autoRouterIdSubnet")
    def auto_router_id_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        return pulumi.get(self, "auto_router_id_subnet")

    @auto_router_id_subnet.setter
    def auto_router_id_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auto_router_id_subnet", value)

    @property
    @pulumi.getter(name="autoRouterIdSubnet6")
    def auto_router_id_subnet6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        return pulumi.get(self, "auto_router_id_subnet6")

    @auto_router_id_subnet6.setter
    def auto_router_id_subnet6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auto_router_id_subnet6", value)

    @property
    @pulumi.getter(name="coreAsBorder")
    def core_as_border(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        """
        return pulumi.get(self, "core_as_border")

    @core_as_border.setter
    def core_as_border(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "core_as_border", value)

    @property
    @pulumi.getter
    def overlay(self) -> Optional[pulumi.Input['EvpnTopologyEvpnOptionsOverlayArgs']]:
        return pulumi.get(self, "overlay")

    @overlay.setter
    def overlay(self, value: Optional[pulumi.Input['EvpnTopologyEvpnOptionsOverlayArgs']]):
        pulumi.set(self, "overlay", value)

    @property
    @pulumi.getter(name="perVlanVgaV4Mac")
    def per_vlan_vga_v4_mac(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        """
        return pulumi.get(self, "per_vlan_vga_v4_mac")

    @per_vlan_vga_v4_mac.setter
    def per_vlan_vga_v4_mac(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "per_vlan_vga_v4_mac", value)

    @property
    @pulumi.getter(name="perVlanVgaV6Mac")
    def per_vlan_vga_v6_mac(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        """
        return pulumi.get(self, "per_vlan_vga_v6_mac")

    @per_vlan_vga_v6_mac.setter
    def per_vlan_vga_v6_mac(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "per_vlan_vga_v6_mac", value)

    @property
    @pulumi.getter(name="routedAt")
    def routed_at(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        """
        return pulumi.get(self, "routed_at")

    @routed_at.setter
    def routed_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "routed_at", value)

    @property
    @pulumi.getter
    def underlay(self) -> Optional[pulumi.Input['EvpnTopologyEvpnOptionsUnderlayArgs']]:
        return pulumi.get(self, "underlay")

    @underlay.setter
    def underlay(self, value: Optional[pulumi.Input['EvpnTopologyEvpnOptionsUnderlayArgs']]):
        pulumi.set(self, "underlay", value)

    @property
    @pulumi.getter(name="vsInstances")
    def vs_instances(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['EvpnTopologyEvpnOptionsVsInstancesArgs']]]]:
        """
        Optional, for EX9200 only to segregate virtual-switches
        """
        return pulumi.get(self, "vs_instances")

    @vs_instances.setter
    def vs_instances(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['EvpnTopologyEvpnOptionsVsInstancesArgs']]]]):
        pulumi.set(self, "vs_instances", value)


if not MYPY:
    class EvpnTopologyEvpnOptionsOverlayArgsDict(TypedDict):
        as_: NotRequired[pulumi.Input[builtins.int]]
        """
        Overlay BGP Local AS Number
        """
elif False:
    EvpnTopologyEvpnOptionsOverlayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvpnTopologyEvpnOptionsOverlayArgs:
    def __init__(__self__, *,
                 as_: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] as_: Overlay BGP Local AS Number
        """
        if as_ is not None:
            pulumi.set(__self__, "as_", as_)

    @property
    @pulumi.getter(name="as")
    def as_(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Overlay BGP Local AS Number
        """
        return pulumi.get(self, "as_")

    @as_.setter
    def as_(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "as_", value)


if not MYPY:
    class EvpnTopologyEvpnOptionsUnderlayArgsDict(TypedDict):
        as_base: NotRequired[pulumi.Input[builtins.int]]
        """
        Underlay BGP Base AS Number
        """
        routed_id_prefix: NotRequired[pulumi.Input[builtins.str]]
        subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        """
        use_ipv6: NotRequired[pulumi.Input[builtins.bool]]
        """
        If v6 is desired for underlay
        """
elif False:
    EvpnTopologyEvpnOptionsUnderlayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvpnTopologyEvpnOptionsUnderlayArgs:
    def __init__(__self__, *,
                 as_base: Optional[pulumi.Input[builtins.int]] = None,
                 routed_id_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 subnet: Optional[pulumi.Input[builtins.str]] = None,
                 use_ipv6: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] as_base: Underlay BGP Base AS Number
        :param pulumi.Input[builtins.str] subnet: Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        :param pulumi.Input[builtins.bool] use_ipv6: If v6 is desired for underlay
        """
        if as_base is not None:
            pulumi.set(__self__, "as_base", as_base)
        if routed_id_prefix is not None:
            pulumi.set(__self__, "routed_id_prefix", routed_id_prefix)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if use_ipv6 is not None:
            pulumi.set(__self__, "use_ipv6", use_ipv6)

    @property
    @pulumi.getter(name="asBase")
    def as_base(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Underlay BGP Base AS Number
        """
        return pulumi.get(self, "as_base")

    @as_base.setter
    def as_base(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "as_base", value)

    @property
    @pulumi.getter(name="routedIdPrefix")
    def routed_id_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "routed_id_prefix")

    @routed_id_prefix.setter
    def routed_id_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "routed_id_prefix", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="useIpv6")
    def use_ipv6(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If v6 is desired for underlay
        """
        return pulumi.get(self, "use_ipv6")

    @use_ipv6.setter
    def use_ipv6(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_ipv6", value)


if not MYPY:
    class EvpnTopologyEvpnOptionsVsInstancesArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    EvpnTopologyEvpnOptionsVsInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvpnTopologyEvpnOptionsVsInstancesArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class EvpnTopologySwitchesArgsDict(TypedDict):
        role: pulumi.Input[builtins.str]
        """
        use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
        """
        deviceprofile_id: NotRequired[pulumi.Input[builtins.str]]
        evpn_id: NotRequired[pulumi.Input[builtins.int]]
        mac: NotRequired[pulumi.Input[builtins.str]]
        model: NotRequired[pulumi.Input[builtins.str]]
        pod: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
          * for CLOS, to group dist / access switches into pods
          * for ERB/CRB, to group dist / esilag-access into pods
        """
        pods: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        By default, core switches are assumed to be connecting all pods. 
        if you want to limit the pods, you can specify pods.
        """
        router_id: NotRequired[pulumi.Input[builtins.str]]
        site_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    EvpnTopologySwitchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvpnTopologySwitchesArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[builtins.str],
                 deviceprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 evpn_id: Optional[pulumi.Input[builtins.int]] = None,
                 mac: Optional[pulumi.Input[builtins.str]] = None,
                 model: Optional[pulumi.Input[builtins.str]] = None,
                 pod: Optional[pulumi.Input[builtins.int]] = None,
                 pods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 router_id: Optional[pulumi.Input[builtins.str]] = None,
                 site_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] role: use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
        :param pulumi.Input[builtins.int] pod: Optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
                 * for CLOS, to group dist / access switches into pods
                 * for ERB/CRB, to group dist / esilag-access into pods
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] pods: By default, core switches are assumed to be connecting all pods. 
               if you want to limit the pods, you can specify pods.
        """
        pulumi.set(__self__, "role", role)
        if deviceprofile_id is not None:
            pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        if evpn_id is not None:
            pulumi.set(__self__, "evpn_id", evpn_id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[builtins.str]:
        """
        use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "deviceprofile_id")

    @deviceprofile_id.setter
    def deviceprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deviceprofile_id", value)

    @property
    @pulumi.getter(name="evpnId")
    def evpn_id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "evpn_id")

    @evpn_id.setter
    def evpn_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "evpn_id", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
          * for CLOS, to group dist / access switches into pods
          * for ERB/CRB, to group dist / esilag-access into pods
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        By default, core switches are assumed to be connecting all pods. 
        if you want to limit the pods, you can specify pods.
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "pods", value)

    @property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "router_id", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "site_id", value)


if not MYPY:
    class GatewaytemplateBgpConfigArgsDict(TypedDict):
        auth_key: NotRequired[pulumi.Input[builtins.str]]
        bfd_minimum_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        When bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        bfd_multiplier: NotRequired[pulumi.Input[builtins.int]]
        """
        When bfd_minimum_interval_is_configured alone
        """
        disable_bfd: NotRequired[pulumi.Input[builtins.bool]]
        """
        BFD provides faster path failure detection and is enabled by default
        """
        export: NotRequired[pulumi.Input[builtins.str]]
        export_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Default export policies if no per-neighbor policies defined
        """
        extended_v4_nexthop: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        graceful_restart_time: NotRequired[pulumi.Input[builtins.int]]
        """
        `0` means disable
        """
        hold_time: NotRequired[pulumi.Input[builtins.int]]
        import_: NotRequired[pulumi.Input[builtins.str]]
        import_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Default import policies if no per-neighbor policies defined
        """
        local_as: NotRequired[pulumi.Input[builtins.str]]
        """
        Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        neighbor_as: NotRequired[pulumi.Input[builtins.str]]
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        neighbors: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateBgpConfigNeighborsArgsDict']]]]
        """
        If per-neighbor as is desired. Property key is the neighbor address
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        """
        no_private_as: NotRequired[pulumi.Input[builtins.bool]]
        no_readvertise_to_overlay: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, we'll re-advertise all learned BGP routers toward overlay
        """
        tunnel_name: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`tunnel`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `external`, `internal`
        """
        via: NotRequired[pulumi.Input[builtins.str]]
        """
        network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        vpn_name: NotRequired[pulumi.Input[builtins.str]]
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        If `via`==`wan`
        """
elif False:
    GatewaytemplateBgpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateBgpConfigArgs:
    def __init__(__self__, *,
                 auth_key: Optional[pulumi.Input[builtins.str]] = None,
                 bfd_minimum_interval: Optional[pulumi.Input[builtins.int]] = None,
                 bfd_multiplier: Optional[pulumi.Input[builtins.int]] = None,
                 disable_bfd: Optional[pulumi.Input[builtins.bool]] = None,
                 export: Optional[pulumi.Input[builtins.str]] = None,
                 export_policy: Optional[pulumi.Input[builtins.str]] = None,
                 extended_v4_nexthop: Optional[pulumi.Input[builtins.bool]] = None,
                 graceful_restart_time: Optional[pulumi.Input[builtins.int]] = None,
                 hold_time: Optional[pulumi.Input[builtins.int]] = None,
                 import_: Optional[pulumi.Input[builtins.str]] = None,
                 import_policy: Optional[pulumi.Input[builtins.str]] = None,
                 local_as: Optional[pulumi.Input[builtins.str]] = None,
                 neighbor_as: Optional[pulumi.Input[builtins.str]] = None,
                 neighbors: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateBgpConfigNeighborsArgs']]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 no_private_as: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[builtins.bool]] = None,
                 tunnel_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 via: Optional[pulumi.Input[builtins.str]] = None,
                 vpn_name: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] bfd_minimum_interval: When bfd_multiplier is configured alone. Default:
                 * 1000 if `type`==`external`
                 * 350 `type`==`internal`
        :param pulumi.Input[builtins.int] bfd_multiplier: When bfd_minimum_interval_is_configured alone
        :param pulumi.Input[builtins.bool] disable_bfd: BFD provides faster path failure detection and is enabled by default
        :param pulumi.Input[builtins.str] export_policy: Default export policies if no per-neighbor policies defined
        :param pulumi.Input[builtins.bool] extended_v4_nexthop: By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        :param pulumi.Input[builtins.int] graceful_restart_time: `0` means disable
        :param pulumi.Input[builtins.str] import_policy: Default import policies if no per-neighbor policies defined
        :param pulumi.Input[builtins.str] local_as: Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param pulumi.Input[builtins.str] neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateBgpConfigNeighborsArgs']]] neighbors: If per-neighbor as is desired. Property key is the neighbor address
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        :param pulumi.Input[builtins.bool] no_readvertise_to_overlay: By default, we'll re-advertise all learned BGP routers toward overlay
        :param pulumi.Input[builtins.str] tunnel_name: If `type`==`tunnel`
        :param pulumi.Input[builtins.str] type: enum: `external`, `internal`
        :param pulumi.Input[builtins.str] via: network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        :param pulumi.Input[builtins.str] wan_name: If `via`==`wan`
        """
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if bfd_multiplier is not None:
            pulumi.set(__self__, "bfd_multiplier", bfd_multiplier)
        if disable_bfd is not None:
            pulumi.set(__self__, "disable_bfd", disable_bfd)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if extended_v4_nexthop is not None:
            pulumi.set(__self__, "extended_v4_nexthop", extended_v4_nexthop)
        if graceful_restart_time is not None:
            pulumi.set(__self__, "graceful_restart_time", graceful_restart_time)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if no_private_as is not None:
            pulumi.set(__self__, "no_private_as", no_private_as)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if tunnel_name is not None:
            pulumi.set(__self__, "tunnel_name", tunnel_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if via is not None:
            pulumi.set(__self__, "via", via)
        if vpn_name is not None:
            pulumi.set(__self__, "vpn_name", vpn_name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "auth_key")

    @auth_key.setter
    def auth_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_key", value)

    @property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        return pulumi.get(self, "bfd_minimum_interval")

    @bfd_minimum_interval.setter
    def bfd_minimum_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bfd_minimum_interval", value)

    @property
    @pulumi.getter(name="bfdMultiplier")
    def bfd_multiplier(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When bfd_minimum_interval_is_configured alone
        """
        return pulumi.get(self, "bfd_multiplier")

    @bfd_multiplier.setter
    def bfd_multiplier(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bfd_multiplier", value)

    @property
    @pulumi.getter(name="disableBfd")
    def disable_bfd(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        BFD provides faster path failure detection and is enabled by default
        """
        return pulumi.get(self, "disable_bfd")

    @disable_bfd.setter
    def disable_bfd(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_bfd", value)

    @property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default export policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="extendedV4Nexthop")
    def extended_v4_nexthop(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        return pulumi.get(self, "extended_v4_nexthop")

    @extended_v4_nexthop.setter
    def extended_v4_nexthop(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "extended_v4_nexthop", value)

    @property
    @pulumi.getter(name="gracefulRestartTime")
    def graceful_restart_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        `0` means disable
        """
        return pulumi.get(self, "graceful_restart_time")

    @graceful_restart_time.setter
    def graceful_restart_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "graceful_restart_time", value)

    @property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hold_time", value)

    @property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "import_")

    @import_.setter
    def import_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default import policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "local_as")

    @local_as.setter
    def local_as(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_as", value)

    @property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @neighbor_as.setter
    def neighbor_as(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "neighbor_as", value)

    @property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateBgpConfigNeighborsArgs']]]]:
        """
        If per-neighbor as is desired. Property key is the neighbor address
        """
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateBgpConfigNeighborsArgs']]]]):
        pulumi.set(self, "neighbors", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="noPrivateAs")
    def no_private_as(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "no_private_as")

    @no_private_as.setter
    def no_private_as(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_private_as", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, we'll re-advertise all learned BGP routers toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`tunnel`
        """
        return pulumi.get(self, "tunnel_name")

    @tunnel_name.setter
    def tunnel_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tunnel_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `external`, `internal`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter(name="vpnName")
    def vpn_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vpn_name")

    @vpn_name.setter
    def vpn_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpn_name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `via`==`wan`
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewaytemplateBgpConfigNeighborsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        export_policy: NotRequired[pulumi.Input[builtins.str]]
        hold_time: NotRequired[pulumi.Input[builtins.int]]
        import_policy: NotRequired[pulumi.Input[builtins.str]]
        multihop_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Assuming BGP neighbor is directly connected
        """
        neighbor_as: NotRequired[pulumi.Input[builtins.str]]
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
elif False:
    GatewaytemplateBgpConfigNeighborsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateBgpConfigNeighborsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 export_policy: Optional[pulumi.Input[builtins.str]] = None,
                 hold_time: Optional[pulumi.Input[builtins.int]] = None,
                 import_policy: Optional[pulumi.Input[builtins.str]] = None,
                 multihop_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 neighbor_as: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: If true, the BGP session to this neighbor will be administratively disabled/shutdown
        :param pulumi.Input[builtins.int] multihop_ttl: Assuming BGP neighbor is directly connected
        :param pulumi.Input[builtins.str] neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if multihop_ttl is not None:
            pulumi.set(__self__, "multihop_ttl", multihop_ttl)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hold_time", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="multihopTtl")
    def multihop_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Assuming BGP neighbor is directly connected
        """
        return pulumi.get(self, "multihop_ttl")

    @multihop_ttl.setter
    def multihop_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "multihop_ttl", value)

    @property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @neighbor_as.setter
    def neighbor_as(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "neighbor_as", value)


if not MYPY:
    class GatewaytemplateDhcpdConfigArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigArgsDict']]]]
        """
        Property key is the network name
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set to `false`, disable the DHCP server
        """
elif False:
    GatewaytemplateDhcpdConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateDhcpdConfigArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigArgs']]] config: Property key is the network name
        :param pulumi.Input[builtins.bool] enabled: If set to `false`, disable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigArgs']]]]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigArgs']]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to `false`, disable the DHCP server
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewaytemplateDhcpdConfigConfigArgsDict(TypedDict):
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        fixed_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigFixedBindingsArgsDict']]]]
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        ip_end: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`local`
        """
        ip_end6: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type6`==`local`
        """
        ip_start: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`local`
        """
        ip_start6: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type6`==`local`
        """
        lease_time: NotRequired[pulumi.Input[builtins.int]]
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigOptionsArgsDict']]]]
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        server_id_override: NotRequired[pulumi.Input[builtins.bool]]
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`relay`
        """
        servers6s: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type6`==`relay`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        type6: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        vendor_encapsulated: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgsDict']]]]
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
elif False:
    GatewaytemplateDhcpdConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateDhcpdConfigConfigArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 fixed_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigFixedBindingsArgs']]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip_end: Optional[pulumi.Input[builtins.str]] = None,
                 ip_end6: Optional[pulumi.Input[builtins.str]] = None,
                 ip_start: Optional[pulumi.Input[builtins.str]] = None,
                 ip_start6: Optional[pulumi.Input[builtins.str]] = None,
                 lease_time: Optional[pulumi.Input[builtins.int]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigOptionsArgs']]]] = None,
                 server_id_override: Optional[pulumi.Input[builtins.bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 servers6s: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 type6: Optional[pulumi.Input[builtins.str]] = None,
                 vendor_encapsulated: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_suffixes: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigFixedBindingsArgs']]] fixed_bindings: If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        :param pulumi.Input[builtins.str] gateway: If `type`==`local` - optional, `ip` will be used if not provided
        :param pulumi.Input[builtins.str] ip_end: If `type`==`local`
        :param pulumi.Input[builtins.str] ip_end6: If `type6`==`local`
        :param pulumi.Input[builtins.str] ip_start: If `type`==`local`
        :param pulumi.Input[builtins.str] ip_start6: If `type6`==`local`
        :param pulumi.Input[builtins.int] lease_time: In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigOptionsArgs']]] options: If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        :param pulumi.Input[builtins.bool] server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] servers: If `type`==`relay`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] servers6s: If `type6`==`relay`
        :param pulumi.Input[builtins.str] type: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param pulumi.Input[builtins.str] type6: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs']]] vendor_encapsulated: If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_end6 is not None:
            pulumi.set(__self__, "ip_end6", ip_end6)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if ip_start6 is not None:
            pulumi.set(__self__, "ip_start6", ip_start6)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if servers6s is not None:
            pulumi.set(__self__, "servers6s", servers6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapsulated is not None:
            pulumi.set(__self__, "vendor_encapsulated", vendor_encapsulated)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigFixedBindingsArgs']]]]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @fixed_bindings.setter
    def fixed_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigFixedBindingsArgs']]]]):
        pulumi.set(self, "fixed_bindings", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_end")

    @ip_end.setter
    def ip_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_end", value)

    @property
    @pulumi.getter(name="ipEnd6")
    def ip_end6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip_end6")

    @ip_end6.setter
    def ip_end6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_end6", value)

    @property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_start")

    @ip_start.setter
    def ip_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_start", value)

    @property
    @pulumi.getter(name="ipStart6")
    def ip_start6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip_start6")

    @ip_start6.setter
    def ip_start6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_start6", value)

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @lease_time.setter
    def lease_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "lease_time", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigOptionsArgs']]]]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigOptionsArgs']]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @server_id_override.setter
    def server_id_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "server_id_override", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter
    def servers6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type6`==`relay`
        """
        return pulumi.get(self, "servers6s")

    @servers6s.setter
    def servers6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "servers6s", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type6", value)

    @property
    @pulumi.getter(name="vendorEncapsulated")
    def vendor_encapsulated(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs']]]]:
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
        return pulumi.get(self, "vendor_encapsulated")

    @vendor_encapsulated.setter
    def vendor_encapsulated(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs']]]]):
        pulumi.set(self, "vendor_encapsulated", value)


if not MYPY:
    class GatewaytemplateDhcpdConfigConfigFixedBindingsArgsDict(TypedDict):
        ip: pulumi.Input[builtins.str]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateDhcpdConfigConfigFixedBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateDhcpdConfigConfigFixedBindingsArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[builtins.str],
                 name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewaytemplateDhcpdConfigConfigOptionsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateDhcpdConfigConfigOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateDhcpdConfigConfigOptionsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewaytemplateExtraRoutes6ArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
elif False:
    GatewaytemplateExtraRoutes6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateExtraRoutes6Args:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class GatewaytemplateExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
elif False:
    GatewaytemplateExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class GatewaytemplateIdpProfilesArgsDict(TypedDict):
        base_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `critical`, `standard`, `strict`
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        org_id: NotRequired[pulumi.Input[builtins.str]]
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateIdpProfilesOverwriteArgsDict']]]]
elif False:
    GatewaytemplateIdpProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateIdpProfilesArgs:
    def __init__(__self__, *,
                 base_profile: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateIdpProfilesOverwriteArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] base_profile: enum: `critical`, `standard`, `strict`
        """
        if base_profile is not None:
            pulumi.set(__self__, "base_profile", base_profile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)

    @property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @base_profile.setter
    def base_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_profile", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateIdpProfilesOverwriteArgs']]]]:
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateIdpProfilesOverwriteArgs']]]]):
        pulumi.set(self, "overwrites", value)


if not MYPY:
    class GatewaytemplateIdpProfilesOverwriteArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        matching: NotRequired[pulumi.Input['GatewaytemplateIdpProfilesOverwriteMatchingArgsDict']]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateIdpProfilesOverwriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateIdpProfilesOverwriteArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 matching: Optional[pulumi.Input['GatewaytemplateIdpProfilesOverwriteMatchingArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['GatewaytemplateIdpProfilesOverwriteMatchingArgs']]:
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['GatewaytemplateIdpProfilesOverwriteMatchingArgs']]):
        pulumi.set(self, "matching", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewaytemplateIdpProfilesOverwriteMatchingArgsDict(TypedDict):
        attack_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        dst_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    GatewaytemplateIdpProfilesOverwriteMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateIdpProfilesOverwriteMatchingArgs:
    def __init__(__self__, *,
                 attack_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dst_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "attack_names")

    @attack_names.setter
    def attack_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attack_names", value)

    @property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "dst_subnets")

    @dst_subnets.setter
    def dst_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dst_subnets", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "severities", value)


if not MYPY:
    class GatewaytemplateIpConfigsArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[builtins.str]]
        netmask: NotRequired[pulumi.Input[builtins.str]]
        secondary_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional list of secondary IPs in CIDR format
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
elif False:
    GatewaytemplateIpConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateIpConfigsArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] secondary_ips: Optional list of secondary IPs in CIDR format
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if secondary_ips is not None:
            pulumi.set(__self__, "secondary_ips", secondary_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="secondaryIps")
    def secondary_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional list of secondary IPs in CIDR format
        """
        return pulumi.get(self, "secondary_ips")

    @secondary_ips.setter
    def secondary_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "secondary_ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewaytemplateNetworkArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        subnet: pulumi.Input[builtins.str]
        disallow_mist_services: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disallow Mist Devices in the network
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        gateway6: NotRequired[pulumi.Input[builtins.str]]
        internal_access: NotRequired[pulumi.Input['GatewaytemplateNetworkInternalAccessArgsDict']]
        internet_access: NotRequired[pulumi.Input['GatewaytemplateNetworkInternetAccessArgsDict']]
        """
        Whether this network has direct internet access
        """
        isolation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow clients in the network to talk to each other
        """
        multicast: NotRequired[pulumi.Input['GatewaytemplateNetworkMulticastArgsDict']]
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        routed_for_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        subnet6: NotRequired[pulumi.Input[builtins.str]]
        tenants: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkTenantsArgsDict']]]]
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
        vpn_access: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessArgsDict']]]]
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
elif False:
    GatewaytemplateNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 subnet: pulumi.Input[builtins.str],
                 disallow_mist_services: Optional[pulumi.Input[builtins.bool]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 gateway6: Optional[pulumi.Input[builtins.str]] = None,
                 internal_access: Optional[pulumi.Input['GatewaytemplateNetworkInternalAccessArgs']] = None,
                 internet_access: Optional[pulumi.Input['GatewaytemplateNetworkInternetAccessArgs']] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 multicast: Optional[pulumi.Input['GatewaytemplateNetworkMulticastArgs']] = None,
                 routed_for_networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subnet6: Optional[pulumi.Input[builtins.str]] = None,
                 tenants: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkTenantsArgs']]]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vpn_access: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] disallow_mist_services: Whether to disallow Mist Devices in the network
        :param pulumi.Input['GatewaytemplateNetworkInternetAccessArgs'] internet_access: Whether this network has direct internet access
        :param pulumi.Input[builtins.bool] isolation: Whether to allow clients in the network to talk to each other
        :param pulumi.Input['GatewaytemplateNetworkMulticastArgs'] multicast: Whether to enable multicast support (only PIM-sparse mode is supported)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] routed_for_networks: For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkTenantsArgs']]] tenants: Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessArgs']]] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        if disallow_mist_services is not None:
            pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if internal_access is not None:
            pulumi.set(__self__, "internal_access", internal_access)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if routed_for_networks is not None:
            pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_access is not None:
            pulumi.set(__self__, "vpn_access", vpn_access)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @disallow_mist_services.setter
    def disallow_mist_services(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disallow_mist_services", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def gateway6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gateway6")

    @gateway6.setter
    def gateway6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway6", value)

    @property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> Optional[pulumi.Input['GatewaytemplateNetworkInternalAccessArgs']]:
        return pulumi.get(self, "internal_access")

    @internal_access.setter
    def internal_access(self, value: Optional[pulumi.Input['GatewaytemplateNetworkInternalAccessArgs']]):
        pulumi.set(self, "internal_access", value)

    @property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[pulumi.Input['GatewaytemplateNetworkInternetAccessArgs']]:
        """
        Whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @internet_access.setter
    def internet_access(self, value: Optional[pulumi.Input['GatewaytemplateNetworkInternetAccessArgs']]):
        pulumi.set(self, "internet_access", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['GatewaytemplateNetworkMulticastArgs']]:
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['GatewaytemplateNetworkMulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @routed_for_networks.setter
    def routed_for_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "routed_for_networks", value)

    @property
    @pulumi.getter
    def subnet6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "subnet6")

    @subnet6.setter
    def subnet6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet6", value)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkTenantsArgs']]]]:
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkTenantsArgs']]]]):
        pulumi.set(self, "tenants", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessArgs']]]]:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")

    @vpn_access.setter
    def vpn_access(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessArgs']]]]):
        pulumi.set(self, "vpn_access", value)


if not MYPY:
    class GatewaytemplateNetworkInternalAccessArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    GatewaytemplateNetworkInternalAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkInternalAccessArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewaytemplateNetworkInternetAccessArgsDict(TypedDict):
        create_simple_service_policy: NotRequired[pulumi.Input[builtins.bool]]
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessDestinationNatArgsDict']]]]
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        restricted: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessStaticNatArgsDict']]]]
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
elif False:
    GatewaytemplateNetworkInternetAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkInternetAccessArgs:
    def __init__(__self__, *,
                 create_simple_service_policy: Optional[pulumi.Input[builtins.bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessDestinationNatArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 restricted: Optional[pulumi.Input[builtins.bool]] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessStaticNatArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessDestinationNatArgs']]] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param pulumi.Input[builtins.bool] restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessStaticNatArgs']]] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "create_simple_service_policy")

    @create_simple_service_policy.setter
    def create_simple_service_policy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create_simple_service_policy", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessDestinationNatArgs']]]]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def restricted(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @restricted.setter
    def restricted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restricted", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessStaticNatArgs']]]]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkInternetAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)


if not MYPY:
    class GatewaytemplateNetworkInternetAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
elif False:
    GatewaytemplateNetworkInternetAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkInternetAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewaytemplateNetworkInternetAccessStaticNatArgsDict(TypedDict):
        internal_ip: pulumi.Input[builtins.str]
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        name: pulumi.Input[builtins.str]
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
elif False:
    GatewaytemplateNetworkInternetAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkInternetAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> pulumi.Input[builtins.str]:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewaytemplateNetworkMulticastArgsDict(TypedDict):
        disable_igmp: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        groups: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkMulticastGroupsArgsDict']]]]
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
elif False:
    GatewaytemplateNetworkMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkMulticastArgs:
    def __init__(__self__, *,
                 disable_igmp: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkMulticastGroupsArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkMulticastGroupsArgs']]] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @disable_igmp.setter
    def disable_igmp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_igmp", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkMulticastGroupsArgs']]]]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkMulticastGroupsArgs']]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class GatewaytemplateNetworkMulticastGroupsArgsDict(TypedDict):
        rp_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        RP (rendezvous point) IP Address
        """
elif False:
    GatewaytemplateNetworkMulticastGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkMulticastGroupsArgs:
    def __init__(__self__, *,
                 rp_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")

    @rp_ip.setter
    def rp_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rp_ip", value)


if not MYPY:
    class GatewaytemplateNetworkTenantsArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    GatewaytemplateNetworkTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkTenantsArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class GatewaytemplateNetworkVpnAccessArgsDict(TypedDict):
        advertised_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        allow_ping: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow ping from vpn into this routed network
        """
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessDestinationNatArgsDict']]]]
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        nat_pool: NotRequired[pulumi.Input[builtins.str]]
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        no_readvertise_to_lan_bgp: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward LAN-side BGP peers
        """
        no_readvertise_to_lan_ospf: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward LAN-side OSPF peers
        """
        no_readvertise_to_overlay: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        other_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        routed: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether this network is routable
        """
        source_nat: NotRequired[pulumi.Input['GatewaytemplateNetworkVpnAccessSourceNatArgsDict']]
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessStaticNatArgsDict']]]]
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        summarized_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        summarized_subnet_to_lan_bgp: NotRequired[pulumi.Input[builtins.str]]
        """
        toward LAN-side BGP peers
        """
        summarized_subnet_to_lan_ospf: NotRequired[pulumi.Input[builtins.str]]
        """
        toward LAN-side OSPF peers
        """
elif False:
    GatewaytemplateNetworkVpnAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkVpnAccessArgs:
    def __init__(__self__, *,
                 advertised_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 allow_ping: Optional[pulumi.Input[builtins.bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessDestinationNatArgs']]]] = None,
                 nat_pool: Optional[pulumi.Input[builtins.str]] = None,
                 no_readvertise_to_lan_bgp: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_lan_ospf: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[builtins.bool]] = None,
                 other_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 routed: Optional[pulumi.Input[builtins.bool]] = None,
                 source_nat: Optional[pulumi.Input['GatewaytemplateNetworkVpnAccessSourceNatArgs']] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessStaticNatArgs']]]] = None,
                 summarized_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 summarized_subnet_to_lan_bgp: Optional[pulumi.Input[builtins.str]] = None,
                 summarized_subnet_to_lan_ospf: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param pulumi.Input[builtins.bool] allow_ping: Whether to allow ping from vpn into this routed network
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessDestinationNatArgs']]] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param pulumi.Input[builtins.str] nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param pulumi.Input[builtins.bool] no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[builtins.bool] no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param pulumi.Input[builtins.bool] no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param pulumi.Input[builtins.bool] routed: Whether this network is routable
        :param pulumi.Input['GatewaytemplateNetworkVpnAccessSourceNatArgs'] source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessStaticNatArgs']]] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param pulumi.Input[builtins.str] summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[builtins.str] summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @advertised_subnet.setter
    def advertised_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "advertised_subnet", value)

    @property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @allow_ping.setter
    def allow_ping(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ping", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessDestinationNatArgs']]]]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nat_pool", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @no_readvertise_to_lan_bgp.setter
    def no_readvertise_to_lan_bgp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_lan_bgp", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @no_readvertise_to_lan_ospf.setter
    def no_readvertise_to_lan_ospf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_lan_ospf", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @other_vrfs.setter
    def other_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "other_vrfs", value)

    @property
    @pulumi.getter
    def routed(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @routed.setter
    def routed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "routed", value)

    @property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional[pulumi.Input['GatewaytemplateNetworkVpnAccessSourceNatArgs']]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @source_nat.setter
    def source_nat(self, value: Optional[pulumi.Input['GatewaytemplateNetworkVpnAccessSourceNatArgs']]):
        pulumi.set(self, "source_nat", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessStaticNatArgs']]]]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplateNetworkVpnAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)

    @property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @summarized_subnet.setter
    def summarized_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @summarized_subnet_to_lan_bgp.setter
    def summarized_subnet_to_lan_bgp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet_to_lan_bgp", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")

    @summarized_subnet_to_lan_ospf.setter
    def summarized_subnet_to_lan_ospf(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet_to_lan_ospf", value)


if not MYPY:
    class GatewaytemplateNetworkVpnAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateNetworkVpnAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkVpnAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewaytemplateNetworkVpnAccessSourceNatArgsDict(TypedDict):
        external_ip: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateNetworkVpnAccessSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkVpnAccessSourceNatArgs:
    def __init__(__self__, *,
                 external_ip: Optional[pulumi.Input[builtins.str]] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_ip")

    @external_ip.setter
    def external_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_ip", value)


if not MYPY:
    class GatewaytemplateNetworkVpnAccessStaticNatArgsDict(TypedDict):
        internal_ip: pulumi.Input[builtins.str]
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        name: pulumi.Input[builtins.str]
elif False:
    GatewaytemplateNetworkVpnAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateNetworkVpnAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> pulumi.Input[builtins.str]:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewaytemplateOobIpConfigArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        node1: NotRequired[pulumi.Input['GatewaytemplateOobIpConfigNode1ArgsDict']]
        """
        For HA Cluster, node1 can have different IP Config
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[builtins.bool]]
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[builtins.bool]]
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateOobIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateOobIpConfigArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 node1: Optional[pulumi.Input['GatewaytemplateOobIpConfigNode1Args']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[builtins.bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gateway: If `type`==`static`
        :param pulumi.Input[builtins.str] ip: If `type`==`static`
        :param pulumi.Input[builtins.str] netmask: If `type`==`static`
        :param pulumi.Input['GatewaytemplateOobIpConfigNode1Args'] node1: For HA Cluster, node1 can have different IP Config
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        :param pulumi.Input[builtins.bool] use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[builtins.bool] use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if node1 is not None:
            pulumi.set(__self__, "node1", node1)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def node1(self) -> Optional[pulumi.Input['GatewaytemplateOobIpConfigNode1Args']]:
        """
        For HA Cluster, node1 can have different IP Config
        """
        return pulumi.get(self, "node1")

    @node1.setter
    def node1(self, value: Optional[pulumi.Input['GatewaytemplateOobIpConfigNode1Args']]):
        pulumi.set(self, "node1", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GatewaytemplateOobIpConfigNode1ArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`static`
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        Used only if `subnet` is not specified in `networks`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[builtins.bool]]
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplateOobIpConfigNode1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateOobIpConfigNode1Args:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[builtins.bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gateway: If `type`==`static`
        :param pulumi.Input[builtins.str] netmask: Used only if `subnet` is not specified in `networks`
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        :param pulumi.Input[builtins.bool] use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[builtins.bool] use_mgmt_vrf_for_host_out: Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GatewaytemplatePathPreferencesArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplatePathPreferencesPathArgsDict']]]]
        strategy: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
elif False:
    GatewaytemplatePathPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePathPreferencesArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplatePathPreferencesPathArgs']]]] = None,
                 strategy: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] strategy: enum: `ecmp`, `ordered`, `weighted`
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplatePathPreferencesPathArgs']]]]:
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplatePathPreferencesPathArgs']]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class GatewaytemplatePathPreferencesPathArgsDict(TypedDict):
        cost: NotRequired[pulumi.Input[builtins.int]]
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        gateway_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        internet_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required when `type`==`local`
        """
        target_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `type`==`vpn`
        """
elif False:
    GatewaytemplatePathPreferencesPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePathPreferencesPathArgs:
    def __init__(__self__, *,
                 cost: Optional[pulumi.Input[builtins.int]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 gateway_ip: Optional[pulumi.Input[builtins.str]] = None,
                 internet_access: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: For SSR Only. `true`, if this specific path is undesired
        :param pulumi.Input[builtins.str] gateway_ip: Only if `type`==`local`, if a different gateway is desired
        :param pulumi.Input[builtins.bool] internet_access: Only if `type`==`vpn`, if this vpn path can be used for internet
        :param pulumi.Input[builtins.str] name: Required when 
                 * `type`==`vpn`: the name of the VPN Path to use 
                 * `type`==`wan`: the name of the WAN interface to use
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: Required when `type`==`local`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_ips: If `type`==`local`, if destination IP is to be replaced
        :param pulumi.Input[builtins.str] type: enum: `local`, `tunnel`, `vpn`, `wan`
        :param pulumi.Input[builtins.str] wan_name: Optional if `type`==`vpn`
        """
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cost", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway_ip", value)

    @property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        return pulumi.get(self, "internet_access")

    @internet_access.setter
    def internet_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "internet_access", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required when `type`==`local`
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        return pulumi.get(self, "target_ips")

    @target_ips.setter
    def target_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `type`==`vpn`
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewaytemplatePortConfigArgsDict(TypedDict):
        usage: pulumi.Input[builtins.str]
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        ae_disable_lacp: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        ae_idx: NotRequired[pulumi.Input[builtins.str]]
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        ae_lacp_force_up: NotRequired[pulumi.Input[builtins.bool]]
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        aggregated: NotRequired[pulumi.Input[builtins.bool]]
        critical: NotRequired[pulumi.Input[builtins.bool]]
        """
        To generate port up/down alarm, set it to true
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        disable_autoneg: NotRequired[pulumi.Input[builtins.bool]]
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Port admin up (true) / down (false)
        """
        dsl_type: NotRequired[pulumi.Input[builtins.str]]
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        dsl_vci: NotRequired[pulumi.Input[builtins.int]]
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        dsl_vpi: NotRequired[pulumi.Input[builtins.int]]
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        duplex: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `full`, `half`
        """
        ip_config: NotRequired[pulumi.Input['GatewaytemplatePortConfigIpConfigArgsDict']]
        """
        Junos IP Config
        """
        lte_apn: NotRequired[pulumi.Input[builtins.str]]
        """
        If `wan_type`==`lte`
        """
        lte_auth: NotRequired[pulumi.Input[builtins.str]]
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        lte_backup: NotRequired[pulumi.Input[builtins.bool]]
        lte_password: NotRequired[pulumi.Input[builtins.str]]
        """
        If `wan_type`==`lte`
        """
        lte_username: NotRequired[pulumi.Input[builtins.str]]
        """
        If `wan_type`==`lte`
        """
        mtu: NotRequired[pulumi.Input[builtins.int]]
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name that we'll use to derive config
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        outer_vlan_id: NotRequired[pulumi.Input[builtins.int]]
        """
        For Q-in-Q
        """
        poe_disabled: NotRequired[pulumi.Input[builtins.bool]]
        port_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        preserve_dscp: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        redundant: NotRequired[pulumi.Input[builtins.bool]]
        """
        If HA mode
        """
        redundant_group: NotRequired[pulumi.Input[builtins.int]]
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        reth_idx: NotRequired[pulumi.Input[builtins.str]]
        """
        For SRX only and if HA Mode
        """
        reth_node: NotRequired[pulumi.Input[builtins.str]]
        """
        If HA mode
        """
        reth_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        speed: NotRequired[pulumi.Input[builtins.str]]
        ssr_no_virtual_mac: NotRequired[pulumi.Input[builtins.bool]]
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        svr_port_range: NotRequired[pulumi.Input[builtins.str]]
        """
        For SSR only
        """
        traffic_shaping: NotRequired[pulumi.Input['GatewaytemplatePortConfigTrafficShapingArgsDict']]
        vlan_id: NotRequired[pulumi.Input[builtins.str]]
        vpn_paths: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigVpnPathsArgsDict']]]]
        """
        Property key is the VPN name
        """
        wan_arp_policer: NotRequired[pulumi.Input[builtins.str]]
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        wan_ext_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        wan_extra_routes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigWanExtraRoutesArgsDict']]]]
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        wan_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        wan_probe_override: NotRequired[pulumi.Input['GatewaytemplatePortConfigWanProbeOverrideArgsDict']]
        """
        Only if `usage`==`wan`
        """
        wan_source_nat: NotRequired[pulumi.Input['GatewaytemplatePortConfigWanSourceNatArgsDict']]
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        wan_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
elif False:
    GatewaytemplatePortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[builtins.str],
                 ae_disable_lacp: Optional[pulumi.Input[builtins.bool]] = None,
                 ae_idx: Optional[pulumi.Input[builtins.str]] = None,
                 ae_lacp_force_up: Optional[pulumi.Input[builtins.bool]] = None,
                 aggregated: Optional[pulumi.Input[builtins.bool]] = None,
                 critical: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disable_autoneg: Optional[pulumi.Input[builtins.bool]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dsl_type: Optional[pulumi.Input[builtins.str]] = None,
                 dsl_vci: Optional[pulumi.Input[builtins.int]] = None,
                 dsl_vpi: Optional[pulumi.Input[builtins.int]] = None,
                 duplex: Optional[pulumi.Input[builtins.str]] = None,
                 ip_config: Optional[pulumi.Input['GatewaytemplatePortConfigIpConfigArgs']] = None,
                 lte_apn: Optional[pulumi.Input[builtins.str]] = None,
                 lte_auth: Optional[pulumi.Input[builtins.str]] = None,
                 lte_backup: Optional[pulumi.Input[builtins.bool]] = None,
                 lte_password: Optional[pulumi.Input[builtins.str]] = None,
                 lte_username: Optional[pulumi.Input[builtins.str]] = None,
                 mtu: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 outer_vlan_id: Optional[pulumi.Input[builtins.int]] = None,
                 poe_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 port_network: Optional[pulumi.Input[builtins.str]] = None,
                 preserve_dscp: Optional[pulumi.Input[builtins.bool]] = None,
                 redundant: Optional[pulumi.Input[builtins.bool]] = None,
                 redundant_group: Optional[pulumi.Input[builtins.int]] = None,
                 reth_idx: Optional[pulumi.Input[builtins.str]] = None,
                 reth_node: Optional[pulumi.Input[builtins.str]] = None,
                 reth_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 speed: Optional[pulumi.Input[builtins.str]] = None,
                 ssr_no_virtual_mac: Optional[pulumi.Input[builtins.bool]] = None,
                 svr_port_range: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_shaping: Optional[pulumi.Input['GatewaytemplatePortConfigTrafficShapingArgs']] = None,
                 vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 vpn_paths: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigVpnPathsArgs']]]] = None,
                 wan_arp_policer: Optional[pulumi.Input[builtins.str]] = None,
                 wan_ext_ip: Optional[pulumi.Input[builtins.str]] = None,
                 wan_extra_routes: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigWanExtraRoutesArgs']]]] = None,
                 wan_networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wan_probe_override: Optional[pulumi.Input['GatewaytemplatePortConfigWanProbeOverrideArgs']] = None,
                 wan_source_nat: Optional[pulumi.Input['GatewaytemplatePortConfigWanSourceNatArgs']] = None,
                 wan_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] usage: port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        :param pulumi.Input[builtins.bool] ae_disable_lacp: If `aggregated`==`true`. To disable LCP support for the AE interface
        :param pulumi.Input[builtins.str] ae_idx: If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        :param pulumi.Input[builtins.bool] ae_lacp_force_up: For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        :param pulumi.Input[builtins.bool] critical: To generate port up/down alarm, set it to true
        :param pulumi.Input[builtins.str] description: Interface Description. Can be a variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.bool] disabled: Port admin up (true) / down (false)
        :param pulumi.Input[builtins.str] dsl_type: if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        :param pulumi.Input[builtins.int] dsl_vci: If `wan_type`==`dsl`, 16 bit int
        :param pulumi.Input[builtins.int] dsl_vpi: If `wan_type`==`dsl`, 8 bit int
        :param pulumi.Input[builtins.str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input['GatewaytemplatePortConfigIpConfigArgs'] ip_config: Junos IP Config
        :param pulumi.Input[builtins.str] lte_apn: If `wan_type`==`lte`
        :param pulumi.Input[builtins.str] lte_auth: if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        :param pulumi.Input[builtins.str] lte_password: If `wan_type`==`lte`
        :param pulumi.Input[builtins.str] lte_username: If `wan_type`==`lte`
        :param pulumi.Input[builtins.str] name: Name that we'll use to derive config
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: if `usage`==`lan`, name of the `org.Network` resource
        :param pulumi.Input[builtins.int] outer_vlan_id: For Q-in-Q
        :param pulumi.Input[builtins.str] port_network: Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        :param pulumi.Input[builtins.bool] preserve_dscp: Whether to preserve dscp when sending traffic over VPN (SSR-only)
        :param pulumi.Input[builtins.bool] redundant: If HA mode
        :param pulumi.Input[builtins.int] redundant_group: If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        :param pulumi.Input[builtins.str] reth_idx: For SRX only and if HA Mode
        :param pulumi.Input[builtins.str] reth_node: If HA mode
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] reth_nodes: SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        :param pulumi.Input[builtins.bool] ssr_no_virtual_mac: When SSR is running as VM, this is required on certain hosting platforms
        :param pulumi.Input[builtins.str] svr_port_range: For SSR only
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigVpnPathsArgs']]] vpn_paths: Property key is the VPN name
        :param pulumi.Input[builtins.str] wan_arp_policer: Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        :param pulumi.Input[builtins.str] wan_ext_ip: Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigWanExtraRoutesArgs']]] wan_extra_routes: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wan_networks: Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        :param pulumi.Input['GatewaytemplatePortConfigWanProbeOverrideArgs'] wan_probe_override: Only if `usage`==`wan`
        :param pulumi.Input['GatewaytemplatePortConfigWanSourceNatArgs'] wan_source_nat: Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        :param pulumi.Input[builtins.str] wan_type: Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_force_up is not None:
            pulumi.set(__self__, "ae_lacp_force_up", ae_lacp_force_up)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dsl_type is not None:
            pulumi.set(__self__, "dsl_type", dsl_type)
        if dsl_vci is not None:
            pulumi.set(__self__, "dsl_vci", dsl_vci)
        if dsl_vpi is not None:
            pulumi.set(__self__, "dsl_vpi", dsl_vpi)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if lte_apn is not None:
            pulumi.set(__self__, "lte_apn", lte_apn)
        if lte_auth is not None:
            pulumi.set(__self__, "lte_auth", lte_auth)
        if lte_backup is not None:
            pulumi.set(__self__, "lte_backup", lte_backup)
        if lte_password is not None:
            pulumi.set(__self__, "lte_password", lte_password)
        if lte_username is not None:
            pulumi.set(__self__, "lte_username", lte_username)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if outer_vlan_id is not None:
            pulumi.set(__self__, "outer_vlan_id", outer_vlan_id)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if preserve_dscp is not None:
            pulumi.set(__self__, "preserve_dscp", preserve_dscp)
        if redundant is not None:
            pulumi.set(__self__, "redundant", redundant)
        if redundant_group is not None:
            pulumi.set(__self__, "redundant_group", redundant_group)
        if reth_idx is not None:
            pulumi.set(__self__, "reth_idx", reth_idx)
        if reth_node is not None:
            pulumi.set(__self__, "reth_node", reth_node)
        if reth_nodes is not None:
            pulumi.set(__self__, "reth_nodes", reth_nodes)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssr_no_virtual_mac is not None:
            pulumi.set(__self__, "ssr_no_virtual_mac", ssr_no_virtual_mac)
        if svr_port_range is not None:
            pulumi.set(__self__, "svr_port_range", svr_port_range)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)
        if wan_arp_policer is not None:
            pulumi.set(__self__, "wan_arp_policer", wan_arp_policer)
        if wan_ext_ip is not None:
            pulumi.set(__self__, "wan_ext_ip", wan_ext_ip)
        if wan_extra_routes is not None:
            pulumi.set(__self__, "wan_extra_routes", wan_extra_routes)
        if wan_networks is not None:
            pulumi.set(__self__, "wan_networks", wan_networks)
        if wan_probe_override is not None:
            pulumi.set(__self__, "wan_probe_override", wan_probe_override)
        if wan_source_nat is not None:
            pulumi.set(__self__, "wan_source_nat", wan_source_nat)
        if wan_type is not None:
            pulumi.set(__self__, "wan_type", wan_type)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[builtins.str]:
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @ae_disable_lacp.setter
    def ae_disable_lacp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ae_disable_lacp", value)

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        return pulumi.get(self, "ae_idx")

    @ae_idx.setter
    def ae_idx(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ae_idx", value)

    @property
    @pulumi.getter(name="aeLacpForceUp")
    def ae_lacp_force_up(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        return pulumi.get(self, "ae_lacp_force_up")

    @ae_lacp_force_up.setter
    def ae_lacp_force_up(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ae_lacp_force_up", value)

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aggregated")

    @aggregated.setter
    def aggregated(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aggregated", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To generate port up/down alarm, set it to true
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Port admin up (true) / down (false)
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="dslType")
    def dsl_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        return pulumi.get(self, "dsl_type")

    @dsl_type.setter
    def dsl_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dsl_type", value)

    @property
    @pulumi.getter(name="dslVci")
    def dsl_vci(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        return pulumi.get(self, "dsl_vci")

    @dsl_vci.setter
    def dsl_vci(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dsl_vci", value)

    @property
    @pulumi.getter(name="dslVpi")
    def dsl_vpi(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        return pulumi.get(self, "dsl_vpi")

    @dsl_vpi.setter
    def dsl_vpi(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dsl_vpi", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional[pulumi.Input['GatewaytemplatePortConfigIpConfigArgs']]:
        """
        Junos IP Config
        """
        return pulumi.get(self, "ip_config")

    @ip_config.setter
    def ip_config(self, value: Optional[pulumi.Input['GatewaytemplatePortConfigIpConfigArgs']]):
        pulumi.set(self, "ip_config", value)

    @property
    @pulumi.getter(name="lteApn")
    def lte_apn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_apn")

    @lte_apn.setter
    def lte_apn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_apn", value)

    @property
    @pulumi.getter(name="lteAuth")
    def lte_auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "lte_auth")

    @lte_auth.setter
    def lte_auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_auth", value)

    @property
    @pulumi.getter(name="lteBackup")
    def lte_backup(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "lte_backup")

    @lte_backup.setter
    def lte_backup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "lte_backup", value)

    @property
    @pulumi.getter(name="ltePassword")
    def lte_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_password")

    @lte_password.setter
    def lte_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_password", value)

    @property
    @pulumi.getter(name="lteUsername")
    def lte_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_username")

    @lte_username.setter
    def lte_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lte_username", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name that we'll use to derive config
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="outerVlanId")
    def outer_vlan_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        For Q-in-Q
        """
        return pulumi.get(self, "outer_vlan_id")

    @outer_vlan_id.setter
    def outer_vlan_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "outer_vlan_id", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        return pulumi.get(self, "port_network")

    @port_network.setter
    def port_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_network", value)

    @property
    @pulumi.getter(name="preserveDscp")
    def preserve_dscp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        return pulumi.get(self, "preserve_dscp")

    @preserve_dscp.setter
    def preserve_dscp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "preserve_dscp", value)

    @property
    @pulumi.getter
    def redundant(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If HA mode
        """
        return pulumi.get(self, "redundant")

    @redundant.setter
    def redundant(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "redundant", value)

    @property
    @pulumi.getter(name="redundantGroup")
    def redundant_group(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        return pulumi.get(self, "redundant_group")

    @redundant_group.setter
    def redundant_group(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redundant_group", value)

    @property
    @pulumi.getter(name="rethIdx")
    def reth_idx(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For SRX only and if HA Mode
        """
        return pulumi.get(self, "reth_idx")

    @reth_idx.setter
    def reth_idx(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reth_idx", value)

    @property
    @pulumi.getter(name="rethNode")
    def reth_node(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If HA mode
        """
        return pulumi.get(self, "reth_node")

    @reth_node.setter
    def reth_node(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reth_node", value)

    @property
    @pulumi.getter(name="rethNodes")
    def reth_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        return pulumi.get(self, "reth_nodes")

    @reth_nodes.setter
    def reth_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "reth_nodes", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="ssrNoVirtualMac")
    def ssr_no_virtual_mac(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        return pulumi.get(self, "ssr_no_virtual_mac")

    @ssr_no_virtual_mac.setter
    def ssr_no_virtual_mac(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssr_no_virtual_mac", value)

    @property
    @pulumi.getter(name="svrPortRange")
    def svr_port_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For SSR only
        """
        return pulumi.get(self, "svr_port_range")

    @svr_port_range.setter
    def svr_port_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "svr_port_range", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['GatewaytemplatePortConfigTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['GatewaytemplatePortConfigTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigVpnPathsArgs']]]]:
        """
        Property key is the VPN name
        """
        return pulumi.get(self, "vpn_paths")

    @vpn_paths.setter
    def vpn_paths(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigVpnPathsArgs']]]]):
        pulumi.set(self, "vpn_paths", value)

    @property
    @pulumi.getter(name="wanArpPolicer")
    def wan_arp_policer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        return pulumi.get(self, "wan_arp_policer")

    @wan_arp_policer.setter
    def wan_arp_policer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_arp_policer", value)

    @property
    @pulumi.getter(name="wanExtIp")
    def wan_ext_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        return pulumi.get(self, "wan_ext_ip")

    @wan_ext_ip.setter
    def wan_ext_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_ext_ip", value)

    @property
    @pulumi.getter(name="wanExtraRoutes")
    def wan_extra_routes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigWanExtraRoutesArgs']]]]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        return pulumi.get(self, "wan_extra_routes")

    @wan_extra_routes.setter
    def wan_extra_routes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewaytemplatePortConfigWanExtraRoutesArgs']]]]):
        pulumi.set(self, "wan_extra_routes", value)

    @property
    @pulumi.getter(name="wanNetworks")
    def wan_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        return pulumi.get(self, "wan_networks")

    @wan_networks.setter
    def wan_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wan_networks", value)

    @property
    @pulumi.getter(name="wanProbeOverride")
    def wan_probe_override(self) -> Optional[pulumi.Input['GatewaytemplatePortConfigWanProbeOverrideArgs']]:
        """
        Only if `usage`==`wan`
        """
        return pulumi.get(self, "wan_probe_override")

    @wan_probe_override.setter
    def wan_probe_override(self, value: Optional[pulumi.Input['GatewaytemplatePortConfigWanProbeOverrideArgs']]):
        pulumi.set(self, "wan_probe_override", value)

    @property
    @pulumi.getter(name="wanSourceNat")
    def wan_source_nat(self) -> Optional[pulumi.Input['GatewaytemplatePortConfigWanSourceNatArgs']]:
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        return pulumi.get(self, "wan_source_nat")

    @wan_source_nat.setter
    def wan_source_nat(self, value: Optional[pulumi.Input['GatewaytemplatePortConfigWanSourceNatArgs']]):
        pulumi.set(self, "wan_source_nat", value)

    @property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        return pulumi.get(self, "wan_type")

    @wan_type.setter
    def wan_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_type", value)


if not MYPY:
    class GatewaytemplatePortConfigIpConfigArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        netmask: NotRequired[pulumi.Input[builtins.str]]
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, the network to be used for mgmt
        """
        poser_password: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`pppoe`
        """
        pppoe_auth: NotRequired[pulumi.Input[builtins.str]]
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        pppoe_username: NotRequired[pulumi.Input[builtins.str]]
        """
        If `type`==`pppoe`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `pppoe`, `static`
        """
elif False:
    GatewaytemplatePortConfigIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigIpConfigArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 netmask: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 poser_password: Optional[pulumi.Input[builtins.str]] = None,
                 pppoe_auth: Optional[pulumi.Input[builtins.str]] = None,
                 pppoe_username: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns: Except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_suffixes: Except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[builtins.str] gateway: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] ip: Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] netmask: Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] network: Optional, the network to be used for mgmt
        :param pulumi.Input[builtins.str] poser_password: If `type`==`pppoe`
        :param pulumi.Input[builtins.str] pppoe_auth: if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        :param pulumi.Input[builtins.str] pppoe_username: If `type`==`pppoe`
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `pppoe`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if poser_password is not None:
            pulumi.set(__self__, "poser_password", poser_password)
        if pppoe_auth is not None:
            pulumi.set(__self__, "pppoe_auth", pppoe_auth)
        if pppoe_username is not None:
            pulumi.set(__self__, "pppoe_username", pppoe_username)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="poserPassword")
    def poser_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "poser_password")

    @poser_password.setter
    def poser_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "poser_password", value)

    @property
    @pulumi.getter(name="pppoeAuth")
    def pppoe_auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "pppoe_auth")

    @pppoe_auth.setter
    def pppoe_auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pppoe_auth", value)

    @property
    @pulumi.getter(name="pppoeUsername")
    def pppoe_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "pppoe_username")

    @pppoe_username.setter
    def pppoe_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pppoe_username", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `pppoe`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewaytemplatePortConfigTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_tx_kbps: NotRequired[pulumi.Input[builtins.int]]
        """
        Interface Transmit Cap in kbps
        """
elif False:
    GatewaytemplatePortConfigTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_tx_kbps: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param pulumi.Input[builtins.int] max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")

    @max_tx_kbps.setter
    def max_tx_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tx_kbps", value)


if not MYPY:
    class GatewaytemplatePortConfigVpnPathsArgsDict(TypedDict):
        bfd_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        bfd_use_tunnel_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        preference: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        traffic_shaping: NotRequired[pulumi.Input['GatewaytemplatePortConfigVpnPathsTrafficShapingArgsDict']]
elif False:
    GatewaytemplatePortConfigVpnPathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigVpnPathsArgs:
    def __init__(__self__, *,
                 bfd_profile: Optional[pulumi.Input[builtins.str]] = None,
                 bfd_use_tunnel_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 preference: Optional[pulumi.Input[builtins.int]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_shaping: Optional[pulumi.Input['GatewaytemplatePortConfigVpnPathsTrafficShapingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] bfd_profile: Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        :param pulumi.Input[builtins.bool] bfd_use_tunnel_mode: Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        :param pulumi.Input[builtins.int] preference: Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        :param pulumi.Input[builtins.str] role: If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @bfd_profile.setter
    def bfd_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bfd_profile", value)

    @property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @bfd_use_tunnel_mode.setter
    def bfd_use_tunnel_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bfd_use_tunnel_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['GatewaytemplatePortConfigVpnPathsTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['GatewaytemplatePortConfigVpnPathsTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)


if not MYPY:
    class GatewaytemplatePortConfigVpnPathsTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_tx_kbps: NotRequired[pulumi.Input[builtins.int]]
        """
        Interface Transmit Cap in kbps
        """
elif False:
    GatewaytemplatePortConfigVpnPathsTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigVpnPathsTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_tx_kbps: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param pulumi.Input[builtins.int] max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")

    @max_tx_kbps.setter
    def max_tx_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tx_kbps", value)


if not MYPY:
    class GatewaytemplatePortConfigWanExtraRoutesArgsDict(TypedDict):
        via: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GatewaytemplatePortConfigWanExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigWanExtraRoutesArgs:
    def __init__(__self__, *,
                 via: Optional[pulumi.Input[builtins.str]] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "via", value)


if not MYPY:
    class GatewaytemplatePortConfigWanProbeOverrideArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        probe_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `broadband`, `lte`
        """
elif False:
    GatewaytemplatePortConfigWanProbeOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigWanProbeOverrideArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 probe_profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] probe_profile: enum: `broadband`, `lte`
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if probe_profile is not None:
            pulumi.set(__self__, "probe_profile", probe_profile)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="probeProfile")
    def probe_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "probe_profile")

    @probe_profile.setter
    def probe_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "probe_profile", value)


if not MYPY:
    class GatewaytemplatePortConfigWanSourceNatArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Or to disable the source-nat
        """
        nat_pool: NotRequired[pulumi.Input[builtins.str]]
        """
        If alternative nat_pool is desired
        """
elif False:
    GatewaytemplatePortConfigWanSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplatePortConfigWanSourceNatArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 nat_pool: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: Or to disable the source-nat
        :param pulumi.Input[builtins.str] nat_pool: If alternative nat_pool is desired
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Or to disable the source-nat
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If alternative nat_pool is desired
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nat_pool", value)


if not MYPY:
    class GatewaytemplateRoutingPoliciesArgsDict(TypedDict):
        terms: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateRoutingPoliciesTermArgsDict']]]]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
elif False:
    GatewaytemplateRoutingPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateRoutingPoliciesArgs:
    def __init__(__self__, *,
                 terms: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateRoutingPoliciesTermArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GatewaytemplateRoutingPoliciesTermArgs']]] terms: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @property
    @pulumi.getter
    def terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateRoutingPoliciesTermArgs']]]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "terms")

    @terms.setter
    def terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateRoutingPoliciesTermArgs']]]]):
        pulumi.set(self, "terms", value)


if not MYPY:
    class GatewaytemplateRoutingPoliciesTermArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['GatewaytemplateRoutingPoliciesTermActionArgsDict']]
        """
        When used as import policy
        """
        matching: NotRequired[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingArgsDict']]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
elif False:
    GatewaytemplateRoutingPoliciesTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateRoutingPoliciesTermArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermActionArgs']] = None,
                 matching: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingArgs']] = None):
        """
        :param pulumi.Input['GatewaytemplateRoutingPoliciesTermActionArgs'] action: When used as import policy
        :param pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingArgs'] matching: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermActionArgs']]:
        """
        When used as import policy
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingArgs']]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingArgs']]):
        pulumi.set(self, "matching", value)


if not MYPY:
    class GatewaytemplateRoutingPoliciesTermActionArgsDict(TypedDict):
        accept: NotRequired[pulumi.Input[builtins.bool]]
        add_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        add_target_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional
        """
        exclude_as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional. To exclude certain AS
        """
        exclude_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        export_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional
        """
        local_preference: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional, for an import policy, local_preference can be changed
        """
        prepend_as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
elif False:
    GatewaytemplateRoutingPoliciesTermActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateRoutingPoliciesTermActionArgs:
    def __init__(__self__, *,
                 accept: Optional[pulumi.Input[builtins.bool]] = None,
                 add_communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 add_target_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 exclude_as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 exclude_communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 export_communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 local_preference: Optional[pulumi.Input[builtins.str]] = None,
                 prepend_as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] add_target_vrfs: For SSR, hub decides how VRF routes are leaked on spoke
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] communities: When used as export policy, optional
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exclude_as_paths: When used as export policy, optional. To exclude certain AS
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] export_communities: When used as export policy, optional
        :param pulumi.Input[builtins.str] local_preference: Optional, for an import policy, local_preference can be changed
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prepend_as_paths: When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if add_communities is not None:
            pulumi.set(__self__, "add_communities", add_communities)
        if add_target_vrfs is not None:
            pulumi.set(__self__, "add_target_vrfs", add_target_vrfs)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if exclude_as_paths is not None:
            pulumi.set(__self__, "exclude_as_paths", exclude_as_paths)
        if exclude_communities is not None:
            pulumi.set(__self__, "exclude_communities", exclude_communities)
        if export_communities is not None:
            pulumi.set(__self__, "export_communities", export_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if prepend_as_paths is not None:
            pulumi.set(__self__, "prepend_as_paths", prepend_as_paths)

    @property
    @pulumi.getter
    def accept(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "accept")

    @accept.setter
    def accept(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "accept", value)

    @property
    @pulumi.getter(name="addCommunities")
    def add_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "add_communities")

    @add_communities.setter
    def add_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "add_communities", value)

    @property
    @pulumi.getter(name="addTargetVrfs")
    def add_target_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        return pulumi.get(self, "add_target_vrfs")

    @add_target_vrfs.setter
    def add_target_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "add_target_vrfs", value)

    @property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "communities", value)

    @property
    @pulumi.getter(name="excludeAsPaths")
    def exclude_as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional. To exclude certain AS
        """
        return pulumi.get(self, "exclude_as_paths")

    @exclude_as_paths.setter
    def exclude_as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_as_paths", value)

    @property
    @pulumi.getter(name="excludeCommunities")
    def exclude_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "exclude_communities")

    @exclude_communities.setter
    def exclude_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_communities", value)

    @property
    @pulumi.getter(name="exportCommunities")
    def export_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "export_communities")

    @export_communities.setter
    def export_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "export_communities", value)

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional, for an import policy, local_preference can be changed
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_preference", value)

    @property
    @pulumi.getter(name="prependAsPaths")
    def prepend_as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        return pulumi.get(self, "prepend_as_paths")

    @prepend_as_paths.setter
    def prepend_as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prepend_as_paths", value)


if not MYPY:
    class GatewaytemplateRoutingPoliciesTermMatchingArgsDict(TypedDict):
        as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        takes regular expression
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        route_exists: NotRequired[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgsDict']]
        vpn_neighbor_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        vpn_path_sla: NotRequired[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgsDict']]
        vpn_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
elif False:
    GatewaytemplateRoutingPoliciesTermMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateRoutingPoliciesTermMatchingArgs:
    def __init__(__self__, *,
                 as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 route_exists: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgs']] = None,
                 vpn_neighbor_macs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vpn_path_sla: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgs']] = None,
                 vpn_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] as_paths: takes regular expression
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] prefixes: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] protocols: `direct`, `bgp`, `osp`, `static`, `aggregate`...
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vpn_neighbor_macs: overlay-facing criteria (used for bgp_config where via=vpn)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vpn_paths: overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_exists is not None:
            pulumi.set(__self__, "route_exists", route_exists)
        if vpn_neighbor_macs is not None:
            pulumi.set(__self__, "vpn_neighbor_macs", vpn_neighbor_macs)
        if vpn_path_sla is not None:
            pulumi.set(__self__, "vpn_path_sla", vpn_path_sla)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)

    @property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        takes regular expression
        """
        return pulumi.get(self, "as_paths")

    @as_paths.setter
    def as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "as_paths", value)

    @property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "communities", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="routeExists")
    def route_exists(self) -> Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgs']]:
        return pulumi.get(self, "route_exists")

    @route_exists.setter
    def route_exists(self, value: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgs']]):
        pulumi.set(self, "route_exists", value)

    @property
    @pulumi.getter(name="vpnNeighborMacs")
    def vpn_neighbor_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        return pulumi.get(self, "vpn_neighbor_macs")

    @vpn_neighbor_macs.setter
    def vpn_neighbor_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vpn_neighbor_macs", value)

    @property
    @pulumi.getter(name="vpnPathSla")
    def vpn_path_sla(self) -> Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgs']]:
        return pulumi.get(self, "vpn_path_sla")

    @vpn_path_sla.setter
    def vpn_path_sla(self, value: Optional[pulumi.Input['GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgs']]):
        pulumi.set(self, "vpn_path_sla", value)

    @property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        return pulumi.get(self, "vpn_paths")

    @vpn_paths.setter
    def vpn_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vpn_paths", value)


if not MYPY:
    class GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgsDict(TypedDict):
        route: NotRequired[pulumi.Input[builtins.str]]
        vrf_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
elif False:
    GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateRoutingPoliciesTermMatchingRouteExistsArgs:
    def __init__(__self__, *,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 vrf_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] vrf_name: Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        if route is not None:
            pulumi.set(__self__, "route", route)
        if vrf_name is not None:
            pulumi.set(__self__, "vrf_name", vrf_name)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        return pulumi.get(self, "vrf_name")

    @vrf_name.setter
    def vrf_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vrf_name", value)


if not MYPY:
    class GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgsDict(TypedDict):
        max_jitter: NotRequired[pulumi.Input[builtins.int]]
        max_latency: NotRequired[pulumi.Input[builtins.int]]
        max_loss: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateRoutingPoliciesTermMatchingVpnPathSlaArgs:
    def __init__(__self__, *,
                 max_jitter: Optional[pulumi.Input[builtins.int]] = None,
                 max_latency: Optional[pulumi.Input[builtins.int]] = None,
                 max_loss: Optional[pulumi.Input[builtins.int]] = None):
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)

    @property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_jitter")

    @max_jitter.setter
    def max_jitter(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_jitter", value)

    @property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_latency", value)

    @property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_loss")

    @max_loss.setter
    def max_loss(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_loss", value)


if not MYPY:
    class GatewaytemplateServicePolicyArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        antivirus: NotRequired[pulumi.Input['GatewaytemplateServicePolicyAntivirusArgsDict']]
        """
        For SRX-only
        """
        appqoe: NotRequired[pulumi.Input['GatewaytemplateServicePolicyAppqoeArgsDict']]
        """
        For SRX Only
        """
        ewfs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateServicePolicyEwfArgsDict']]]]
        idp: NotRequired[pulumi.Input['GatewaytemplateServicePolicyIdpArgsDict']]
        local_routing: NotRequired[pulumi.Input[builtins.bool]]
        """
        access within the same VRF
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        path_preference: NotRequired[pulumi.Input[builtins.str]]
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        servicepolicy_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        ssl_proxy: NotRequired[pulumi.Input['GatewaytemplateServicePolicySslProxyArgsDict']]
        """
        For SRX-only
        """
        tenants: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
elif False:
    GatewaytemplateServicePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateServicePolicyArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 antivirus: Optional[pulumi.Input['GatewaytemplateServicePolicyAntivirusArgs']] = None,
                 appqoe: Optional[pulumi.Input['GatewaytemplateServicePolicyAppqoeArgs']] = None,
                 ewfs: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateServicePolicyEwfArgs']]]] = None,
                 idp: Optional[pulumi.Input['GatewaytemplateServicePolicyIdpArgs']] = None,
                 local_routing: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 path_preference: Optional[pulumi.Input[builtins.str]] = None,
                 servicepolicy_id: Optional[pulumi.Input[builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ssl_proxy: Optional[pulumi.Input['GatewaytemplateServicePolicySslProxyArgs']] = None,
                 tenants: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] action: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        :param pulumi.Input['GatewaytemplateServicePolicyAntivirusArgs'] antivirus: For SRX-only
        :param pulumi.Input['GatewaytemplateServicePolicyAppqoeArgs'] appqoe: For SRX Only
        :param pulumi.Input[builtins.bool] local_routing: access within the same VRF
        :param pulumi.Input[builtins.str] name: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        :param pulumi.Input[builtins.str] path_preference: By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        :param pulumi.Input[builtins.str] servicepolicy_id: Used to link servicepolicy defined at org level and overwrite some attributes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] services: Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        :param pulumi.Input['GatewaytemplateServicePolicySslProxyArgs'] ssl_proxy: For SRX-only
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tenants: Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if appqoe is not None:
            pulumi.set(__self__, "appqoe", appqoe)
        if ewfs is not None:
            pulumi.set(__self__, "ewfs", ewfs)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if local_routing is not None:
            pulumi.set(__self__, "local_routing", local_routing)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_preference is not None:
            pulumi.set(__self__, "path_preference", path_preference)
        if servicepolicy_id is not None:
            pulumi.set(__self__, "servicepolicy_id", servicepolicy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssl_proxy is not None:
            pulumi.set(__self__, "ssl_proxy", ssl_proxy)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def antivirus(self) -> Optional[pulumi.Input['GatewaytemplateServicePolicyAntivirusArgs']]:
        """
        For SRX-only
        """
        return pulumi.get(self, "antivirus")

    @antivirus.setter
    def antivirus(self, value: Optional[pulumi.Input['GatewaytemplateServicePolicyAntivirusArgs']]):
        pulumi.set(self, "antivirus", value)

    @property
    @pulumi.getter
    def appqoe(self) -> Optional[pulumi.Input['GatewaytemplateServicePolicyAppqoeArgs']]:
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @appqoe.setter
    def appqoe(self, value: Optional[pulumi.Input['GatewaytemplateServicePolicyAppqoeArgs']]):
        pulumi.set(self, "appqoe", value)

    @property
    @pulumi.getter
    def ewfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateServicePolicyEwfArgs']]]]:
        return pulumi.get(self, "ewfs")

    @ewfs.setter
    def ewfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateServicePolicyEwfArgs']]]]):
        pulumi.set(self, "ewfs", value)

    @property
    @pulumi.getter
    def idp(self) -> Optional[pulumi.Input['GatewaytemplateServicePolicyIdpArgs']]:
        return pulumi.get(self, "idp")

    @idp.setter
    def idp(self, value: Optional[pulumi.Input['GatewaytemplateServicePolicyIdpArgs']]):
        pulumi.set(self, "idp", value)

    @property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @local_routing.setter
    def local_routing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "local_routing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @path_preference.setter
    def path_preference(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path_preference", value)

    @property
    @pulumi.getter(name="servicepolicyId")
    def servicepolicy_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        return pulumi.get(self, "servicepolicy_id")

    @servicepolicy_id.setter
    def servicepolicy_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "servicepolicy_id", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="sslProxy")
    def ssl_proxy(self) -> Optional[pulumi.Input['GatewaytemplateServicePolicySslProxyArgs']]:
        """
        For SRX-only
        """
        return pulumi.get(self, "ssl_proxy")

    @ssl_proxy.setter
    def ssl_proxy(self, value: Optional[pulumi.Input['GatewaytemplateServicePolicySslProxyArgs']]):
        pulumi.set(self, "ssl_proxy", value)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tenants", value)


if not MYPY:
    class GatewaytemplateServicePolicyAntivirusArgsDict(TypedDict):
        avprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        Default / noftp / httponly / or keys from av_profiles
        """
elif False:
    GatewaytemplateServicePolicyAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateServicePolicyAntivirusArgs:
    def __init__(__self__, *,
                 avprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param pulumi.Input[builtins.str] profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @avprofile_id.setter
    def avprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "avprofile_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class GatewaytemplateServicePolicyAppqoeArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    GatewaytemplateServicePolicyAppqoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateServicePolicyAppqoeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewaytemplateServicePolicyEwfArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[builtins.bool]]
        block_message: NotRequired[pulumi.Input[builtins.str]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `critical`, `standard`, `strict`
        """
elif False:
    GatewaytemplateServicePolicyEwfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateServicePolicyEwfArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[builtins.bool]] = None,
                 block_message: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "block_message")

    @block_message.setter
    def block_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "block_message", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class GatewaytemplateServicePolicyIdpArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[builtins.bool]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        idpprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
elif False:
    GatewaytemplateServicePolicyIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateServicePolicyIdpArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 idpprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param pulumi.Input[builtins.str] profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @idpprofile_id.setter
    def idpprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idpprofile_id", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class GatewaytemplateServicePolicySslProxyArgsDict(TypedDict):
        ciphers_category: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `medium`, `strong`, `weak`
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    GatewaytemplateServicePolicySslProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateServicePolicySslProxyArgs:
    def __init__(__self__, *,
                 ciphers_category: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @ciphers_category.setter
    def ciphers_category(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ciphers_category", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsArgsDict(TypedDict):
        auto_provision: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionArgsDict']]
        ike_lifetime: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        ike_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        ike_proposals: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIkeProposalArgsDict']]]]
        """
        If `provider`==`custom-ipsec`
        """
        ipsec_lifetime: NotRequired[pulumi.Input[builtins.int]]
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        ipsec_proposals: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIpsecProposalArgsDict']]]]
        """
        Only if  `provider`==`custom-ipsec`
        """
        local_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `provider`==`custom-ipsec`, networks reachable via this tunnel
        """
        primary: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsPrimaryArgsDict']]
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        probe: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsProbeArgsDict']]
        """
        Only if `provider`==`custom-ipsec`
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        provider: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        psk: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        secondary: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsSecondaryArgsDict']]
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
elif False:
    GatewaytemplateTunnelConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsArgs:
    def __init__(__self__, *,
                 auto_provision: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionArgs']] = None,
                 ike_lifetime: Optional[pulumi.Input[builtins.int]] = None,
                 ike_mode: Optional[pulumi.Input[builtins.str]] = None,
                 ike_proposals: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIkeProposalArgs']]]] = None,
                 ipsec_lifetime: Optional[pulumi.Input[builtins.int]] = None,
                 ipsec_proposals: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIpsecProposalArgs']]]] = None,
                 local_id: Optional[pulumi.Input[builtins.str]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 primary: Optional[pulumi.Input['GatewaytemplateTunnelConfigsPrimaryArgs']] = None,
                 probe: Optional[pulumi.Input['GatewaytemplateTunnelConfigsProbeArgs']] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 provider: Optional[pulumi.Input[builtins.str]] = None,
                 psk: Optional[pulumi.Input[builtins.str]] = None,
                 secondary: Optional[pulumi.Input['GatewaytemplateTunnelConfigsSecondaryArgs']] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] ike_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param pulumi.Input[builtins.str] ike_mode: Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        :param pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIkeProposalArgs']]] ike_proposals: If `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.int] ipsec_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIpsecProposalArgs']]] ipsec_proposals: Only if  `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] local_id: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] mode: Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: If `provider`==`custom-ipsec`, networks reachable via this tunnel
        :param pulumi.Input['GatewaytemplateTunnelConfigsPrimaryArgs'] primary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input['GatewaytemplateTunnelConfigsProbeArgs'] probe: Only if `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] protocol: Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        :param pulumi.Input[builtins.str] provider: Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        :param pulumi.Input[builtins.str] psk: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input['GatewaytemplateTunnelConfigsSecondaryArgs'] secondary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param pulumi.Input[builtins.str] version: Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        if auto_provision is not None:
            pulumi.set(__self__, "auto_provision", auto_provision)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_mode is not None:
            pulumi.set(__self__, "ike_mode", ike_mode)
        if ike_proposals is not None:
            pulumi.set(__self__, "ike_proposals", ike_proposals)
        if ipsec_lifetime is not None:
            pulumi.set(__self__, "ipsec_lifetime", ipsec_lifetime)
        if ipsec_proposals is not None:
            pulumi.set(__self__, "ipsec_proposals", ipsec_proposals)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if probe is not None:
            pulumi.set(__self__, "probe", probe)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionArgs']]:
        return pulumi.get(self, "auto_provision")

    @auto_provision.setter
    def auto_provision(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionArgs']]):
        pulumi.set(self, "auto_provision", value)

    @property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ike_lifetime", value)

    @property
    @pulumi.getter(name="ikeMode")
    def ike_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        return pulumi.get(self, "ike_mode")

    @ike_mode.setter
    def ike_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ike_mode", value)

    @property
    @pulumi.getter(name="ikeProposals")
    def ike_proposals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIkeProposalArgs']]]]:
        """
        If `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ike_proposals")

    @ike_proposals.setter
    def ike_proposals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIkeProposalArgs']]]]):
        pulumi.set(self, "ike_proposals", value)

    @property
    @pulumi.getter(name="ipsecLifetime")
    def ipsec_lifetime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ipsec_lifetime")

    @ipsec_lifetime.setter
    def ipsec_lifetime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ipsec_lifetime", value)

    @property
    @pulumi.getter(name="ipsecProposals")
    def ipsec_proposals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIpsecProposalArgs']]]]:
        """
        Only if  `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ipsec_proposals")

    @ipsec_proposals.setter
    def ipsec_proposals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelConfigsIpsecProposalArgs']]]]):
        pulumi.set(self, "ipsec_proposals", value)

    @property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_id", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `provider`==`custom-ipsec`, networks reachable via this tunnel
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsPrimaryArgs']]:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsPrimaryArgs']]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def probe(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsProbeArgs']]:
        """
        Only if `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "probe")

    @probe.setter
    def probe(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsProbeArgs']]):
        pulumi.set(self, "probe", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psk", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsSecondaryArgs']]:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsSecondaryArgs']]):
        pulumi.set(self, "secondary", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsAutoProvisionArgsDict(TypedDict):
        provider: pulumi.Input[builtins.str]
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        enable: NotRequired[pulumi.Input[builtins.bool]]
        latlng: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionLatlngArgsDict']]
        """
        API override for POP selection
        """
        primary: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgsDict']]
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        API override for POP selection
        """
        secondary: NotRequired[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgsDict']]
elif False:
    GatewaytemplateTunnelConfigsAutoProvisionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsAutoProvisionArgs:
    def __init__(__self__, *,
                 provider: pulumi.Input[builtins.str],
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 latlng: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs']] = None,
                 primary: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgs']] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 secondary: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgs']] = None):
        """
        :param pulumi.Input[builtins.str] provider: enum: `jse-ipsec`, `zscaler-ipsec`
        :param pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs'] latlng: API override for POP selection
        :param pulumi.Input[builtins.str] region: API override for POP selection
        """
        pulumi.set(__self__, "provider", provider)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if latlng is not None:
            pulumi.set(__self__, "latlng", latlng)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[builtins.str]:
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def latlng(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs']]:
        """
        API override for POP selection
        """
        return pulumi.get(self, "latlng")

    @latlng.setter
    def latlng(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs']]):
        pulumi.set(self, "latlng", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgs']]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgs']]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        API override for POP selection
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgs']]:
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input['GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgs']]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsAutoProvisionLatlngArgsDict(TypedDict):
        lat: pulumi.Input[builtins.float]
        lng: pulumi.Input[builtins.float]
elif False:
    GatewaytemplateTunnelConfigsAutoProvisionLatlngArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs:
    def __init__(__self__, *,
                 lat: pulumi.Input[builtins.float],
                 lng: pulumi.Input[builtins.float]):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @property
    @pulumi.getter
    def lat(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "lat", value)

    @property
    @pulumi.getter
    def lng(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgsDict(TypedDict):
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional, only needed if `vars_only`==`false`
        """
elif False:
    GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsAutoProvisionPrimaryArgs:
    def __init__(__self__, *,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgsDict(TypedDict):
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional, only needed if `vars_only`==`false`
        """
elif False:
    GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsAutoProvisionSecondaryArgs:
    def __init__(__self__, *,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsIkeProposalArgsDict(TypedDict):
        auth_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `md5`, `sha1`, `sha2`
        """
        dh_group: NotRequired[pulumi.Input[builtins.str]]
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        enc_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
elif False:
    GatewaytemplateTunnelConfigsIkeProposalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsIkeProposalArgs:
    def __init__(__self__, *,
                 auth_algo: Optional[pulumi.Input[builtins.str]] = None,
                 dh_group: Optional[pulumi.Input[builtins.str]] = None,
                 enc_algo: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_algo: enum: `md5`, `sha1`, `sha2`
        :param pulumi.Input[builtins.str] dh_group: enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param pulumi.Input[builtins.str] enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @auth_algo.setter
    def auth_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_algo", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")

    @enc_algo.setter
    def enc_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_algo", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsIpsecProposalArgsDict(TypedDict):
        auth_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `md5`, `sha1`, `sha2`
        """
        dh_group: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        enc_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
elif False:
    GatewaytemplateTunnelConfigsIpsecProposalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsIpsecProposalArgs:
    def __init__(__self__, *,
                 auth_algo: Optional[pulumi.Input[builtins.str]] = None,
                 dh_group: Optional[pulumi.Input[builtins.str]] = None,
                 enc_algo: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_algo: enum: `md5`, `sha1`, `sha2`
        :param pulumi.Input[builtins.str] dh_group: Only if `provider`==`custom-ipsec`. enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param pulumi.Input[builtins.str] enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @auth_algo.setter
    def auth_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_algo", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")

    @enc_algo.setter
    def enc_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_algo", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsPrimaryArgsDict(TypedDict):
        hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        internal_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        remote_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
elif False:
    GatewaytemplateTunnelConfigsPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsPrimaryArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 internal_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 remote_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "wan_names", value)

    @property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @internal_ips.setter
    def internal_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "internal_ips", value)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")

    @remote_ids.setter
    def remote_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "remote_ids", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsProbeArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[builtins.int]]
        """
        How often to trigger the probe
        """
        threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of consecutive misses before declaring the tunnel down
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Time within which to complete the connectivity check
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `http`, `icmp`
        """
elif False:
    GatewaytemplateTunnelConfigsProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsProbeArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[builtins.int]] = None,
                 threshold: Optional[pulumi.Input[builtins.int]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] interval: How often to trigger the probe
        :param pulumi.Input[builtins.int] threshold: Number of consecutive misses before declaring the tunnel down
        :param pulumi.Input[builtins.int] timeout: Time within which to complete the connectivity check
        :param pulumi.Input[builtins.str] type: enum: `http`, `icmp`
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How often to trigger the probe
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of consecutive misses before declaring the tunnel down
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time within which to complete the connectivity check
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewaytemplateTunnelConfigsSecondaryArgsDict(TypedDict):
        hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        internal_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        remote_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
elif False:
    GatewaytemplateTunnelConfigsSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelConfigsSecondaryArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 wan_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 internal_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 remote_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "wan_names", value)

    @property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @internal_ips.setter
    def internal_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "internal_ips", value)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")

    @remote_ids.setter
    def remote_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "remote_ids", value)


if not MYPY:
    class GatewaytemplateTunnelProviderOptionsArgsDict(TypedDict):
        jse: NotRequired[pulumi.Input['GatewaytemplateTunnelProviderOptionsJseArgsDict']]
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        zscaler: NotRequired[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerArgsDict']]
        """
        For zscaler-ipsec and zscaler-gre
        """
elif False:
    GatewaytemplateTunnelProviderOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelProviderOptionsArgs:
    def __init__(__self__, *,
                 jse: Optional[pulumi.Input['GatewaytemplateTunnelProviderOptionsJseArgs']] = None,
                 zscaler: Optional[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerArgs']] = None):
        """
        :param pulumi.Input['GatewaytemplateTunnelProviderOptionsJseArgs'] jse: For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        :param pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerArgs'] zscaler: For zscaler-ipsec and zscaler-gre
        """
        if jse is not None:
            pulumi.set(__self__, "jse", jse)
        if zscaler is not None:
            pulumi.set(__self__, "zscaler", zscaler)

    @property
    @pulumi.getter
    def jse(self) -> Optional[pulumi.Input['GatewaytemplateTunnelProviderOptionsJseArgs']]:
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        return pulumi.get(self, "jse")

    @jse.setter
    def jse(self, value: Optional[pulumi.Input['GatewaytemplateTunnelProviderOptionsJseArgs']]):
        pulumi.set(self, "jse", value)

    @property
    @pulumi.getter
    def zscaler(self) -> Optional[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerArgs']]:
        """
        For zscaler-ipsec and zscaler-gre
        """
        return pulumi.get(self, "zscaler")

    @zscaler.setter
    def zscaler(self, value: Optional[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerArgs']]):
        pulumi.set(self, "zscaler", value)


if not MYPY:
    class GatewaytemplateTunnelProviderOptionsJseArgsDict(TypedDict):
        num_users: NotRequired[pulumi.Input[builtins.int]]
        org_name: NotRequired[pulumi.Input[builtins.str]]
        """
        JSE Organization name
        """
elif False:
    GatewaytemplateTunnelProviderOptionsJseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelProviderOptionsJseArgs:
    def __init__(__self__, *,
                 num_users: Optional[pulumi.Input[builtins.int]] = None,
                 org_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] org_name: JSE Organization name
        """
        if num_users is not None:
            pulumi.set(__self__, "num_users", num_users)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)

    @property
    @pulumi.getter(name="numUsers")
    def num_users(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "num_users")

    @num_users.setter
    def num_users(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "num_users", value)

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JSE Organization name
        """
        return pulumi.get(self, "org_name")

    @org_name.setter
    def org_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_name", value)


if not MYPY:
    class GatewaytemplateTunnelProviderOptionsZscalerArgsDict(TypedDict):
        aup_block_internet_until_accepted: NotRequired[pulumi.Input[builtins.bool]]
        aup_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        aup_force_ssl_inspection: NotRequired[pulumi.Input[builtins.bool]]
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        aup_timeout_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        auth_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable this option to enforce user authentication
        """
        caution_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        dn_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        idle_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        ofw_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `true`, enable the firewall control option
        """
        sub_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgsDict']]]]
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        surrogate_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        surrogate_ip_enforced_for_known_browsers: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        surrogate_refresh_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        up_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        xff_forward_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Location uses proxy chaining to forward traffic
        """
elif False:
    GatewaytemplateTunnelProviderOptionsZscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelProviderOptionsZscalerArgs:
    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_force_ssl_inspection: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_timeout_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 auth_required: Optional[pulumi.Input[builtins.bool]] = None,
                 caution_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dn_bandwidth: Optional[pulumi.Input[builtins.float]] = None,
                 idle_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 ofw_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 sub_locations: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs']]]] = None,
                 surrogate_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_refresh_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 up_bandwidth: Optional[pulumi.Input[builtins.float]] = None,
                 xff_forward_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param pulumi.Input[builtins.bool] aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param pulumi.Input[builtins.int] aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param pulumi.Input[builtins.bool] auth_required: Enable this option to enforce user authentication
        :param pulumi.Input[builtins.bool] caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param pulumi.Input[builtins.float] dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param pulumi.Input[builtins.int] idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param pulumi.Input[builtins.bool] ofw_enabled: If `true`, enable the firewall control option
        :param pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs']]] sub_locations: `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        :param pulumi.Input[builtins.bool] surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param pulumi.Input[builtins.bool] surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param pulumi.Input[builtins.int] surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param pulumi.Input[builtins.float] up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param pulumi.Input[builtins.bool] xff_forward_enabled: Location uses proxy chaining to forward traffic
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if sub_locations is not None:
            pulumi.set(__self__, "sub_locations", sub_locations)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)
        if xff_forward_enabled is not None:
            pulumi.set(__self__, "xff_forward_enabled", xff_forward_enabled)

    @property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @aup_block_internet_until_accepted.setter
    def aup_block_internet_until_accepted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_block_internet_until_accepted", value)

    @property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @aup_enabled.setter
    def aup_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_enabled", value)

    @property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @aup_force_ssl_inspection.setter
    def aup_force_ssl_inspection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_force_ssl_inspection", value)

    @property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @aup_timeout_in_days.setter
    def aup_timeout_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "aup_timeout_in_days", value)

    @property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable this option to enforce user authentication
        """
        return pulumi.get(self, "auth_required")

    @auth_required.setter
    def auth_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auth_required", value)

    @property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @caution_enabled.setter
    def caution_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "caution_enabled", value)

    @property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @dn_bandwidth.setter
    def dn_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "dn_bandwidth", value)

    @property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @idle_time_in_minutes.setter
    def idle_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idle_time_in_minutes", value)

    @property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @ofw_enabled.setter
    def ofw_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ofw_enabled", value)

    @property
    @pulumi.getter(name="subLocations")
    def sub_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs']]]]:
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        return pulumi.get(self, "sub_locations")

    @sub_locations.setter
    def sub_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs']]]]):
        pulumi.set(self, "sub_locations", value)

    @property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @surrogate_ip.setter
    def surrogate_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip", value)

    @property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @surrogate_ip_enforced_for_known_browsers.setter
    def surrogate_ip_enforced_for_known_browsers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip_enforced_for_known_browsers", value)

    @property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @surrogate_refresh_time_in_minutes.setter
    def surrogate_refresh_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "surrogate_refresh_time_in_minutes", value)

    @property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @up_bandwidth.setter
    def up_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "up_bandwidth", value)

    @property
    @pulumi.getter(name="xffForwardEnabled")
    def xff_forward_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Location uses proxy chaining to forward traffic
        """
        return pulumi.get(self, "xff_forward_enabled")

    @xff_forward_enabled.setter
    def xff_forward_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "xff_forward_enabled", value)


if not MYPY:
    class GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgsDict(TypedDict):
        aup_block_internet_until_accepted: NotRequired[pulumi.Input[builtins.bool]]
        aup_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        aup_force_ssl_inspection: NotRequired[pulumi.Input[builtins.bool]]
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        aup_timeout_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        auth_required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable this option to authenticate users
        """
        caution_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        dn_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        idle_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Network name
        """
        ofw_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `true`, enable the firewall control option
        """
        surrogate_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        surrogate_ip_enforced_for_known_browsers: NotRequired[pulumi.Input[builtins.bool]]
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        surrogate_refresh_time_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        up_bandwidth: NotRequired[pulumi.Input[builtins.float]]
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
elif False:
    GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs:
    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_force_ssl_inspection: Optional[pulumi.Input[builtins.bool]] = None,
                 aup_timeout_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 auth_required: Optional[pulumi.Input[builtins.bool]] = None,
                 caution_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 dn_bandwidth: Optional[pulumi.Input[builtins.float]] = None,
                 idle_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 ofw_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[pulumi.Input[builtins.bool]] = None,
                 surrogate_refresh_time_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 up_bandwidth: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.bool] aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param pulumi.Input[builtins.bool] aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param pulumi.Input[builtins.int] aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param pulumi.Input[builtins.bool] auth_required: Enable this option to authenticate users
        :param pulumi.Input[builtins.bool] caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param pulumi.Input[builtins.float] dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param pulumi.Input[builtins.int] idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param pulumi.Input[builtins.str] name: Network name
        :param pulumi.Input[builtins.bool] ofw_enabled: If `true`, enable the firewall control option
        :param pulumi.Input[builtins.bool] surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param pulumi.Input[builtins.bool] surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param pulumi.Input[builtins.int] surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param pulumi.Input[builtins.float] up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)

    @property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @aup_block_internet_until_accepted.setter
    def aup_block_internet_until_accepted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_block_internet_until_accepted", value)

    @property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @aup_enabled.setter
    def aup_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_enabled", value)

    @property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @aup_force_ssl_inspection.setter
    def aup_force_ssl_inspection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aup_force_ssl_inspection", value)

    @property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @aup_timeout_in_days.setter
    def aup_timeout_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "aup_timeout_in_days", value)

    @property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable this option to authenticate users
        """
        return pulumi.get(self, "auth_required")

    @auth_required.setter
    def auth_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auth_required", value)

    @property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @caution_enabled.setter
    def caution_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "caution_enabled", value)

    @property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @dn_bandwidth.setter
    def dn_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "dn_bandwidth", value)

    @property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @idle_time_in_minutes.setter
    def idle_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idle_time_in_minutes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @ofw_enabled.setter
    def ofw_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ofw_enabled", value)

    @property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @surrogate_ip.setter
    def surrogate_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip", value)

    @property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @surrogate_ip_enforced_for_known_browsers.setter
    def surrogate_ip_enforced_for_known_browsers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "surrogate_ip_enforced_for_known_browsers", value)

    @property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @surrogate_refresh_time_in_minutes.setter
    def surrogate_refresh_time_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "surrogate_refresh_time_in_minutes", value)

    @property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @up_bandwidth.setter
    def up_bandwidth(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "up_bandwidth", value)


if not MYPY:
    class GatewaytemplateVrfConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable VRF (when supported on the device)
        """
elif False:
    GatewaytemplateVrfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateVrfConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewaytemplateVrfInstancesArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    GatewaytemplateVrfInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewaytemplateVrfInstancesArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class IdpprofileOverwriteArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        matching: NotRequired[pulumi.Input['IdpprofileOverwriteMatchingArgsDict']]
elif False:
    IdpprofileOverwriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdpprofileOverwriteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 matching: Optional[pulumi.Input['IdpprofileOverwriteMatchingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['IdpprofileOverwriteMatchingArgs']]:
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['IdpprofileOverwriteMatchingArgs']]):
        pulumi.set(self, "matching", value)


if not MYPY:
    class IdpprofileOverwriteMatchingArgsDict(TypedDict):
        attack_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        dst_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    IdpprofileOverwriteMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdpprofileOverwriteMatchingArgs:
    def __init__(__self__, *,
                 attack_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dst_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "attack_names")

    @attack_names.setter
    def attack_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attack_names", value)

    @property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "dst_subnets")

    @dst_subnets.setter
    def dst_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dst_subnets", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "severities", value)


if not MYPY:
    class InventoryInventoryArgsDict(TypedDict):
        claim_code: NotRequired[pulumi.Input[builtins.str]]
        """
        device claim code
        """
        deviceprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        deviceprofile id if assigned, null if not assigned
        """
        hostname: NotRequired[pulumi.Input[builtins.str]]
        """
        hostname reported by the device
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        device id
        """
        mac: NotRequired[pulumi.Input[builtins.str]]
        """
        device MAC address
        """
        model: NotRequired[pulumi.Input[builtins.str]]
        """
        device model
        """
        org_id: NotRequired[pulumi.Input[builtins.str]]
        serial: NotRequired[pulumi.Input[builtins.str]]
        """
        device serial
        """
        site_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Site ID. Used to assign device to a Site
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ap`, `gateway`, `switch`
        """
        unclaim_when_destroyed: NotRequired[pulumi.Input[builtins.bool]]
        """
        Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
        """
        vc_mac: NotRequired[pulumi.Input[builtins.str]]
        """
        if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
elif False:
    InventoryInventoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InventoryInventoryArgs:
    def __init__(__self__, *,
                 claim_code: Optional[pulumi.Input[builtins.str]] = None,
                 deviceprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 hostname: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 mac: Optional[pulumi.Input[builtins.str]] = None,
                 model: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 serial: Optional[pulumi.Input[builtins.str]] = None,
                 site_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 unclaim_when_destroyed: Optional[pulumi.Input[builtins.bool]] = None,
                 vc_mac: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] claim_code: device claim code
        :param pulumi.Input[builtins.str] deviceprofile_id: deviceprofile id if assigned, null if not assigned
        :param pulumi.Input[builtins.str] hostname: hostname reported by the device
        :param pulumi.Input[builtins.str] id: device id
        :param pulumi.Input[builtins.str] mac: device MAC address
        :param pulumi.Input[builtins.str] model: device model
        :param pulumi.Input[builtins.str] serial: device serial
        :param pulumi.Input[builtins.str] site_id: Site ID. Used to assign device to a Site
        :param pulumi.Input[builtins.str] type: enum: `ap`, `gateway`, `switch`
        :param pulumi.Input[builtins.bool] unclaim_when_destroyed: Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
        :param pulumi.Input[builtins.str] vc_mac: if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
        if claim_code is not None:
            pulumi.set(__self__, "claim_code", claim_code)
        if deviceprofile_id is not None:
            pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unclaim_when_destroyed is not None:
            pulumi.set(__self__, "unclaim_when_destroyed", unclaim_when_destroyed)
        if vc_mac is not None:
            pulumi.set(__self__, "vc_mac", vc_mac)

    @property
    @pulumi.getter(name="claimCode")
    def claim_code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        device claim code
        """
        return pulumi.get(self, "claim_code")

    @claim_code.setter
    def claim_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "claim_code", value)

    @property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        deviceprofile id if assigned, null if not assigned
        """
        return pulumi.get(self, "deviceprofile_id")

    @deviceprofile_id.setter
    def deviceprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deviceprofile_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        hostname reported by the device
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        device id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        device MAC address
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        device model
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        device serial
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "serial", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Site ID. Used to assign device to a Site
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ap`, `gateway`, `switch`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="unclaimWhenDestroyed")
    def unclaim_when_destroyed(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
        """
        return pulumi.get(self, "unclaim_when_destroyed")

    @unclaim_when_destroyed.setter
    def unclaim_when_destroyed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unclaim_when_destroyed", value)

    @property
    @pulumi.getter(name="vcMac")
    def vc_mac(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
        return pulumi.get(self, "vc_mac")

    @vc_mac.setter
    def vc_mac(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vc_mac", value)


if not MYPY:
    class NacruleMatchingArgsDict(TypedDict):
        auth_type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `peap-tls`, `psk`
        """
        families: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        """
        mfgs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        """
        models: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        """
        nactags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        os_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        """
        port_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        site_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of site ids to match
        """
        sitegroup_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of sitegroup ids to match
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of vendors to match
        """
elif False:
    NacruleMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NacruleMatchingArgs:
    def __init__(__self__, *,
                 auth_type: Optional[pulumi.Input[builtins.str]] = None,
                 families: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mfgs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 models: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 nactags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 os_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 port_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 site_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 sitegroup_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `peap-tls`, `psk`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] families: List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mfgs: List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] models: List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] os_types: List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] site_ids: List of site ids to match
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sitegroup_ids: List of sitegroup ids to match
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vendors: List of vendors to match
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if families is not None:
            pulumi.set(__self__, "families", families)
        if mfgs is not None:
            pulumi.set(__self__, "mfgs", mfgs)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if nactags is not None:
            pulumi.set(__self__, "nactags", nactags)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if port_types is not None:
            pulumi.set(__self__, "port_types", port_types)
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `peap-tls`, `psk`
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        """
        return pulumi.get(self, "families")

    @families.setter
    def families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "families", value)

    @property
    @pulumi.getter
    def mfgs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        """
        return pulumi.get(self, "mfgs")

    @mfgs.setter
    def mfgs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mfgs", value)

    @property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "models", value)

    @property
    @pulumi.getter
    def nactags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "nactags")

    @nactags.setter
    def nactags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "nactags", value)

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        """
        return pulumi.get(self, "os_types")

    @os_types.setter
    def os_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "os_types", value)

    @property
    @pulumi.getter(name="portTypes")
    def port_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "port_types")

    @port_types.setter
    def port_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "port_types", value)

    @property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of site ids to match
        """
        return pulumi.get(self, "site_ids")

    @site_ids.setter
    def site_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "site_ids", value)

    @property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of sitegroup ids to match
        """
        return pulumi.get(self, "sitegroup_ids")

    @sitegroup_ids.setter
    def sitegroup_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sitegroup_ids", value)

    @property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of vendors to match
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class NacruleNotMatchingArgsDict(TypedDict):
        auth_type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `peap-tls`, `psk`
        """
        families: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        """
        mfgs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        """
        models: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        """
        nactags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        os_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        """
        port_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        site_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of site ids to match
        """
        sitegroup_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of sitegroup ids to match
        """
        vendors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of vendors to match
        """
elif False:
    NacruleNotMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NacruleNotMatchingArgs:
    def __init__(__self__, *,
                 auth_type: Optional[pulumi.Input[builtins.str]] = None,
                 families: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mfgs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 models: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 nactags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 os_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 port_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 site_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 sitegroup_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vendors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `peap-tls`, `psk`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] families: List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mfgs: List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] models: List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] os_types: List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] site_ids: List of site ids to match
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sitegroup_ids: List of sitegroup ids to match
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vendors: List of vendors to match
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if families is not None:
            pulumi.set(__self__, "families", families)
        if mfgs is not None:
            pulumi.set(__self__, "mfgs", mfgs)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if nactags is not None:
            pulumi.set(__self__, "nactags", nactags)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if port_types is not None:
            pulumi.set(__self__, "port_types", port_types)
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `peap-tls`, `psk`
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        """
        return pulumi.get(self, "families")

    @families.setter
    def families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "families", value)

    @property
    @pulumi.getter
    def mfgs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        """
        return pulumi.get(self, "mfgs")

    @mfgs.setter
    def mfgs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mfgs", value)

    @property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "models", value)

    @property
    @pulumi.getter
    def nactags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "nactags")

    @nactags.setter
    def nactags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "nactags", value)

    @property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        """
        return pulumi.get(self, "os_types")

    @os_types.setter
    def os_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "os_types", value)

    @property
    @pulumi.getter(name="portTypes")
    def port_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "port_types")

    @port_types.setter
    def port_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "port_types", value)

    @property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of site ids to match
        """
        return pulumi.get(self, "site_ids")

    @site_ids.setter
    def site_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "site_ids", value)

    @property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of sitegroup ids to match
        """
        return pulumi.get(self, "sitegroup_ids")

    @sitegroup_ids.setter
    def sitegroup_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sitegroup_ids", value)

    @property
    @pulumi.getter
    def vendors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of vendors to match
        """
        return pulumi.get(self, "vendors")

    @vendors.setter
    def vendors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vendors", value)


if not MYPY:
    class NetworkInternalAccessArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    NetworkInternalAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInternalAccessArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NetworkInternetAccessArgsDict(TypedDict):
        create_simple_service_policy: NotRequired[pulumi.Input[builtins.bool]]
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessDestinationNatArgsDict']]]]
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        restricted: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessStaticNatArgsDict']]]]
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
elif False:
    NetworkInternetAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInternetAccessArgs:
    def __init__(__self__, *,
                 create_simple_service_policy: Optional[pulumi.Input[builtins.bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessDestinationNatArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 restricted: Optional[pulumi.Input[builtins.bool]] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessStaticNatArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessDestinationNatArgs']]] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param pulumi.Input[builtins.bool] restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessStaticNatArgs']]] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "create_simple_service_policy")

    @create_simple_service_policy.setter
    def create_simple_service_policy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create_simple_service_policy", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessDestinationNatArgs']]]]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def restricted(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @restricted.setter
    def restricted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restricted", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessStaticNatArgs']]]]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkInternetAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)


if not MYPY:
    class NetworkInternetAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
elif False:
    NetworkInternetAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInternetAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class NetworkInternetAccessStaticNatArgsDict(TypedDict):
        internal_ip: pulumi.Input[builtins.str]
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        name: pulumi.Input[builtins.str]
        wan_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
elif False:
    NetworkInternetAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInternetAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 wan_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> pulumi.Input[builtins.str]:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class NetworkMulticastArgsDict(TypedDict):
        disable_igmp: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        groups: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworkMulticastGroupsArgsDict']]]]
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
elif False:
    NetworkMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkMulticastArgs:
    def __init__(__self__, *,
                 disable_igmp: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 groups: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkMulticastGroupsArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworkMulticastGroupsArgs']]] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @disable_igmp.setter
    def disable_igmp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_igmp", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkMulticastGroupsArgs']]]]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkMulticastGroupsArgs']]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class NetworkMulticastGroupsArgsDict(TypedDict):
        rp_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        RP (rendezvous point) IP Address
        """
elif False:
    NetworkMulticastGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkMulticastGroupsArgs:
    def __init__(__self__, *,
                 rp_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")

    @rp_ip.setter
    def rp_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rp_ip", value)


if not MYPY:
    class NetworkTenantsArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    NetworkTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkTenantsArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class NetworkVpnAccessArgsDict(TypedDict):
        advertised_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        allow_ping: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow ping from vpn into this routed network
        """
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessDestinationNatArgsDict']]]]
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        nat_pool: NotRequired[pulumi.Input[builtins.str]]
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        no_readvertise_to_lan_bgp: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward LAN-side BGP peers
        """
        no_readvertise_to_lan_ospf: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward LAN-side OSPF peers
        """
        no_readvertise_to_overlay: NotRequired[pulumi.Input[builtins.bool]]
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        other_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        routed: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether this network is routable
        """
        source_nat: NotRequired[pulumi.Input['NetworkVpnAccessSourceNatArgsDict']]
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessStaticNatArgsDict']]]]
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        summarized_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        summarized_subnet_to_lan_bgp: NotRequired[pulumi.Input[builtins.str]]
        """
        toward LAN-side BGP peers
        """
        summarized_subnet_to_lan_ospf: NotRequired[pulumi.Input[builtins.str]]
        """
        toward LAN-side OSPF peers
        """
elif False:
    NetworkVpnAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkVpnAccessArgs:
    def __init__(__self__, *,
                 advertised_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 allow_ping: Optional[pulumi.Input[builtins.bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessDestinationNatArgs']]]] = None,
                 nat_pool: Optional[pulumi.Input[builtins.str]] = None,
                 no_readvertise_to_lan_bgp: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_lan_ospf: Optional[pulumi.Input[builtins.bool]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[builtins.bool]] = None,
                 other_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 routed: Optional[pulumi.Input[builtins.bool]] = None,
                 source_nat: Optional[pulumi.Input['NetworkVpnAccessSourceNatArgs']] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessStaticNatArgs']]]] = None,
                 summarized_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 summarized_subnet_to_lan_bgp: Optional[pulumi.Input[builtins.str]] = None,
                 summarized_subnet_to_lan_ospf: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param pulumi.Input[builtins.bool] allow_ping: Whether to allow ping from vpn into this routed network
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessDestinationNatArgs']]] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param pulumi.Input[builtins.str] nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param pulumi.Input[builtins.bool] no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[builtins.bool] no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param pulumi.Input[builtins.bool] no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param pulumi.Input[builtins.bool] routed: Whether this network is routable
        :param pulumi.Input['NetworkVpnAccessSourceNatArgs'] source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessStaticNatArgs']]] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param pulumi.Input[builtins.str] summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param pulumi.Input[builtins.str] summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[builtins.str] summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @advertised_subnet.setter
    def advertised_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "advertised_subnet", value)

    @property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @allow_ping.setter
    def allow_ping(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_ping", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessDestinationNatArgs']]]]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nat_pool", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @no_readvertise_to_lan_bgp.setter
    def no_readvertise_to_lan_bgp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_lan_bgp", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @no_readvertise_to_lan_ospf.setter
    def no_readvertise_to_lan_ospf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_lan_ospf", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @other_vrfs.setter
    def other_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "other_vrfs", value)

    @property
    @pulumi.getter
    def routed(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @routed.setter
    def routed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "routed", value)

    @property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional[pulumi.Input['NetworkVpnAccessSourceNatArgs']]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @source_nat.setter
    def source_nat(self, value: Optional[pulumi.Input['NetworkVpnAccessSourceNatArgs']]):
        pulumi.set(self, "source_nat", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessStaticNatArgs']]]]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworkVpnAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)

    @property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @summarized_subnet.setter
    def summarized_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @summarized_subnet_to_lan_bgp.setter
    def summarized_subnet_to_lan_bgp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet_to_lan_bgp", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")

    @summarized_subnet_to_lan_ospf.setter
    def summarized_subnet_to_lan_ospf(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "summarized_subnet_to_lan_ospf", value)


if not MYPY:
    class NetworkVpnAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworkVpnAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkVpnAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class NetworkVpnAccessSourceNatArgsDict(TypedDict):
        external_ip: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworkVpnAccessSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkVpnAccessSourceNatArgs:
    def __init__(__self__, *,
                 external_ip: Optional[pulumi.Input[builtins.str]] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "external_ip")

    @external_ip.setter
    def external_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_ip", value)


if not MYPY:
    class NetworkVpnAccessStaticNatArgsDict(TypedDict):
        internal_ip: pulumi.Input[builtins.str]
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        name: pulumi.Input[builtins.str]
elif False:
    NetworkVpnAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkVpnAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> pulumi.Input[builtins.str]:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NetworktemplateAclPolicyArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgsDict']]]]
        """
        ACL Policy Actions:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        src_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        ACL Policy Source Tags:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
elif False:
    NetworktemplateAclPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateAclPolicyArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 src_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]] actions: ACL Policy Actions:
                 - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
                 - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] src_tags: ACL Policy Source Tags:
                 - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
                 - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_tags is not None:
            pulumi.set(__self__, "src_tags", src_tags)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]]]:
        """
        ACL Policy Actions:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="srcTags")
    def src_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        ACL Policy Source Tags:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "src_tags")

    @src_tags.setter
    def src_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "src_tags", value)


if not MYPY:
    class NetworktemplateAclPolicyActionArgsDict(TypedDict):
        dst_tag: pulumi.Input[builtins.str]
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `allow`, `deny`
        """
elif False:
    NetworktemplateAclPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateAclPolicyActionArgs:
    def __init__(__self__, *,
                 dst_tag: pulumi.Input[builtins.str],
                 action: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: enum: `allow`, `deny`
        """
        pulumi.set(__self__, "dst_tag", dst_tag)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="dstTag")
    def dst_tag(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "dst_tag")

    @dst_tag.setter
    def dst_tag(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "dst_tag", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class NetworktemplateAclTagsArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        enum: 
          * `any`: matching anything not identified
          * `dynamic_gbp`: from the gbp_tag received from RADIUS
          * `gbp_resource`: can only be used in `dst_tags`
          * `mac`
          * `network`
          * `radius_group`
          * `resource`: can only be used in `dst_tags`
          * `static_gbp`: applying gbp tag against matching conditions
          * `subnet`'
        """
        gbp_tag: NotRequired[pulumi.Input[builtins.int]]
        """
        Required if
          - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
          - `type`==`gbp_resource`
          - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        If:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)
        """
        radius_group: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgsDict']]]]
        """
        If `type`==`resource` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
elif False:
    NetworktemplateAclTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateAclTagsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 gbp_tag: Optional[pulumi.Input[builtins.int]] = None,
                 macs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 radius_group: Optional[pulumi.Input[builtins.str]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] type: enum: 
                 * `any`: matching anything not identified
                 * `dynamic_gbp`: from the gbp_tag received from RADIUS
                 * `gbp_resource`: can only be used in `dst_tags`
                 * `mac`
                 * `network`
                 * `radius_group`
                 * `resource`: can only be used in `dst_tags`
                 * `static_gbp`: applying gbp tag against matching conditions
                 * `subnet`'
        :param pulumi.Input[builtins.int] gbp_tag: Required if
                 - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
                 - `type`==`gbp_resource`
                 - `type`==`static_gbp` (applying gbp tag against matching conditions)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] macs: Required if 
               - `type`==`mac`
               - `type`==`static_gbp` if from matching mac
        :param pulumi.Input[builtins.str] network: If:
                 * `type`==`mac` (optional. default is `any`)
                 * `type`==`subnet` (optional. default is `any`)
                 * `type`==`network`
                 * `type`==`resource` (optional. default is `any`)
                 * `type`==`static_gbp` if from matching network (vlan)
        :param pulumi.Input[builtins.str] radius_group: Required if:
                 * `type`==`radius_group`
                 * `type`==`static_gbp`
               if from matching radius_group
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]] specs: If `type`==`resource` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnets: If 
               - `type`==`subnet` 
               - `type`==`resource` (optional. default is `any`)
               - `type`==`static_gbp` if from matching subnet
        """
        pulumi.set(__self__, "type", type)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if macs is not None:
            pulumi.set(__self__, "macs", macs)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        enum: 
          * `any`: matching anything not identified
          * `dynamic_gbp`: from the gbp_tag received from RADIUS
          * `gbp_resource`: can only be used in `dst_tags`
          * `mac`
          * `network`
          * `radius_group`
          * `resource`: can only be used in `dst_tags`
          * `static_gbp`: applying gbp tag against matching conditions
          * `subnet`'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required if
          - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
          - `type`==`gbp_resource`
          - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        return pulumi.get(self, "gbp_tag")

    @gbp_tag.setter
    def gbp_tag(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "gbp_tag", value)

    @property
    @pulumi.getter
    def macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        return pulumi.get(self, "macs")

    @macs.setter
    def macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "macs", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        return pulumi.get(self, "radius_group")

    @radius_group.setter
    def radius_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "radius_group", value)

    @property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]]]:
        """
        If `type`==`resource` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]]]):
        pulumi.set(self, "specs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class NetworktemplateAclTagsSpecArgsDict(TypedDict):
        port_range: NotRequired[pulumi.Input[builtins.str]]
        """
        Matched dst port, "0" means any
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
elif False:
    NetworktemplateAclTagsSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateAclTagsSpecArgs:
    def __init__(__self__, *,
                 port_range: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] port_range: Matched dst port, "0" means any
        :param pulumi.Input[builtins.str] protocol: `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class NetworktemplateDhcpSnoopingArgsDict(TypedDict):
        all_networks: NotRequired[pulumi.Input[builtins.bool]]
        enable_arp_spoof_check: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable for dynamic ARP inspection check
        """
        enable_ip_source_guard: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable for check for forging source IP address
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
elif False:
    NetworktemplateDhcpSnoopingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateDhcpSnoopingArgs:
    def __init__(__self__, *,
                 all_networks: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_arp_spoof_check: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_ip_source_guard: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_arp_spoof_check: Enable for dynamic ARP inspection check
        :param pulumi.Input[builtins.bool] enable_ip_source_guard: Enable for check for forging source IP address
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_ip_source_guard is not None:
            pulumi.set(__self__, "enable_ip_source_guard", enable_ip_source_guard)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "all_networks")

    @all_networks.setter
    def all_networks(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "all_networks", value)

    @property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable for dynamic ARP inspection check
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @enable_arp_spoof_check.setter
    def enable_arp_spoof_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_arp_spoof_check", value)

    @property
    @pulumi.getter(name="enableIpSourceGuard")
    def enable_ip_source_guard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable for check for forging source IP address
        """
        return pulumi.get(self, "enable_ip_source_guard")

    @enable_ip_source_guard.setter
    def enable_ip_source_guard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_ip_source_guard", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class NetworktemplateExtraRoutes6ArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
        """
        Next-hop IP Address
        """
        discard: NotRequired[pulumi.Input[builtins.bool]]
        """
        This takes precedence
        """
        metric: NotRequired[pulumi.Input[builtins.int]]
        next_qualified: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgsDict']]]]
        no_resolve: NotRequired[pulumi.Input[builtins.bool]]
        preference: NotRequired[pulumi.Input[builtins.int]]
elif False:
    NetworktemplateExtraRoutes6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateExtraRoutes6Args:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str],
                 discard: Optional[pulumi.Input[builtins.bool]] = None,
                 metric: Optional[pulumi.Input[builtins.int]] = None,
                 next_qualified: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgs']]]] = None,
                 no_resolve: Optional[pulumi.Input[builtins.bool]] = None,
                 preference: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] via: Next-hop IP Address
        :param pulumi.Input[builtins.bool] discard: This takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        """
        Next-hop IP Address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This takes precedence
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgs']]]]:
        return pulumi.get(self, "next_qualified")

    @next_qualified.setter
    def next_qualified(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgs']]]]):
        pulumi.set(self, "next_qualified", value)

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "no_resolve")

    @no_resolve.setter
    def no_resolve(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_resolve", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class NetworktemplateExtraRoutes6NextQualifiedArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[builtins.int]]
        preference: NotRequired[pulumi.Input[builtins.int]]
elif False:
    NetworktemplateExtraRoutes6NextQualifiedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateExtraRoutes6NextQualifiedArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[builtins.int]] = None,
                 preference: Optional[pulumi.Input[builtins.int]] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class NetworktemplateExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
        """
        Next-hop IP Address
        """
        discard: NotRequired[pulumi.Input[builtins.bool]]
        """
        This takes precedence
        """
        metric: NotRequired[pulumi.Input[builtins.int]]
        next_qualified: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgsDict']]]]
        no_resolve: NotRequired[pulumi.Input[builtins.bool]]
        preference: NotRequired[pulumi.Input[builtins.int]]
elif False:
    NetworktemplateExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str],
                 discard: Optional[pulumi.Input[builtins.bool]] = None,
                 metric: Optional[pulumi.Input[builtins.int]] = None,
                 next_qualified: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgs']]]] = None,
                 no_resolve: Optional[pulumi.Input[builtins.bool]] = None,
                 preference: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] via: Next-hop IP Address
        :param pulumi.Input[builtins.bool] discard: This takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        """
        Next-hop IP Address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This takes precedence
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgs']]]]:
        return pulumi.get(self, "next_qualified")

    @next_qualified.setter
    def next_qualified(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgs']]]]):
        pulumi.set(self, "next_qualified", value)

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "no_resolve")

    @no_resolve.setter
    def no_resolve(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_resolve", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class NetworktemplateExtraRoutesNextQualifiedArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[builtins.int]]
        preference: NotRequired[pulumi.Input[builtins.int]]
elif False:
    NetworktemplateExtraRoutesNextQualifiedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateExtraRoutesNextQualifiedArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[builtins.int]] = None,
                 preference: Optional[pulumi.Input[builtins.int]] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class NetworktemplateMistNacArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        network: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateMistNacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateMistNacArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)


if not MYPY:
    class NetworktemplateNetworksArgsDict(TypedDict):
        vlan_id: pulumi.Input[builtins.str]
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        """
        gateway6: NotRequired[pulumi.Input[builtins.str]]
        """
        Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        """
        isolation: NotRequired[pulumi.Input[builtins.bool]]
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        """
        isolation_vlan_id: NotRequired[pulumi.Input[builtins.str]]
        subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        subnet6: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional for pure switching, required when L3 / routing features are used
        """
elif False:
    NetworktemplateNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateNetworksArgs:
    def __init__(__self__, *,
                 vlan_id: pulumi.Input[builtins.str],
                 gateway: Optional[pulumi.Input[builtins.str]] = None,
                 gateway6: Optional[pulumi.Input[builtins.str]] = None,
                 isolation: Optional[pulumi.Input[builtins.bool]] = None,
                 isolation_vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 subnet: Optional[pulumi.Input[builtins.str]] = None,
                 subnet6: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] gateway: Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        :param pulumi.Input[builtins.str] gateway6: Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        :param pulumi.Input[builtins.bool] isolation: whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        :param pulumi.Input[builtins.str] subnet: Optional for pure switching, required when L3 / routing features are used
        :param pulumi.Input[builtins.str] subnet6: Optional for pure switching, required when L3 / routing features are used
        """
        pulumi.set(__self__, "vlan_id", vlan_id)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if isolation_vlan_id is not None:
            pulumi.set(__self__, "isolation_vlan_id", isolation_vlan_id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def gateway6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        """
        return pulumi.get(self, "gateway6")

    @gateway6.setter
    def gateway6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway6", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="isolationVlanId")
    def isolation_vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "isolation_vlan_id")

    @isolation_vlan_id.setter
    def isolation_vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "isolation_vlan_id", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter
    def subnet6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet6")

    @subnet6.setter
    def subnet6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet6", value)


if not MYPY:
    class NetworktemplateOspfAreasArgsDict(TypedDict):
        networks: pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateOspfAreasNetworksArgsDict']]]
        include_loopback: NotRequired[pulumi.Input[builtins.bool]]
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        OSPF type. enum: `default`, `nssa`, `stub`
        """
elif False:
    NetworktemplateOspfAreasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateOspfAreasArgs:
    def __init__(__self__, *,
                 networks: pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateOspfAreasNetworksArgs']]],
                 include_loopback: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: OSPF type. enum: `default`, `nssa`, `stub`
        """
        pulumi.set(__self__, "networks", networks)
        if include_loopback is not None:
            pulumi.set(__self__, "include_loopback", include_loopback)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def networks(self) -> pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateOspfAreasNetworksArgs']]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateOspfAreasNetworksArgs']]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="includeLoopback")
    def include_loopback(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "include_loopback")

    @include_loopback.setter
    def include_loopback(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_loopback", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        OSPF type. enum: `default`, `nssa`, `stub`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworktemplateOspfAreasNetworksArgsDict(TypedDict):
        auth_keys: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Required if `auth_type`==`md5`. Property key is the key number
        """
        auth_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `auth_type`==`password`, the password, max length is 8
        """
        auth_type: NotRequired[pulumi.Input[builtins.str]]
        """
        auth type. enum: `md5`, `none`, `password`
        """
        bfd_minimum_interval: NotRequired[pulumi.Input[builtins.int]]
        dead_interval: NotRequired[pulumi.Input[builtins.int]]
        export_policy: NotRequired[pulumi.Input[builtins.str]]
        hello_interval: NotRequired[pulumi.Input[builtins.int]]
        import_policy: NotRequired[pulumi.Input[builtins.str]]
        interface_type: NotRequired[pulumi.Input[builtins.str]]
        """
        interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        """
        metric: NotRequired[pulumi.Input[builtins.int]]
        no_readvertise_to_overlay: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, we'll re-advertise all learned OSPF routes toward overlay
        """
        passive: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to send OSPF-Hello
        """
elif False:
    NetworktemplateOspfAreasNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateOspfAreasNetworksArgs:
    def __init__(__self__, *,
                 auth_keys: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 auth_password: Optional[pulumi.Input[builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[builtins.str]] = None,
                 bfd_minimum_interval: Optional[pulumi.Input[builtins.int]] = None,
                 dead_interval: Optional[pulumi.Input[builtins.int]] = None,
                 export_policy: Optional[pulumi.Input[builtins.str]] = None,
                 hello_interval: Optional[pulumi.Input[builtins.int]] = None,
                 import_policy: Optional[pulumi.Input[builtins.str]] = None,
                 interface_type: Optional[pulumi.Input[builtins.str]] = None,
                 metric: Optional[pulumi.Input[builtins.int]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[builtins.bool]] = None,
                 passive: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] auth_keys: Required if `auth_type`==`md5`. Property key is the key number
        :param pulumi.Input[builtins.str] auth_password: Required if `auth_type`==`password`, the password, max length is 8
        :param pulumi.Input[builtins.str] auth_type: auth type. enum: `md5`, `none`, `password`
        :param pulumi.Input[builtins.str] interface_type: interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        :param pulumi.Input[builtins.bool] no_readvertise_to_overlay: By default, we'll re-advertise all learned OSPF routes toward overlay
        :param pulumi.Input[builtins.bool] passive: Whether to send OSPF-Hello
        """
        if auth_keys is not None:
            pulumi.set(__self__, "auth_keys", auth_keys)
        if auth_password is not None:
            pulumi.set(__self__, "auth_password", auth_password)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if dead_interval is not None:
            pulumi.set(__self__, "dead_interval", dead_interval)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)

    @property
    @pulumi.getter(name="authKeys")
    def auth_keys(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Required if `auth_type`==`md5`. Property key is the key number
        """
        return pulumi.get(self, "auth_keys")

    @auth_keys.setter
    def auth_keys(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "auth_keys", value)

    @property
    @pulumi.getter(name="authPassword")
    def auth_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `auth_type`==`password`, the password, max length is 8
        """
        return pulumi.get(self, "auth_password")

    @auth_password.setter
    def auth_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_password", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        auth type. enum: `md5`, `none`, `password`
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "bfd_minimum_interval")

    @bfd_minimum_interval.setter
    def bfd_minimum_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bfd_minimum_interval", value)

    @property
    @pulumi.getter(name="deadInterval")
    def dead_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "dead_interval")

    @dead_interval.setter
    def dead_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dead_interval", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hello_interval", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        """
        return pulumi.get(self, "interface_type")

    @interface_type.setter
    def interface_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "interface_type", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, we'll re-advertise all learned OSPF routes toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to send OSPF-Hello
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "passive", value)


if not MYPY:
    class NetworktemplatePortMirroringArgsDict(TypedDict):
        input_networks_ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        input_port_ids_egresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        input_port_ids_ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        output_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
        output_port_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
elif False:
    NetworktemplatePortMirroringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplatePortMirroringArgs:
    def __init__(__self__, *,
                 input_networks_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 input_port_ids_egresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 input_port_ids_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 output_network: Optional[pulumi.Input[builtins.str]] = None,
                 output_port_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_networks_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_port_ids_egresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_port_ids_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[builtins.str] output_network: Exactly one of the `output_port_id` or `output_network` should be provided
        :param pulumi.Input[builtins.str] output_port_id: Exactly one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @input_networks_ingresses.setter
    def input_networks_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_networks_ingresses", value)

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @input_port_ids_egresses.setter
    def input_port_ids_egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_port_ids_egresses", value)

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @input_port_ids_ingresses.setter
    def input_port_ids_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_port_ids_ingresses", value)

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @output_network.setter
    def output_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "output_network", value)

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")

    @output_port_id.setter
    def output_port_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "output_port_id", value)


if not MYPY:
    class NetworktemplatePortUsagesArgsDict(TypedDict):
        all_networks: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        allow_dhcpd: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        """
        allow_multiple_supplicants: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic`
        """
        bypass_auth_when_server_down: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        bypass_auth_when_server_down_for_unknown_client: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic`
        """
        disable_autoneg: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        duplex: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        """
        dynamic_vlan_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        enable_mac_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        enable_qos: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic`
        """
        guest_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        inter_isolation_network_link: NotRequired[pulumi.Input[builtins.bool]]
        """
        `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        """
        inter_switch_link: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        mac_auth_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        mac_auth_preferred: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        mac_auth_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        mac_limit: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        mtu: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        persist_mac: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        poe_disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        port_auth: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        port_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        reauth_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        """
        reset_default_when: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgsDict']]]]
        """
        Only if `mode`==`dynamic`
        """
        server_fail_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        server_reject_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        speed: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        storm_control: NotRequired[pulumi.Input['NetworktemplatePortUsagesStormControlArgsDict']]
        """
        Switch storm control. Only if `mode`!=`dynamic`
        """
        stp_edge: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        stp_no_root_port: NotRequired[pulumi.Input[builtins.bool]]
        stp_p2p: NotRequired[pulumi.Input[builtins.bool]]
        ui_evpntopo_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
        """
        use_vstp: NotRequired[pulumi.Input[builtins.bool]]
        """
        If this is connected to a vstp network
        """
        voip_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
elif False:
    NetworktemplatePortUsagesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplatePortUsagesArgs:
    def __init__(__self__, *,
                 all_networks: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_dhcpd: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_multiple_supplicants: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_auth_when_server_down: Optional[pulumi.Input[builtins.bool]] = None,
                 bypass_auth_when_server_down_for_unknown_client: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disable_autoneg: Optional[pulumi.Input[builtins.bool]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 duplex: Optional[pulumi.Input[builtins.str]] = None,
                 dynamic_vlan_networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enable_mac_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_qos: Optional[pulumi.Input[builtins.bool]] = None,
                 guest_network: Optional[pulumi.Input[builtins.str]] = None,
                 inter_isolation_network_link: Optional[pulumi.Input[builtins.bool]] = None,
                 inter_switch_link: Optional[pulumi.Input[builtins.bool]] = None,
                 mac_auth_only: Optional[pulumi.Input[builtins.bool]] = None,
                 mac_auth_preferred: Optional[pulumi.Input[builtins.bool]] = None,
                 mac_auth_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 mac_limit: Optional[pulumi.Input[builtins.str]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 mtu: Optional[pulumi.Input[builtins.str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 persist_mac: Optional[pulumi.Input[builtins.bool]] = None,
                 poe_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 port_auth: Optional[pulumi.Input[builtins.str]] = None,
                 port_network: Optional[pulumi.Input[builtins.str]] = None,
                 reauth_interval: Optional[pulumi.Input[builtins.str]] = None,
                 reset_default_when: Optional[pulumi.Input[builtins.str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]]] = None,
                 server_fail_network: Optional[pulumi.Input[builtins.str]] = None,
                 server_reject_network: Optional[pulumi.Input[builtins.str]] = None,
                 speed: Optional[pulumi.Input[builtins.str]] = None,
                 storm_control: Optional[pulumi.Input['NetworktemplatePortUsagesStormControlArgs']] = None,
                 stp_edge: Optional[pulumi.Input[builtins.bool]] = None,
                 stp_no_root_port: Optional[pulumi.Input[builtins.bool]] = None,
                 stp_p2p: Optional[pulumi.Input[builtins.bool]] = None,
                 ui_evpntopo_id: Optional[pulumi.Input[builtins.str]] = None,
                 use_vstp: Optional[pulumi.Input[builtins.bool]] = None,
                 voip_network: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param pulumi.Input[builtins.bool] allow_dhcpd: Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        :param pulumi.Input[builtins.bool] allow_multiple_supplicants: Only if `mode`!=`dynamic`
        :param pulumi.Input[builtins.bool] bypass_auth_when_server_down: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param pulumi.Input[builtins.bool] bypass_auth_when_server_down_for_unknown_client: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param pulumi.Input[builtins.str] description: Only if `mode`!=`dynamic`
        :param pulumi.Input[builtins.bool] disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param pulumi.Input[builtins.bool] disabled: Only if `mode`!=`dynamic` whether the port is disabled
        :param pulumi.Input[builtins.str] duplex: Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dynamic_vlan_networks: Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param pulumi.Input[builtins.bool] enable_mac_auth: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        :param pulumi.Input[builtins.bool] enable_qos: Only if `mode`!=`dynamic`
        :param pulumi.Input[builtins.str] guest_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param pulumi.Input[builtins.bool] inter_isolation_network_link: `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        :param pulumi.Input[builtins.bool] inter_switch_link: Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param pulumi.Input[builtins.bool] mac_auth_only: Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        :param pulumi.Input[builtins.bool] mac_auth_preferred: Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        :param pulumi.Input[builtins.str] mac_auth_protocol: Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param pulumi.Input[builtins.str] mac_limit: Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        :param pulumi.Input[builtins.str] mode: `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        :param pulumi.Input[builtins.str] mtu: Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param pulumi.Input[builtins.bool] persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param pulumi.Input[builtins.bool] poe_disabled: Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        :param pulumi.Input[builtins.str] port_auth: Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        :param pulumi.Input[builtins.str] port_network: Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        :param pulumi.Input[builtins.str] reauth_interval: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        :param pulumi.Input[builtins.str] reset_default_when: Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]] rules: Only if `mode`==`dynamic`
        :param pulumi.Input[builtins.str] server_fail_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        :param pulumi.Input[builtins.str] server_reject_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        :param pulumi.Input[builtins.str] speed: Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        :param pulumi.Input['NetworktemplatePortUsagesStormControlArgs'] storm_control: Switch storm control. Only if `mode`!=`dynamic`
        :param pulumi.Input[builtins.bool] stp_edge: Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        :param pulumi.Input[builtins.str] ui_evpntopo_id: Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
        :param pulumi.Input[builtins.bool] use_vstp: If this is connected to a vstp network
        :param pulumi.Input[builtins.str] voip_network: Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unknown_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unknown_client", bypass_auth_when_server_down_for_unknown_client)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_isolation_network_link is not None:
            pulumi.set(__self__, "inter_isolation_network_link", inter_isolation_network_link)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if reset_default_when is not None:
            pulumi.set(__self__, "reset_default_when", reset_default_when)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if server_fail_network is not None:
            pulumi.set(__self__, "server_fail_network", server_fail_network)
        if server_reject_network is not None:
            pulumi.set(__self__, "server_reject_network", server_reject_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if stp_no_root_port is not None:
            pulumi.set(__self__, "stp_no_root_port", stp_no_root_port)
        if stp_p2p is not None:
            pulumi.set(__self__, "stp_p2p", stp_p2p)
        if ui_evpntopo_id is not None:
            pulumi.set(__self__, "ui_evpntopo_id", ui_evpntopo_id)
        if use_vstp is not None:
            pulumi.set(__self__, "use_vstp", use_vstp)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @all_networks.setter
    def all_networks(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "all_networks", value)

    @property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @allow_dhcpd.setter
    def allow_dhcpd(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_dhcpd", value)

    @property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "allow_multiple_supplicants")

    @allow_multiple_supplicants.setter
    def allow_multiple_supplicants(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_multiple_supplicants", value)

    @property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @bypass_auth_when_server_down.setter
    def bypass_auth_when_server_down(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bypass_auth_when_server_down", value)

    @property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnknownClient")
    def bypass_auth_when_server_down_for_unknown_client(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unknown_client")

    @bypass_auth_when_server_down_for_unknown_client.setter
    def bypass_auth_when_server_down_for_unknown_client(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bypass_auth_when_server_down_for_unknown_client", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @dynamic_vlan_networks.setter
    def dynamic_vlan_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dynamic_vlan_networks", value)

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @enable_mac_auth.setter
    def enable_mac_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_mac_auth", value)

    @property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "enable_qos")

    @enable_qos.setter
    def enable_qos(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_qos", value)

    @property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @guest_network.setter
    def guest_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "guest_network", value)

    @property
    @pulumi.getter(name="interIsolationNetworkLink")
    def inter_isolation_network_link(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_isolation_network_link")

    @inter_isolation_network_link.setter
    def inter_isolation_network_link(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inter_isolation_network_link", value)

    @property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @inter_switch_link.setter
    def inter_switch_link(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inter_switch_link", value)

    @property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @mac_auth_only.setter
    def mac_auth_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "mac_auth_only", value)

    @property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        return pulumi.get(self, "mac_auth_preferred")

    @mac_auth_preferred.setter
    def mac_auth_preferred(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "mac_auth_preferred", value)

    @property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @mac_auth_protocol.setter
    def mac_auth_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac_auth_protocol", value)

    @property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        """
        return pulumi.get(self, "mac_limit")

    @mac_limit.setter
    def mac_limit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac_limit", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @persist_mac.setter
    def persist_mac(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "persist_mac", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @port_auth.setter
    def port_auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_auth", value)

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @port_network.setter
    def port_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_network", value)

    @property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        """
        return pulumi.get(self, "reauth_interval")

    @reauth_interval.setter
    def reauth_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reauth_interval", value)

    @property
    @pulumi.getter(name="resetDefaultWhen")
    def reset_default_when(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        return pulumi.get(self, "reset_default_when")

    @reset_default_when.setter
    def reset_default_when(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reset_default_when", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]]]:
        """
        Only if `mode`==`dynamic`
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="serverFailNetwork")
    def server_fail_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        return pulumi.get(self, "server_fail_network")

    @server_fail_network.setter
    def server_fail_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_fail_network", value)

    @property
    @pulumi.getter(name="serverRejectNetwork")
    def server_reject_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "server_reject_network")

    @server_reject_network.setter
    def server_reject_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_reject_network", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional[pulumi.Input['NetworktemplatePortUsagesStormControlArgs']]:
        """
        Switch storm control. Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "storm_control")

    @storm_control.setter
    def storm_control(self, value: Optional[pulumi.Input['NetworktemplatePortUsagesStormControlArgs']]):
        pulumi.set(self, "storm_control", value)

    @property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @stp_edge.setter
    def stp_edge(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "stp_edge", value)

    @property
    @pulumi.getter(name="stpNoRootPort")
    def stp_no_root_port(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "stp_no_root_port")

    @stp_no_root_port.setter
    def stp_no_root_port(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "stp_no_root_port", value)

    @property
    @pulumi.getter(name="stpP2p")
    def stp_p2p(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "stp_p2p")

    @stp_p2p.setter
    def stp_p2p(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "stp_p2p", value)

    @property
    @pulumi.getter(name="uiEvpntopoId")
    def ui_evpntopo_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
        """
        return pulumi.get(self, "ui_evpntopo_id")

    @ui_evpntopo_id.setter
    def ui_evpntopo_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ui_evpntopo_id", value)

    @property
    @pulumi.getter(name="useVstp")
    def use_vstp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If this is connected to a vstp network
        """
        return pulumi.get(self, "use_vstp")

    @use_vstp.setter
    def use_vstp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_vstp", value)

    @property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")

    @voip_network.setter
    def voip_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "voip_network", value)


if not MYPY:
    class NetworktemplatePortUsagesRuleArgsDict(TypedDict):
        src: pulumi.Input[builtins.str]
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        equals: NotRequired[pulumi.Input[builtins.str]]
        equals_anies: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Use `equals_any` to match any item in a list
        """
        expression: NotRequired[pulumi.Input[builtins.str]]
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        usage: NotRequired[pulumi.Input[builtins.str]]
        """
        `port_usage` name
        """
elif False:
    NetworktemplatePortUsagesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplatePortUsagesRuleArgs:
    def __init__(__self__, *,
                 src: pulumi.Input[builtins.str],
                 equals: Optional[pulumi.Input[builtins.str]] = None,
                 equals_anies: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 expression: Optional[pulumi.Input[builtins.str]] = None,
                 usage: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] src: enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] equals_anies: Use `equals_any` to match any item in a list
        :param pulumi.Input[builtins.str] expression: "[0:3]":"abcdef" > "abc"
               "split(.)[1]": "a.b.c" > "b"
               "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        :param pulumi.Input[builtins.str] usage: `port_usage` name
        """
        pulumi.set(__self__, "src", src)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if equals_anies is not None:
            pulumi.set(__self__, "equals_anies", equals_anies)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def src(self) -> pulumi.Input[builtins.str]:
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        return pulumi.get(self, "src")

    @src.setter
    def src(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "src", value)

    @property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "equals", value)

    @property
    @pulumi.getter(name="equalsAnies")
    def equals_anies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Use `equals_any` to match any item in a list
        """
        return pulumi.get(self, "equals_anies")

    @equals_anies.setter
    def equals_anies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "equals_anies", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `port_usage` name
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class NetworktemplatePortUsagesStormControlArgsDict(TypedDict):
        no_broadcast: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable storm control on broadcast traffic
        """
        no_multicast: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable storm control on multicast traffic
        """
        no_registered_multicast: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable storm control on registered multicast traffic
        """
        no_unknown_unicast: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable storm control on unknown unicast traffic
        """
        percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
elif False:
    NetworktemplatePortUsagesStormControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplatePortUsagesStormControlArgs:
    def __init__(__self__, *,
                 no_broadcast: Optional[pulumi.Input[builtins.bool]] = None,
                 no_multicast: Optional[pulumi.Input[builtins.bool]] = None,
                 no_registered_multicast: Optional[pulumi.Input[builtins.bool]] = None,
                 no_unknown_unicast: Optional[pulumi.Input[builtins.bool]] = None,
                 percentage: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] no_broadcast: Whether to disable storm control on broadcast traffic
        :param pulumi.Input[builtins.bool] no_multicast: Whether to disable storm control on multicast traffic
        :param pulumi.Input[builtins.bool] no_registered_multicast: Whether to disable storm control on registered multicast traffic
        :param pulumi.Input[builtins.bool] no_unknown_unicast: Whether to disable storm control on unknown unicast traffic
        :param pulumi.Input[builtins.int] percentage: Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @no_broadcast.setter
    def no_broadcast(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_broadcast", value)

    @property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @no_multicast.setter
    def no_multicast(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_multicast", value)

    @property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @no_registered_multicast.setter
    def no_registered_multicast(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_registered_multicast", value)

    @property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @no_unknown_unicast.setter
    def no_unknown_unicast(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_unknown_unicast", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class NetworktemplateRadiusConfigArgsDict(TypedDict):
        acct_immediate_update: NotRequired[pulumi.Input[builtins.bool]]
        acct_interim_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        acct_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgsDict']]]]
        auth_server_selection: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ordered`, `unordered`
        """
        auth_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgsDict']]]]
        auth_servers_retries: NotRequired[pulumi.Input[builtins.int]]
        """
        Radius auth session retries
        """
        auth_servers_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Radius auth session timeout
        """
        coa_enabled: NotRequired[pulumi.Input[builtins.bool]]
        coa_port: NotRequired[pulumi.Input[builtins.str]]
        fast_dot1x_timers: NotRequired[pulumi.Input[builtins.bool]]
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        source_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Use `network`or `source_ip`
        """
elif False:
    NetworktemplateRadiusConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRadiusConfigArgs:
    def __init__(__self__, *,
                 acct_immediate_update: Optional[pulumi.Input[builtins.bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[builtins.int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgs']]]] = None,
                 auth_server_selection: Optional[pulumi.Input[builtins.str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgs']]]] = None,
                 auth_servers_retries: Optional[pulumi.Input[builtins.int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 coa_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 coa_port: Optional[pulumi.Input[builtins.str]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[builtins.bool]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 source_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param pulumi.Input[builtins.str] auth_server_selection: enum: `ordered`, `unordered`
        :param pulumi.Input[builtins.int] auth_servers_retries: Radius auth session retries
        :param pulumi.Input[builtins.int] auth_servers_timeout: Radius auth session timeout
        :param pulumi.Input[builtins.str] network: Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param pulumi.Input[builtins.str] source_ip: Use `network`or `source_ip`
        """
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "acct_immediate_update")

    @acct_immediate_update.setter
    def acct_immediate_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "acct_immediate_update", value)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgs']]]]:
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @auth_server_selection.setter
    def auth_server_selection(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_server_selection", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgs']]]]:
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "coa_enabled")

    @coa_enabled.setter
    def coa_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "coa_enabled", value)

    @property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "coa_port")

    @coa_port.setter
    def coa_port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "coa_port", value)

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "fast_dot1x_timers")

    @fast_dot1x_timers.setter
    def fast_dot1x_timers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fast_dot1x_timers", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class NetworktemplateRadiusConfigAcctServerArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        IP/ hostname of RADIUS server
        """
        secret: pulumi.Input[builtins.str]
        """
        Secret of RADIUS server
        """
        keywrap_enabled: NotRequired[pulumi.Input[builtins.bool]]
        keywrap_format: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ascii`, `hex`
        """
        keywrap_kek: NotRequired[pulumi.Input[builtins.str]]
        keywrap_mack: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateRadiusConfigAcctServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRadiusConfigAcctServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 keywrap_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 keywrap_format: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_kek: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_mack: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] host: IP/ hostname of RADIUS server
        :param pulumi.Input[builtins.str] secret: Secret of RADIUS server
        :param pulumi.Input[builtins.str] keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class NetworktemplateRadiusConfigAuthServerArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        IP/ hostname of RADIUS server
        """
        secret: pulumi.Input[builtins.str]
        """
        Secret of RADIUS server
        """
        keywrap_enabled: NotRequired[pulumi.Input[builtins.bool]]
        keywrap_format: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ascii`, `hex`
        """
        keywrap_kek: NotRequired[pulumi.Input[builtins.str]]
        keywrap_mack: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        require_message_authenticator: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to require Message-Authenticator in requests
        """
elif False:
    NetworktemplateRadiusConfigAuthServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRadiusConfigAuthServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 keywrap_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 keywrap_format: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_kek: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_mack: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 require_message_authenticator: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] host: IP/ hostname of RADIUS server
        :param pulumi.Input[builtins.str] secret: Secret of RADIUS server
        :param pulumi.Input[builtins.str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[builtins.bool] require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")

    @require_message_authenticator.setter
    def require_message_authenticator(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_message_authenticator", value)


if not MYPY:
    class NetworktemplateRemoteSyslogArgsDict(TypedDict):
        archive: NotRequired[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgsDict']]
        console: NotRequired[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgsDict']]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        files: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgsDict']]]]
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        send_to_all_servers: NotRequired[pulumi.Input[builtins.bool]]
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgsDict']]]]
        time_format: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgsDict']]]]
elif False:
    NetworktemplateRemoteSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgs']] = None,
                 console: Optional[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 files: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgs']]]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 send_to_all_servers: Optional[pulumi.Input[builtins.bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgs']]]] = None,
                 time_format: Optional[pulumi.Input[builtins.str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] network: If source_address is configured, will use the vlan firstly otherwise use source_ip
        :param pulumi.Input[builtins.str] time_format: enum: `millisecond`, `year`, `year millisecond`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if console is not None:
            pulumi.set(__self__, "console", console)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if send_to_all_servers is not None:
            pulumi.set(__self__, "send_to_all_servers", send_to_all_servers)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgs']]:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgs']]):
        pulumi.set(self, "archive", value)

    @property
    @pulumi.getter
    def console(self) -> Optional[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgs']]:
        return pulumi.get(self, "console")

    @console.setter
    def console(self, value: Optional[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgs']]):
        pulumi.set(self, "console", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgs']]]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgs']]]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sendToAllServers")
    def send_to_all_servers(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "send_to_all_servers")

    @send_to_all_servers.setter
    def send_to_all_servers(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "send_to_all_servers", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgs']]]]:
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgs']]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class NetworktemplateRemoteSyslogArchiveArgsDict(TypedDict):
        files: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateRemoteSyslogArchiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogArchiveArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NetworktemplateRemoteSyslogConsoleArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgsDict']]]]
elif False:
    NetworktemplateRemoteSyslogConsoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogConsoleArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgs']]]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgs']]]]):
        pulumi.set(self, "contents", value)


if not MYPY:
    class NetworktemplateRemoteSyslogConsoleContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    NetworktemplateRemoteSyslogConsoleContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogConsoleContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[builtins.str]] = None,
                 severity: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[builtins.str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class NetworktemplateRemoteSyslogFileArgsDict(TypedDict):
        archive: NotRequired[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgsDict']]
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgsDict']]]]
        explicit_priority: NotRequired[pulumi.Input[builtins.bool]]
        file: NotRequired[pulumi.Input[builtins.str]]
        match: NotRequired[pulumi.Input[builtins.str]]
        structured_data: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    NetworktemplateRemoteSyslogFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogFileArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgs']] = None,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgs']]]] = None,
                 explicit_priority: Optional[pulumi.Input[builtins.bool]] = None,
                 file: Optional[pulumi.Input[builtins.str]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 structured_data: Optional[pulumi.Input[builtins.bool]] = None):
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)

    @property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgs']]:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgs']]):
        pulumi.set(self, "archive", value)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "explicit_priority")

    @explicit_priority.setter
    def explicit_priority(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "explicit_priority", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "structured_data")

    @structured_data.setter
    def structured_data(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "structured_data", value)


if not MYPY:
    class NetworktemplateRemoteSyslogFileArchiveArgsDict(TypedDict):
        files: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateRemoteSyslogFileArchiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogFileArchiveArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NetworktemplateRemoteSyslogFileContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    NetworktemplateRemoteSyslogFileContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogFileContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[builtins.str]] = None,
                 severity: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[builtins.str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class NetworktemplateRemoteSyslogServerArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgsDict']]]]
        explicit_priority: NotRequired[pulumi.Input[builtins.bool]]
        facility: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        match: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `tcp`, `udp`
        """
        routing_instance: NotRequired[pulumi.Input[builtins.str]]
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        source_address: NotRequired[pulumi.Input[builtins.str]]
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        structured_data: NotRequired[pulumi.Input[builtins.bool]]
        tag: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateRemoteSyslogServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogServerArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgs']]]] = None,
                 explicit_priority: Optional[pulumi.Input[builtins.bool]] = None,
                 facility: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 routing_instance: Optional[pulumi.Input[builtins.str]] = None,
                 severity: Optional[pulumi.Input[builtins.str]] = None,
                 source_address: Optional[pulumi.Input[builtins.str]] = None,
                 structured_data: Optional[pulumi.Input[builtins.bool]] = None,
                 tag: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[builtins.str] protocol: enum: `tcp`, `udp`
        :param pulumi.Input[builtins.str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        :param pulumi.Input[builtins.str] source_address: If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routing_instance is not None:
            pulumi.set(__self__, "routing_instance", routing_instance)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "explicit_priority")

    @explicit_priority.setter
    def explicit_priority(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "explicit_priority", value)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="routingInstance")
    def routing_instance(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "routing_instance")

    @routing_instance.setter
    def routing_instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "routing_instance", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_address", value)

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "structured_data")

    @structured_data.setter
    def structured_data(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "structured_data", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class NetworktemplateRemoteSyslogServerContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    NetworktemplateRemoteSyslogServerContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogServerContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[builtins.str]] = None,
                 severity: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[builtins.str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class NetworktemplateRemoteSyslogUserArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgsDict']]]]
        match: NotRequired[pulumi.Input[builtins.str]]
        user: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateRemoteSyslogUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogUserArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgs']]]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 user: Optional[pulumi.Input[builtins.str]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class NetworktemplateRemoteSyslogUserContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    NetworktemplateRemoteSyslogUserContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateRemoteSyslogUserContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[builtins.str]] = None,
                 severity: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[builtins.str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class NetworktemplateSnmpConfigArgsDict(TypedDict):
        client_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgsDict']]]]
        contact: NotRequired[pulumi.Input[builtins.str]]
        description: NotRequired[pulumi.Input[builtins.str]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        engine_id: NotRequired[pulumi.Input[builtins.str]]
        location: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        network: NotRequired[pulumi.Input[builtins.str]]
        trap_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgsDict']]]]
        v2c_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgsDict']]]]
        v3_config: NotRequired[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgsDict']]
        views: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgsDict']]]]
elif False:
    NetworktemplateSnmpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigArgs:
    def __init__(__self__, *,
                 client_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgs']]]] = None,
                 contact: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 engine_id: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 trap_groups: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgs']]]] = None,
                 v2c_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgs']]]] = None,
                 v3_config: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgs']] = None,
                 views: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgs']]]] = None):
        if client_lists is not None:
            pulumi.set(__self__, "client_lists", client_lists)
        if contact is not None:
            pulumi.set(__self__, "contact", contact)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if trap_groups is not None:
            pulumi.set(__self__, "trap_groups", trap_groups)
        if v2c_configs is not None:
            pulumi.set(__self__, "v2c_configs", v2c_configs)
        if v3_config is not None:
            pulumi.set(__self__, "v3_config", v3_config)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter(name="clientLists")
    def client_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgs']]]]:
        return pulumi.get(self, "client_lists")

    @client_lists.setter
    def client_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgs']]]]):
        pulumi.set(self, "client_lists", value)

    @property
    @pulumi.getter
    def contact(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "contact")

    @contact.setter
    def contact(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "contact", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "engine_id")

    @engine_id.setter
    def engine_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "engine_id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="trapGroups")
    def trap_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgs']]]]:
        return pulumi.get(self, "trap_groups")

    @trap_groups.setter
    def trap_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgs']]]]):
        pulumi.set(self, "trap_groups", value)

    @property
    @pulumi.getter(name="v2cConfigs")
    def v2c_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgs']]]]:
        return pulumi.get(self, "v2c_configs")

    @v2c_configs.setter
    def v2c_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgs']]]]):
        pulumi.set(self, "v2c_configs", value)

    @property
    @pulumi.getter(name="v3Config")
    def v3_config(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgs']]:
        return pulumi.get(self, "v3_config")

    @v3_config.setter
    def v3_config(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgs']]):
        pulumi.set(self, "v3_config", value)

    @property
    @pulumi.getter
    def views(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgs']]]]:
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgs']]]]):
        pulumi.set(self, "views", value)


if not MYPY:
    class NetworktemplateSnmpConfigClientListArgsDict(TypedDict):
        client_list_name: NotRequired[pulumi.Input[builtins.str]]
        clients: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    NetworktemplateSnmpConfigClientListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigClientListArgs:
    def __init__(__self__, *,
                 client_list_name: Optional[pulumi.Input[builtins.str]] = None,
                 clients: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_list_name")

    @client_list_name.setter
    def client_list_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_list_name", value)

    @property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "clients", value)


if not MYPY:
    class NetworktemplateSnmpConfigTrapGroupArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `all`, `v1`, `v2`
        """
elif False:
    NetworktemplateSnmpConfigTrapGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigTrapGroupArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 group_name: Optional[pulumi.Input[builtins.str]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group_name: Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        :param pulumi.Input[builtins.str] version: enum: `all`, `v1`, `v2`
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `all`, `v1`, `v2`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class NetworktemplateSnmpConfigV2cConfigArgsDict(TypedDict):
        authorization: NotRequired[pulumi.Input[builtins.str]]
        client_list_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Client_list_name here should refer to client_list above
        """
        community_name: NotRequired[pulumi.Input[builtins.str]]
        view: NotRequired[pulumi.Input[builtins.str]]
        """
        View name here should be defined in views above
        """
elif False:
    NetworktemplateSnmpConfigV2cConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV2cConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input[builtins.str]] = None,
                 client_list_name: Optional[pulumi.Input[builtins.str]] = None,
                 community_name: Optional[pulumi.Input[builtins.str]] = None,
                 view: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_list_name: Client_list_name here should refer to client_list above
        :param pulumi.Input[builtins.str] view: View name here should be defined in views above
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client_list_name here should refer to client_list above
        """
        return pulumi.get(self, "client_list_name")

    @client_list_name.setter
    def client_list_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_list_name", value)

    @property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "community_name")

    @community_name.setter
    def community_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "community_name", value)

    @property
    @pulumi.getter
    def view(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        View name here should be defined in views above
        """
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "view", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigArgsDict(TypedDict):
        notifies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgsDict']]]]
        notify_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgsDict']]]]
        target_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgsDict']]]]
        target_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgsDict']]]]
        usms: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgsDict']]]]
        vacm: NotRequired[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgsDict']]
elif False:
    NetworktemplateSnmpConfigV3ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigArgs:
    def __init__(__self__, *,
                 notifies: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgs']]]] = None,
                 notify_filters: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs']]]] = None,
                 target_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgs']]]] = None,
                 target_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgs']]]] = None,
                 usms: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgs']]]] = None,
                 vacm: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgs']] = None):
        if notifies is not None:
            pulumi.set(__self__, "notifies", notifies)
        if notify_filters is not None:
            pulumi.set(__self__, "notify_filters", notify_filters)
        if target_addresses is not None:
            pulumi.set(__self__, "target_addresses", target_addresses)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)
        if usms is not None:
            pulumi.set(__self__, "usms", usms)
        if vacm is not None:
            pulumi.set(__self__, "vacm", vacm)

    @property
    @pulumi.getter
    def notifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgs']]]]:
        return pulumi.get(self, "notifies")

    @notifies.setter
    def notifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgs']]]]):
        pulumi.set(self, "notifies", value)

    @property
    @pulumi.getter(name="notifyFilters")
    def notify_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs']]]]:
        return pulumi.get(self, "notify_filters")

    @notify_filters.setter
    def notify_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs']]]]):
        pulumi.set(self, "notify_filters", value)

    @property
    @pulumi.getter(name="targetAddresses")
    def target_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgs']]]]:
        return pulumi.get(self, "target_addresses")

    @target_addresses.setter
    def target_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgs']]]]):
        pulumi.set(self, "target_addresses", value)

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgs']]]]:
        return pulumi.get(self, "target_parameters")

    @target_parameters.setter
    def target_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgs']]]]):
        pulumi.set(self, "target_parameters", value)

    @property
    @pulumi.getter
    def usms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgs']]]]:
        return pulumi.get(self, "usms")

    @usms.setter
    def usms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgs']]]]):
        pulumi.set(self, "usms", value)

    @property
    @pulumi.getter
    def vacm(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgs']]:
        return pulumi.get(self, "vacm")

    @vacm.setter
    def vacm(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgs']]):
        pulumi.set(self, "vacm", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigNotifyArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        tag: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
        """
        enum: `inform`, `trap`
        """
elif False:
    NetworktemplateSnmpConfigV3ConfigNotifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigNotifyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 tag: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] type: enum: `inform`, `trap`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        enum: `inform`, `trap`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigNotifyFilterArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgsDict']]]]
        profile_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateSnmpConfigV3ConfigNotifyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs']]]] = None,
                 profile_name: Optional[pulumi.Input[builtins.str]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile_name", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgsDict(TypedDict):
        oid: pulumi.Input[builtins.str]
        include: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs:
    def __init__(__self__, *,
                 oid: pulumi.Input[builtins.str],
                 include: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "oid", oid)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @property
    @pulumi.getter
    def oid(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "oid")

    @oid.setter
    def oid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "oid", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigTargetAddressArgsDict(TypedDict):
        address: pulumi.Input[builtins.str]
        address_mask: pulumi.Input[builtins.str]
        target_address_name: pulumi.Input[builtins.str]
        port: NotRequired[pulumi.Input[builtins.str]]
        tag_list: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to notify tag, can be multiple with blank
        """
        target_parameters: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to notify target parameters name
        """
elif False:
    NetworktemplateSnmpConfigV3ConfigTargetAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigTargetAddressArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 address_mask: pulumi.Input[builtins.str],
                 target_address_name: pulumi.Input[builtins.str],
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 tag_list: Optional[pulumi.Input[builtins.str]] = None,
                 target_parameters: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] tag_list: Refer to notify tag, can be multiple with blank
        :param pulumi.Input[builtins.str] target_parameters: Refer to notify target parameters name
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "address_mask", address_mask)
        pulumi.set(__self__, "target_address_name", target_address_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressMask")
    def address_mask(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "address_mask")

    @address_mask.setter
    def address_mask(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address_mask", value)

    @property
    @pulumi.getter(name="targetAddressName")
    def target_address_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "target_address_name")

    @target_address_name.setter
    def target_address_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_address_name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to notify tag, can be multiple with blank
        """
        return pulumi.get(self, "tag_list")

    @tag_list.setter
    def tag_list(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tag_list", value)

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to notify target parameters name
        """
        return pulumi.get(self, "target_parameters")

    @target_parameters.setter
    def target_parameters(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_parameters", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigTargetParameterArgsDict(TypedDict):
        message_processing_model: pulumi.Input[builtins.str]
        """
        enum: `v1`, `v2c`, `v3`
        """
        name: pulumi.Input[builtins.str]
        notify_filter: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to profile-name in notify_filter
        """
        security_level: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `authentication`, `none`, `privacy`
        """
        security_model: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `usm`, `v1`, `v2c`
        """
        security_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to security_name in usm
        """
elif False:
    NetworktemplateSnmpConfigV3ConfigTargetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigTargetParameterArgs:
    def __init__(__self__, *,
                 message_processing_model: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 notify_filter: Optional[pulumi.Input[builtins.str]] = None,
                 security_level: Optional[pulumi.Input[builtins.str]] = None,
                 security_model: Optional[pulumi.Input[builtins.str]] = None,
                 security_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] message_processing_model: enum: `v1`, `v2c`, `v3`
        :param pulumi.Input[builtins.str] notify_filter: Refer to profile-name in notify_filter
        :param pulumi.Input[builtins.str] security_level: enum: `authentication`, `none`, `privacy`
        :param pulumi.Input[builtins.str] security_model: enum: `usm`, `v1`, `v2c`
        :param pulumi.Input[builtins.str] security_name: Refer to security_name in usm
        """
        pulumi.set(__self__, "message_processing_model", message_processing_model)
        pulumi.set(__self__, "name", name)
        if notify_filter is not None:
            pulumi.set(__self__, "notify_filter", notify_filter)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter(name="messageProcessingModel")
    def message_processing_model(self) -> pulumi.Input[builtins.str]:
        """
        enum: `v1`, `v2c`, `v3`
        """
        return pulumi.get(self, "message_processing_model")

    @message_processing_model.setter
    def message_processing_model(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "message_processing_model", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notifyFilter")
    def notify_filter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to profile-name in notify_filter
        """
        return pulumi.get(self, "notify_filter")

    @notify_filter.setter
    def notify_filter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "notify_filter", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_model", value)

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to security_name in usm
        """
        return pulumi.get(self, "security_name")

    @security_name.setter
    def security_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_name", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigUsmArgsDict(TypedDict):
        engine_type: pulumi.Input[builtins.str]
        """
        enum: `local_engine`, `remote_engine`
        """
        remote_engine_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required only if `engine_type`==`remote_engine`
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgsDict']]]]
elif False:
    NetworktemplateSnmpConfigV3ConfigUsmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigUsmArgs:
    def __init__(__self__, *,
                 engine_type: pulumi.Input[builtins.str],
                 remote_engine_id: Optional[pulumi.Input[builtins.str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] engine_type: enum: `local_engine`, `remote_engine`
        :param pulumi.Input[builtins.str] remote_engine_id: Required only if `engine_type`==`remote_engine`
        """
        pulumi.set(__self__, "engine_type", engine_type)
        if remote_engine_id is not None:
            pulumi.set(__self__, "remote_engine_id", remote_engine_id)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> pulumi.Input[builtins.str]:
        """
        enum: `local_engine`, `remote_engine`
        """
        return pulumi.get(self, "engine_type")

    @engine_type.setter
    def engine_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "engine_type", value)

    @property
    @pulumi.getter(name="remoteEngineId")
    def remote_engine_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required only if `engine_type`==`remote_engine`
        """
        return pulumi.get(self, "remote_engine_id")

    @remote_engine_id.setter
    def remote_engine_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remote_engine_id", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgs']]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigUsmUserArgsDict(TypedDict):
        authentication_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        authentication_type: NotRequired[pulumi.Input[builtins.str]]
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        """
        encryption_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        encryption_type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateSnmpConfigV3ConfigUsmUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigUsmUserArgs:
    def __init__(__self__, *,
                 authentication_password: Optional[pulumi.Input[builtins.str]] = None,
                 authentication_type: Optional[pulumi.Input[builtins.str]] = None,
                 encryption_password: Optional[pulumi.Input[builtins.str]] = None,
                 encryption_type: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] authentication_password: Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        :param pulumi.Input[builtins.str] authentication_type: sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        :param pulumi.Input[builtins.str] encryption_password: Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        :param pulumi.Input[builtins.str] encryption_type: enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        if authentication_password is not None:
            pulumi.set(__self__, "authentication_password", authentication_password)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="authenticationPassword")
    def authentication_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        return pulumi.get(self, "authentication_password")

    @authentication_password.setter
    def authentication_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authentication_password", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        return pulumi.get(self, "encryption_password")

    @encryption_password.setter
    def encryption_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encryption_password", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigVacmArgsDict(TypedDict):
        accesses: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgsDict']]]]
        security_to_group: NotRequired[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgsDict']]
elif False:
    NetworktemplateSnmpConfigV3ConfigVacmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmArgs:
    def __init__(__self__, *,
                 accesses: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgs']]]] = None,
                 security_to_group: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs']] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if security_to_group is not None:
            pulumi.set(__self__, "security_to_group", security_to_group)

    @property
    @pulumi.getter
    def accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgs']]]]:
        return pulumi.get(self, "accesses")

    @accesses.setter
    def accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgs']]]]):
        pulumi.set(self, "accesses", value)

    @property
    @pulumi.getter(name="securityToGroup")
    def security_to_group(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs']]:
        return pulumi.get(self, "security_to_group")

    @security_to_group.setter
    def security_to_group(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs']]):
        pulumi.set(self, "security_to_group", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigVacmAccessArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[builtins.str]]
        prefix_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgsDict']]]]
elif False:
    NetworktemplateSnmpConfigV3ConfigVacmAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmAccessArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[builtins.str]] = None,
                 prefix_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]]:
        return pulumi.get(self, "prefix_lists")

    @prefix_lists.setter
    def prefix_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]]):
        pulumi.set(self, "prefix_lists", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgsDict(TypedDict):
        context_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        Only required if `type`==`context_prefix`
        """
        notify_view: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to view name
        """
        read_view: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to view name
        """
        security_level: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `authentication`, `none`, `privacy`
        """
        security_model: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        write_view: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to view name
        """
elif False:
    NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs:
    def __init__(__self__, *,
                 context_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 notify_view: Optional[pulumi.Input[builtins.str]] = None,
                 read_view: Optional[pulumi.Input[builtins.str]] = None,
                 security_level: Optional[pulumi.Input[builtins.str]] = None,
                 security_model: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 write_view: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] context_prefix: Only required if `type`==`context_prefix`
        :param pulumi.Input[builtins.str] notify_view: Refer to view name
        :param pulumi.Input[builtins.str] read_view: Refer to view name
        :param pulumi.Input[builtins.str] security_level: enum: `authentication`, `none`, `privacy`
        :param pulumi.Input[builtins.str] security_model: enum: `any`, `usm`, `v1`, `v2c`
        :param pulumi.Input[builtins.str] type: enum: `context_prefix`, `default_context_prefix`
        :param pulumi.Input[builtins.str] write_view: Refer to view name
        """
        if context_prefix is not None:
            pulumi.set(__self__, "context_prefix", context_prefix)
        if notify_view is not None:
            pulumi.set(__self__, "notify_view", notify_view)
        if read_view is not None:
            pulumi.set(__self__, "read_view", read_view)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if write_view is not None:
            pulumi.set(__self__, "write_view", write_view)

    @property
    @pulumi.getter(name="contextPrefix")
    def context_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only required if `type`==`context_prefix`
        """
        return pulumi.get(self, "context_prefix")

    @context_prefix.setter
    def context_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "context_prefix", value)

    @property
    @pulumi.getter(name="notifyView")
    def notify_view(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to view name
        """
        return pulumi.get(self, "notify_view")

    @notify_view.setter
    def notify_view(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "notify_view", value)

    @property
    @pulumi.getter(name="readView")
    def read_view(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to view name
        """
        return pulumi.get(self, "read_view")

    @read_view.setter
    def read_view(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read_view", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_model", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="writeView")
    def write_view(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to view name
        """
        return pulumi.get(self, "write_view")

    @write_view.setter
    def write_view(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "write_view", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict']]]]
        security_model: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `usm`, `v1`, `v2c`
        """
elif False:
    NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]] = None,
                 security_model: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] security_model: enum: `usm`, `v1`, `v2c`
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_model", value)


if not MYPY:
    class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        """
        Refer to group_name under access
        """
        security_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 security_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group: Refer to group_name under access
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Refer to group_name under access
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "security_name")

    @security_name.setter
    def security_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_name", value)


if not MYPY:
    class NetworktemplateSnmpConfigViewArgsDict(TypedDict):
        include: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the root oid configured is included
        """
        oid: NotRequired[pulumi.Input[builtins.str]]
        view_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworktemplateSnmpConfigViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSnmpConfigViewArgs:
    def __init__(__self__, *,
                 include: Optional[pulumi.Input[builtins.bool]] = None,
                 oid: Optional[pulumi.Input[builtins.str]] = None,
                 view_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] include: If the root oid configured is included
        """
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the root oid configured is included
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter
    def oid(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "oid")

    @oid.setter
    def oid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "oid", value)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "view_name")

    @view_name.setter
    def view_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "view_name", value)


if not MYPY:
    class NetworktemplateSwitchMatchingArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[builtins.bool]]
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgsDict']]]]
        """
        list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined
        """
elif False:
    NetworktemplateSwitchMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMatchingArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]] rules: list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]]]:
        """
        list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class NetworktemplateSwitchMatchingRuleArgsDict(TypedDict):
        additional_config_cmds: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        additional CLI commands to append to the generated Junos config. **Note**: no check is done
        """
        ip_config: NotRequired[pulumi.Input['NetworktemplateSwitchMatchingRuleIpConfigArgsDict']]
        """
        In-Band Management interface configuration
        """
        match_model: NotRequired[pulumi.Input[builtins.str]]
        """
        string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes
        """
        match_name: NotRequired[pulumi.Input[builtins.str]]
        """
        string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes
        """
        match_name_offset: NotRequired[pulumi.Input[builtins.int]]
        """
        first character of the switch name to compare to the `match_name` value
        """
        match_role: NotRequired[pulumi.Input[builtins.str]]
        """
        string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes
        """
        match_type: NotRequired[pulumi.Input[builtins.str]]
        """
        property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        """
        match_value: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list
        """
        oob_ip_config: NotRequired[pulumi.Input['NetworktemplateSwitchMatchingRuleOobIpConfigArgsDict']]
        """
        Out-of-Band Management interface configuration
        """
        port_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgsDict']]]]
        """
        Property key is the port name or range (e.g. "ge-0/0/0-10")
        """
        port_mirroring: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgsDict']]]]
        """
        Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed
        """
elif False:
    NetworktemplateSwitchMatchingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMatchingRuleArgs:
    def __init__(__self__, *,
                 additional_config_cmds: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ip_config: Optional[pulumi.Input['NetworktemplateSwitchMatchingRuleIpConfigArgs']] = None,
                 match_model: Optional[pulumi.Input[builtins.str]] = None,
                 match_name: Optional[pulumi.Input[builtins.str]] = None,
                 match_name_offset: Optional[pulumi.Input[builtins.int]] = None,
                 match_role: Optional[pulumi.Input[builtins.str]] = None,
                 match_type: Optional[pulumi.Input[builtins.str]] = None,
                 match_value: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 oob_ip_config: Optional[pulumi.Input['NetworktemplateSwitchMatchingRuleOobIpConfigArgs']] = None,
                 port_config: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]]] = None,
                 port_mirroring: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] additional_config_cmds: additional CLI commands to append to the generated Junos config. **Note**: no check is done
        :param pulumi.Input['NetworktemplateSwitchMatchingRuleIpConfigArgs'] ip_config: In-Band Management interface configuration
        :param pulumi.Input[builtins.str] match_model: string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes
        :param pulumi.Input[builtins.str] match_name: string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes
        :param pulumi.Input[builtins.int] match_name_offset: first character of the switch name to compare to the `match_name` value
        :param pulumi.Input[builtins.str] match_role: string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes
        :param pulumi.Input[builtins.str] match_type: property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        :param pulumi.Input[builtins.str] name: Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list
        :param pulumi.Input['NetworktemplateSwitchMatchingRuleOobIpConfigArgs'] oob_ip_config: Out-of-Band Management interface configuration
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]] port_config: Property key is the port name or range (e.g. "ge-0/0/0-10")
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]] port_mirroring: Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed
        """
        if additional_config_cmds is not None:
            pulumi.set(__self__, "additional_config_cmds", additional_config_cmds)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if match_model is not None:
            pulumi.set(__self__, "match_model", match_model)
        if match_name is not None:
            pulumi.set(__self__, "match_name", match_name)
        if match_name_offset is not None:
            pulumi.set(__self__, "match_name_offset", match_name_offset)
        if match_role is not None:
            pulumi.set(__self__, "match_role", match_role)
        if match_type is not None:
            warnings.warn("""The `match_type` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `match_name`, `match_model` and `match_role`attribuites and may be removed in future versions.
Please update your configurations.""", DeprecationWarning)
            pulumi.log.warn("""match_type is deprecated: The `match_type` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `match_name`, `match_model` and `match_role`attribuites and may be removed in future versions.
Please update your configurations.""")
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            warnings.warn("""The `match_value` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `match_name`, `match_model` and `match_role`attribuites and may be removed in future versions.
Please update your configurations.""", DeprecationWarning)
            pulumi.log.warn("""match_value is deprecated: The `match_value` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `match_name`, `match_model` and `match_role`attribuites and may be removed in future versions.
Please update your configurations.""")
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if oob_ip_config is not None:
            pulumi.set(__self__, "oob_ip_config", oob_ip_config)
        if port_config is not None:
            pulumi.set(__self__, "port_config", port_config)
        if port_mirroring is not None:
            pulumi.set(__self__, "port_mirroring", port_mirroring)

    @property
    @pulumi.getter(name="additionalConfigCmds")
    def additional_config_cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        additional CLI commands to append to the generated Junos config. **Note**: no check is done
        """
        return pulumi.get(self, "additional_config_cmds")

    @additional_config_cmds.setter
    def additional_config_cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "additional_config_cmds", value)

    @property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional[pulumi.Input['NetworktemplateSwitchMatchingRuleIpConfigArgs']]:
        """
        In-Band Management interface configuration
        """
        return pulumi.get(self, "ip_config")

    @ip_config.setter
    def ip_config(self, value: Optional[pulumi.Input['NetworktemplateSwitchMatchingRuleIpConfigArgs']]):
        pulumi.set(self, "ip_config", value)

    @property
    @pulumi.getter(name="matchModel")
    def match_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes
        """
        return pulumi.get(self, "match_model")

    @match_model.setter
    def match_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_model", value)

    @property
    @pulumi.getter(name="matchName")
    def match_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes
        """
        return pulumi.get(self, "match_name")

    @match_name.setter
    def match_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_name", value)

    @property
    @pulumi.getter(name="matchNameOffset")
    def match_name_offset(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        first character of the switch name to compare to the `match_name` value
        """
        return pulumi.get(self, "match_name_offset")

    @match_name_offset.setter
    def match_name_offset(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "match_name_offset", value)

    @property
    @pulumi.getter(name="matchRole")
    def match_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes
        """
        return pulumi.get(self, "match_role")

    @match_role.setter
    def match_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_role", value)

    @property
    @pulumi.getter(name="matchType")
    @_utilities.deprecated("""The `match_type` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `match_name`, `match_model` and `match_role`attribuites and may be removed in future versions.
Please update your configurations.""")
    def match_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    @_utilities.deprecated("""The `match_value` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `match_name`, `match_model` and `match_role`attribuites and may be removed in future versions.
Please update your configurations.""")
    def match_value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="oobIpConfig")
    def oob_ip_config(self) -> Optional[pulumi.Input['NetworktemplateSwitchMatchingRuleOobIpConfigArgs']]:
        """
        Out-of-Band Management interface configuration
        """
        return pulumi.get(self, "oob_ip_config")

    @oob_ip_config.setter
    def oob_ip_config(self, value: Optional[pulumi.Input['NetworktemplateSwitchMatchingRuleOobIpConfigArgs']]):
        pulumi.set(self, "oob_ip_config", value)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]]]:
        """
        Property key is the port name or range (e.g. "ge-0/0/0-10")
        """
        return pulumi.get(self, "port_config")

    @port_config.setter
    def port_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]]]):
        pulumi.set(self, "port_config", value)

    @property
    @pulumi.getter(name="portMirroring")
    def port_mirroring(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]]]:
        """
        Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed
        """
        return pulumi.get(self, "port_mirroring")

    @port_mirroring.setter
    def port_mirroring(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]]]):
        pulumi.set(self, "port_mirroring", value)


if not MYPY:
    class NetworktemplateSwitchMatchingRuleIpConfigArgsDict(TypedDict):
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        VLAN Name for the management interface
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
elif False:
    NetworktemplateSwitchMatchingRuleIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMatchingRuleIpConfigArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] network: VLAN Name for the management interface
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        VLAN Name for the management interface
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworktemplateSwitchMatchingRuleOobIpConfigArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[builtins.bool]]
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[builtins.bool]]
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
elif False:
    NetworktemplateSwitchMatchingRuleOobIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMatchingRuleOobIpConfigArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[builtins.bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] type: enum: `dhcp`, `static`
        :param pulumi.Input[builtins.bool] use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[builtins.bool] use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)


if not MYPY:
    class NetworktemplateSwitchMatchingRulePortConfigArgsDict(TypedDict):
        usage: pulumi.Input[builtins.str]
        """
        Port usage name. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        ae_disable_lacp: NotRequired[pulumi.Input[builtins.bool]]
        """
        To disable LACP support for the AE interface
        """
        ae_idx: NotRequired[pulumi.Input[builtins.int]]
        """
        Users could force to use the designated AE name
        """
        ae_lacp_slow: NotRequired[pulumi.Input[builtins.bool]]
        """
        To use fast timeout
        """
        aggregated: NotRequired[pulumi.Input[builtins.bool]]
        critical: NotRequired[pulumi.Input[builtins.bool]]
        """
        To generate port up/down alarm
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        disable_autoneg: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        duplex: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `full`, `half`
        """
        dynamic_usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        esilag: NotRequired[pulumi.Input[builtins.bool]]
        mtu: NotRequired[pulumi.Input[builtins.int]]
        """
        Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        no_local_overwrite: NotRequired[pulumi.Input[builtins.bool]]
        """
        Prevent helpdesk to override the port config
        """
        poe_disabled: NotRequired[pulumi.Input[builtins.bool]]
        speed: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
elif False:
    NetworktemplateSwitchMatchingRulePortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMatchingRulePortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[builtins.str],
                 ae_disable_lacp: Optional[pulumi.Input[builtins.bool]] = None,
                 ae_idx: Optional[pulumi.Input[builtins.int]] = None,
                 ae_lacp_slow: Optional[pulumi.Input[builtins.bool]] = None,
                 aggregated: Optional[pulumi.Input[builtins.bool]] = None,
                 critical: Optional[pulumi.Input[builtins.bool]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disable_autoneg: Optional[pulumi.Input[builtins.bool]] = None,
                 duplex: Optional[pulumi.Input[builtins.str]] = None,
                 dynamic_usage: Optional[pulumi.Input[builtins.str]] = None,
                 esilag: Optional[pulumi.Input[builtins.bool]] = None,
                 mtu: Optional[pulumi.Input[builtins.int]] = None,
                 no_local_overwrite: Optional[pulumi.Input[builtins.bool]] = None,
                 poe_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 speed: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] usage: Port usage name. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param pulumi.Input[builtins.bool] ae_disable_lacp: To disable LACP support for the AE interface
        :param pulumi.Input[builtins.int] ae_idx: Users could force to use the designated AE name
        :param pulumi.Input[builtins.bool] ae_lacp_slow: To use fast timeout
        :param pulumi.Input[builtins.bool] critical: To generate port up/down alarm
        :param pulumi.Input[builtins.bool] disable_autoneg: If `speed` and `duplex` are specified, whether to disable autonegotiation
        :param pulumi.Input[builtins.str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input[builtins.str] dynamic_usage: Enable dynamic usage for this port. Set to `dynamic` to enable.
        :param pulumi.Input[builtins.int] mtu: Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param pulumi.Input[builtins.bool] no_local_overwrite: Prevent helpdesk to override the port config
        :param pulumi.Input[builtins.str] speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_slow is not None:
            pulumi.set(__self__, "ae_lacp_slow", ae_lacp_slow)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_usage is not None:
            pulumi.set(__self__, "dynamic_usage", dynamic_usage)
        if esilag is not None:
            pulumi.set(__self__, "esilag", esilag)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if no_local_overwrite is not None:
            pulumi.set(__self__, "no_local_overwrite", no_local_overwrite)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[builtins.str]:
        """
        Port usage name. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To disable LACP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @ae_disable_lacp.setter
    def ae_disable_lacp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ae_disable_lacp", value)

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Users could force to use the designated AE name
        """
        return pulumi.get(self, "ae_idx")

    @ae_idx.setter
    def ae_idx(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ae_idx", value)

    @property
    @pulumi.getter(name="aeLacpSlow")
    def ae_lacp_slow(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To use fast timeout
        """
        return pulumi.get(self, "ae_lacp_slow")

    @ae_lacp_slow.setter
    def ae_lacp_slow(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ae_lacp_slow", value)

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "aggregated")

    @aggregated.setter
    def aggregated(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "aggregated", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="dynamicUsage")
    def dynamic_usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        return pulumi.get(self, "dynamic_usage")

    @dynamic_usage.setter
    def dynamic_usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dynamic_usage", value)

    @property
    @pulumi.getter
    def esilag(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "esilag")

    @esilag.setter
    def esilag(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "esilag", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="noLocalOverwrite")
    def no_local_overwrite(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Prevent helpdesk to override the port config
        """
        return pulumi.get(self, "no_local_overwrite")

    @no_local_overwrite.setter
    def no_local_overwrite(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_local_overwrite", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "speed", value)


if not MYPY:
    class NetworktemplateSwitchMatchingRulePortMirroringArgsDict(TypedDict):
        input_networks_ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        input_port_ids_egresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        input_port_ids_ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        output_network: NotRequired[pulumi.Input[builtins.str]]
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
        output_port_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
elif False:
    NetworktemplateSwitchMatchingRulePortMirroringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMatchingRulePortMirroringArgs:
    def __init__(__self__, *,
                 input_networks_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 input_port_ids_egresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 input_port_ids_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 output_network: Optional[pulumi.Input[builtins.str]] = None,
                 output_port_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_networks_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_port_ids_egresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_port_ids_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[builtins.str] output_network: Exactly one of the `output_port_id` or `output_network` should be provided
        :param pulumi.Input[builtins.str] output_port_id: Exactly one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @input_networks_ingresses.setter
    def input_networks_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_networks_ingresses", value)

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @input_port_ids_egresses.setter
    def input_port_ids_egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_port_ids_egresses", value)

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @input_port_ids_ingresses.setter
    def input_port_ids_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_port_ids_ingresses", value)

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @output_network.setter
    def output_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "output_network", value)

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Exactly one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")

    @output_port_id.setter
    def output_port_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "output_port_id", value)


if not MYPY:
    class NetworktemplateSwitchMgmtArgsDict(TypedDict):
        ap_affinity_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        cli_banner: NotRequired[pulumi.Input[builtins.str]]
        """
        Set Banners for switches. Allows markup formatting
        """
        cli_idle_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets timeout for switches
        """
        config_revert_timer: NotRequired[pulumi.Input[builtins.int]]
        """
        Rollback timer for commit confirmed
        """
        dhcp_option_fqdn: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable to provide the FQDN with DHCP option 81
        """
        disable_oob_down_alarm: NotRequired[pulumi.Input[builtins.bool]]
        fips_enabled: NotRequired[pulumi.Input[builtins.bool]]
        local_accounts: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMgmtLocalAccountsArgsDict']]]]
        """
        Property key is the user name. For Local user authentication
        """
        mxedge_proxy_host: NotRequired[pulumi.Input[builtins.str]]
        """
        IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        """
        mxedge_proxy_port: NotRequired[pulumi.Input[builtins.str]]
        """
        Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        """
        protect_re: NotRequired[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgsDict']]
        """
        Restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        root_password: NotRequired[pulumi.Input[builtins.str]]
        tacacs: NotRequired[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgsDict']]
        use_mxedge_proxy: NotRequired[pulumi.Input[builtins.bool]]
        """
        To use mxedge as proxy
        """
elif False:
    NetworktemplateSwitchMgmtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtArgs:
    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 cli_banner: Optional[pulumi.Input[builtins.str]] = None,
                 cli_idle_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 config_revert_timer: Optional[pulumi.Input[builtins.int]] = None,
                 dhcp_option_fqdn: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_oob_down_alarm: Optional[pulumi.Input[builtins.bool]] = None,
                 fips_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 local_accounts: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMgmtLocalAccountsArgs']]]] = None,
                 mxedge_proxy_host: Optional[pulumi.Input[builtins.str]] = None,
                 mxedge_proxy_port: Optional[pulumi.Input[builtins.str]] = None,
                 protect_re: Optional[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs']] = None,
                 root_password: Optional[pulumi.Input[builtins.str]] = None,
                 tacacs: Optional[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgs']] = None,
                 use_mxedge_proxy: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] ap_affinity_threshold: AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        :param pulumi.Input[builtins.str] cli_banner: Set Banners for switches. Allows markup formatting
        :param pulumi.Input[builtins.int] cli_idle_timeout: Sets timeout for switches
        :param pulumi.Input[builtins.int] config_revert_timer: Rollback timer for commit confirmed
        :param pulumi.Input[builtins.bool] dhcp_option_fqdn: Enable to provide the FQDN with DHCP option 81
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMgmtLocalAccountsArgs']]] local_accounts: Property key is the user name. For Local user authentication
        :param pulumi.Input[builtins.str] mxedge_proxy_host: IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        :param pulumi.Input[builtins.str] mxedge_proxy_port: Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        :param pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs'] protect_re: Restrict inbound-traffic to host
               when enabled, all traffic that is not essential to our operation will be dropped 
               e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        :param pulumi.Input[builtins.bool] use_mxedge_proxy: To use mxedge as proxy
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)
        if cli_banner is not None:
            pulumi.set(__self__, "cli_banner", cli_banner)
        if cli_idle_timeout is not None:
            pulumi.set(__self__, "cli_idle_timeout", cli_idle_timeout)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if dhcp_option_fqdn is not None:
            pulumi.set(__self__, "dhcp_option_fqdn", dhcp_option_fqdn)
        if disable_oob_down_alarm is not None:
            pulumi.set(__self__, "disable_oob_down_alarm", disable_oob_down_alarm)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if local_accounts is not None:
            pulumi.set(__self__, "local_accounts", local_accounts)
        if mxedge_proxy_host is not None:
            pulumi.set(__self__, "mxedge_proxy_host", mxedge_proxy_host)
        if mxedge_proxy_port is not None:
            pulumi.set(__self__, "mxedge_proxy_port", mxedge_proxy_port)
        if protect_re is not None:
            pulumi.set(__self__, "protect_re", protect_re)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if tacacs is not None:
            pulumi.set(__self__, "tacacs", tacacs)
        if use_mxedge_proxy is not None:
            pulumi.set(__self__, "use_mxedge_proxy", use_mxedge_proxy)

    @property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")

    @ap_affinity_threshold.setter
    def ap_affinity_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ap_affinity_threshold", value)

    @property
    @pulumi.getter(name="cliBanner")
    def cli_banner(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set Banners for switches. Allows markup formatting
        """
        return pulumi.get(self, "cli_banner")

    @cli_banner.setter
    def cli_banner(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cli_banner", value)

    @property
    @pulumi.getter(name="cliIdleTimeout")
    def cli_idle_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets timeout for switches
        """
        return pulumi.get(self, "cli_idle_timeout")

    @cli_idle_timeout.setter
    def cli_idle_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cli_idle_timeout", value)

    @property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @config_revert_timer.setter
    def config_revert_timer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "config_revert_timer", value)

    @property
    @pulumi.getter(name="dhcpOptionFqdn")
    def dhcp_option_fqdn(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable to provide the FQDN with DHCP option 81
        """
        return pulumi.get(self, "dhcp_option_fqdn")

    @dhcp_option_fqdn.setter
    def dhcp_option_fqdn(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dhcp_option_fqdn", value)

    @property
    @pulumi.getter(name="disableOobDownAlarm")
    def disable_oob_down_alarm(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disable_oob_down_alarm")

    @disable_oob_down_alarm.setter
    def disable_oob_down_alarm(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_oob_down_alarm", value)

    @property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "fips_enabled")

    @fips_enabled.setter
    def fips_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fips_enabled", value)

    @property
    @pulumi.getter(name="localAccounts")
    def local_accounts(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMgmtLocalAccountsArgs']]]]:
        """
        Property key is the user name. For Local user authentication
        """
        return pulumi.get(self, "local_accounts")

    @local_accounts.setter
    def local_accounts(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMgmtLocalAccountsArgs']]]]):
        pulumi.set(self, "local_accounts", value)

    @property
    @pulumi.getter(name="mxedgeProxyHost")
    def mxedge_proxy_host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        """
        return pulumi.get(self, "mxedge_proxy_host")

    @mxedge_proxy_host.setter
    def mxedge_proxy_host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mxedge_proxy_host", value)

    @property
    @pulumi.getter(name="mxedgeProxyPort")
    def mxedge_proxy_port(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        """
        return pulumi.get(self, "mxedge_proxy_port")

    @mxedge_proxy_port.setter
    def mxedge_proxy_port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mxedge_proxy_port", value)

    @property
    @pulumi.getter(name="protectRe")
    def protect_re(self) -> Optional[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs']]:
        """
        Restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "protect_re")

    @protect_re.setter
    def protect_re(self, value: Optional[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs']]):
        pulumi.set(self, "protect_re", value)

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "root_password")

    @root_password.setter
    def root_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "root_password", value)

    @property
    @pulumi.getter
    def tacacs(self) -> Optional[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgs']]:
        return pulumi.get(self, "tacacs")

    @tacacs.setter
    def tacacs(self, value: Optional[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgs']]):
        pulumi.set(self, "tacacs", value)

    @property
    @pulumi.getter(name="useMxedgeProxy")
    def use_mxedge_proxy(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To use mxedge as proxy
        """
        return pulumi.get(self, "use_mxedge_proxy")

    @use_mxedge_proxy.setter
    def use_mxedge_proxy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mxedge_proxy", value)


if not MYPY:
    class NetworktemplateSwitchMgmtLocalAccountsArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[builtins.str]]
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
elif False:
    NetworktemplateSwitchMgmtLocalAccountsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtLocalAccountsArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] role: enum: `admin`, `helpdesk`, `none`, `read`
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class NetworktemplateSwitchMgmtProtectReArgsDict(TypedDict):
        allowed_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        optionally, services we'll allow. enum: `icmp`, `ssh`
        """
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgsDict']]]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        When enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        trusted_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        host/subnets we'll allow traffic to/from
        """
elif False:
    NetworktemplateSwitchMgmtProtectReArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtProtectReArgs:
    def __init__(__self__, *,
                 allowed_services: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 trusted_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_services: optionally, services we'll allow. enum: `icmp`, `ssh`
        :param pulumi.Input[builtins.bool] enabled: When enabled, all traffic that is not essential to our operation will be dropped
               e.g. ntp / dns / traffic to mist will be allowed by default
                    if dhcpd is enabled, we'll make sure it works
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] trusted_hosts: host/subnets we'll allow traffic to/from
        """
        if allowed_services is not None:
            pulumi.set(__self__, "allowed_services", allowed_services)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if trusted_hosts is not None:
            pulumi.set(__self__, "trusted_hosts", trusted_hosts)

    @property
    @pulumi.getter(name="allowedServices")
    def allowed_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        optionally, services we'll allow. enum: `icmp`, `ssh`
        """
        return pulumi.get(self, "allowed_services")

    @allowed_services.setter
    def allowed_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_services", value)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgs']]]]:
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="trustedHosts")
    def trusted_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        host/subnets we'll allow traffic to/from
        """
        return pulumi.get(self, "trusted_hosts")

    @trusted_hosts.setter
    def trusted_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "trusted_hosts", value)


if not MYPY:
    class NetworktemplateSwitchMgmtProtectReCustomArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        port_range: NotRequired[pulumi.Input[builtins.str]]
        """
        matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
elif False:
    NetworktemplateSwitchMgmtProtectReCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtProtectReCustomArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 port_range: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] port_range: matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        :param pulumi.Input[builtins.str] protocol: enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        pulumi.set(__self__, "subnets", subnets)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class NetworktemplateSwitchMgmtTacacsArgsDict(TypedDict):
        acct_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgsDict']]]]
        default_role: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        Which network the TACACS server resides
        """
        tacplus_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgsDict']]]]
elif False:
    NetworktemplateSwitchMgmtTacacsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtTacacsArgs:
    def __init__(__self__, *,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgs']]]] = None,
                 default_role: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 tacplus_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] default_role: enum: `admin`, `helpdesk`, `none`, `read`
        :param pulumi.Input[builtins.str] network: Which network the TACACS server resides
        """
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if default_role is not None:
            pulumi.set(__self__, "default_role", default_role)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if tacplus_servers is not None:
            pulumi.set(__self__, "tacplus_servers", tacplus_servers)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgs']]]]:
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter(name="defaultRole")
    def default_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "default_role")

    @default_role.setter
    def default_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_role", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Which network the TACACS server resides
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="tacplusServers")
    def tacplus_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgs']]]]:
        return pulumi.get(self, "tacplus_servers")

    @tacplus_servers.setter
    def tacplus_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgs']]]]):
        pulumi.set(self, "tacplus_servers", value)


if not MYPY:
    class NetworktemplateSwitchMgmtTacacsAcctServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        secret: NotRequired[pulumi.Input[builtins.str]]
        timeout: NotRequired[pulumi.Input[builtins.int]]
elif False:
    NetworktemplateSwitchMgmtTacacsAcctServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtTacacsAcctServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 secret: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class NetworktemplateSwitchMgmtTacacsTacplusServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        secret: NotRequired[pulumi.Input[builtins.str]]
        timeout: NotRequired[pulumi.Input[builtins.int]]
elif False:
    NetworktemplateSwitchMgmtTacacsTacplusServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateSwitchMgmtTacacsTacplusServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 secret: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class NetworktemplateVrfConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable VRF (when supported on the device)
        """
elif False:
    NetworktemplateVrfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateVrfConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NetworktemplateVrfInstancesArgsDict(TypedDict):
        evpn_auto_loopback_subnet: NotRequired[pulumi.Input[builtins.str]]
        evpn_auto_loopback_subnet6: NotRequired[pulumi.Input[builtins.str]]
        extra_routes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutesArgsDict']]]]
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        extra_routes6: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutes6ArgsDict']]]]
        """
        Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    NetworktemplateVrfInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateVrfInstancesArgs:
    def __init__(__self__, *,
                 evpn_auto_loopback_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 evpn_auto_loopback_subnet6: Optional[pulumi.Input[builtins.str]] = None,
                 extra_routes: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutesArgs']]]] = None,
                 extra_routes6: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutes6Args']]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutesArgs']]] extra_routes: Property key is the destination CIDR (e.g. "10.0.0.0/8")
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutes6Args']]] extra_routes6: Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        if evpn_auto_loopback_subnet is not None:
            pulumi.set(__self__, "evpn_auto_loopback_subnet", evpn_auto_loopback_subnet)
        if evpn_auto_loopback_subnet6 is not None:
            pulumi.set(__self__, "evpn_auto_loopback_subnet6", evpn_auto_loopback_subnet6)
        if extra_routes is not None:
            pulumi.set(__self__, "extra_routes", extra_routes)
        if extra_routes6 is not None:
            pulumi.set(__self__, "extra_routes6", extra_routes6)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="evpnAutoLoopbackSubnet")
    def evpn_auto_loopback_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "evpn_auto_loopback_subnet")

    @evpn_auto_loopback_subnet.setter
    def evpn_auto_loopback_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "evpn_auto_loopback_subnet", value)

    @property
    @pulumi.getter(name="evpnAutoLoopbackSubnet6")
    def evpn_auto_loopback_subnet6(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "evpn_auto_loopback_subnet6")

    @evpn_auto_loopback_subnet6.setter
    def evpn_auto_loopback_subnet6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "evpn_auto_loopback_subnet6", value)

    @property
    @pulumi.getter(name="extraRoutes")
    def extra_routes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutesArgs']]]]:
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        return pulumi.get(self, "extra_routes")

    @extra_routes.setter
    def extra_routes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutesArgs']]]]):
        pulumi.set(self, "extra_routes", value)

    @property
    @pulumi.getter(name="extraRoutes6")
    def extra_routes6(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutes6Args']]]]:
        """
        Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        return pulumi.get(self, "extra_routes6")

    @extra_routes6.setter
    def extra_routes6(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesExtraRoutes6Args']]]]):
        pulumi.set(self, "extra_routes6", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class NetworktemplateVrfInstancesExtraRoutes6ArgsDict(TypedDict):
        via: NotRequired[pulumi.Input[builtins.str]]
        """
        Next-hop address
        """
elif False:
    NetworktemplateVrfInstancesExtraRoutes6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateVrfInstancesExtraRoutes6Args:
    def __init__(__self__, *,
                 via: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] via: Next-hop address
        """
        if via is not None:
            pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "via", value)


if not MYPY:
    class NetworktemplateVrfInstancesExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[builtins.str]
        """
        Next-hop address
        """
elif False:
    NetworktemplateVrfInstancesExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworktemplateVrfInstancesExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] via: Next-hop address
        """
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[builtins.str]:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class RftemplateBand24ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    RftemplateBand24ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateBand24Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class RftemplateBand5ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    RftemplateBand5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateBand5Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class RftemplateBand5On24RadioArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    RftemplateBand5On24RadioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateBand5On24RadioArgs:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class RftemplateBand6ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
        standard_power: NotRequired[pulumi.Input[builtins.bool]]
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
elif False:
    RftemplateBand6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateBand6Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None,
                 standard_power: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        :param pulumi.Input[builtins.bool] standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)

    @property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")

    @standard_power.setter
    def standard_power(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "standard_power", value)


if not MYPY:
    class RftemplateModelSpecificArgsDict(TypedDict):
        ant_gain24: NotRequired[pulumi.Input[builtins.int]]
        ant_gain5: NotRequired[pulumi.Input[builtins.int]]
        ant_gain6: NotRequired[pulumi.Input[builtins.int]]
        band24: NotRequired[pulumi.Input['RftemplateModelSpecificBand24ArgsDict']]
        """
        Radio Band AP settings
        """
        band24_usage: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `24`, `5`, `6`, `auto`
        """
        band5: NotRequired[pulumi.Input['RftemplateModelSpecificBand5ArgsDict']]
        """
        Radio Band AP settings
        """
        band5_on24_radio: NotRequired[pulumi.Input['RftemplateModelSpecificBand5On24RadioArgsDict']]
        """
        Radio Band AP settings
        """
        band6: NotRequired[pulumi.Input['RftemplateModelSpecificBand6ArgsDict']]
        """
        Radio Band AP settings
        """
elif False:
    RftemplateModelSpecificArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateModelSpecificArgs:
    def __init__(__self__, *,
                 ant_gain24: Optional[pulumi.Input[builtins.int]] = None,
                 ant_gain5: Optional[pulumi.Input[builtins.int]] = None,
                 ant_gain6: Optional[pulumi.Input[builtins.int]] = None,
                 band24: Optional[pulumi.Input['RftemplateModelSpecificBand24Args']] = None,
                 band24_usage: Optional[pulumi.Input[builtins.str]] = None,
                 band5: Optional[pulumi.Input['RftemplateModelSpecificBand5Args']] = None,
                 band5_on24_radio: Optional[pulumi.Input['RftemplateModelSpecificBand5On24RadioArgs']] = None,
                 band6: Optional[pulumi.Input['RftemplateModelSpecificBand6Args']] = None):
        """
        :param pulumi.Input['RftemplateModelSpecificBand24Args'] band24: Radio Band AP settings
        :param pulumi.Input[builtins.str] band24_usage: enum: `24`, `5`, `6`, `auto`
        :param pulumi.Input['RftemplateModelSpecificBand5Args'] band5: Radio Band AP settings
        :param pulumi.Input['RftemplateModelSpecificBand5On24RadioArgs'] band5_on24_radio: Radio Band AP settings
        :param pulumi.Input['RftemplateModelSpecificBand6Args'] band6: Radio Band AP settings
        """
        if ant_gain24 is not None:
            pulumi.set(__self__, "ant_gain24", ant_gain24)
        if ant_gain5 is not None:
            pulumi.set(__self__, "ant_gain5", ant_gain5)
        if ant_gain6 is not None:
            pulumi.set(__self__, "ant_gain6", ant_gain6)
        if band24 is not None:
            pulumi.set(__self__, "band24", band24)
        if band24_usage is not None:
            pulumi.set(__self__, "band24_usage", band24_usage)
        if band5 is not None:
            pulumi.set(__self__, "band5", band5)
        if band5_on24_radio is not None:
            pulumi.set(__self__, "band5_on24_radio", band5_on24_radio)
        if band6 is not None:
            pulumi.set(__self__, "band6", band6)

    @property
    @pulumi.getter(name="antGain24")
    def ant_gain24(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain24")

    @ant_gain24.setter
    def ant_gain24(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain24", value)

    @property
    @pulumi.getter(name="antGain5")
    def ant_gain5(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain5")

    @ant_gain5.setter
    def ant_gain5(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain5", value)

    @property
    @pulumi.getter(name="antGain6")
    def ant_gain6(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain6")

    @ant_gain6.setter
    def ant_gain6(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain6", value)

    @property
    @pulumi.getter
    def band24(self) -> Optional[pulumi.Input['RftemplateModelSpecificBand24Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band24")

    @band24.setter
    def band24(self, value: Optional[pulumi.Input['RftemplateModelSpecificBand24Args']]):
        pulumi.set(self, "band24", value)

    @property
    @pulumi.getter(name="band24Usage")
    def band24_usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `24`, `5`, `6`, `auto`
        """
        return pulumi.get(self, "band24_usage")

    @band24_usage.setter
    def band24_usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "band24_usage", value)

    @property
    @pulumi.getter
    def band5(self) -> Optional[pulumi.Input['RftemplateModelSpecificBand5Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5")

    @band5.setter
    def band5(self, value: Optional[pulumi.Input['RftemplateModelSpecificBand5Args']]):
        pulumi.set(self, "band5", value)

    @property
    @pulumi.getter(name="band5On24Radio")
    def band5_on24_radio(self) -> Optional[pulumi.Input['RftemplateModelSpecificBand5On24RadioArgs']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5_on24_radio")

    @band5_on24_radio.setter
    def band5_on24_radio(self, value: Optional[pulumi.Input['RftemplateModelSpecificBand5On24RadioArgs']]):
        pulumi.set(self, "band5_on24_radio", value)

    @property
    @pulumi.getter
    def band6(self) -> Optional[pulumi.Input['RftemplateModelSpecificBand6Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band6")

    @band6.setter
    def band6(self, value: Optional[pulumi.Input['RftemplateModelSpecificBand6Args']]):
        pulumi.set(self, "band6", value)


if not MYPY:
    class RftemplateModelSpecificBand24ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    RftemplateModelSpecificBand24ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateModelSpecificBand24Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class RftemplateModelSpecificBand5ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    RftemplateModelSpecificBand5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateModelSpecificBand5Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class RftemplateModelSpecificBand5On24RadioArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    RftemplateModelSpecificBand5On24RadioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateModelSpecificBand5On24RadioArgs:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class RftemplateModelSpecificBand6ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[builtins.bool]]
        ant_gain: NotRequired[pulumi.Input[builtins.int]]
        antenna_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the radio
        """
        power: NotRequired[pulumi.Input[builtins.int]]
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        power_max: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[builtins.int]]
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `auto`, `long`, `short`
        """
        standard_power: NotRequired[pulumi.Input[builtins.bool]]
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
elif False:
    RftemplateModelSpecificBand6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RftemplateModelSpecificBand6Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[builtins.bool]] = None,
                 ant_gain: Optional[pulumi.Input[builtins.int]] = None,
                 antenna_mode: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 power: Optional[pulumi.Input[builtins.int]] = None,
                 power_max: Optional[pulumi.Input[builtins.int]] = None,
                 power_min: Optional[pulumi.Input[builtins.int]] = None,
                 preamble: Optional[pulumi.Input[builtins.str]] = None,
                 standard_power: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[builtins.int] bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[builtins.bool] disabled: Whether to disable the radio
        :param pulumi.Input[builtins.int] power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param pulumi.Input[builtins.int] power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.int] power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[builtins.str] preamble: enum: `auto`, `long`, `short`
        :param pulumi.Input[builtins.bool] standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preamble", value)

    @property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")

    @standard_power.setter
    def standard_power(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "standard_power", value)


if not MYPY:
    class ServiceSpecArgsDict(TypedDict):
        port_range: NotRequired[pulumi.Input[builtins.str]]
        """
        Port number, port range, or variable
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
elif False:
    ServiceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSpecArgs:
    def __init__(__self__, *,
                 port_range: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] port_range: Port number, port range, or variable
        :param pulumi.Input[builtins.str] protocol: `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Port number, port range, or variable
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class ServicepolicyAamwArgsDict(TypedDict):
        aamwprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `docsonly`, `executables`, `standard`
        """
elif False:
    ServicepolicyAamwArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicepolicyAamwArgs:
    def __init__(__self__, *,
                 aamwprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] aamwprofile_id: org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        :param pulumi.Input[builtins.str] profile: enum: `docsonly`, `executables`, `standard`
        """
        if aamwprofile_id is not None:
            pulumi.set(__self__, "aamwprofile_id", aamwprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="aamwprofileId")
    def aamwprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "aamwprofile_id")

    @aamwprofile_id.setter
    def aamwprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aamwprofile_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `docsonly`, `executables`, `standard`
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class ServicepolicyAntivirusArgsDict(TypedDict):
        avprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        Default / noftp / httponly / or keys from av_profiles
        """
elif False:
    ServicepolicyAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicepolicyAntivirusArgs:
    def __init__(__self__, *,
                 avprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param pulumi.Input[builtins.str] profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @avprofile_id.setter
    def avprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "avprofile_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class ServicepolicyAppqoeArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ServicepolicyAppqoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicepolicyAppqoeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ServicepolicyEwfArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[builtins.bool]]
        block_message: NotRequired[pulumi.Input[builtins.str]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `critical`, `standard`, `strict`
        """
elif False:
    ServicepolicyEwfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicepolicyEwfArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[builtins.bool]] = None,
                 block_message: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "block_message")

    @block_message.setter
    def block_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "block_message", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class ServicepolicyIdpArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[builtins.bool]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        idpprofile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
elif False:
    ServicepolicyIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicepolicyIdpArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 idpprofile_id: Optional[pulumi.Input[builtins.str]] = None,
                 profile: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param pulumi.Input[builtins.str] profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @idpprofile_id.setter
    def idpprofile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idpprofile_id", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class ServicepolicySslProxyArgsDict(TypedDict):
        ciphers_category: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `medium`, `strong`, `weak`
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ServicepolicySslProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServicepolicySslProxyArgs:
    def __init__(__self__, *,
                 ciphers_category: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @ciphers_category.setter
    def ciphers_category(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ciphers_category", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SettingApiPolicyArgsDict(TypedDict):
        no_reveal: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, API hides password/secrets when the user doesn't have write access
          * `true`: API will hide passwords/secrets for all users
          * `false`: API will hide passwords/secrets for read-only users
        """
elif False:
    SettingApiPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingApiPolicyArgs:
    def __init__(__self__, *,
                 no_reveal: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] no_reveal: By default, API hides password/secrets when the user doesn't have write access
                 * `true`: API will hide passwords/secrets for all users
                 * `false`: API will hide passwords/secrets for read-only users
        """
        if no_reveal is not None:
            pulumi.set(__self__, "no_reveal", no_reveal)

    @property
    @pulumi.getter(name="noReveal")
    def no_reveal(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, API hides password/secrets when the user doesn't have write access
          * `true`: API will hide passwords/secrets for all users
          * `false`: API will hide passwords/secrets for read-only users
        """
        return pulumi.get(self, "no_reveal")

    @no_reveal.setter
    def no_reveal(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "no_reveal", value)


if not MYPY:
    class SettingCelonaArgsDict(TypedDict):
        api_key: pulumi.Input[builtins.str]
        api_prefix: pulumi.Input[builtins.str]
elif False:
    SettingCelonaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingCelonaArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[builtins.str],
                 api_prefix: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_prefix", api_prefix)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "api_prefix")

    @api_prefix.setter
    def api_prefix(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_prefix", value)


if not MYPY:
    class SettingCloudsharkArgsDict(TypedDict):
        apitoken: NotRequired[pulumi.Input[builtins.str]]
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        If using CS Enterprise
        """
elif False:
    SettingCloudsharkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingCloudsharkArgs:
    def __init__(__self__, *,
                 apitoken: Optional[pulumi.Input[builtins.str]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] url: If using CS Enterprise
        """
        if apitoken is not None:
            pulumi.set(__self__, "apitoken", apitoken)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def apitoken(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "apitoken")

    @apitoken.setter
    def apitoken(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "apitoken", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If using CS Enterprise
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class SettingCradlepointArgsDict(TypedDict):
        cp_api_id: NotRequired[pulumi.Input[builtins.str]]
        cp_api_key: NotRequired[pulumi.Input[builtins.str]]
        ecm_api_id: NotRequired[pulumi.Input[builtins.str]]
        ecm_api_key: NotRequired[pulumi.Input[builtins.str]]
        enable_lldp: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    SettingCradlepointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingCradlepointArgs:
    def __init__(__self__, *,
                 cp_api_id: Optional[pulumi.Input[builtins.str]] = None,
                 cp_api_key: Optional[pulumi.Input[builtins.str]] = None,
                 ecm_api_id: Optional[pulumi.Input[builtins.str]] = None,
                 ecm_api_key: Optional[pulumi.Input[builtins.str]] = None,
                 enable_lldp: Optional[pulumi.Input[builtins.bool]] = None):
        if cp_api_id is not None:
            pulumi.set(__self__, "cp_api_id", cp_api_id)
        if cp_api_key is not None:
            pulumi.set(__self__, "cp_api_key", cp_api_key)
        if ecm_api_id is not None:
            pulumi.set(__self__, "ecm_api_id", ecm_api_id)
        if ecm_api_key is not None:
            pulumi.set(__self__, "ecm_api_key", ecm_api_key)
        if enable_lldp is not None:
            pulumi.set(__self__, "enable_lldp", enable_lldp)

    @property
    @pulumi.getter(name="cpApiId")
    def cp_api_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cp_api_id")

    @cp_api_id.setter
    def cp_api_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cp_api_id", value)

    @property
    @pulumi.getter(name="cpApiKey")
    def cp_api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cp_api_key")

    @cp_api_key.setter
    def cp_api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cp_api_key", value)

    @property
    @pulumi.getter(name="ecmApiId")
    def ecm_api_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ecm_api_id")

    @ecm_api_id.setter
    def ecm_api_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ecm_api_id", value)

    @property
    @pulumi.getter(name="ecmApiKey")
    def ecm_api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ecm_api_key")

    @ecm_api_key.setter
    def ecm_api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ecm_api_key", value)

    @property
    @pulumi.getter(name="enableLldp")
    def enable_lldp(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable_lldp")

    @enable_lldp.setter
    def enable_lldp(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_lldp", value)


if not MYPY:
    class SettingDeviceCertArgsDict(TypedDict):
        cert: pulumi.Input[builtins.str]
        key: pulumi.Input[builtins.str]
elif False:
    SettingDeviceCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingDeviceCertArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class SettingInstallerArgsDict(TypedDict):
        allow_all_devices: NotRequired[pulumi.Input[builtins.bool]]
        allow_all_sites: NotRequired[pulumi.Input[builtins.bool]]
        extra_site_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        grace_period: NotRequired[pulumi.Input[builtins.int]]
elif False:
    SettingInstallerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingInstallerArgs:
    def __init__(__self__, *,
                 allow_all_devices: Optional[pulumi.Input[builtins.bool]] = None,
                 allow_all_sites: Optional[pulumi.Input[builtins.bool]] = None,
                 extra_site_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 grace_period: Optional[pulumi.Input[builtins.int]] = None):
        if allow_all_devices is not None:
            pulumi.set(__self__, "allow_all_devices", allow_all_devices)
        if allow_all_sites is not None:
            pulumi.set(__self__, "allow_all_sites", allow_all_sites)
        if extra_site_ids is not None:
            pulumi.set(__self__, "extra_site_ids", extra_site_ids)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="allowAllDevices")
    def allow_all_devices(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_all_devices")

    @allow_all_devices.setter
    def allow_all_devices(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_all_devices", value)

    @property
    @pulumi.getter(name="allowAllSites")
    def allow_all_sites(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "allow_all_sites")

    @allow_all_sites.setter
    def allow_all_sites(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_all_sites", value)

    @property
    @pulumi.getter(name="extraSiteIds")
    def extra_site_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extra_site_ids")

    @extra_site_ids.setter
    def extra_site_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extra_site_ids", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "grace_period", value)


if not MYPY:
    class SettingJcloudArgsDict(TypedDict):
        org_apitoken: pulumi.Input[builtins.str]
        """
        JCloud Org Token
        """
        org_apitoken_name: pulumi.Input[builtins.str]
        """
        JCloud Org Token Name
        """
        org_id: pulumi.Input[builtins.str]
        """
        JCloud Org ID
        """
elif False:
    SettingJcloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingJcloudArgs:
    def __init__(__self__, *,
                 org_apitoken: pulumi.Input[builtins.str],
                 org_apitoken_name: pulumi.Input[builtins.str],
                 org_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] org_apitoken: JCloud Org Token
        :param pulumi.Input[builtins.str] org_apitoken_name: JCloud Org Token Name
        :param pulumi.Input[builtins.str] org_id: JCloud Org ID
        """
        pulumi.set(__self__, "org_apitoken", org_apitoken)
        pulumi.set(__self__, "org_apitoken_name", org_apitoken_name)
        pulumi.set(__self__, "org_id", org_id)

    @property
    @pulumi.getter(name="orgApitoken")
    def org_apitoken(self) -> pulumi.Input[builtins.str]:
        """
        JCloud Org Token
        """
        return pulumi.get(self, "org_apitoken")

    @org_apitoken.setter
    def org_apitoken(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "org_apitoken", value)

    @property
    @pulumi.getter(name="orgApitokenName")
    def org_apitoken_name(self) -> pulumi.Input[builtins.str]:
        """
        JCloud Org Token Name
        """
        return pulumi.get(self, "org_apitoken_name")

    @org_apitoken_name.setter
    def org_apitoken_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "org_apitoken_name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Input[builtins.str]:
        """
        JCloud Org ID
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "org_id", value)


if not MYPY:
    class SettingJcloudRaArgsDict(TypedDict):
        org_apitoken: NotRequired[pulumi.Input[builtins.str]]
        """
        JCloud Routing Assurance Org Token
        """
        org_apitoken_name: NotRequired[pulumi.Input[builtins.str]]
        """
        JCloud Routing Assurance Org Token Name
        """
        org_id: NotRequired[pulumi.Input[builtins.str]]
        """
        JCloud Routing Assurance Org ID
        """
elif False:
    SettingJcloudRaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingJcloudRaArgs:
    def __init__(__self__, *,
                 org_apitoken: Optional[pulumi.Input[builtins.str]] = None,
                 org_apitoken_name: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] org_apitoken: JCloud Routing Assurance Org Token
        :param pulumi.Input[builtins.str] org_apitoken_name: JCloud Routing Assurance Org Token Name
        :param pulumi.Input[builtins.str] org_id: JCloud Routing Assurance Org ID
        """
        if org_apitoken is not None:
            pulumi.set(__self__, "org_apitoken", org_apitoken)
        if org_apitoken_name is not None:
            pulumi.set(__self__, "org_apitoken_name", org_apitoken_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)

    @property
    @pulumi.getter(name="orgApitoken")
    def org_apitoken(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JCloud Routing Assurance Org Token
        """
        return pulumi.get(self, "org_apitoken")

    @org_apitoken.setter
    def org_apitoken(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_apitoken", value)

    @property
    @pulumi.getter(name="orgApitokenName")
    def org_apitoken_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JCloud Routing Assurance Org Token Name
        """
        return pulumi.get(self, "org_apitoken_name")

    @org_apitoken_name.setter
    def org_apitoken_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_apitoken_name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JCloud Routing Assurance Org ID
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)


if not MYPY:
    class SettingJuniperArgsDict(TypedDict):
        accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['SettingJuniperAccountArgsDict']]]]
elif False:
    SettingJuniperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingJuniperArgs:
    def __init__(__self__, *,
                 accounts: Optional[pulumi.Input[Sequence[pulumi.Input['SettingJuniperAccountArgs']]]] = None):
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)

    @property
    @pulumi.getter
    def accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingJuniperAccountArgs']]]]:
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingJuniperAccountArgs']]]]):
        pulumi.set(self, "accounts", value)


if not MYPY:
    class SettingJuniperAccountArgsDict(TypedDict):
        linked_by: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SettingJuniperAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingJuniperAccountArgs:
    def __init__(__self__, *,
                 linked_by: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        if linked_by is not None:
            pulumi.set(__self__, "linked_by", linked_by)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="linkedBy")
    def linked_by(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "linked_by")

    @linked_by.setter
    def linked_by(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "linked_by", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SettingJunosShellAccessArgsDict(TypedDict):
        admin: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `admin`, `viewer`, `none`
        """
        helpdesk: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `admin`, `viewer`, `none`
        """
        read: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `admin`, `viewer`, `none`
        """
        write: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `admin`, `viewer`, `none`
        """
elif False:
    SettingJunosShellAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingJunosShellAccessArgs:
    def __init__(__self__, *,
                 admin: Optional[pulumi.Input[builtins.str]] = None,
                 helpdesk: Optional[pulumi.Input[builtins.str]] = None,
                 read: Optional[pulumi.Input[builtins.str]] = None,
                 write: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] admin: enum: `admin`, `viewer`, `none`
        :param pulumi.Input[builtins.str] helpdesk: enum: `admin`, `viewer`, `none`
        :param pulumi.Input[builtins.str] read: enum: `admin`, `viewer`, `none`
        :param pulumi.Input[builtins.str] write: enum: `admin`, `viewer`, `none`
        """
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if helpdesk is not None:
            pulumi.set(__self__, "helpdesk", helpdesk)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if write is not None:
            pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def admin(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "admin")

    @admin.setter
    def admin(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin", value)

    @property
    @pulumi.getter
    def helpdesk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "helpdesk")

    @helpdesk.setter
    def helpdesk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "helpdesk", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def write(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "write", value)


if not MYPY:
    class SettingMgmtArgsDict(TypedDict):
        mxtunnel_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of Mist Tunnels
        """
        use_mxtunnel: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
        """
        use_wxtunnel: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to use wxtunnel for mgmt connectivity
        """
elif False:
    SettingMgmtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingMgmtArgs:
    def __init__(__self__, *,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 use_mxtunnel: Optional[pulumi.Input[builtins.bool]] = None,
                 use_wxtunnel: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxtunnel_ids: List of Mist Tunnels
        :param pulumi.Input[builtins.bool] use_mxtunnel: Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
        :param pulumi.Input[builtins.bool] use_wxtunnel: Whether to use wxtunnel for mgmt connectivity
        """
        if mxtunnel_ids is not None:
            pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        if use_mxtunnel is not None:
            pulumi.set(__self__, "use_mxtunnel", use_mxtunnel)
        if use_wxtunnel is not None:
            pulumi.set(__self__, "use_wxtunnel", use_wxtunnel)

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of Mist Tunnels
        """
        return pulumi.get(self, "mxtunnel_ids")

    @mxtunnel_ids.setter
    def mxtunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mxtunnel_ids", value)

    @property
    @pulumi.getter(name="useMxtunnel")
    def use_mxtunnel(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
        """
        return pulumi.get(self, "use_mxtunnel")

    @use_mxtunnel.setter
    def use_mxtunnel(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mxtunnel", value)

    @property
    @pulumi.getter(name="useWxtunnel")
    def use_wxtunnel(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to use wxtunnel for mgmt connectivity
        """
        return pulumi.get(self, "use_wxtunnel")

    @use_wxtunnel.setter
    def use_wxtunnel(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_wxtunnel", value)


if not MYPY:
    class SettingMistNacArgsDict(TypedDict):
        cacerts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of PEM-encoded ca certs
        """
        default_idp_id: NotRequired[pulumi.Input[builtins.str]]
        """
        use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
        """
        disable_rsae_algorithms: NotRequired[pulumi.Input[builtins.bool]]
        """
        to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html
        """
        eap_ssl_security_level: NotRequired[pulumi.Input[builtins.int]]
        """
        eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
        """
        eu_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled
        """
        idp_machine_cert_lookup_field: NotRequired[pulumi.Input[builtins.str]]
        """
        allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`
        """
        idp_user_cert_lookup_field: NotRequired[pulumi.Input[builtins.str]]
        """
        allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`
        """
        idps: NotRequired[pulumi.Input[Sequence[pulumi.Input['SettingMistNacIdpArgsDict']]]]
        server_cert: NotRequired[pulumi.Input['SettingMistNacServerCertArgsDict']]
        """
        radius server cert to be presented in EAP TLS
        """
        use_ip_version: NotRequired[pulumi.Input[builtins.str]]
        """
        by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
        """
        use_ssl_port: NotRequired[pulumi.Input[builtins.bool]]
        """
        By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled
        """
elif False:
    SettingMistNacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingMistNacArgs:
    def __init__(__self__, *,
                 cacerts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 default_idp_id: Optional[pulumi.Input[builtins.str]] = None,
                 disable_rsae_algorithms: Optional[pulumi.Input[builtins.bool]] = None,
                 eap_ssl_security_level: Optional[pulumi.Input[builtins.int]] = None,
                 eu_only: Optional[pulumi.Input[builtins.bool]] = None,
                 idp_machine_cert_lookup_field: Optional[pulumi.Input[builtins.str]] = None,
                 idp_user_cert_lookup_field: Optional[pulumi.Input[builtins.str]] = None,
                 idps: Optional[pulumi.Input[Sequence[pulumi.Input['SettingMistNacIdpArgs']]]] = None,
                 server_cert: Optional[pulumi.Input['SettingMistNacServerCertArgs']] = None,
                 use_ip_version: Optional[pulumi.Input[builtins.str]] = None,
                 use_ssl_port: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] cacerts: List of PEM-encoded ca certs
        :param pulumi.Input[builtins.str] default_idp_id: use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
        :param pulumi.Input[builtins.bool] disable_rsae_algorithms: to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html
        :param pulumi.Input[builtins.int] eap_ssl_security_level: eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
        :param pulumi.Input[builtins.bool] eu_only: By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled
        :param pulumi.Input[builtins.str] idp_machine_cert_lookup_field: allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`
        :param pulumi.Input[builtins.str] idp_user_cert_lookup_field: allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`
        :param pulumi.Input['SettingMistNacServerCertArgs'] server_cert: radius server cert to be presented in EAP TLS
        :param pulumi.Input[builtins.str] use_ip_version: by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
        :param pulumi.Input[builtins.bool] use_ssl_port: By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled
        """
        if cacerts is not None:
            pulumi.set(__self__, "cacerts", cacerts)
        if default_idp_id is not None:
            pulumi.set(__self__, "default_idp_id", default_idp_id)
        if disable_rsae_algorithms is not None:
            pulumi.set(__self__, "disable_rsae_algorithms", disable_rsae_algorithms)
        if eap_ssl_security_level is not None:
            pulumi.set(__self__, "eap_ssl_security_level", eap_ssl_security_level)
        if eu_only is not None:
            pulumi.set(__self__, "eu_only", eu_only)
        if idp_machine_cert_lookup_field is not None:
            pulumi.set(__self__, "idp_machine_cert_lookup_field", idp_machine_cert_lookup_field)
        if idp_user_cert_lookup_field is not None:
            pulumi.set(__self__, "idp_user_cert_lookup_field", idp_user_cert_lookup_field)
        if idps is not None:
            pulumi.set(__self__, "idps", idps)
        if server_cert is not None:
            pulumi.set(__self__, "server_cert", server_cert)
        if use_ip_version is not None:
            pulumi.set(__self__, "use_ip_version", use_ip_version)
        if use_ssl_port is not None:
            pulumi.set(__self__, "use_ssl_port", use_ssl_port)

    @property
    @pulumi.getter
    def cacerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of PEM-encoded ca certs
        """
        return pulumi.get(self, "cacerts")

    @cacerts.setter
    def cacerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "cacerts", value)

    @property
    @pulumi.getter(name="defaultIdpId")
    def default_idp_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
        """
        return pulumi.get(self, "default_idp_id")

    @default_idp_id.setter
    def default_idp_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_idp_id", value)

    @property
    @pulumi.getter(name="disableRsaeAlgorithms")
    def disable_rsae_algorithms(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html
        """
        return pulumi.get(self, "disable_rsae_algorithms")

    @disable_rsae_algorithms.setter
    def disable_rsae_algorithms(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_rsae_algorithms", value)

    @property
    @pulumi.getter(name="eapSslSecurityLevel")
    def eap_ssl_security_level(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
        """
        return pulumi.get(self, "eap_ssl_security_level")

    @eap_ssl_security_level.setter
    def eap_ssl_security_level(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "eap_ssl_security_level", value)

    @property
    @pulumi.getter(name="euOnly")
    def eu_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled
        """
        return pulumi.get(self, "eu_only")

    @eu_only.setter
    def eu_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "eu_only", value)

    @property
    @pulumi.getter(name="idpMachineCertLookupField")
    def idp_machine_cert_lookup_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`
        """
        return pulumi.get(self, "idp_machine_cert_lookup_field")

    @idp_machine_cert_lookup_field.setter
    def idp_machine_cert_lookup_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idp_machine_cert_lookup_field", value)

    @property
    @pulumi.getter(name="idpUserCertLookupField")
    def idp_user_cert_lookup_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`
        """
        return pulumi.get(self, "idp_user_cert_lookup_field")

    @idp_user_cert_lookup_field.setter
    def idp_user_cert_lookup_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idp_user_cert_lookup_field", value)

    @property
    @pulumi.getter
    def idps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingMistNacIdpArgs']]]]:
        return pulumi.get(self, "idps")

    @idps.setter
    def idps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingMistNacIdpArgs']]]]):
        pulumi.set(self, "idps", value)

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> Optional[pulumi.Input['SettingMistNacServerCertArgs']]:
        """
        radius server cert to be presented in EAP TLS
        """
        return pulumi.get(self, "server_cert")

    @server_cert.setter
    def server_cert(self, value: Optional[pulumi.Input['SettingMistNacServerCertArgs']]):
        pulumi.set(self, "server_cert", value)

    @property
    @pulumi.getter(name="useIpVersion")
    def use_ip_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
        """
        return pulumi.get(self, "use_ip_version")

    @use_ip_version.setter
    def use_ip_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "use_ip_version", value)

    @property
    @pulumi.getter(name="useSslPort")
    def use_ssl_port(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled
        """
        return pulumi.get(self, "use_ssl_port")

    @use_ssl_port.setter
    def use_ssl_port(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_ssl_port", value)


if not MYPY:
    class SettingMistNacIdpArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        ID of the `mist_nacidp`
        """
        user_realms: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Which realm should trigger this IDP. User Realm is extracted from:
          * Username-AVP (`mist.com` from john@mist.com)
          * Cert CN
        """
        exclude_realms: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org
        """
elif False:
    SettingMistNacIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingMistNacIdpArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 user_realms: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 exclude_realms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] id: ID of the `mist_nacidp`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_realms: Which realm should trigger this IDP. User Realm is extracted from:
                 * Username-AVP (`mist.com` from john@mist.com)
                 * Cert CN
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exclude_realms: When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "user_realms", user_realms)
        if exclude_realms is not None:
            pulumi.set(__self__, "exclude_realms", exclude_realms)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        ID of the `mist_nacidp`
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="userRealms")
    def user_realms(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Which realm should trigger this IDP. User Realm is extracted from:
          * Username-AVP (`mist.com` from john@mist.com)
          * Cert CN
        """
        return pulumi.get(self, "user_realms")

    @user_realms.setter
    def user_realms(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "user_realms", value)

    @property
    @pulumi.getter(name="excludeRealms")
    def exclude_realms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org
        """
        return pulumi.get(self, "exclude_realms")

    @exclude_realms.setter
    def exclude_realms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_realms", value)


if not MYPY:
    class SettingMistNacServerCertArgsDict(TypedDict):
        cert: NotRequired[pulumi.Input[builtins.str]]
        key: NotRequired[pulumi.Input[builtins.str]]
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        private key password (optional)
        """
elif False:
    SettingMistNacServerCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingMistNacServerCertArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input[builtins.str]] = None,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password: private key password (optional)
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        private key password (optional)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class SettingMxedgeMgmtArgsDict(TypedDict):
        config_auto_revert: NotRequired[pulumi.Input[builtins.bool]]
        fips_enabled: NotRequired[pulumi.Input[builtins.bool]]
        mist_password: NotRequired[pulumi.Input[builtins.str]]
        oob_ip_type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `dhcp`, `disabled`, `static`
        """
        oob_ip_type6: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        root_password: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SettingMxedgeMgmtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingMxedgeMgmtArgs:
    def __init__(__self__, *,
                 config_auto_revert: Optional[pulumi.Input[builtins.bool]] = None,
                 fips_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 mist_password: Optional[pulumi.Input[builtins.str]] = None,
                 oob_ip_type: Optional[pulumi.Input[builtins.str]] = None,
                 oob_ip_type6: Optional[pulumi.Input[builtins.str]] = None,
                 root_password: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] oob_ip_type: enum: `dhcp`, `disabled`, `static`
        :param pulumi.Input[builtins.str] oob_ip_type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if config_auto_revert is not None:
            pulumi.set(__self__, "config_auto_revert", config_auto_revert)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if mist_password is not None:
            pulumi.set(__self__, "mist_password", mist_password)
        if oob_ip_type is not None:
            pulumi.set(__self__, "oob_ip_type", oob_ip_type)
        if oob_ip_type6 is not None:
            pulumi.set(__self__, "oob_ip_type6", oob_ip_type6)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)

    @property
    @pulumi.getter(name="configAutoRevert")
    def config_auto_revert(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "config_auto_revert")

    @config_auto_revert.setter
    def config_auto_revert(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "config_auto_revert", value)

    @property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "fips_enabled")

    @fips_enabled.setter
    def fips_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "fips_enabled", value)

    @property
    @pulumi.getter(name="mistPassword")
    def mist_password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "mist_password")

    @mist_password.setter
    def mist_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mist_password", value)

    @property
    @pulumi.getter(name="oobIpType")
    def oob_ip_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "oob_ip_type")

    @oob_ip_type.setter
    def oob_ip_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "oob_ip_type", value)

    @property
    @pulumi.getter(name="oobIpType6")
    def oob_ip_type6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "oob_ip_type6")

    @oob_ip_type6.setter
    def oob_ip_type6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "oob_ip_type6", value)

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "root_password")

    @root_password.setter
    def root_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "root_password", value)


if not MYPY:
    class SettingOpticPortConfigArgsDict(TypedDict):
        channelized: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable channelization
        """
        speed: NotRequired[pulumi.Input[builtins.str]]
        """
        Interface speed (e.g. `25g`, `50g`), use the chassis speed by default
        """
elif False:
    SettingOpticPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingOpticPortConfigArgs:
    def __init__(__self__, *,
                 channelized: Optional[pulumi.Input[builtins.bool]] = None,
                 speed: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] channelized: Enable channelization
        :param pulumi.Input[builtins.str] speed: Interface speed (e.g. `25g`, `50g`), use the chassis speed by default
        """
        if channelized is not None:
            pulumi.set(__self__, "channelized", channelized)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def channelized(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable channelization
        """
        return pulumi.get(self, "channelized")

    @channelized.setter
    def channelized(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "channelized", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Interface speed (e.g. `25g`, `50g`), use the chassis speed by default
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "speed", value)


if not MYPY:
    class SettingPasswordPolicyArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the policy is enabled
        """
        expiry_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        password expiry in days
        """
        min_length: NotRequired[pulumi.Input[builtins.int]]
        """
        Required password length
        """
        requires_special_char: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to require special character
        """
        requires_two_factor_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to require two-factor auth
        """
elif False:
    SettingPasswordPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingPasswordPolicyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 expiry_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 min_length: Optional[pulumi.Input[builtins.int]] = None,
                 requires_special_char: Optional[pulumi.Input[builtins.bool]] = None,
                 requires_two_factor_auth: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether the policy is enabled
        :param pulumi.Input[builtins.int] expiry_in_days: password expiry in days
        :param pulumi.Input[builtins.int] min_length: Required password length
        :param pulumi.Input[builtins.bool] requires_special_char: Whether to require special character
        :param pulumi.Input[builtins.bool] requires_two_factor_auth: Whether to require two-factor auth
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expiry_in_days is not None:
            pulumi.set(__self__, "expiry_in_days", expiry_in_days)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if requires_special_char is not None:
            pulumi.set(__self__, "requires_special_char", requires_special_char)
        if requires_two_factor_auth is not None:
            pulumi.set(__self__, "requires_two_factor_auth", requires_two_factor_auth)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the policy is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="expiryInDays")
    def expiry_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        password expiry in days
        """
        return pulumi.get(self, "expiry_in_days")

    @expiry_in_days.setter
    def expiry_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expiry_in_days", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Required password length
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter(name="requiresSpecialChar")
    def requires_special_char(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to require special character
        """
        return pulumi.get(self, "requires_special_char")

    @requires_special_char.setter
    def requires_special_char(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "requires_special_char", value)

    @property
    @pulumi.getter(name="requiresTwoFactorAuth")
    def requires_two_factor_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to require two-factor auth
        """
        return pulumi.get(self, "requires_two_factor_auth")

    @requires_two_factor_auth.setter
    def requires_two_factor_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "requires_two_factor_auth", value)


if not MYPY:
    class SettingPcapArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[builtins.str]]
        max_pkt_len: NotRequired[pulumi.Input[builtins.int]]
        """
        Max_len of non-management packets to capture
        """
elif False:
    SettingPcapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingPcapArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[builtins.str]] = None,
                 max_pkt_len: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_pkt_len: Max_len of non-management packets to capture
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if max_pkt_len is not None:
            pulumi.set(__self__, "max_pkt_len", max_pkt_len)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="maxPktLen")
    def max_pkt_len(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max_len of non-management packets to capture
        """
        return pulumi.get(self, "max_pkt_len")

    @max_pkt_len.setter
    def max_pkt_len(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_pkt_len", value)


if not MYPY:
    class SettingSecurityArgsDict(TypedDict):
        disable_local_ssh: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled
        """
        fips_zeroize_password: NotRequired[pulumi.Input[builtins.str]]
        """
        password required to zeroize devices (FIPS) on site level
        """
        limit_ssh_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
        """
elif False:
    SettingSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSecurityArgs:
    def __init__(__self__, *,
                 disable_local_ssh: Optional[pulumi.Input[builtins.bool]] = None,
                 fips_zeroize_password: Optional[pulumi.Input[builtins.str]] = None,
                 limit_ssh_access: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_local_ssh: Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled
        :param pulumi.Input[builtins.str] fips_zeroize_password: password required to zeroize devices (FIPS) on site level
        :param pulumi.Input[builtins.bool] limit_ssh_access: Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
        """
        if disable_local_ssh is not None:
            pulumi.set(__self__, "disable_local_ssh", disable_local_ssh)
        if fips_zeroize_password is not None:
            pulumi.set(__self__, "fips_zeroize_password", fips_zeroize_password)
        if limit_ssh_access is not None:
            pulumi.set(__self__, "limit_ssh_access", limit_ssh_access)

    @property
    @pulumi.getter(name="disableLocalSsh")
    def disable_local_ssh(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled
        """
        return pulumi.get(self, "disable_local_ssh")

    @disable_local_ssh.setter
    def disable_local_ssh(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_local_ssh", value)

    @property
    @pulumi.getter(name="fipsZeroizePassword")
    def fips_zeroize_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        password required to zeroize devices (FIPS) on site level
        """
        return pulumi.get(self, "fips_zeroize_password")

    @fips_zeroize_password.setter
    def fips_zeroize_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fips_zeroize_password", value)

    @property
    @pulumi.getter(name="limitSshAccess")
    def limit_ssh_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
        """
        return pulumi.get(self, "limit_ssh_access")

    @limit_ssh_access.setter
    def limit_ssh_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "limit_ssh_access", value)


if not MYPY:
    class SettingSwitchMgmtArgsDict(TypedDict):
        ap_affinity_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        remove_existing_configs: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `false`, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        """
elif False:
    SettingSwitchMgmtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSwitchMgmtArgs:
    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 remove_existing_configs: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] ap_affinity_threshold: If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        :param pulumi.Input[builtins.bool] remove_existing_configs: If `false`, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)
        if remove_existing_configs is not None:
            pulumi.set(__self__, "remove_existing_configs", remove_existing_configs)

    @property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")

    @ap_affinity_threshold.setter
    def ap_affinity_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ap_affinity_threshold", value)

    @property
    @pulumi.getter(name="removeExistingConfigs")
    def remove_existing_configs(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `false`, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        """
        return pulumi.get(self, "remove_existing_configs")

    @remove_existing_configs.setter
    def remove_existing_configs(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "remove_existing_configs", value)


if not MYPY:
    class SettingSyntheticTestArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgsDict']]]]
        wan_speedtest: NotRequired[pulumi.Input['SettingSyntheticTestWanSpeedtestArgsDict']]
elif False:
    SettingSyntheticTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSyntheticTestArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 vlans: Optional[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgs']]]] = None,
                 wan_speedtest: Optional[pulumi.Input['SettingSyntheticTestWanSpeedtestArgs']] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)
        if wan_speedtest is not None:
            pulumi.set(__self__, "wan_speedtest", wan_speedtest)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgs']]]]:
        return pulumi.get(self, "vlans")

    @vlans.setter
    def vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgs']]]]):
        pulumi.set(self, "vlans", value)

    @property
    @pulumi.getter(name="wanSpeedtest")
    def wan_speedtest(self) -> Optional[pulumi.Input['SettingSyntheticTestWanSpeedtestArgs']]:
        return pulumi.get(self, "wan_speedtest")

    @wan_speedtest.setter
    def wan_speedtest(self, value: Optional[pulumi.Input['SettingSyntheticTestWanSpeedtestArgs']]):
        pulumi.set(self, "wan_speedtest", value)


if not MYPY:
    class SettingSyntheticTestVlanArgsDict(TypedDict):
        custom_test_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        For some vlans where we don't want this to run
        """
        vlan_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    SettingSyntheticTestVlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSyntheticTestVlanArgs:
    def __init__(__self__, *,
                 custom_test_urls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] disabled: For some vlans where we don't want this to run
        """
        if custom_test_urls is not None:
            pulumi.set(__self__, "custom_test_urls", custom_test_urls)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @property
    @pulumi.getter(name="customTestUrls")
    def custom_test_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "custom_test_urls")

    @custom_test_urls.setter
    def custom_test_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "custom_test_urls", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For some vlans where we don't want this to run
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vlan_ids", value)


if not MYPY:
    class SettingSyntheticTestWanSpeedtestArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        time_of_day: NotRequired[pulumi.Input[builtins.str]]
        """
        `any` / HH:MM (24-hour format)
        """
elif False:
    SettingSyntheticTestWanSpeedtestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingSyntheticTestWanSpeedtestArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 time_of_day: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] time_of_day: `any` / HH:MM (24-hour format)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_of_day is not None:
            pulumi.set(__self__, "time_of_day", time_of_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        `any` / HH:MM (24-hour format)
        """
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_of_day", value)


if not MYPY:
    class SettingVpnOptionsArgsDict(TypedDict):
        as_base: NotRequired[pulumi.Input[builtins.int]]
        st_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        requiring /12 or bigger to support 16 private IPs for 65535 gateways
        """
elif False:
    SettingVpnOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingVpnOptionsArgs:
    def __init__(__self__, *,
                 as_base: Optional[pulumi.Input[builtins.int]] = None,
                 st_subnet: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] st_subnet: requiring /12 or bigger to support 16 private IPs for 65535 gateways
        """
        if as_base is not None:
            pulumi.set(__self__, "as_base", as_base)
        if st_subnet is not None:
            pulumi.set(__self__, "st_subnet", st_subnet)

    @property
    @pulumi.getter(name="asBase")
    def as_base(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "as_base")

    @as_base.setter
    def as_base(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "as_base", value)

    @property
    @pulumi.getter(name="stSubnet")
    def st_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        requiring /12 or bigger to support 16 private IPs for 65535 gateways
        """
        return pulumi.get(self, "st_subnet")

    @st_subnet.setter
    def st_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "st_subnet", value)


if not MYPY:
    class SettingWanPmaArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    SettingWanPmaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingWanPmaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SettingWiredPmaArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    SettingWiredPmaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingWiredPmaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SettingWirelessPmaArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    SettingWirelessPmaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SettingWirelessPmaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SsoRolePrivilegeArgsDict(TypedDict):
        role: pulumi.Input[builtins.str]
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        scope: pulumi.Input[builtins.str]
        """
        enum: `org`, `site`, `sitegroup`
        """
        site_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `scope`==`site`
        """
        sitegroup_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `scope`==`sitegroup`
        """
        views: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
        You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
        Below are the list of supported UI views. Note that this is UI only feature.  

          | UI View | Required Role | Description |
          | --- | --- | --- |
          | `reporting` | `read` | full access to all analytics tools |
          | `marketing` | `read` | can view analytics and location maps |
          | `super_observer` | `read` | can view all the organization except the subscription page |
          | `location` | `write` | can view and manage location maps, can view analytics |
          | `security` | `write` | can view and manage site labels, policies and security |
          | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
          | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
          | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
elif False:
    SsoRolePrivilegeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SsoRolePrivilegeArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[builtins.str],
                 scope: pulumi.Input[builtins.str],
                 site_id: Optional[pulumi.Input[builtins.str]] = None,
                 sitegroup_id: Optional[pulumi.Input[builtins.str]] = None,
                 views: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] role: access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        :param pulumi.Input[builtins.str] scope: enum: `org`, `site`, `sitegroup`
        :param pulumi.Input[builtins.str] site_id: Required if `scope`==`site`
        :param pulumi.Input[builtins.str] sitegroup_id: Required if `scope`==`sitegroup`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] views: Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
               You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
               Below are the list of supported UI views. Note that this is UI only feature.  
               
                 | UI View | Required Role | Description |
                 | --- | --- | --- |
                 | `reporting` | `read` | full access to all analytics tools |
                 | `marketing` | `read` | can view analytics and location maps |
                 | `super_observer` | `read` | can view all the organization except the subscription page |
                 | `location` | `write` | can view and manage location maps, can view analytics |
                 | `security` | `write` | can view and manage site labels, policies and security |
                 | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
                 | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
                 | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "scope", scope)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if sitegroup_id is not None:
            pulumi.set(__self__, "sitegroup_id", sitegroup_id)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[builtins.str]:
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[builtins.str]:
        """
        enum: `org`, `site`, `sitegroup`
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `scope`==`site`
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter(name="sitegroupId")
    def sitegroup_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `scope`==`sitegroup`
        """
        return pulumi.get(self, "sitegroup_id")

    @sitegroup_id.setter
    def sitegroup_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sitegroup_id", value)

    @property
    @pulumi.getter
    def views(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
        You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
        Below are the list of supported UI views. Note that this is UI only feature.  

          | UI View | Required Role | Description |
          | --- | --- | --- |
          | `reporting` | `read` | full access to all analytics tools |
          | `marketing` | `read` | can view analytics and location maps |
          | `super_observer` | `read` | can view all the organization except the subscription page |
          | `location` | `write` | can view and manage location maps, can view analytics |
          | `security` | `write` | can view and manage site labels, policies and security |
          | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
          | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
          | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "views", value)


if not MYPY:
    class VpnPathSelectionArgsDict(TypedDict):
        strategy: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `disabled`, `simple`, `manual`
        """
elif False:
    VpnPathSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnPathSelectionArgs:
    def __init__(__self__, *,
                 strategy: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] strategy: enum: `disabled`, `simple`, `manual`
        """
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `disabled`, `simple`, `manual`
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class VpnPathsArgsDict(TypedDict):
        bfd_profile: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `broadband`, `lte`
        """
        bfd_use_tunnel_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        If `type`==`mesh` and for SSR only, whether to use tunnel mode
        """
        ip: NotRequired[pulumi.Input[builtins.str]]
        """
        If different from the wan port
        """
        peer_paths: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['VpnPathsPeerPathsArgsDict']]]]
        """
        If `type`==`mesh`, Property key is the Peer Interface name
        """
        pod: NotRequired[pulumi.Input[builtins.int]]
        traffic_shaping: NotRequired[pulumi.Input['VpnPathsTrafficShapingArgsDict']]
elif False:
    VpnPathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnPathsArgs:
    def __init__(__self__, *,
                 bfd_profile: Optional[pulumi.Input[builtins.str]] = None,
                 bfd_use_tunnel_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 ip: Optional[pulumi.Input[builtins.str]] = None,
                 peer_paths: Optional[pulumi.Input[Mapping[str, pulumi.Input['VpnPathsPeerPathsArgs']]]] = None,
                 pod: Optional[pulumi.Input[builtins.int]] = None,
                 traffic_shaping: Optional[pulumi.Input['VpnPathsTrafficShapingArgs']] = None):
        """
        :param pulumi.Input[builtins.str] bfd_profile: enum: `broadband`, `lte`
        :param pulumi.Input[builtins.bool] bfd_use_tunnel_mode: If `type`==`mesh` and for SSR only, whether to use tunnel mode
        :param pulumi.Input[builtins.str] ip: If different from the wan port
        :param pulumi.Input[Mapping[str, pulumi.Input['VpnPathsPeerPathsArgs']]] peer_paths: If `type`==`mesh`, Property key is the Peer Interface name
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if peer_paths is not None:
            pulumi.set(__self__, "peer_paths", peer_paths)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @bfd_profile.setter
    def bfd_profile(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bfd_profile", value)

    @property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If `type`==`mesh` and for SSR only, whether to use tunnel mode
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @bfd_use_tunnel_mode.setter
    def bfd_use_tunnel_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bfd_use_tunnel_mode", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If different from the wan port
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="peerPaths")
    def peer_paths(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['VpnPathsPeerPathsArgs']]]]:
        """
        If `type`==`mesh`, Property key is the Peer Interface name
        """
        return pulumi.get(self, "peer_paths")

    @peer_paths.setter
    def peer_paths(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['VpnPathsPeerPathsArgs']]]]):
        pulumi.set(self, "peer_paths", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['VpnPathsTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['VpnPathsTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)


if not MYPY:
    class VpnPathsPeerPathsArgsDict(TypedDict):
        preference: NotRequired[pulumi.Input[builtins.int]]
elif False:
    VpnPathsPeerPathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnPathsPeerPathsArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input[builtins.int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class VpnPathsTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        max_tx_kbps: NotRequired[pulumi.Input[builtins.int]]
elif False:
    VpnPathsTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnPathsTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_tx_kbps: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] class_percentages: percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_tx_kbps")

    @max_tx_kbps.setter
    def max_tx_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tx_kbps", value)


if not MYPY:
    class WlanAcctServerArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        IP/ hostname of RADIUS server
        """
        secret: pulumi.Input[builtins.str]
        """
        Secret of RADIUS server
        """
        keywrap_enabled: NotRequired[pulumi.Input[builtins.bool]]
        keywrap_format: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ascii`, `hex`
        """
        keywrap_kek: NotRequired[pulumi.Input[builtins.str]]
        keywrap_mack: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
elif False:
    WlanAcctServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAcctServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 keywrap_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 keywrap_format: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_kek: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_mack: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] host: IP/ hostname of RADIUS server
        :param pulumi.Input[builtins.str] secret: Secret of RADIUS server
        :param pulumi.Input[builtins.str] keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WlanAirwatchArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[builtins.str]]
        """
        API Key
        """
        console_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Console URL
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username
        """
elif False:
    WlanAirwatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAirwatchArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[builtins.str]] = None,
                 console_url: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_key: API Key
        :param pulumi.Input[builtins.str] console_url: Console URL
        :param pulumi.Input[builtins.str] password: Password
        :param pulumi.Input[builtins.str] username: Username
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if console_url is not None:
            pulumi.set(__self__, "console_url", console_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="consoleUrl")
    def console_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Console URL
        """
        return pulumi.get(self, "console_url")

    @console_url.setter
    def console_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "console_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class WlanAppLimitArgsDict(TypedDict):
        apps: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]]
        """
        Map from app key to bandwidth in kbps. 
        Property key is the app key, defined in Get Application List
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        wxtag_ids: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]]
        """
        Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
elif False:
    WlanAppLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAppLimitArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]] apps: Map from app key to bandwidth in kbps. 
               Property key is the app key, defined in Get Application List
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]] wxtag_ids: Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]]:
        """
        Map from app key to bandwidth in kbps. 
        Property key is the app key, defined in Get Application List
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]]:
        """
        Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
        return pulumi.get(self, "wxtag_ids")

    @wxtag_ids.setter
    def wxtag_ids(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "wxtag_ids", value)


if not MYPY:
    class WlanAppQosArgsDict(TypedDict):
        apps: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgsDict']]]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        others: NotRequired[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgsDict']]]]
elif False:
    WlanAppQosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAppQosArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgs']]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 others: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgs']]]] = None):
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if others is not None:
            pulumi.set(__self__, "others", others)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgs']]]]:
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgs']]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def others(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgs']]]]:
        return pulumi.get(self, "others")

    @others.setter
    def others(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgs']]]]):
        pulumi.set(self, "others", value)


if not MYPY:
    class WlanAppQosAppsArgsDict(TypedDict):
        dscp: NotRequired[pulumi.Input[builtins.str]]
        """
        DSCP value range between 0 and 63
        """
        dst_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        src_subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
elif False:
    WlanAppQosAppsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAppQosAppsArgs:
    def __init__(__self__, *,
                 dscp: Optional[pulumi.Input[builtins.str]] = None,
                 dst_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 src_subnet: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] dscp: DSCP value range between 0 and 63
        :param pulumi.Input[builtins.str] dst_subnet: Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        :param pulumi.Input[builtins.str] src_subnet: Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DSCP value range between 0 and 63
        """
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "dst_subnet")

    @dst_subnet.setter
    def dst_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dst_subnet", value)

    @property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "src_subnet")

    @src_subnet.setter
    def src_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "src_subnet", value)


if not MYPY:
    class WlanAppQosOtherArgsDict(TypedDict):
        dscp: NotRequired[pulumi.Input[builtins.str]]
        dst_subnet: NotRequired[pulumi.Input[builtins.str]]
        port_ranges: NotRequired[pulumi.Input[builtins.str]]
        protocol: NotRequired[pulumi.Input[builtins.str]]
        src_subnet: NotRequired[pulumi.Input[builtins.str]]
elif False:
    WlanAppQosOtherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAppQosOtherArgs:
    def __init__(__self__, *,
                 dscp: Optional[pulumi.Input[builtins.str]] = None,
                 dst_subnet: Optional[pulumi.Input[builtins.str]] = None,
                 port_ranges: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 src_subnet: Optional[pulumi.Input[builtins.str]] = None):
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dst_subnet")

    @dst_subnet.setter
    def dst_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dst_subnet", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "src_subnet")

    @src_subnet.setter
    def src_subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "src_subnet", value)


if not MYPY:
    class WlanAuthArgsDict(TypedDict):
        anticlog_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        SAE anti-clogging token threshold
        """
        eap_reauth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to trigger EAP reauth when the session ends
        """
        enable_mac_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable MAC Auth, uses the same auth_servers
        """
        key_idx: NotRequired[pulumi.Input[builtins.int]]
        """
        When `type`==`wep`
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        """
        multi_psk_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        When `type`==`psk`, whether to only use multi_psk
        """
        owe: NotRequired[pulumi.Input[builtins.str]]
        """
        if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        """
        pairwises: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        """
        private_wlan: NotRequired[pulumi.Input[builtins.bool]]
        """
        When `multi_psk_only`==`true`, whether private wlan is enabled
        """
        psk: NotRequired[pulumi.Input[builtins.str]]
        """
        When `type`==`psk`, 8-64 characters, or 64 hex characters
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        """
        wep_as_secondary_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable WEP as secondary auth
        """
elif False:
    WlanAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAuthArgs:
    def __init__(__self__, *,
                 anticlog_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 eap_reauth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_mac_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 key_idx: Optional[pulumi.Input[builtins.int]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 multi_psk_only: Optional[pulumi.Input[builtins.bool]] = None,
                 owe: Optional[pulumi.Input[builtins.str]] = None,
                 pairwises: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 private_wlan: Optional[pulumi.Input[builtins.bool]] = None,
                 psk: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 wep_as_secondary_auth: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] anticlog_threshold: SAE anti-clogging token threshold
        :param pulumi.Input[builtins.bool] eap_reauth: Whether to trigger EAP reauth when the session ends
        :param pulumi.Input[builtins.bool] enable_mac_auth: Whether to enable MAC Auth, uses the same auth_servers
        :param pulumi.Input[builtins.int] key_idx: When `type`==`wep`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] keys: When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        :param pulumi.Input[builtins.bool] multi_psk_only: When `type`==`psk`, whether to only use multi_psk
        :param pulumi.Input[builtins.str] owe: if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] pairwises: When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        :param pulumi.Input[builtins.bool] private_wlan: When `multi_psk_only`==`true`, whether private wlan is enabled
        :param pulumi.Input[builtins.str] psk: When `type`==`psk`, 8-64 characters, or 64 hex characters
        :param pulumi.Input[builtins.str] type: enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        :param pulumi.Input[builtins.bool] wep_as_secondary_auth: Enable WEP as secondary auth
        """
        if anticlog_threshold is not None:
            pulumi.set(__self__, "anticlog_threshold", anticlog_threshold)
        if eap_reauth is not None:
            pulumi.set(__self__, "eap_reauth", eap_reauth)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if key_idx is not None:
            pulumi.set(__self__, "key_idx", key_idx)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if multi_psk_only is not None:
            pulumi.set(__self__, "multi_psk_only", multi_psk_only)
        if owe is not None:
            pulumi.set(__self__, "owe", owe)
        if pairwises is not None:
            pulumi.set(__self__, "pairwises", pairwises)
        if private_wlan is not None:
            pulumi.set(__self__, "private_wlan", private_wlan)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wep_as_secondary_auth is not None:
            pulumi.set(__self__, "wep_as_secondary_auth", wep_as_secondary_auth)

    @property
    @pulumi.getter(name="anticlogThreshold")
    def anticlog_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        SAE anti-clogging token threshold
        """
        return pulumi.get(self, "anticlog_threshold")

    @anticlog_threshold.setter
    def anticlog_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "anticlog_threshold", value)

    @property
    @pulumi.getter(name="eapReauth")
    def eap_reauth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to trigger EAP reauth when the session ends
        """
        return pulumi.get(self, "eap_reauth")

    @eap_reauth.setter
    def eap_reauth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "eap_reauth", value)

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable MAC Auth, uses the same auth_servers
        """
        return pulumi.get(self, "enable_mac_auth")

    @enable_mac_auth.setter
    def enable_mac_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_mac_auth", value)

    @property
    @pulumi.getter(name="keyIdx")
    def key_idx(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When `type`==`wep`
        """
        return pulumi.get(self, "key_idx")

    @key_idx.setter
    def key_idx(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "key_idx", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="multiPskOnly")
    def multi_psk_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When `type`==`psk`, whether to only use multi_psk
        """
        return pulumi.get(self, "multi_psk_only")

    @multi_psk_only.setter
    def multi_psk_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "multi_psk_only", value)

    @property
    @pulumi.getter
    def owe(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        """
        return pulumi.get(self, "owe")

    @owe.setter
    def owe(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owe", value)

    @property
    @pulumi.getter
    def pairwises(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        """
        return pulumi.get(self, "pairwises")

    @pairwises.setter
    def pairwises(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pairwises", value)

    @property
    @pulumi.getter(name="privateWlan")
    def private_wlan(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When `multi_psk_only`==`true`, whether private wlan is enabled
        """
        return pulumi.get(self, "private_wlan")

    @private_wlan.setter
    def private_wlan(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "private_wlan", value)

    @property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When `type`==`psk`, 8-64 characters, or 64 hex characters
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psk", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="wepAsSecondaryAuth")
    def wep_as_secondary_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable WEP as secondary auth
        """
        return pulumi.get(self, "wep_as_secondary_auth")

    @wep_as_secondary_auth.setter
    def wep_as_secondary_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wep_as_secondary_auth", value)


if not MYPY:
    class WlanAuthServerArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        IP/ hostname of RADIUS server
        """
        secret: pulumi.Input[builtins.str]
        """
        Secret of RADIUS server
        """
        keywrap_enabled: NotRequired[pulumi.Input[builtins.bool]]
        keywrap_format: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `ascii`, `hex`
        """
        keywrap_kek: NotRequired[pulumi.Input[builtins.str]]
        keywrap_mack: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        require_message_authenticator: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to require Message-Authenticator in requests
        """
elif False:
    WlanAuthServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanAuthServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 keywrap_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 keywrap_format: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_kek: Optional[pulumi.Input[builtins.str]] = None,
                 keywrap_mack: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 require_message_authenticator: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] host: IP/ hostname of RADIUS server
        :param pulumi.Input[builtins.str] secret: Secret of RADIUS server
        :param pulumi.Input[builtins.str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[builtins.bool] require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")

    @require_message_authenticator.setter
    def require_message_authenticator(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_message_authenticator", value)


if not MYPY:
    class WlanBonjourArgsDict(TypedDict):
        additional_vlan_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgsDict']]]]
        """
        What services are allowed. 
        Property key is the service name
        """
elif False:
    WlanBonjourArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanBonjourArgs:
    def __init__(__self__, *,
                 additional_vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] additional_vlan_ids: additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        :param pulumi.Input[builtins.bool] enabled: Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        :param pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]] services: What services are allowed. 
               Property key is the service name
        """
        if additional_vlan_ids is not None:
            pulumi.set(__self__, "additional_vlan_ids", additional_vlan_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="additionalVlanIds")
    def additional_vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        """
        return pulumi.get(self, "additional_vlan_ids")

    @additional_vlan_ids.setter
    def additional_vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "additional_vlan_ids", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]]]:
        """
        What services are allowed. 
        Property key is the service name
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class WlanBonjourServicesArgsDict(TypedDict):
        disable_local: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        """
        radius_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional, if the service is further restricted for certain RADIUS groups
        """
        scope: NotRequired[pulumi.Input[builtins.str]]
        """
        how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
elif False:
    WlanBonjourServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanBonjourServicesArgs:
    def __init__(__self__, *,
                 disable_local: Optional[pulumi.Input[builtins.bool]] = None,
                 radius_groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 scope: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_local: Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_groups: Optional, if the service is further restricted for certain RADIUS groups
        :param pulumi.Input[builtins.str] scope: how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        if disable_local is not None:
            pulumi.set(__self__, "disable_local", disable_local)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="disableLocal")
    def disable_local(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        """
        return pulumi.get(self, "disable_local")

    @disable_local.setter
    def disable_local(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_local", value)

    @property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional, if the service is further restricted for certain RADIUS groups
        """
        return pulumi.get(self, "radius_groups")

    @radius_groups.setter
    def radius_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "radius_groups", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WlanCiscoCwaArgsDict(TypedDict):
        allowed_hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of hostnames without http(s):// (matched by substring)
        """
        allowed_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of CIDRs
        """
        blocked_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of blocked CIDRs
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    WlanCiscoCwaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanCiscoCwaArgs:
    def __init__(__self__, *,
                 allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 blocked_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_subnets: List of CIDRs
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] blocked_subnets: List of blocked CIDRs
        """
        if allowed_hostnames is not None:
            pulumi.set(__self__, "allowed_hostnames", allowed_hostnames)
        if allowed_subnets is not None:
            pulumi.set(__self__, "allowed_subnets", allowed_subnets)
        if blocked_subnets is not None:
            pulumi.set(__self__, "blocked_subnets", blocked_subnets)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="allowedHostnames")
    def allowed_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "allowed_hostnames")

    @allowed_hostnames.setter
    def allowed_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_hostnames", value)

    @property
    @pulumi.getter(name="allowedSubnets")
    def allowed_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "allowed_subnets")

    @allowed_subnets.setter
    def allowed_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_subnets", value)

    @property
    @pulumi.getter(name="blockedSubnets")
    def blocked_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of blocked CIDRs
        """
        return pulumi.get(self, "blocked_subnets")

    @blocked_subnets.setter
    def blocked_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "blocked_subnets", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WlanCoaServerArgsDict(TypedDict):
        ip: pulumi.Input[builtins.str]
        secret: pulumi.Input[builtins.str]
        disable_event_timestamp_check: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable Event-Timestamp Check
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        port: NotRequired[pulumi.Input[builtins.str]]
elif False:
    WlanCoaServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanCoaServerArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[builtins.str],
                 secret: pulumi.Input[builtins.str],
                 disable_event_timestamp_check: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_event_timestamp_check: Whether to disable Event-Timestamp Check
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "secret", secret)
        if disable_event_timestamp_check is not None:
            pulumi.set(__self__, "disable_event_timestamp_check", disable_event_timestamp_check)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="disableEventTimestampCheck")
    def disable_event_timestamp_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable Event-Timestamp Check
        """
        return pulumi.get(self, "disable_event_timestamp_check")

    @disable_event_timestamp_check.setter
    def disable_event_timestamp_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_event_timestamp_check", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WlanDnsServerRewriteArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        radius_groups: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
elif False:
    WlanDnsServerRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanDnsServerRewriteArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 radius_groups: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] radius_groups: Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
        return pulumi.get(self, "radius_groups")

    @radius_groups.setter
    def radius_groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "radius_groups", value)


if not MYPY:
    class WlanDynamicPskArgsDict(TypedDict):
        default_psk: NotRequired[pulumi.Input[builtins.str]]
        """
        Default PSK to use if cloud WLC is not available, 8-63 characters
        """
        default_vlan_id: NotRequired[pulumi.Input[builtins.str]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        force_lookup: NotRequired[pulumi.Input[builtins.bool]]
        """
        When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `cloud_psks`, `radius`
        """
elif False:
    WlanDynamicPskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanDynamicPskArgs:
    def __init__(__self__, *,
                 default_psk: Optional[pulumi.Input[builtins.str]] = None,
                 default_vlan_id: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 force_lookup: Optional[pulumi.Input[builtins.bool]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] default_psk: Default PSK to use if cloud WLC is not available, 8-63 characters
        :param pulumi.Input[builtins.bool] force_lookup: When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        :param pulumi.Input[builtins.str] source: enum: `cloud_psks`, `radius`
        """
        if default_psk is not None:
            pulumi.set(__self__, "default_psk", default_psk)
        if default_vlan_id is not None:
            pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force_lookup is not None:
            pulumi.set(__self__, "force_lookup", force_lookup)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="defaultPsk")
    def default_psk(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default PSK to use if cloud WLC is not available, 8-63 characters
        """
        return pulumi.get(self, "default_psk")

    @default_psk.setter
    def default_psk(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_psk", value)

    @property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "default_vlan_id")

    @default_vlan_id.setter
    def default_vlan_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_vlan_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="forceLookup")
    def force_lookup(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        """
        return pulumi.get(self, "force_lookup")

    @force_lookup.setter
    def force_lookup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_lookup", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `cloud_psks`, `radius`
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class WlanDynamicVlanArgsDict(TypedDict):
        default_vlan_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        """
        local_vlan_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        VLAN_ids to be locally bridged
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        """
        vlans: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
          * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
          * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
elif False:
    WlanDynamicVlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanDynamicVlanArgs:
    def __init__(__self__, *,
                 default_vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 local_vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 vlans: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] default_vlan_ids: Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        :param pulumi.Input[builtins.bool] enabled: Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] local_vlan_ids: VLAN_ids to be locally bridged
        :param pulumi.Input[builtins.str] type: standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] vlans: Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
                 * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
                 * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        if default_vlan_ids is not None:
            pulumi.set(__self__, "default_vlan_ids", default_vlan_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if local_vlan_ids is not None:
            pulumi.set(__self__, "local_vlan_ids", local_vlan_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="defaultVlanIds")
    def default_vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        """
        return pulumi.get(self, "default_vlan_ids")

    @default_vlan_ids.setter
    def default_vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "default_vlan_ids", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="localVlanIds")
    def local_vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        VLAN_ids to be locally bridged
        """
        return pulumi.get(self, "local_vlan_ids")

    @local_vlan_ids.setter
    def local_vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "local_vlan_ids", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def vlans(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
          * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
          * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        return pulumi.get(self, "vlans")

    @vlans.setter
    def vlans(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vlans", value)


if not MYPY:
    class WlanHotspot20ArgsDict(TypedDict):
        domain_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable hotspot 2.0 config
        """
        nai_realms: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        operators: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of operators to support
        """
        rcois: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        venue_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Venue name, default is site name
        """
elif False:
    WlanHotspot20ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanHotspot20Args:
    def __init__(__self__, *,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 nai_realms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 operators: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rcois: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 venue_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Whether to enable hotspot 2.0 config
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] operators: List of operators to support
        :param pulumi.Input[builtins.str] venue_name: Venue name, default is site name
        """
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if nai_realms is not None:
            pulumi.set(__self__, "nai_realms", nai_realms)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)
        if rcois is not None:
            pulumi.set(__self__, "rcois", rcois)
        if venue_name is not None:
            pulumi.set(__self__, "venue_name", venue_name)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable hotspot 2.0 config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="naiRealms")
    def nai_realms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "nai_realms")

    @nai_realms.setter
    def nai_realms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "nai_realms", value)

    @property
    @pulumi.getter
    def operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of operators to support
        """
        return pulumi.get(self, "operators")

    @operators.setter
    def operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "operators", value)

    @property
    @pulumi.getter
    def rcois(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "rcois")

    @rcois.setter
    def rcois(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "rcois", value)

    @property
    @pulumi.getter(name="venueName")
    def venue_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Venue name, default is site name
        """
        return pulumi.get(self, "venue_name")

    @venue_name.setter
    def venue_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "venue_name", value)


if not MYPY:
    class WlanInjectDhcpOption82ArgsDict(TypedDict):
        circuit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
          * {{AP_MAC}}
          * {{AP_MAC_DASHED}}
          * {{AP_MODEL}}
          * {{AP_NAME}}
          * {{SITE_NAME}}
          * {{SSID}}
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to inject option 82 when forwarding DHCP packets
        """
elif False:
    WlanInjectDhcpOption82ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanInjectDhcpOption82Args:
    def __init__(__self__, *,
                 circuit_id: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] circuit_id: Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
                 * {{AP_MAC}}
                 * {{AP_MAC_DASHED}}
                 * {{AP_MODEL}}
                 * {{AP_NAME}}
                 * {{SITE_NAME}}
                 * {{SSID}}
        :param pulumi.Input[builtins.bool] enabled: Whether to inject option 82 when forwarding DHCP packets
        """
        if circuit_id is not None:
            pulumi.set(__self__, "circuit_id", circuit_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="circuitId")
    def circuit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
          * {{AP_MAC}}
          * {{AP_MAC_DASHED}}
          * {{AP_MODEL}}
          * {{AP_NAME}}
          * {{SITE_NAME}}
          * {{SSID}}
        """
        return pulumi.get(self, "circuit_id")

    @circuit_id.setter
    def circuit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "circuit_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to inject option 82 when forwarding DHCP packets
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WlanMistNacArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        When enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed
        """
elif False:
    WlanMistNacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanMistNacArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: When enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WlanPortalArgsDict(TypedDict):
        allow_wlan_id_roam: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        """
        amazon_client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        amazon_client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        """
        amazon_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        amazon_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether amazon is enabled as a login method
        """
        amazon_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        """
        auth: NotRequired[pulumi.Input[builtins.str]]
        """
        authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        """
        azure_client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `azure_enabled`==`true`. Azure active directory app client id
        """
        azure_client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `azure_enabled`==`true`. Azure active directory app client secret
        """
        azure_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether Azure Active Directory is enabled as a login method
        """
        azure_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        """
        azure_tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `azure_enabled`==`true`. Azure active directory tenant id.
        """
        broadnet_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`broadnet`
        """
        broadnet_sid: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`broadnet`
        """
        broadnet_user_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`broadnet`
        """
        bypass_when_cloud_down: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        """
        clickatell_api_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`clickatell`
        """
        cross_site: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        """
        email_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether email (access code verification) is enabled as a login method
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether guest portal is enabled
        """
        expire: NotRequired[pulumi.Input[builtins.int]]
        """
        How long to remain authorized, in minutes
        """
        external_portal_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        """
        facebook_client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        facebook_client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        """
        facebook_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        facebook_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether facebook is enabled as a login method
        """
        facebook_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        """
        forward: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to forward the user to another URL after authorized
        """
        forward_url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL to forward the user to
        """
        google_client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        google_client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        """
        google_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        google_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether Google is enabled as login method
        """
        google_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        """
        gupshup_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`gupshup`
        """
        gupshup_userid: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`gupshup`
        """
        microsoft_client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        microsoft_client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        """
        microsoft_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        microsoft_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether microsoft 365 is enabled as a login method
        """
        microsoft_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        """
        passphrase_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether password is enabled
        """
        passphrase_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `passphrase_enabled`==`true`.
        """
        predefined_sponsors_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        """
        predefined_sponsors_hide_email: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to hide sponsors email from list of sponsors
        """
        privacy: NotRequired[pulumi.Input[builtins.bool]]
        puzzel_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`puzzel`
        """
        puzzel_service_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`puzzel`
        """
        puzzel_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`puzzel`
        """
        sms_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether sms is enabled as a login method
        """
        sms_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        """
        sms_message_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `sms_enabled`==`true`. SMS Message format
        """
        sms_provider: NotRequired[pulumi.Input[builtins.str]]
        """
        Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        """
        sponsor_auto_approve: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        """
        sponsor_email_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        """
        sponsor_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether sponsor is enabled
        """
        sponsor_expire: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        """
        sponsor_link_validity_duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes. Default is 60 minutes.
        """
        sponsor_notify_all: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        """
        sponsor_status_notify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        """
        sponsors: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        object of allowed sponsors email with name. Required if `sponsor_enabled`
                    is `true` and `sponsor_email_domains` is empty.

                    Property key is the sponsor email, Property value is the sponsor name
        """
        sso_default_role: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `wlan_portal_auth`==`sso`, default role to assign if theres no match. By default, an assertion is treated as invalid when theres no role matched
        """
        sso_forced_role: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `wlan_portal_auth`==`sso`
        """
        sso_idp_cert: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        """
        sso_idp_sign_algo: NotRequired[pulumi.Input[builtins.str]]
        """
        Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        """
        sso_idp_sso_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        """
        sso_issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        """
        sso_nameid_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        """
        telstra_client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        """
        telstra_client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        """
        twilio_auth_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`twilio`, Auth token account with twilio account
        """
        twilio_phone_number: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        """
        twilio_sid: NotRequired[pulumi.Input[builtins.str]]
        """
        Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
elif False:
    WlanPortalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanPortalArgs:
    def __init__(__self__, *,
                 allow_wlan_id_roam: Optional[pulumi.Input[builtins.bool]] = None,
                 amazon_client_id: Optional[pulumi.Input[builtins.str]] = None,
                 amazon_client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 amazon_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 amazon_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 amazon_expire: Optional[pulumi.Input[builtins.int]] = None,
                 auth: Optional[pulumi.Input[builtins.str]] = None,
                 azure_client_id: Optional[pulumi.Input[builtins.str]] = None,
                 azure_client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 azure_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 azure_expire: Optional[pulumi.Input[builtins.int]] = None,
                 azure_tenant_id: Optional[pulumi.Input[builtins.str]] = None,
                 broadnet_password: Optional[pulumi.Input[builtins.str]] = None,
                 broadnet_sid: Optional[pulumi.Input[builtins.str]] = None,
                 broadnet_user_id: Optional[pulumi.Input[builtins.str]] = None,
                 bypass_when_cloud_down: Optional[pulumi.Input[builtins.bool]] = None,
                 clickatell_api_key: Optional[pulumi.Input[builtins.str]] = None,
                 cross_site: Optional[pulumi.Input[builtins.bool]] = None,
                 email_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 expire: Optional[pulumi.Input[builtins.int]] = None,
                 external_portal_url: Optional[pulumi.Input[builtins.str]] = None,
                 facebook_client_id: Optional[pulumi.Input[builtins.str]] = None,
                 facebook_client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 facebook_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 facebook_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 facebook_expire: Optional[pulumi.Input[builtins.int]] = None,
                 forward: Optional[pulumi.Input[builtins.bool]] = None,
                 forward_url: Optional[pulumi.Input[builtins.str]] = None,
                 google_client_id: Optional[pulumi.Input[builtins.str]] = None,
                 google_client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 google_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 google_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 google_expire: Optional[pulumi.Input[builtins.int]] = None,
                 gupshup_password: Optional[pulumi.Input[builtins.str]] = None,
                 gupshup_userid: Optional[pulumi.Input[builtins.str]] = None,
                 microsoft_client_id: Optional[pulumi.Input[builtins.str]] = None,
                 microsoft_client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 microsoft_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 microsoft_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 microsoft_expire: Optional[pulumi.Input[builtins.int]] = None,
                 passphrase_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 passphrase_expire: Optional[pulumi.Input[builtins.int]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 predefined_sponsors_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 predefined_sponsors_hide_email: Optional[pulumi.Input[builtins.bool]] = None,
                 privacy: Optional[pulumi.Input[builtins.bool]] = None,
                 puzzel_password: Optional[pulumi.Input[builtins.str]] = None,
                 puzzel_service_id: Optional[pulumi.Input[builtins.str]] = None,
                 puzzel_username: Optional[pulumi.Input[builtins.str]] = None,
                 sms_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 sms_expire: Optional[pulumi.Input[builtins.int]] = None,
                 sms_message_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_provider: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_auto_approve: Optional[pulumi.Input[builtins.bool]] = None,
                 sponsor_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 sponsor_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 sponsor_expire: Optional[pulumi.Input[builtins.int]] = None,
                 sponsor_link_validity_duration: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_notify_all: Optional[pulumi.Input[builtins.bool]] = None,
                 sponsor_status_notify: Optional[pulumi.Input[builtins.bool]] = None,
                 sponsors: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 sso_default_role: Optional[pulumi.Input[builtins.str]] = None,
                 sso_forced_role: Optional[pulumi.Input[builtins.str]] = None,
                 sso_idp_cert: Optional[pulumi.Input[builtins.str]] = None,
                 sso_idp_sign_algo: Optional[pulumi.Input[builtins.str]] = None,
                 sso_idp_sso_url: Optional[pulumi.Input[builtins.str]] = None,
                 sso_issuer: Optional[pulumi.Input[builtins.str]] = None,
                 sso_nameid_format: Optional[pulumi.Input[builtins.str]] = None,
                 telstra_client_id: Optional[pulumi.Input[builtins.str]] = None,
                 telstra_client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 twilio_auth_token: Optional[pulumi.Input[builtins.str]] = None,
                 twilio_phone_number: Optional[pulumi.Input[builtins.str]] = None,
                 twilio_sid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] allow_wlan_id_roam: Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        :param pulumi.Input[builtins.str] amazon_client_id: Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[builtins.str] amazon_client_secret: Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] amazon_email_domains: Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[builtins.bool] amazon_enabled: Whether amazon is enabled as a login method
        :param pulumi.Input[builtins.int] amazon_expire: Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.str] auth: authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        :param pulumi.Input[builtins.str] azure_client_id: Required if `azure_enabled`==`true`. Azure active directory app client id
        :param pulumi.Input[builtins.str] azure_client_secret: Required if `azure_enabled`==`true`. Azure active directory app client secret
        :param pulumi.Input[builtins.bool] azure_enabled: Whether Azure Active Directory is enabled as a login method
        :param pulumi.Input[builtins.int] azure_expire: Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.str] azure_tenant_id: Required if `azure_enabled`==`true`. Azure active directory tenant id.
        :param pulumi.Input[builtins.str] broadnet_password: Required if `sms_provider`==`broadnet`
        :param pulumi.Input[builtins.str] broadnet_sid: Required if `sms_provider`==`broadnet`
        :param pulumi.Input[builtins.str] broadnet_user_id: Required if `sms_provider`==`broadnet`
        :param pulumi.Input[builtins.bool] bypass_when_cloud_down: Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        :param pulumi.Input[builtins.str] clickatell_api_key: Required if `sms_provider`==`clickatell`
        :param pulumi.Input[builtins.bool] cross_site: Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        :param pulumi.Input[builtins.bool] email_enabled: Whether email (access code verification) is enabled as a login method
        :param pulumi.Input[builtins.bool] enabled: Whether guest portal is enabled
        :param pulumi.Input[builtins.int] expire: How long to remain authorized, in minutes
        :param pulumi.Input[builtins.str] external_portal_url: Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        :param pulumi.Input[builtins.str] facebook_client_id: Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[builtins.str] facebook_client_secret: Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] facebook_email_domains: Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[builtins.bool] facebook_enabled: Whether facebook is enabled as a login method
        :param pulumi.Input[builtins.int] facebook_expire: Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.bool] forward: Whether to forward the user to another URL after authorized
        :param pulumi.Input[builtins.str] forward_url: URL to forward the user to
        :param pulumi.Input[builtins.str] google_client_id: Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[builtins.str] google_client_secret: Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] google_email_domains: Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[builtins.bool] google_enabled: Whether Google is enabled as login method
        :param pulumi.Input[builtins.int] google_expire: Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.str] gupshup_password: Required if `sms_provider`==`gupshup`
        :param pulumi.Input[builtins.str] gupshup_userid: Required if `sms_provider`==`gupshup`
        :param pulumi.Input[builtins.str] microsoft_client_id: Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[builtins.str] microsoft_client_secret: Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] microsoft_email_domains: Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[builtins.bool] microsoft_enabled: Whether microsoft 365 is enabled as a login method
        :param pulumi.Input[builtins.int] microsoft_expire: Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.bool] passphrase_enabled: Whether password is enabled
        :param pulumi.Input[builtins.int] passphrase_expire: Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        :param pulumi.Input[builtins.str] password: Required if `passphrase_enabled`==`true`.
        :param pulumi.Input[builtins.bool] predefined_sponsors_enabled: Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        :param pulumi.Input[builtins.bool] predefined_sponsors_hide_email: Whether to hide sponsors email from list of sponsors
        :param pulumi.Input[builtins.str] puzzel_password: Required if `sms_provider`==`puzzel`
        :param pulumi.Input[builtins.str] puzzel_service_id: Required if `sms_provider`==`puzzel`
        :param pulumi.Input[builtins.str] puzzel_username: Required if `sms_provider`==`puzzel`
        :param pulumi.Input[builtins.bool] sms_enabled: Whether sms is enabled as a login method
        :param pulumi.Input[builtins.int] sms_expire: Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.str] sms_message_format: Optional if `sms_enabled`==`true`. SMS Message format
        :param pulumi.Input[builtins.str] sms_provider: Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        :param pulumi.Input[builtins.bool] sponsor_auto_approve: Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sponsor_email_domains: List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        :param pulumi.Input[builtins.bool] sponsor_enabled: Whether sponsor is enabled
        :param pulumi.Input[builtins.int] sponsor_expire: Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[builtins.str] sponsor_link_validity_duration: Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes. Default is 60 minutes.
        :param pulumi.Input[builtins.bool] sponsor_notify_all: Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        :param pulumi.Input[builtins.bool] sponsor_status_notify: Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] sponsors: object of allowed sponsors email with name. Required if `sponsor_enabled`
                           is `true` and `sponsor_email_domains` is empty.
               
                           Property key is the sponsor email, Property value is the sponsor name
        :param pulumi.Input[builtins.str] sso_default_role: Optional if `wlan_portal_auth`==`sso`, default role to assign if theres no match. By default, an assertion is treated as invalid when theres no role matched
        :param pulumi.Input[builtins.str] sso_forced_role: Optional if `wlan_portal_auth`==`sso`
        :param pulumi.Input[builtins.str] sso_idp_cert: Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        :param pulumi.Input[builtins.str] sso_idp_sign_algo: Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        :param pulumi.Input[builtins.str] sso_idp_sso_url: Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        :param pulumi.Input[builtins.str] sso_issuer: Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        :param pulumi.Input[builtins.str] sso_nameid_format: Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        :param pulumi.Input[builtins.str] telstra_client_id: Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        :param pulumi.Input[builtins.str] telstra_client_secret: Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        :param pulumi.Input[builtins.str] twilio_auth_token: Required if `sms_provider`==`twilio`, Auth token account with twilio account
        :param pulumi.Input[builtins.str] twilio_phone_number: Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        :param pulumi.Input[builtins.str] twilio_sid: Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        if allow_wlan_id_roam is not None:
            pulumi.set(__self__, "allow_wlan_id_roam", allow_wlan_id_roam)
        if amazon_client_id is not None:
            pulumi.set(__self__, "amazon_client_id", amazon_client_id)
        if amazon_client_secret is not None:
            pulumi.set(__self__, "amazon_client_secret", amazon_client_secret)
        if amazon_email_domains is not None:
            pulumi.set(__self__, "amazon_email_domains", amazon_email_domains)
        if amazon_enabled is not None:
            pulumi.set(__self__, "amazon_enabled", amazon_enabled)
        if amazon_expire is not None:
            pulumi.set(__self__, "amazon_expire", amazon_expire)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if azure_client_id is not None:
            pulumi.set(__self__, "azure_client_id", azure_client_id)
        if azure_client_secret is not None:
            pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        if azure_enabled is not None:
            pulumi.set(__self__, "azure_enabled", azure_enabled)
        if azure_expire is not None:
            pulumi.set(__self__, "azure_expire", azure_expire)
        if azure_tenant_id is not None:
            pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        if broadnet_password is not None:
            pulumi.set(__self__, "broadnet_password", broadnet_password)
        if broadnet_sid is not None:
            pulumi.set(__self__, "broadnet_sid", broadnet_sid)
        if broadnet_user_id is not None:
            pulumi.set(__self__, "broadnet_user_id", broadnet_user_id)
        if bypass_when_cloud_down is not None:
            pulumi.set(__self__, "bypass_when_cloud_down", bypass_when_cloud_down)
        if clickatell_api_key is not None:
            pulumi.set(__self__, "clickatell_api_key", clickatell_api_key)
        if cross_site is not None:
            pulumi.set(__self__, "cross_site", cross_site)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if external_portal_url is not None:
            pulumi.set(__self__, "external_portal_url", external_portal_url)
        if facebook_client_id is not None:
            pulumi.set(__self__, "facebook_client_id", facebook_client_id)
        if facebook_client_secret is not None:
            pulumi.set(__self__, "facebook_client_secret", facebook_client_secret)
        if facebook_email_domains is not None:
            pulumi.set(__self__, "facebook_email_domains", facebook_email_domains)
        if facebook_enabled is not None:
            pulumi.set(__self__, "facebook_enabled", facebook_enabled)
        if facebook_expire is not None:
            pulumi.set(__self__, "facebook_expire", facebook_expire)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if forward_url is not None:
            pulumi.set(__self__, "forward_url", forward_url)
        if google_client_id is not None:
            pulumi.set(__self__, "google_client_id", google_client_id)
        if google_client_secret is not None:
            pulumi.set(__self__, "google_client_secret", google_client_secret)
        if google_email_domains is not None:
            pulumi.set(__self__, "google_email_domains", google_email_domains)
        if google_enabled is not None:
            pulumi.set(__self__, "google_enabled", google_enabled)
        if google_expire is not None:
            pulumi.set(__self__, "google_expire", google_expire)
        if gupshup_password is not None:
            pulumi.set(__self__, "gupshup_password", gupshup_password)
        if gupshup_userid is not None:
            pulumi.set(__self__, "gupshup_userid", gupshup_userid)
        if microsoft_client_id is not None:
            pulumi.set(__self__, "microsoft_client_id", microsoft_client_id)
        if microsoft_client_secret is not None:
            pulumi.set(__self__, "microsoft_client_secret", microsoft_client_secret)
        if microsoft_email_domains is not None:
            pulumi.set(__self__, "microsoft_email_domains", microsoft_email_domains)
        if microsoft_enabled is not None:
            pulumi.set(__self__, "microsoft_enabled", microsoft_enabled)
        if microsoft_expire is not None:
            pulumi.set(__self__, "microsoft_expire", microsoft_expire)
        if passphrase_enabled is not None:
            pulumi.set(__self__, "passphrase_enabled", passphrase_enabled)
        if passphrase_expire is not None:
            pulumi.set(__self__, "passphrase_expire", passphrase_expire)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if predefined_sponsors_enabled is not None:
            pulumi.set(__self__, "predefined_sponsors_enabled", predefined_sponsors_enabled)
        if predefined_sponsors_hide_email is not None:
            pulumi.set(__self__, "predefined_sponsors_hide_email", predefined_sponsors_hide_email)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if puzzel_password is not None:
            pulumi.set(__self__, "puzzel_password", puzzel_password)
        if puzzel_service_id is not None:
            pulumi.set(__self__, "puzzel_service_id", puzzel_service_id)
        if puzzel_username is not None:
            pulumi.set(__self__, "puzzel_username", puzzel_username)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if sms_expire is not None:
            pulumi.set(__self__, "sms_expire", sms_expire)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_provider is not None:
            pulumi.set(__self__, "sms_provider", sms_provider)
        if sponsor_auto_approve is not None:
            pulumi.set(__self__, "sponsor_auto_approve", sponsor_auto_approve)
        if sponsor_email_domains is not None:
            pulumi.set(__self__, "sponsor_email_domains", sponsor_email_domains)
        if sponsor_enabled is not None:
            pulumi.set(__self__, "sponsor_enabled", sponsor_enabled)
        if sponsor_expire is not None:
            pulumi.set(__self__, "sponsor_expire", sponsor_expire)
        if sponsor_link_validity_duration is not None:
            pulumi.set(__self__, "sponsor_link_validity_duration", sponsor_link_validity_duration)
        if sponsor_notify_all is not None:
            pulumi.set(__self__, "sponsor_notify_all", sponsor_notify_all)
        if sponsor_status_notify is not None:
            pulumi.set(__self__, "sponsor_status_notify", sponsor_status_notify)
        if sponsors is not None:
            pulumi.set(__self__, "sponsors", sponsors)
        if sso_default_role is not None:
            pulumi.set(__self__, "sso_default_role", sso_default_role)
        if sso_forced_role is not None:
            pulumi.set(__self__, "sso_forced_role", sso_forced_role)
        if sso_idp_cert is not None:
            pulumi.set(__self__, "sso_idp_cert", sso_idp_cert)
        if sso_idp_sign_algo is not None:
            pulumi.set(__self__, "sso_idp_sign_algo", sso_idp_sign_algo)
        if sso_idp_sso_url is not None:
            pulumi.set(__self__, "sso_idp_sso_url", sso_idp_sso_url)
        if sso_issuer is not None:
            pulumi.set(__self__, "sso_issuer", sso_issuer)
        if sso_nameid_format is not None:
            pulumi.set(__self__, "sso_nameid_format", sso_nameid_format)
        if telstra_client_id is not None:
            pulumi.set(__self__, "telstra_client_id", telstra_client_id)
        if telstra_client_secret is not None:
            pulumi.set(__self__, "telstra_client_secret", telstra_client_secret)
        if twilio_auth_token is not None:
            pulumi.set(__self__, "twilio_auth_token", twilio_auth_token)
        if twilio_phone_number is not None:
            pulumi.set(__self__, "twilio_phone_number", twilio_phone_number)
        if twilio_sid is not None:
            pulumi.set(__self__, "twilio_sid", twilio_sid)

    @property
    @pulumi.getter(name="allowWlanIdRoam")
    def allow_wlan_id_roam(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "allow_wlan_id_roam")

    @allow_wlan_id_roam.setter
    def allow_wlan_id_roam(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_wlan_id_roam", value)

    @property
    @pulumi.getter(name="amazonClientId")
    def amazon_client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "amazon_client_id")

    @amazon_client_id.setter
    def amazon_client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "amazon_client_id", value)

    @property
    @pulumi.getter(name="amazonClientSecret")
    def amazon_client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "amazon_client_secret")

    @amazon_client_secret.setter
    def amazon_client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "amazon_client_secret", value)

    @property
    @pulumi.getter(name="amazonEmailDomains")
    def amazon_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "amazon_email_domains")

    @amazon_email_domains.setter
    def amazon_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "amazon_email_domains", value)

    @property
    @pulumi.getter(name="amazonEnabled")
    def amazon_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether amazon is enabled as a login method
        """
        return pulumi.get(self, "amazon_enabled")

    @amazon_enabled.setter
    def amazon_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "amazon_enabled", value)

    @property
    @pulumi.getter(name="amazonExpire")
    def amazon_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "amazon_expire")

    @amazon_expire.setter
    def amazon_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "amazon_expire", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `azure_enabled`==`true`. Azure active directory app client id
        """
        return pulumi.get(self, "azure_client_id")

    @azure_client_id.setter
    def azure_client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "azure_client_id", value)

    @property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `azure_enabled`==`true`. Azure active directory app client secret
        """
        return pulumi.get(self, "azure_client_secret")

    @azure_client_secret.setter
    def azure_client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "azure_client_secret", value)

    @property
    @pulumi.getter(name="azureEnabled")
    def azure_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Azure Active Directory is enabled as a login method
        """
        return pulumi.get(self, "azure_enabled")

    @azure_enabled.setter
    def azure_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "azure_enabled", value)

    @property
    @pulumi.getter(name="azureExpire")
    def azure_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "azure_expire")

    @azure_expire.setter
    def azure_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "azure_expire", value)

    @property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `azure_enabled`==`true`. Azure active directory tenant id.
        """
        return pulumi.get(self, "azure_tenant_id")

    @azure_tenant_id.setter
    def azure_tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "azure_tenant_id", value)

    @property
    @pulumi.getter(name="broadnetPassword")
    def broadnet_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_password")

    @broadnet_password.setter
    def broadnet_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "broadnet_password", value)

    @property
    @pulumi.getter(name="broadnetSid")
    def broadnet_sid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_sid")

    @broadnet_sid.setter
    def broadnet_sid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "broadnet_sid", value)

    @property
    @pulumi.getter(name="broadnetUserId")
    def broadnet_user_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_user_id")

    @broadnet_user_id.setter
    def broadnet_user_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "broadnet_user_id", value)

    @property
    @pulumi.getter(name="bypassWhenCloudDown")
    def bypass_when_cloud_down(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        """
        return pulumi.get(self, "bypass_when_cloud_down")

    @bypass_when_cloud_down.setter
    def bypass_when_cloud_down(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bypass_when_cloud_down", value)

    @property
    @pulumi.getter(name="clickatellApiKey")
    def clickatell_api_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`clickatell`
        """
        return pulumi.get(self, "clickatell_api_key")

    @clickatell_api_key.setter
    def clickatell_api_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "clickatell_api_key", value)

    @property
    @pulumi.getter(name="crossSite")
    def cross_site(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "cross_site")

    @cross_site.setter
    def cross_site(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cross_site", value)

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether email (access code verification) is enabled as a login method
        """
        return pulumi.get(self, "email_enabled")

    @email_enabled.setter
    def email_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "email_enabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether guest portal is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How long to remain authorized, in minutes
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expire", value)

    @property
    @pulumi.getter(name="externalPortalUrl")
    def external_portal_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        """
        return pulumi.get(self, "external_portal_url")

    @external_portal_url.setter
    def external_portal_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_portal_url", value)

    @property
    @pulumi.getter(name="facebookClientId")
    def facebook_client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "facebook_client_id")

    @facebook_client_id.setter
    def facebook_client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facebook_client_id", value)

    @property
    @pulumi.getter(name="facebookClientSecret")
    def facebook_client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "facebook_client_secret")

    @facebook_client_secret.setter
    def facebook_client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "facebook_client_secret", value)

    @property
    @pulumi.getter(name="facebookEmailDomains")
    def facebook_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "facebook_email_domains")

    @facebook_email_domains.setter
    def facebook_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "facebook_email_domains", value)

    @property
    @pulumi.getter(name="facebookEnabled")
    def facebook_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether facebook is enabled as a login method
        """
        return pulumi.get(self, "facebook_enabled")

    @facebook_enabled.setter
    def facebook_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "facebook_enabled", value)

    @property
    @pulumi.getter(name="facebookExpire")
    def facebook_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "facebook_expire")

    @facebook_expire.setter
    def facebook_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "facebook_expire", value)

    @property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to forward the user to another URL after authorized
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "forward", value)

    @property
    @pulumi.getter(name="forwardUrl")
    def forward_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL to forward the user to
        """
        return pulumi.get(self, "forward_url")

    @forward_url.setter
    def forward_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "forward_url", value)

    @property
    @pulumi.getter(name="googleClientId")
    def google_client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "google_client_id")

    @google_client_id.setter
    def google_client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "google_client_id", value)

    @property
    @pulumi.getter(name="googleClientSecret")
    def google_client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "google_client_secret")

    @google_client_secret.setter
    def google_client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "google_client_secret", value)

    @property
    @pulumi.getter(name="googleEmailDomains")
    def google_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "google_email_domains")

    @google_email_domains.setter
    def google_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "google_email_domains", value)

    @property
    @pulumi.getter(name="googleEnabled")
    def google_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Google is enabled as login method
        """
        return pulumi.get(self, "google_enabled")

    @google_enabled.setter
    def google_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "google_enabled", value)

    @property
    @pulumi.getter(name="googleExpire")
    def google_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "google_expire")

    @google_expire.setter
    def google_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "google_expire", value)

    @property
    @pulumi.getter(name="gupshupPassword")
    def gupshup_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_password")

    @gupshup_password.setter
    def gupshup_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gupshup_password", value)

    @property
    @pulumi.getter(name="gupshupUserid")
    def gupshup_userid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_userid")

    @gupshup_userid.setter
    def gupshup_userid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gupshup_userid", value)

    @property
    @pulumi.getter(name="microsoftClientId")
    def microsoft_client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "microsoft_client_id")

    @microsoft_client_id.setter
    def microsoft_client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microsoft_client_id", value)

    @property
    @pulumi.getter(name="microsoftClientSecret")
    def microsoft_client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "microsoft_client_secret")

    @microsoft_client_secret.setter
    def microsoft_client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microsoft_client_secret", value)

    @property
    @pulumi.getter(name="microsoftEmailDomains")
    def microsoft_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "microsoft_email_domains")

    @microsoft_email_domains.setter
    def microsoft_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "microsoft_email_domains", value)

    @property
    @pulumi.getter(name="microsoftEnabled")
    def microsoft_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether microsoft 365 is enabled as a login method
        """
        return pulumi.get(self, "microsoft_enabled")

    @microsoft_enabled.setter
    def microsoft_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "microsoft_enabled", value)

    @property
    @pulumi.getter(name="microsoftExpire")
    def microsoft_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "microsoft_expire")

    @microsoft_expire.setter
    def microsoft_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "microsoft_expire", value)

    @property
    @pulumi.getter(name="passphraseEnabled")
    def passphrase_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether password is enabled
        """
        return pulumi.get(self, "passphrase_enabled")

    @passphrase_enabled.setter
    def passphrase_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "passphrase_enabled", value)

    @property
    @pulumi.getter(name="passphraseExpire")
    def passphrase_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        """
        return pulumi.get(self, "passphrase_expire")

    @passphrase_expire.setter
    def passphrase_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "passphrase_expire", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `passphrase_enabled`==`true`.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="predefinedSponsorsEnabled")
    def predefined_sponsors_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        """
        return pulumi.get(self, "predefined_sponsors_enabled")

    @predefined_sponsors_enabled.setter
    def predefined_sponsors_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "predefined_sponsors_enabled", value)

    @property
    @pulumi.getter(name="predefinedSponsorsHideEmail")
    def predefined_sponsors_hide_email(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to hide sponsors email from list of sponsors
        """
        return pulumi.get(self, "predefined_sponsors_hide_email")

    @predefined_sponsors_hide_email.setter
    def predefined_sponsors_hide_email(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "predefined_sponsors_hide_email", value)

    @property
    @pulumi.getter
    def privacy(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "privacy")

    @privacy.setter
    def privacy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "privacy", value)

    @property
    @pulumi.getter(name="puzzelPassword")
    def puzzel_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_password")

    @puzzel_password.setter
    def puzzel_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "puzzel_password", value)

    @property
    @pulumi.getter(name="puzzelServiceId")
    def puzzel_service_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_service_id")

    @puzzel_service_id.setter
    def puzzel_service_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "puzzel_service_id", value)

    @property
    @pulumi.getter(name="puzzelUsername")
    def puzzel_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_username")

    @puzzel_username.setter
    def puzzel_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "puzzel_username", value)

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether sms is enabled as a login method
        """
        return pulumi.get(self, "sms_enabled")

    @sms_enabled.setter
    def sms_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sms_enabled", value)

    @property
    @pulumi.getter(name="smsExpire")
    def sms_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sms_expire")

    @sms_expire.setter
    def sms_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "sms_expire", value)

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `sms_enabled`==`true`. SMS Message format
        """
        return pulumi.get(self, "sms_message_format")

    @sms_message_format.setter
    def sms_message_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_message_format", value)

    @property
    @pulumi.getter(name="smsProvider")
    def sms_provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        """
        return pulumi.get(self, "sms_provider")

    @sms_provider.setter
    def sms_provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_provider", value)

    @property
    @pulumi.getter(name="sponsorAutoApprove")
    def sponsor_auto_approve(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        """
        return pulumi.get(self, "sponsor_auto_approve")

    @sponsor_auto_approve.setter
    def sponsor_auto_approve(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sponsor_auto_approve", value)

    @property
    @pulumi.getter(name="sponsorEmailDomains")
    def sponsor_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        """
        return pulumi.get(self, "sponsor_email_domains")

    @sponsor_email_domains.setter
    def sponsor_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sponsor_email_domains", value)

    @property
    @pulumi.getter(name="sponsorEnabled")
    def sponsor_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether sponsor is enabled
        """
        return pulumi.get(self, "sponsor_enabled")

    @sponsor_enabled.setter
    def sponsor_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sponsor_enabled", value)

    @property
    @pulumi.getter(name="sponsorExpire")
    def sponsor_expire(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sponsor_expire")

    @sponsor_expire.setter
    def sponsor_expire(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "sponsor_expire", value)

    @property
    @pulumi.getter(name="sponsorLinkValidityDuration")
    def sponsor_link_validity_duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes. Default is 60 minutes.
        """
        return pulumi.get(self, "sponsor_link_validity_duration")

    @sponsor_link_validity_duration.setter
    def sponsor_link_validity_duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_link_validity_duration", value)

    @property
    @pulumi.getter(name="sponsorNotifyAll")
    def sponsor_notify_all(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        """
        return pulumi.get(self, "sponsor_notify_all")

    @sponsor_notify_all.setter
    def sponsor_notify_all(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sponsor_notify_all", value)

    @property
    @pulumi.getter(name="sponsorStatusNotify")
    def sponsor_status_notify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        """
        return pulumi.get(self, "sponsor_status_notify")

    @sponsor_status_notify.setter
    def sponsor_status_notify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sponsor_status_notify", value)

    @property
    @pulumi.getter
    def sponsors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        object of allowed sponsors email with name. Required if `sponsor_enabled`
                    is `true` and `sponsor_email_domains` is empty.

                    Property key is the sponsor email, Property value is the sponsor name
        """
        return pulumi.get(self, "sponsors")

    @sponsors.setter
    def sponsors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sponsors", value)

    @property
    @pulumi.getter(name="ssoDefaultRole")
    def sso_default_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `wlan_portal_auth`==`sso`, default role to assign if theres no match. By default, an assertion is treated as invalid when theres no role matched
        """
        return pulumi.get(self, "sso_default_role")

    @sso_default_role.setter
    def sso_default_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_default_role", value)

    @property
    @pulumi.getter(name="ssoForcedRole")
    def sso_forced_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `wlan_portal_auth`==`sso`
        """
        return pulumi.get(self, "sso_forced_role")

    @sso_forced_role.setter
    def sso_forced_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_forced_role", value)

    @property
    @pulumi.getter(name="ssoIdpCert")
    def sso_idp_cert(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        """
        return pulumi.get(self, "sso_idp_cert")

    @sso_idp_cert.setter
    def sso_idp_cert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_idp_cert", value)

    @property
    @pulumi.getter(name="ssoIdpSignAlgo")
    def sso_idp_sign_algo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        """
        return pulumi.get(self, "sso_idp_sign_algo")

    @sso_idp_sign_algo.setter
    def sso_idp_sign_algo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_idp_sign_algo", value)

    @property
    @pulumi.getter(name="ssoIdpSsoUrl")
    def sso_idp_sso_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        """
        return pulumi.get(self, "sso_idp_sso_url")

    @sso_idp_sso_url.setter
    def sso_idp_sso_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_idp_sso_url", value)

    @property
    @pulumi.getter(name="ssoIssuer")
    def sso_issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        """
        return pulumi.get(self, "sso_issuer")

    @sso_issuer.setter
    def sso_issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_issuer", value)

    @property
    @pulumi.getter(name="ssoNameidFormat")
    def sso_nameid_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        """
        return pulumi.get(self, "sso_nameid_format")

    @sso_nameid_format.setter
    def sso_nameid_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_nameid_format", value)

    @property
    @pulumi.getter(name="telstraClientId")
    def telstra_client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        """
        return pulumi.get(self, "telstra_client_id")

    @telstra_client_id.setter
    def telstra_client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "telstra_client_id", value)

    @property
    @pulumi.getter(name="telstraClientSecret")
    def telstra_client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        """
        return pulumi.get(self, "telstra_client_secret")

    @telstra_client_secret.setter
    def telstra_client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "telstra_client_secret", value)

    @property
    @pulumi.getter(name="twilioAuthToken")
    def twilio_auth_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`twilio`, Auth token account with twilio account
        """
        return pulumi.get(self, "twilio_auth_token")

    @twilio_auth_token.setter
    def twilio_auth_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "twilio_auth_token", value)

    @property
    @pulumi.getter(name="twilioPhoneNumber")
    def twilio_phone_number(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        """
        return pulumi.get(self, "twilio_phone_number")

    @twilio_phone_number.setter
    def twilio_phone_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "twilio_phone_number", value)

    @property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        return pulumi.get(self, "twilio_sid")

    @twilio_sid.setter
    def twilio_sid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "twilio_sid", value)


if not MYPY:
    class WlanPortalTemplatePortalTemplateArgsDict(TypedDict):
        access_code_alternate_email: NotRequired[pulumi.Input[builtins.str]]
        alignment: NotRequired[pulumi.Input[builtins.str]]
        """
        defines alignment on portal. enum: `center`, `left`, `right`
        """
        auth_button_amazon: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Amazon auth button
        """
        auth_button_azure: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Azure auth button
        """
        auth_button_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Email auth button
        """
        auth_button_facebook: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Facebook auth button
        """
        auth_button_google: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Google auth button
        """
        auth_button_microsoft: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Microsoft auth button
        """
        auth_button_passphrase: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for passphrase auth button
        """
        auth_button_sms: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for SMS auth button
        """
        auth_button_sponsor: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Sponsor auth button
        """
        auth_label: NotRequired[pulumi.Input[builtins.str]]
        back_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the link to go back to /logon
        """
        color: NotRequired[pulumi.Input[builtins.str]]
        """
        Portal main color
        """
        color_dark: NotRequired[pulumi.Input[builtins.str]]
        color_light: NotRequired[pulumi.Input[builtins.str]]
        company: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether company field is required
        """
        company_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when company not provided
        """
        company_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of company field
        """
        email: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether email field is required
        """
        email_access_domain_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when a user has valid social login but doesn't match specified email domains.
        """
        email_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for cancel confirmation code submission using email auth
        """
        email_code_cancel: NotRequired[pulumi.Input[builtins.str]]
        email_code_error: NotRequired[pulumi.Input[builtins.str]]
        email_code_field_label: NotRequired[pulumi.Input[builtins.str]]
        email_code_message: NotRequired[pulumi.Input[builtins.str]]
        email_code_submit: NotRequired[pulumi.Input[builtins.str]]
        email_code_title: NotRequired[pulumi.Input[builtins.str]]
        email_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when email not provided
        """
        email_field_label: NotRequired[pulumi.Input[builtins.str]]
        email_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of email field
        """
        email_message: NotRequired[pulumi.Input[builtins.str]]
        email_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for confirmation code submit button using email auth
        """
        email_title: NotRequired[pulumi.Input[builtins.str]]
        """
        Title for the Email registration
        """
        field1: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to ask field1
        """
        field1error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field1 not provided
        """
        field1label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field1
        """
        field1required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether field1 is required field
        """
        field2: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to ask field2
        """
        field2error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field2 not provided
        """
        field2label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field2
        """
        field2required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether field2 is required field
        """
        field3: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to ask field3
        """
        field3error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field3 not provided
        """
        field3label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field3
        """
        field3required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether field3 is required field
        """
        field4: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to ask field4
        """
        field4error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field4 not provided
        """
        field4label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field4
        """
        field4required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether field4 is required field
        """
        locales: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['WlanPortalTemplatePortalTemplateLocalesArgsDict']]]]
        """
        Can be used to localize the portal based on the User Agent. Allowed property key values are:
          `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
          `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
          `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
          `zh-Hans`, `zh-Hant`
        """
        logo: NotRequired[pulumi.Input[builtins.str]]
        """
        path to the background image file. File must be a `png` image less than 100kB and image dimension must be less 500px x 200px (width x height).
        """
        marketing_policy_link: NotRequired[pulumi.Input[builtins.str]]
        """
        label of the link to go to /marketing_policy
        """
        marketing_policy_opt_in: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether marketing policy optin is enabled
        """
        marketing_policy_opt_in_label: NotRequired[pulumi.Input[builtins.str]]
        """
        label for marketing optin
        """
        marketing_policy_opt_in_text: NotRequired[pulumi.Input[builtins.str]]
        """
        marketing policy text
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        multi_auth: NotRequired[pulumi.Input[builtins.bool]]
        name: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether name field is required
        """
        name_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when name not provided
        """
        name_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of name field
        """
        opt_out_default: NotRequired[pulumi.Input[builtins.bool]]
        """
        Default value for the `Do not store` checkbox
        """
        optout: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to display Do Not Store My Personal Information
        """
        optout_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Do Not Store My Personal Information
        """
        page_title: NotRequired[pulumi.Input[builtins.str]]
        passphrase_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for the Passphrase cancel button
        """
        passphrase_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when invalid passphrase is provided
        """
        passphrase_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Passphrase
        """
        passphrase_message: NotRequired[pulumi.Input[builtins.str]]
        passphrase_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for the Passphrase submit button
        """
        passphrase_title: NotRequired[pulumi.Input[builtins.str]]
        """
        Title for passphrase details page
        """
        powered_by: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to show \\"Powered by Mist\\"
        """
        privacy: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to require the Privacy Term acceptance
        """
        privacy_policy_accept_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Prefix of the label of the link to go to Privacy Policy
        """
        privacy_policy_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when Privacy Policy not accepted
        """
        privacy_policy_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the link to go to Privacy Policy
        """
        privacy_policy_text: NotRequired[pulumi.Input[builtins.str]]
        """
        Text of the Privacy Policy
        """
        required_field_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label to denote required field
        """
        responsive_layout: NotRequired[pulumi.Input[builtins.bool]]
        sign_in_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the button to signin
        """
        sms_carrier_default: NotRequired[pulumi.Input[builtins.str]]
        sms_carrier_error: NotRequired[pulumi.Input[builtins.str]]
        sms_carrier_field_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for mobile carrier drop-down list
        """
        sms_code_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for cancel confirmation code submission
        """
        sms_code_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when confirmation code is invalid
        """
        sms_code_field_label: NotRequired[pulumi.Input[builtins.str]]
        sms_code_message: NotRequired[pulumi.Input[builtins.str]]
        sms_code_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for confirmation code submit button
        """
        sms_code_title: NotRequired[pulumi.Input[builtins.str]]
        sms_country_field_label: NotRequired[pulumi.Input[builtins.str]]
        sms_country_format: NotRequired[pulumi.Input[builtins.str]]
        sms_have_access_code: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for checkbox to specify that the user has access code
        """
        sms_is_twilio: NotRequired[pulumi.Input[builtins.bool]]
        sms_message_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        """
        sms_number_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for canceling mobile details for SMS auth
        """
        sms_number_error: NotRequired[pulumi.Input[builtins.str]]
        sms_number_field_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for field to provide mobile number
        """
        sms_number_format: NotRequired[pulumi.Input[builtins.str]]
        sms_number_message: NotRequired[pulumi.Input[builtins.str]]
        sms_number_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for submit button for code generation
        """
        sms_number_title: NotRequired[pulumi.Input[builtins.str]]
        """
        Title for phone number details
        """
        sms_username_format: NotRequired[pulumi.Input[builtins.str]]
        sms_validity_duration: NotRequired[pulumi.Input[builtins.int]]
        """
        How long confirmation code should be considered valid (in minutes)
        """
        sponsor_back_link: NotRequired[pulumi.Input[builtins.str]]
        sponsor_cancel: NotRequired[pulumi.Input[builtins.str]]
        sponsor_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Sponsor Email
        """
        sponsor_email_error: NotRequired[pulumi.Input[builtins.str]]
        sponsor_email_template: NotRequired[pulumi.Input[builtins.str]]
        """
        HTML template to replace/override default sponsor email template 
        Sponsor Email Template supports following template variables:
          * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
          * `deny_url`: Renders URL to reject the request
          * `guest_email`: Renders Email ID of the guest
          * `guest_name`: Renders Name of the guest
          * `field1`: Renders value of the Custom Field 1
          * `field2`: Renders value of the Custom Field 2
          * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
          * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        """
        sponsor_info_approved: NotRequired[pulumi.Input[builtins.str]]
        sponsor_info_denied: NotRequired[pulumi.Input[builtins.str]]
        sponsor_info_pending: NotRequired[pulumi.Input[builtins.str]]
        sponsor_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Sponsor Name
        """
        sponsor_name_error: NotRequired[pulumi.Input[builtins.str]]
        sponsor_note_pending: NotRequired[pulumi.Input[builtins.str]]
        sponsor_request_access: NotRequired[pulumi.Input[builtins.str]]
        """
        Submit button label request Wifi Access and notify sponsor about guest request
        """
        sponsor_status_approved: NotRequired[pulumi.Input[builtins.str]]
        """
        Text to display if sponsor approves request
        """
        sponsor_status_denied: NotRequired[pulumi.Input[builtins.str]]
        """
        Text to display when sponsor denies request
        """
        sponsor_status_pending: NotRequired[pulumi.Input[builtins.str]]
        """
        Text to display if request is still pending
        """
        sponsor_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Submit button label to notify sponsor about guest request
        """
        sponsors_error: NotRequired[pulumi.Input[builtins.str]]
        sponsors_field_label: NotRequired[pulumi.Input[builtins.str]]
        tos: NotRequired[pulumi.Input[builtins.bool]]
        tos_accept_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Prefix of the label of the link to go to tos
        """
        tos_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when tos not accepted
        """
        tos_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the link to go to tos
        """
        tos_text: NotRequired[pulumi.Input[builtins.str]]
        """
        Text of the Terms of Service
        """
elif False:
    WlanPortalTemplatePortalTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanPortalTemplatePortalTemplateArgs:
    def __init__(__self__, *,
                 access_code_alternate_email: Optional[pulumi.Input[builtins.str]] = None,
                 alignment: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_amazon: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_azure: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_email: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_facebook: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_google: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_microsoft: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_passphrase: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_sms: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_sponsor: Optional[pulumi.Input[builtins.str]] = None,
                 auth_label: Optional[pulumi.Input[builtins.str]] = None,
                 back_link: Optional[pulumi.Input[builtins.str]] = None,
                 color: Optional[pulumi.Input[builtins.str]] = None,
                 color_dark: Optional[pulumi.Input[builtins.str]] = None,
                 color_light: Optional[pulumi.Input[builtins.str]] = None,
                 company: Optional[pulumi.Input[builtins.bool]] = None,
                 company_error: Optional[pulumi.Input[builtins.str]] = None,
                 company_label: Optional[pulumi.Input[builtins.str]] = None,
                 email: Optional[pulumi.Input[builtins.bool]] = None,
                 email_access_domain_error: Optional[pulumi.Input[builtins.str]] = None,
                 email_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_error: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_message: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_submit: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_title: Optional[pulumi.Input[builtins.str]] = None,
                 email_error: Optional[pulumi.Input[builtins.str]] = None,
                 email_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_message: Optional[pulumi.Input[builtins.str]] = None,
                 email_submit: Optional[pulumi.Input[builtins.str]] = None,
                 email_title: Optional[pulumi.Input[builtins.str]] = None,
                 field1: Optional[pulumi.Input[builtins.bool]] = None,
                 field1error: Optional[pulumi.Input[builtins.str]] = None,
                 field1label: Optional[pulumi.Input[builtins.str]] = None,
                 field1required: Optional[pulumi.Input[builtins.bool]] = None,
                 field2: Optional[pulumi.Input[builtins.bool]] = None,
                 field2error: Optional[pulumi.Input[builtins.str]] = None,
                 field2label: Optional[pulumi.Input[builtins.str]] = None,
                 field2required: Optional[pulumi.Input[builtins.bool]] = None,
                 field3: Optional[pulumi.Input[builtins.bool]] = None,
                 field3error: Optional[pulumi.Input[builtins.str]] = None,
                 field3label: Optional[pulumi.Input[builtins.str]] = None,
                 field3required: Optional[pulumi.Input[builtins.bool]] = None,
                 field4: Optional[pulumi.Input[builtins.bool]] = None,
                 field4error: Optional[pulumi.Input[builtins.str]] = None,
                 field4label: Optional[pulumi.Input[builtins.str]] = None,
                 field4required: Optional[pulumi.Input[builtins.bool]] = None,
                 locales: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanPortalTemplatePortalTemplateLocalesArgs']]]] = None,
                 logo: Optional[pulumi.Input[builtins.str]] = None,
                 marketing_policy_link: Optional[pulumi.Input[builtins.str]] = None,
                 marketing_policy_opt_in: Optional[pulumi.Input[builtins.bool]] = None,
                 marketing_policy_opt_in_label: Optional[pulumi.Input[builtins.str]] = None,
                 marketing_policy_opt_in_text: Optional[pulumi.Input[builtins.str]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 multi_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.bool]] = None,
                 name_error: Optional[pulumi.Input[builtins.str]] = None,
                 name_label: Optional[pulumi.Input[builtins.str]] = None,
                 opt_out_default: Optional[pulumi.Input[builtins.bool]] = None,
                 optout: Optional[pulumi.Input[builtins.bool]] = None,
                 optout_label: Optional[pulumi.Input[builtins.str]] = None,
                 page_title: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_error: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_label: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_message: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_submit: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_title: Optional[pulumi.Input[builtins.str]] = None,
                 powered_by: Optional[pulumi.Input[builtins.bool]] = None,
                 privacy: Optional[pulumi.Input[builtins.bool]] = None,
                 privacy_policy_accept_label: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_error: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_link: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_text: Optional[pulumi.Input[builtins.str]] = None,
                 required_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 responsive_layout: Optional[pulumi.Input[builtins.bool]] = None,
                 sign_in_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_carrier_default: Optional[pulumi.Input[builtins.str]] = None,
                 sms_carrier_error: Optional[pulumi.Input[builtins.str]] = None,
                 sms_carrier_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_error: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_message: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_submit: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_title: Optional[pulumi.Input[builtins.str]] = None,
                 sms_country_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_country_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_have_access_code: Optional[pulumi.Input[builtins.str]] = None,
                 sms_is_twilio: Optional[pulumi.Input[builtins.bool]] = None,
                 sms_message_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_error: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_message: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_submit: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_title: Optional[pulumi.Input[builtins.str]] = None,
                 sms_username_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_validity_duration: Optional[pulumi.Input[builtins.int]] = None,
                 sponsor_back_link: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_email: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_email_error: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_email_template: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_info_approved: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_info_denied: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_info_pending: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_name: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_name_error: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_note_pending: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_request_access: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_status_approved: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_status_denied: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_status_pending: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_submit: Optional[pulumi.Input[builtins.str]] = None,
                 sponsors_error: Optional[pulumi.Input[builtins.str]] = None,
                 sponsors_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 tos: Optional[pulumi.Input[builtins.bool]] = None,
                 tos_accept_label: Optional[pulumi.Input[builtins.str]] = None,
                 tos_error: Optional[pulumi.Input[builtins.str]] = None,
                 tos_link: Optional[pulumi.Input[builtins.str]] = None,
                 tos_text: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] alignment: defines alignment on portal. enum: `center`, `left`, `right`
        :param pulumi.Input[builtins.str] auth_button_amazon: Label for Amazon auth button
        :param pulumi.Input[builtins.str] auth_button_azure: Label for Azure auth button
        :param pulumi.Input[builtins.str] auth_button_email: Label for Email auth button
        :param pulumi.Input[builtins.str] auth_button_facebook: Label for Facebook auth button
        :param pulumi.Input[builtins.str] auth_button_google: Label for Google auth button
        :param pulumi.Input[builtins.str] auth_button_microsoft: Label for Microsoft auth button
        :param pulumi.Input[builtins.str] auth_button_passphrase: Label for passphrase auth button
        :param pulumi.Input[builtins.str] auth_button_sms: Label for SMS auth button
        :param pulumi.Input[builtins.str] auth_button_sponsor: Label for Sponsor auth button
        :param pulumi.Input[builtins.str] back_link: Label of the link to go back to /logon
        :param pulumi.Input[builtins.str] color: Portal main color
        :param pulumi.Input[builtins.bool] company: Whether company field is required
        :param pulumi.Input[builtins.str] company_error: Error message when company not provided
        :param pulumi.Input[builtins.str] company_label: Label of company field
        :param pulumi.Input[builtins.bool] email: Whether email field is required
        :param pulumi.Input[builtins.str] email_access_domain_error: Error message when a user has valid social login but doesn't match specified email domains.
        :param pulumi.Input[builtins.str] email_cancel: Label for cancel confirmation code submission using email auth
        :param pulumi.Input[builtins.str] email_error: Error message when email not provided
        :param pulumi.Input[builtins.str] email_label: Label of email field
        :param pulumi.Input[builtins.str] email_submit: Label for confirmation code submit button using email auth
        :param pulumi.Input[builtins.str] email_title: Title for the Email registration
        :param pulumi.Input[builtins.bool] field1: Whether to ask field1
        :param pulumi.Input[builtins.str] field1error: Error message when field1 not provided
        :param pulumi.Input[builtins.str] field1label: Label of field1
        :param pulumi.Input[builtins.bool] field1required: Whether field1 is required field
        :param pulumi.Input[builtins.bool] field2: Whether to ask field2
        :param pulumi.Input[builtins.str] field2error: Error message when field2 not provided
        :param pulumi.Input[builtins.str] field2label: Label of field2
        :param pulumi.Input[builtins.bool] field2required: Whether field2 is required field
        :param pulumi.Input[builtins.bool] field3: Whether to ask field3
        :param pulumi.Input[builtins.str] field3error: Error message when field3 not provided
        :param pulumi.Input[builtins.str] field3label: Label of field3
        :param pulumi.Input[builtins.bool] field3required: Whether field3 is required field
        :param pulumi.Input[builtins.bool] field4: Whether to ask field4
        :param pulumi.Input[builtins.str] field4error: Error message when field4 not provided
        :param pulumi.Input[builtins.str] field4label: Label of field4
        :param pulumi.Input[builtins.bool] field4required: Whether field4 is required field
        :param pulumi.Input[Mapping[str, pulumi.Input['WlanPortalTemplatePortalTemplateLocalesArgs']]] locales: Can be used to localize the portal based on the User Agent. Allowed property key values are:
                 `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
                 `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
                 `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
                 `zh-Hans`, `zh-Hant`
        :param pulumi.Input[builtins.str] logo: path to the background image file. File must be a `png` image less than 100kB and image dimension must be less 500px x 200px (width x height).
        :param pulumi.Input[builtins.str] marketing_policy_link: label of the link to go to /marketing_policy
        :param pulumi.Input[builtins.bool] marketing_policy_opt_in: Whether marketing policy optin is enabled
        :param pulumi.Input[builtins.str] marketing_policy_opt_in_label: label for marketing optin
        :param pulumi.Input[builtins.str] marketing_policy_opt_in_text: marketing policy text
        :param pulumi.Input[builtins.bool] name: Whether name field is required
        :param pulumi.Input[builtins.str] name_error: Error message when name not provided
        :param pulumi.Input[builtins.str] name_label: Label of name field
        :param pulumi.Input[builtins.bool] opt_out_default: Default value for the `Do not store` checkbox
        :param pulumi.Input[builtins.bool] optout: Whether to display Do Not Store My Personal Information
        :param pulumi.Input[builtins.str] optout_label: Label for Do Not Store My Personal Information
        :param pulumi.Input[builtins.str] passphrase_cancel: Label for the Passphrase cancel button
        :param pulumi.Input[builtins.str] passphrase_error: Error message when invalid passphrase is provided
        :param pulumi.Input[builtins.str] passphrase_label: Passphrase
        :param pulumi.Input[builtins.str] passphrase_submit: Label for the Passphrase submit button
        :param pulumi.Input[builtins.str] passphrase_title: Title for passphrase details page
        :param pulumi.Input[builtins.bool] powered_by: Whether to show \\"Powered by Mist\\"
        :param pulumi.Input[builtins.bool] privacy: Whether to require the Privacy Term acceptance
        :param pulumi.Input[builtins.str] privacy_policy_accept_label: Prefix of the label of the link to go to Privacy Policy
        :param pulumi.Input[builtins.str] privacy_policy_error: Error message when Privacy Policy not accepted
        :param pulumi.Input[builtins.str] privacy_policy_link: Label of the link to go to Privacy Policy
        :param pulumi.Input[builtins.str] privacy_policy_text: Text of the Privacy Policy
        :param pulumi.Input[builtins.str] required_field_label: Label to denote required field
        :param pulumi.Input[builtins.str] sign_in_label: Label of the button to signin
        :param pulumi.Input[builtins.str] sms_carrier_field_label: Label for mobile carrier drop-down list
        :param pulumi.Input[builtins.str] sms_code_cancel: Label for cancel confirmation code submission
        :param pulumi.Input[builtins.str] sms_code_error: Error message when confirmation code is invalid
        :param pulumi.Input[builtins.str] sms_code_submit: Label for confirmation code submit button
        :param pulumi.Input[builtins.str] sms_have_access_code: Label for checkbox to specify that the user has access code
        :param pulumi.Input[builtins.str] sms_message_format: Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        :param pulumi.Input[builtins.str] sms_number_cancel: Label for canceling mobile details for SMS auth
        :param pulumi.Input[builtins.str] sms_number_field_label: Label for field to provide mobile number
        :param pulumi.Input[builtins.str] sms_number_submit: Label for submit button for code generation
        :param pulumi.Input[builtins.str] sms_number_title: Title for phone number details
        :param pulumi.Input[builtins.int] sms_validity_duration: How long confirmation code should be considered valid (in minutes)
        :param pulumi.Input[builtins.str] sponsor_email: Label for Sponsor Email
        :param pulumi.Input[builtins.str] sponsor_email_template: HTML template to replace/override default sponsor email template 
               Sponsor Email Template supports following template variables:
                 * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
                 * `deny_url`: Renders URL to reject the request
                 * `guest_email`: Renders Email ID of the guest
                 * `guest_name`: Renders Name of the guest
                 * `field1`: Renders value of the Custom Field 1
                 * `field2`: Renders value of the Custom Field 2
                 * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
                 * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        :param pulumi.Input[builtins.str] sponsor_name: Label for Sponsor Name
        :param pulumi.Input[builtins.str] sponsor_request_access: Submit button label request Wifi Access and notify sponsor about guest request
        :param pulumi.Input[builtins.str] sponsor_status_approved: Text to display if sponsor approves request
        :param pulumi.Input[builtins.str] sponsor_status_denied: Text to display when sponsor denies request
        :param pulumi.Input[builtins.str] sponsor_status_pending: Text to display if request is still pending
        :param pulumi.Input[builtins.str] sponsor_submit: Submit button label to notify sponsor about guest request
        :param pulumi.Input[builtins.str] tos_accept_label: Prefix of the label of the link to go to tos
        :param pulumi.Input[builtins.str] tos_error: Error message when tos not accepted
        :param pulumi.Input[builtins.str] tos_link: Label of the link to go to tos
        :param pulumi.Input[builtins.str] tos_text: Text of the Terms of Service
        """
        if access_code_alternate_email is not None:
            pulumi.set(__self__, "access_code_alternate_email", access_code_alternate_email)
        if alignment is not None:
            pulumi.set(__self__, "alignment", alignment)
        if auth_button_amazon is not None:
            pulumi.set(__self__, "auth_button_amazon", auth_button_amazon)
        if auth_button_azure is not None:
            pulumi.set(__self__, "auth_button_azure", auth_button_azure)
        if auth_button_email is not None:
            pulumi.set(__self__, "auth_button_email", auth_button_email)
        if auth_button_facebook is not None:
            pulumi.set(__self__, "auth_button_facebook", auth_button_facebook)
        if auth_button_google is not None:
            pulumi.set(__self__, "auth_button_google", auth_button_google)
        if auth_button_microsoft is not None:
            pulumi.set(__self__, "auth_button_microsoft", auth_button_microsoft)
        if auth_button_passphrase is not None:
            pulumi.set(__self__, "auth_button_passphrase", auth_button_passphrase)
        if auth_button_sms is not None:
            pulumi.set(__self__, "auth_button_sms", auth_button_sms)
        if auth_button_sponsor is not None:
            pulumi.set(__self__, "auth_button_sponsor", auth_button_sponsor)
        if auth_label is not None:
            pulumi.set(__self__, "auth_label", auth_label)
        if back_link is not None:
            pulumi.set(__self__, "back_link", back_link)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_dark is not None:
            pulumi.set(__self__, "color_dark", color_dark)
        if color_light is not None:
            pulumi.set(__self__, "color_light", color_light)
        if company is not None:
            pulumi.set(__self__, "company", company)
        if company_error is not None:
            pulumi.set(__self__, "company_error", company_error)
        if company_label is not None:
            pulumi.set(__self__, "company_label", company_label)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_access_domain_error is not None:
            pulumi.set(__self__, "email_access_domain_error", email_access_domain_error)
        if email_cancel is not None:
            pulumi.set(__self__, "email_cancel", email_cancel)
        if email_code_cancel is not None:
            pulumi.set(__self__, "email_code_cancel", email_code_cancel)
        if email_code_error is not None:
            pulumi.set(__self__, "email_code_error", email_code_error)
        if email_code_field_label is not None:
            pulumi.set(__self__, "email_code_field_label", email_code_field_label)
        if email_code_message is not None:
            pulumi.set(__self__, "email_code_message", email_code_message)
        if email_code_submit is not None:
            pulumi.set(__self__, "email_code_submit", email_code_submit)
        if email_code_title is not None:
            pulumi.set(__self__, "email_code_title", email_code_title)
        if email_error is not None:
            pulumi.set(__self__, "email_error", email_error)
        if email_field_label is not None:
            pulumi.set(__self__, "email_field_label", email_field_label)
        if email_label is not None:
            pulumi.set(__self__, "email_label", email_label)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_submit is not None:
            pulumi.set(__self__, "email_submit", email_submit)
        if email_title is not None:
            pulumi.set(__self__, "email_title", email_title)
        if field1 is not None:
            pulumi.set(__self__, "field1", field1)
        if field1error is not None:
            pulumi.set(__self__, "field1error", field1error)
        if field1label is not None:
            pulumi.set(__self__, "field1label", field1label)
        if field1required is not None:
            pulumi.set(__self__, "field1required", field1required)
        if field2 is not None:
            pulumi.set(__self__, "field2", field2)
        if field2error is not None:
            pulumi.set(__self__, "field2error", field2error)
        if field2label is not None:
            pulumi.set(__self__, "field2label", field2label)
        if field2required is not None:
            pulumi.set(__self__, "field2required", field2required)
        if field3 is not None:
            pulumi.set(__self__, "field3", field3)
        if field3error is not None:
            pulumi.set(__self__, "field3error", field3error)
        if field3label is not None:
            pulumi.set(__self__, "field3label", field3label)
        if field3required is not None:
            pulumi.set(__self__, "field3required", field3required)
        if field4 is not None:
            pulumi.set(__self__, "field4", field4)
        if field4error is not None:
            pulumi.set(__self__, "field4error", field4error)
        if field4label is not None:
            pulumi.set(__self__, "field4label", field4label)
        if field4required is not None:
            pulumi.set(__self__, "field4required", field4required)
        if locales is not None:
            pulumi.set(__self__, "locales", locales)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if marketing_policy_link is not None:
            pulumi.set(__self__, "marketing_policy_link", marketing_policy_link)
        if marketing_policy_opt_in is not None:
            pulumi.set(__self__, "marketing_policy_opt_in", marketing_policy_opt_in)
        if marketing_policy_opt_in_label is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_label", marketing_policy_opt_in_label)
        if marketing_policy_opt_in_text is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_text", marketing_policy_opt_in_text)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if multi_auth is not None:
            pulumi.set(__self__, "multi_auth", multi_auth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_error is not None:
            pulumi.set(__self__, "name_error", name_error)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if opt_out_default is not None:
            pulumi.set(__self__, "opt_out_default", opt_out_default)
        if optout is not None:
            pulumi.set(__self__, "optout", optout)
        if optout_label is not None:
            pulumi.set(__self__, "optout_label", optout_label)
        if page_title is not None:
            pulumi.set(__self__, "page_title", page_title)
        if passphrase_cancel is not None:
            pulumi.set(__self__, "passphrase_cancel", passphrase_cancel)
        if passphrase_error is not None:
            pulumi.set(__self__, "passphrase_error", passphrase_error)
        if passphrase_label is not None:
            pulumi.set(__self__, "passphrase_label", passphrase_label)
        if passphrase_message is not None:
            pulumi.set(__self__, "passphrase_message", passphrase_message)
        if passphrase_submit is not None:
            pulumi.set(__self__, "passphrase_submit", passphrase_submit)
        if passphrase_title is not None:
            pulumi.set(__self__, "passphrase_title", passphrase_title)
        if powered_by is not None:
            pulumi.set(__self__, "powered_by", powered_by)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if privacy_policy_accept_label is not None:
            pulumi.set(__self__, "privacy_policy_accept_label", privacy_policy_accept_label)
        if privacy_policy_error is not None:
            pulumi.set(__self__, "privacy_policy_error", privacy_policy_error)
        if privacy_policy_link is not None:
            pulumi.set(__self__, "privacy_policy_link", privacy_policy_link)
        if privacy_policy_text is not None:
            pulumi.set(__self__, "privacy_policy_text", privacy_policy_text)
        if required_field_label is not None:
            pulumi.set(__self__, "required_field_label", required_field_label)
        if responsive_layout is not None:
            pulumi.set(__self__, "responsive_layout", responsive_layout)
        if sign_in_label is not None:
            pulumi.set(__self__, "sign_in_label", sign_in_label)
        if sms_carrier_default is not None:
            pulumi.set(__self__, "sms_carrier_default", sms_carrier_default)
        if sms_carrier_error is not None:
            pulumi.set(__self__, "sms_carrier_error", sms_carrier_error)
        if sms_carrier_field_label is not None:
            pulumi.set(__self__, "sms_carrier_field_label", sms_carrier_field_label)
        if sms_code_cancel is not None:
            pulumi.set(__self__, "sms_code_cancel", sms_code_cancel)
        if sms_code_error is not None:
            pulumi.set(__self__, "sms_code_error", sms_code_error)
        if sms_code_field_label is not None:
            pulumi.set(__self__, "sms_code_field_label", sms_code_field_label)
        if sms_code_message is not None:
            pulumi.set(__self__, "sms_code_message", sms_code_message)
        if sms_code_submit is not None:
            pulumi.set(__self__, "sms_code_submit", sms_code_submit)
        if sms_code_title is not None:
            pulumi.set(__self__, "sms_code_title", sms_code_title)
        if sms_country_field_label is not None:
            pulumi.set(__self__, "sms_country_field_label", sms_country_field_label)
        if sms_country_format is not None:
            pulumi.set(__self__, "sms_country_format", sms_country_format)
        if sms_have_access_code is not None:
            pulumi.set(__self__, "sms_have_access_code", sms_have_access_code)
        if sms_is_twilio is not None:
            pulumi.set(__self__, "sms_is_twilio", sms_is_twilio)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_number_cancel is not None:
            pulumi.set(__self__, "sms_number_cancel", sms_number_cancel)
        if sms_number_error is not None:
            pulumi.set(__self__, "sms_number_error", sms_number_error)
        if sms_number_field_label is not None:
            pulumi.set(__self__, "sms_number_field_label", sms_number_field_label)
        if sms_number_format is not None:
            pulumi.set(__self__, "sms_number_format", sms_number_format)
        if sms_number_message is not None:
            pulumi.set(__self__, "sms_number_message", sms_number_message)
        if sms_number_submit is not None:
            pulumi.set(__self__, "sms_number_submit", sms_number_submit)
        if sms_number_title is not None:
            pulumi.set(__self__, "sms_number_title", sms_number_title)
        if sms_username_format is not None:
            pulumi.set(__self__, "sms_username_format", sms_username_format)
        if sms_validity_duration is not None:
            pulumi.set(__self__, "sms_validity_duration", sms_validity_duration)
        if sponsor_back_link is not None:
            pulumi.set(__self__, "sponsor_back_link", sponsor_back_link)
        if sponsor_cancel is not None:
            pulumi.set(__self__, "sponsor_cancel", sponsor_cancel)
        if sponsor_email is not None:
            pulumi.set(__self__, "sponsor_email", sponsor_email)
        if sponsor_email_error is not None:
            pulumi.set(__self__, "sponsor_email_error", sponsor_email_error)
        if sponsor_email_template is not None:
            pulumi.set(__self__, "sponsor_email_template", sponsor_email_template)
        if sponsor_info_approved is not None:
            pulumi.set(__self__, "sponsor_info_approved", sponsor_info_approved)
        if sponsor_info_denied is not None:
            pulumi.set(__self__, "sponsor_info_denied", sponsor_info_denied)
        if sponsor_info_pending is not None:
            pulumi.set(__self__, "sponsor_info_pending", sponsor_info_pending)
        if sponsor_name is not None:
            pulumi.set(__self__, "sponsor_name", sponsor_name)
        if sponsor_name_error is not None:
            pulumi.set(__self__, "sponsor_name_error", sponsor_name_error)
        if sponsor_note_pending is not None:
            pulumi.set(__self__, "sponsor_note_pending", sponsor_note_pending)
        if sponsor_request_access is not None:
            pulumi.set(__self__, "sponsor_request_access", sponsor_request_access)
        if sponsor_status_approved is not None:
            pulumi.set(__self__, "sponsor_status_approved", sponsor_status_approved)
        if sponsor_status_denied is not None:
            pulumi.set(__self__, "sponsor_status_denied", sponsor_status_denied)
        if sponsor_status_pending is not None:
            pulumi.set(__self__, "sponsor_status_pending", sponsor_status_pending)
        if sponsor_submit is not None:
            pulumi.set(__self__, "sponsor_submit", sponsor_submit)
        if sponsors_error is not None:
            pulumi.set(__self__, "sponsors_error", sponsors_error)
        if sponsors_field_label is not None:
            pulumi.set(__self__, "sponsors_field_label", sponsors_field_label)
        if tos is not None:
            pulumi.set(__self__, "tos", tos)
        if tos_accept_label is not None:
            pulumi.set(__self__, "tos_accept_label", tos_accept_label)
        if tos_error is not None:
            pulumi.set(__self__, "tos_error", tos_error)
        if tos_link is not None:
            pulumi.set(__self__, "tos_link", tos_link)
        if tos_text is not None:
            pulumi.set(__self__, "tos_text", tos_text)

    @property
    @pulumi.getter(name="accessCodeAlternateEmail")
    def access_code_alternate_email(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "access_code_alternate_email")

    @access_code_alternate_email.setter
    def access_code_alternate_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_code_alternate_email", value)

    @property
    @pulumi.getter
    def alignment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        defines alignment on portal. enum: `center`, `left`, `right`
        """
        return pulumi.get(self, "alignment")

    @alignment.setter
    def alignment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "alignment", value)

    @property
    @pulumi.getter(name="authButtonAmazon")
    def auth_button_amazon(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Amazon auth button
        """
        return pulumi.get(self, "auth_button_amazon")

    @auth_button_amazon.setter
    def auth_button_amazon(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_amazon", value)

    @property
    @pulumi.getter(name="authButtonAzure")
    def auth_button_azure(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Azure auth button
        """
        return pulumi.get(self, "auth_button_azure")

    @auth_button_azure.setter
    def auth_button_azure(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_azure", value)

    @property
    @pulumi.getter(name="authButtonEmail")
    def auth_button_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Email auth button
        """
        return pulumi.get(self, "auth_button_email")

    @auth_button_email.setter
    def auth_button_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_email", value)

    @property
    @pulumi.getter(name="authButtonFacebook")
    def auth_button_facebook(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Facebook auth button
        """
        return pulumi.get(self, "auth_button_facebook")

    @auth_button_facebook.setter
    def auth_button_facebook(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_facebook", value)

    @property
    @pulumi.getter(name="authButtonGoogle")
    def auth_button_google(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Google auth button
        """
        return pulumi.get(self, "auth_button_google")

    @auth_button_google.setter
    def auth_button_google(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_google", value)

    @property
    @pulumi.getter(name="authButtonMicrosoft")
    def auth_button_microsoft(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Microsoft auth button
        """
        return pulumi.get(self, "auth_button_microsoft")

    @auth_button_microsoft.setter
    def auth_button_microsoft(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_microsoft", value)

    @property
    @pulumi.getter(name="authButtonPassphrase")
    def auth_button_passphrase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for passphrase auth button
        """
        return pulumi.get(self, "auth_button_passphrase")

    @auth_button_passphrase.setter
    def auth_button_passphrase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_passphrase", value)

    @property
    @pulumi.getter(name="authButtonSms")
    def auth_button_sms(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for SMS auth button
        """
        return pulumi.get(self, "auth_button_sms")

    @auth_button_sms.setter
    def auth_button_sms(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_sms", value)

    @property
    @pulumi.getter(name="authButtonSponsor")
    def auth_button_sponsor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Sponsor auth button
        """
        return pulumi.get(self, "auth_button_sponsor")

    @auth_button_sponsor.setter
    def auth_button_sponsor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_sponsor", value)

    @property
    @pulumi.getter(name="authLabel")
    def auth_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "auth_label")

    @auth_label.setter
    def auth_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_label", value)

    @property
    @pulumi.getter(name="backLink")
    def back_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the link to go back to /logon
        """
        return pulumi.get(self, "back_link")

    @back_link.setter
    def back_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "back_link", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Portal main color
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="colorDark")
    def color_dark(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "color_dark")

    @color_dark.setter
    def color_dark(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "color_dark", value)

    @property
    @pulumi.getter(name="colorLight")
    def color_light(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "color_light")

    @color_light.setter
    def color_light(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "color_light", value)

    @property
    @pulumi.getter
    def company(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether company field is required
        """
        return pulumi.get(self, "company")

    @company.setter
    def company(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "company", value)

    @property
    @pulumi.getter(name="companyError")
    def company_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when company not provided
        """
        return pulumi.get(self, "company_error")

    @company_error.setter
    def company_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "company_error", value)

    @property
    @pulumi.getter(name="companyLabel")
    def company_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of company field
        """
        return pulumi.get(self, "company_label")

    @company_label.setter
    def company_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "company_label", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether email field is required
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailAccessDomainError")
    def email_access_domain_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when a user has valid social login but doesn't match specified email domains.
        """
        return pulumi.get(self, "email_access_domain_error")

    @email_access_domain_error.setter
    def email_access_domain_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_access_domain_error", value)

    @property
    @pulumi.getter(name="emailCancel")
    def email_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for cancel confirmation code submission using email auth
        """
        return pulumi.get(self, "email_cancel")

    @email_cancel.setter
    def email_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_cancel", value)

    @property
    @pulumi.getter(name="emailCodeCancel")
    def email_code_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_cancel")

    @email_code_cancel.setter
    def email_code_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_cancel", value)

    @property
    @pulumi.getter(name="emailCodeError")
    def email_code_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_error")

    @email_code_error.setter
    def email_code_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_error", value)

    @property
    @pulumi.getter(name="emailCodeFieldLabel")
    def email_code_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_field_label")

    @email_code_field_label.setter
    def email_code_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_field_label", value)

    @property
    @pulumi.getter(name="emailCodeMessage")
    def email_code_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_message")

    @email_code_message.setter
    def email_code_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_message", value)

    @property
    @pulumi.getter(name="emailCodeSubmit")
    def email_code_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_submit")

    @email_code_submit.setter
    def email_code_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_submit", value)

    @property
    @pulumi.getter(name="emailCodeTitle")
    def email_code_title(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_title")

    @email_code_title.setter
    def email_code_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_title", value)

    @property
    @pulumi.getter(name="emailError")
    def email_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when email not provided
        """
        return pulumi.get(self, "email_error")

    @email_error.setter
    def email_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_error", value)

    @property
    @pulumi.getter(name="emailFieldLabel")
    def email_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_field_label")

    @email_field_label.setter
    def email_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_field_label", value)

    @property
    @pulumi.getter(name="emailLabel")
    def email_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of email field
        """
        return pulumi.get(self, "email_label")

    @email_label.setter
    def email_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_label", value)

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_message")

    @email_message.setter
    def email_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_message", value)

    @property
    @pulumi.getter(name="emailSubmit")
    def email_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for confirmation code submit button using email auth
        """
        return pulumi.get(self, "email_submit")

    @email_submit.setter
    def email_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_submit", value)

    @property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Title for the Email registration
        """
        return pulumi.get(self, "email_title")

    @email_title.setter
    def email_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_title", value)

    @property
    @pulumi.getter
    def field1(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to ask field1
        """
        return pulumi.get(self, "field1")

    @field1.setter
    def field1(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field1", value)

    @property
    @pulumi.getter
    def field1error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field1 not provided
        """
        return pulumi.get(self, "field1error")

    @field1error.setter
    def field1error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field1error", value)

    @property
    @pulumi.getter
    def field1label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field1
        """
        return pulumi.get(self, "field1label")

    @field1label.setter
    def field1label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field1label", value)

    @property
    @pulumi.getter
    def field1required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether field1 is required field
        """
        return pulumi.get(self, "field1required")

    @field1required.setter
    def field1required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field1required", value)

    @property
    @pulumi.getter
    def field2(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to ask field2
        """
        return pulumi.get(self, "field2")

    @field2.setter
    def field2(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field2", value)

    @property
    @pulumi.getter
    def field2error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field2 not provided
        """
        return pulumi.get(self, "field2error")

    @field2error.setter
    def field2error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field2error", value)

    @property
    @pulumi.getter
    def field2label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field2
        """
        return pulumi.get(self, "field2label")

    @field2label.setter
    def field2label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field2label", value)

    @property
    @pulumi.getter
    def field2required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether field2 is required field
        """
        return pulumi.get(self, "field2required")

    @field2required.setter
    def field2required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field2required", value)

    @property
    @pulumi.getter
    def field3(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to ask field3
        """
        return pulumi.get(self, "field3")

    @field3.setter
    def field3(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field3", value)

    @property
    @pulumi.getter
    def field3error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field3 not provided
        """
        return pulumi.get(self, "field3error")

    @field3error.setter
    def field3error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field3error", value)

    @property
    @pulumi.getter
    def field3label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field3
        """
        return pulumi.get(self, "field3label")

    @field3label.setter
    def field3label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field3label", value)

    @property
    @pulumi.getter
    def field3required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether field3 is required field
        """
        return pulumi.get(self, "field3required")

    @field3required.setter
    def field3required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field3required", value)

    @property
    @pulumi.getter
    def field4(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to ask field4
        """
        return pulumi.get(self, "field4")

    @field4.setter
    def field4(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field4", value)

    @property
    @pulumi.getter
    def field4error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field4 not provided
        """
        return pulumi.get(self, "field4error")

    @field4error.setter
    def field4error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field4error", value)

    @property
    @pulumi.getter
    def field4label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field4
        """
        return pulumi.get(self, "field4label")

    @field4label.setter
    def field4label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field4label", value)

    @property
    @pulumi.getter
    def field4required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether field4 is required field
        """
        return pulumi.get(self, "field4required")

    @field4required.setter
    def field4required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "field4required", value)

    @property
    @pulumi.getter
    def locales(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanPortalTemplatePortalTemplateLocalesArgs']]]]:
        """
        Can be used to localize the portal based on the User Agent. Allowed property key values are:
          `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
          `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
          `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
          `zh-Hans`, `zh-Hant`
        """
        return pulumi.get(self, "locales")

    @locales.setter
    def locales(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanPortalTemplatePortalTemplateLocalesArgs']]]]):
        pulumi.set(self, "locales", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        path to the background image file. File must be a `png` image less than 100kB and image dimension must be less 500px x 200px (width x height).
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logo", value)

    @property
    @pulumi.getter(name="marketingPolicyLink")
    def marketing_policy_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        label of the link to go to /marketing_policy
        """
        return pulumi.get(self, "marketing_policy_link")

    @marketing_policy_link.setter
    def marketing_policy_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "marketing_policy_link", value)

    @property
    @pulumi.getter(name="marketingPolicyOptIn")
    def marketing_policy_opt_in(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether marketing policy optin is enabled
        """
        return pulumi.get(self, "marketing_policy_opt_in")

    @marketing_policy_opt_in.setter
    def marketing_policy_opt_in(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "marketing_policy_opt_in", value)

    @property
    @pulumi.getter(name="marketingPolicyOptInLabel")
    def marketing_policy_opt_in_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        label for marketing optin
        """
        return pulumi.get(self, "marketing_policy_opt_in_label")

    @marketing_policy_opt_in_label.setter
    def marketing_policy_opt_in_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "marketing_policy_opt_in_label", value)

    @property
    @pulumi.getter(name="marketingPolicyOptInText")
    def marketing_policy_opt_in_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        marketing policy text
        """
        return pulumi.get(self, "marketing_policy_opt_in_text")

    @marketing_policy_opt_in_text.setter
    def marketing_policy_opt_in_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "marketing_policy_opt_in_text", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="multiAuth")
    def multi_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "multi_auth")

    @multi_auth.setter
    def multi_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "multi_auth", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether name field is required
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameError")
    def name_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when name not provided
        """
        return pulumi.get(self, "name_error")

    @name_error.setter
    def name_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_error", value)

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of name field
        """
        return pulumi.get(self, "name_label")

    @name_label.setter
    def name_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_label", value)

    @property
    @pulumi.getter(name="optOutDefault")
    def opt_out_default(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Default value for the `Do not store` checkbox
        """
        return pulumi.get(self, "opt_out_default")

    @opt_out_default.setter
    def opt_out_default(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "opt_out_default", value)

    @property
    @pulumi.getter
    def optout(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to display Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout")

    @optout.setter
    def optout(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "optout", value)

    @property
    @pulumi.getter(name="optoutLabel")
    def optout_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout_label")

    @optout_label.setter
    def optout_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "optout_label", value)

    @property
    @pulumi.getter(name="pageTitle")
    def page_title(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "page_title")

    @page_title.setter
    def page_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "page_title", value)

    @property
    @pulumi.getter(name="passphraseCancel")
    def passphrase_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for the Passphrase cancel button
        """
        return pulumi.get(self, "passphrase_cancel")

    @passphrase_cancel.setter
    def passphrase_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_cancel", value)

    @property
    @pulumi.getter(name="passphraseError")
    def passphrase_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when invalid passphrase is provided
        """
        return pulumi.get(self, "passphrase_error")

    @passphrase_error.setter
    def passphrase_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_error", value)

    @property
    @pulumi.getter(name="passphraseLabel")
    def passphrase_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Passphrase
        """
        return pulumi.get(self, "passphrase_label")

    @passphrase_label.setter
    def passphrase_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_label", value)

    @property
    @pulumi.getter(name="passphraseMessage")
    def passphrase_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "passphrase_message")

    @passphrase_message.setter
    def passphrase_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_message", value)

    @property
    @pulumi.getter(name="passphraseSubmit")
    def passphrase_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for the Passphrase submit button
        """
        return pulumi.get(self, "passphrase_submit")

    @passphrase_submit.setter
    def passphrase_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_submit", value)

    @property
    @pulumi.getter(name="passphraseTitle")
    def passphrase_title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Title for passphrase details page
        """
        return pulumi.get(self, "passphrase_title")

    @passphrase_title.setter
    def passphrase_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_title", value)

    @property
    @pulumi.getter(name="poweredBy")
    def powered_by(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to show \\"Powered by Mist\\"
        """
        return pulumi.get(self, "powered_by")

    @powered_by.setter
    def powered_by(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "powered_by", value)

    @property
    @pulumi.getter
    def privacy(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to require the Privacy Term acceptance
        """
        return pulumi.get(self, "privacy")

    @privacy.setter
    def privacy(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "privacy", value)

    @property
    @pulumi.getter(name="privacyPolicyAcceptLabel")
    def privacy_policy_accept_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prefix of the label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_accept_label")

    @privacy_policy_accept_label.setter
    def privacy_policy_accept_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_accept_label", value)

    @property
    @pulumi.getter(name="privacyPolicyError")
    def privacy_policy_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when Privacy Policy not accepted
        """
        return pulumi.get(self, "privacy_policy_error")

    @privacy_policy_error.setter
    def privacy_policy_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_error", value)

    @property
    @pulumi.getter(name="privacyPolicyLink")
    def privacy_policy_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_link")

    @privacy_policy_link.setter
    def privacy_policy_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_link", value)

    @property
    @pulumi.getter(name="privacyPolicyText")
    def privacy_policy_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text of the Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_text")

    @privacy_policy_text.setter
    def privacy_policy_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_text", value)

    @property
    @pulumi.getter(name="requiredFieldLabel")
    def required_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label to denote required field
        """
        return pulumi.get(self, "required_field_label")

    @required_field_label.setter
    def required_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "required_field_label", value)

    @property
    @pulumi.getter(name="responsiveLayout")
    def responsive_layout(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "responsive_layout")

    @responsive_layout.setter
    def responsive_layout(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "responsive_layout", value)

    @property
    @pulumi.getter(name="signInLabel")
    def sign_in_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the button to signin
        """
        return pulumi.get(self, "sign_in_label")

    @sign_in_label.setter
    def sign_in_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sign_in_label", value)

    @property
    @pulumi.getter(name="smsCarrierDefault")
    def sms_carrier_default(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_carrier_default")

    @sms_carrier_default.setter
    def sms_carrier_default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_carrier_default", value)

    @property
    @pulumi.getter(name="smsCarrierError")
    def sms_carrier_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_carrier_error")

    @sms_carrier_error.setter
    def sms_carrier_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_carrier_error", value)

    @property
    @pulumi.getter(name="smsCarrierFieldLabel")
    def sms_carrier_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for mobile carrier drop-down list
        """
        return pulumi.get(self, "sms_carrier_field_label")

    @sms_carrier_field_label.setter
    def sms_carrier_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_carrier_field_label", value)

    @property
    @pulumi.getter(name="smsCodeCancel")
    def sms_code_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for cancel confirmation code submission
        """
        return pulumi.get(self, "sms_code_cancel")

    @sms_code_cancel.setter
    def sms_code_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_cancel", value)

    @property
    @pulumi.getter(name="smsCodeError")
    def sms_code_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when confirmation code is invalid
        """
        return pulumi.get(self, "sms_code_error")

    @sms_code_error.setter
    def sms_code_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_error", value)

    @property
    @pulumi.getter(name="smsCodeFieldLabel")
    def sms_code_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_code_field_label")

    @sms_code_field_label.setter
    def sms_code_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_field_label", value)

    @property
    @pulumi.getter(name="smsCodeMessage")
    def sms_code_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_code_message")

    @sms_code_message.setter
    def sms_code_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_message", value)

    @property
    @pulumi.getter(name="smsCodeSubmit")
    def sms_code_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for confirmation code submit button
        """
        return pulumi.get(self, "sms_code_submit")

    @sms_code_submit.setter
    def sms_code_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_submit", value)

    @property
    @pulumi.getter(name="smsCodeTitle")
    def sms_code_title(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_code_title")

    @sms_code_title.setter
    def sms_code_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_title", value)

    @property
    @pulumi.getter(name="smsCountryFieldLabel")
    def sms_country_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_country_field_label")

    @sms_country_field_label.setter
    def sms_country_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_country_field_label", value)

    @property
    @pulumi.getter(name="smsCountryFormat")
    def sms_country_format(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_country_format")

    @sms_country_format.setter
    def sms_country_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_country_format", value)

    @property
    @pulumi.getter(name="smsHaveAccessCode")
    def sms_have_access_code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for checkbox to specify that the user has access code
        """
        return pulumi.get(self, "sms_have_access_code")

    @sms_have_access_code.setter
    def sms_have_access_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_have_access_code", value)

    @property
    @pulumi.getter(name="smsIsTwilio")
    def sms_is_twilio(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "sms_is_twilio")

    @sms_is_twilio.setter
    def sms_is_twilio(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sms_is_twilio", value)

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        """
        return pulumi.get(self, "sms_message_format")

    @sms_message_format.setter
    def sms_message_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_message_format", value)

    @property
    @pulumi.getter(name="smsNumberCancel")
    def sms_number_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for canceling mobile details for SMS auth
        """
        return pulumi.get(self, "sms_number_cancel")

    @sms_number_cancel.setter
    def sms_number_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_cancel", value)

    @property
    @pulumi.getter(name="smsNumberError")
    def sms_number_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_number_error")

    @sms_number_error.setter
    def sms_number_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_error", value)

    @property
    @pulumi.getter(name="smsNumberFieldLabel")
    def sms_number_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for field to provide mobile number
        """
        return pulumi.get(self, "sms_number_field_label")

    @sms_number_field_label.setter
    def sms_number_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_field_label", value)

    @property
    @pulumi.getter(name="smsNumberFormat")
    def sms_number_format(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_number_format")

    @sms_number_format.setter
    def sms_number_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_format", value)

    @property
    @pulumi.getter(name="smsNumberMessage")
    def sms_number_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_number_message")

    @sms_number_message.setter
    def sms_number_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_message", value)

    @property
    @pulumi.getter(name="smsNumberSubmit")
    def sms_number_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for submit button for code generation
        """
        return pulumi.get(self, "sms_number_submit")

    @sms_number_submit.setter
    def sms_number_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_submit", value)

    @property
    @pulumi.getter(name="smsNumberTitle")
    def sms_number_title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Title for phone number details
        """
        return pulumi.get(self, "sms_number_title")

    @sms_number_title.setter
    def sms_number_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_title", value)

    @property
    @pulumi.getter(name="smsUsernameFormat")
    def sms_username_format(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_username_format")

    @sms_username_format.setter
    def sms_username_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_username_format", value)

    @property
    @pulumi.getter(name="smsValidityDuration")
    def sms_validity_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How long confirmation code should be considered valid (in minutes)
        """
        return pulumi.get(self, "sms_validity_duration")

    @sms_validity_duration.setter
    def sms_validity_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "sms_validity_duration", value)

    @property
    @pulumi.getter(name="sponsorBackLink")
    def sponsor_back_link(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_back_link")

    @sponsor_back_link.setter
    def sponsor_back_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_back_link", value)

    @property
    @pulumi.getter(name="sponsorCancel")
    def sponsor_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_cancel")

    @sponsor_cancel.setter
    def sponsor_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_cancel", value)

    @property
    @pulumi.getter(name="sponsorEmail")
    def sponsor_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Sponsor Email
        """
        return pulumi.get(self, "sponsor_email")

    @sponsor_email.setter
    def sponsor_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_email", value)

    @property
    @pulumi.getter(name="sponsorEmailError")
    def sponsor_email_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_email_error")

    @sponsor_email_error.setter
    def sponsor_email_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_email_error", value)

    @property
    @pulumi.getter(name="sponsorEmailTemplate")
    def sponsor_email_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HTML template to replace/override default sponsor email template 
        Sponsor Email Template supports following template variables:
          * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
          * `deny_url`: Renders URL to reject the request
          * `guest_email`: Renders Email ID of the guest
          * `guest_name`: Renders Name of the guest
          * `field1`: Renders value of the Custom Field 1
          * `field2`: Renders value of the Custom Field 2
          * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
          * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        """
        return pulumi.get(self, "sponsor_email_template")

    @sponsor_email_template.setter
    def sponsor_email_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_email_template", value)

    @property
    @pulumi.getter(name="sponsorInfoApproved")
    def sponsor_info_approved(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_info_approved")

    @sponsor_info_approved.setter
    def sponsor_info_approved(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_info_approved", value)

    @property
    @pulumi.getter(name="sponsorInfoDenied")
    def sponsor_info_denied(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_info_denied")

    @sponsor_info_denied.setter
    def sponsor_info_denied(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_info_denied", value)

    @property
    @pulumi.getter(name="sponsorInfoPending")
    def sponsor_info_pending(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_info_pending")

    @sponsor_info_pending.setter
    def sponsor_info_pending(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_info_pending", value)

    @property
    @pulumi.getter(name="sponsorName")
    def sponsor_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Sponsor Name
        """
        return pulumi.get(self, "sponsor_name")

    @sponsor_name.setter
    def sponsor_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_name", value)

    @property
    @pulumi.getter(name="sponsorNameError")
    def sponsor_name_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_name_error")

    @sponsor_name_error.setter
    def sponsor_name_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_name_error", value)

    @property
    @pulumi.getter(name="sponsorNotePending")
    def sponsor_note_pending(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_note_pending")

    @sponsor_note_pending.setter
    def sponsor_note_pending(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_note_pending", value)

    @property
    @pulumi.getter(name="sponsorRequestAccess")
    def sponsor_request_access(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Submit button label request Wifi Access and notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_request_access")

    @sponsor_request_access.setter
    def sponsor_request_access(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_request_access", value)

    @property
    @pulumi.getter(name="sponsorStatusApproved")
    def sponsor_status_approved(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text to display if sponsor approves request
        """
        return pulumi.get(self, "sponsor_status_approved")

    @sponsor_status_approved.setter
    def sponsor_status_approved(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_status_approved", value)

    @property
    @pulumi.getter(name="sponsorStatusDenied")
    def sponsor_status_denied(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text to display when sponsor denies request
        """
        return pulumi.get(self, "sponsor_status_denied")

    @sponsor_status_denied.setter
    def sponsor_status_denied(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_status_denied", value)

    @property
    @pulumi.getter(name="sponsorStatusPending")
    def sponsor_status_pending(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text to display if request is still pending
        """
        return pulumi.get(self, "sponsor_status_pending")

    @sponsor_status_pending.setter
    def sponsor_status_pending(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_status_pending", value)

    @property
    @pulumi.getter(name="sponsorSubmit")
    def sponsor_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Submit button label to notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_submit")

    @sponsor_submit.setter
    def sponsor_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_submit", value)

    @property
    @pulumi.getter(name="sponsorsError")
    def sponsors_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsors_error")

    @sponsors_error.setter
    def sponsors_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsors_error", value)

    @property
    @pulumi.getter(name="sponsorsFieldLabel")
    def sponsors_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsors_field_label")

    @sponsors_field_label.setter
    def sponsors_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsors_field_label", value)

    @property
    @pulumi.getter
    def tos(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "tos")

    @tos.setter
    def tos(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tos", value)

    @property
    @pulumi.getter(name="tosAcceptLabel")
    def tos_accept_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prefix of the label of the link to go to tos
        """
        return pulumi.get(self, "tos_accept_label")

    @tos_accept_label.setter
    def tos_accept_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_accept_label", value)

    @property
    @pulumi.getter(name="tosError")
    def tos_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when tos not accepted
        """
        return pulumi.get(self, "tos_error")

    @tos_error.setter
    def tos_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_error", value)

    @property
    @pulumi.getter(name="tosLink")
    def tos_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the link to go to tos
        """
        return pulumi.get(self, "tos_link")

    @tos_link.setter
    def tos_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_link", value)

    @property
    @pulumi.getter(name="tosText")
    def tos_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text of the Terms of Service
        """
        return pulumi.get(self, "tos_text")

    @tos_text.setter
    def tos_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_text", value)


if not MYPY:
    class WlanPortalTemplatePortalTemplateLocalesArgsDict(TypedDict):
        auth_button_amazon: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Amazon auth button
        """
        auth_button_azure: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Azure auth button
        """
        auth_button_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Email auth button
        """
        auth_button_facebook: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Facebook auth button
        """
        auth_button_google: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Google auth button
        """
        auth_button_microsoft: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Microsoft auth button
        """
        auth_button_passphrase: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for passphrase auth button
        """
        auth_button_sms: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for SMS auth button
        """
        auth_button_sponsor: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Sponsor auth button
        """
        auth_label: NotRequired[pulumi.Input[builtins.str]]
        back_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the link to go back to /logon
        """
        company_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when company not provided
        """
        company_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of company field
        """
        email_access_domain_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when a user has valid social login but doesn't match specified email domains.
        """
        email_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for cancel confirmation code submission using email auth
        """
        email_code_cancel: NotRequired[pulumi.Input[builtins.str]]
        email_code_error: NotRequired[pulumi.Input[builtins.str]]
        email_code_field_label: NotRequired[pulumi.Input[builtins.str]]
        email_code_message: NotRequired[pulumi.Input[builtins.str]]
        email_code_submit: NotRequired[pulumi.Input[builtins.str]]
        email_code_title: NotRequired[pulumi.Input[builtins.str]]
        email_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when email not provided
        """
        email_field_label: NotRequired[pulumi.Input[builtins.str]]
        email_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of email field
        """
        email_message: NotRequired[pulumi.Input[builtins.str]]
        email_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for confirmation code submit button using email auth
        """
        email_title: NotRequired[pulumi.Input[builtins.str]]
        """
        Title for the Email registration
        """
        field1error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field1 not provided
        """
        field1label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field1
        """
        field2error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field2 not provided
        """
        field2label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field2
        """
        field3error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field3 not provided
        """
        field3label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field3
        """
        field4error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when field4 not provided
        """
        field4label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of field4
        """
        marketing_policy_link: NotRequired[pulumi.Input[builtins.str]]
        """
        label of the link to go to /marketing_policy
        """
        marketing_policy_opt_in: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether marketing policy optin is enabled
        """
        marketing_policy_opt_in_label: NotRequired[pulumi.Input[builtins.str]]
        """
        label for marketing optin
        """
        marketing_policy_opt_in_text: NotRequired[pulumi.Input[builtins.str]]
        """
        marketing policy text
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        name_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when name not provided
        """
        name_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of name field
        """
        optout_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Do Not Store My Personal Information
        """
        page_title: NotRequired[pulumi.Input[builtins.str]]
        passphrase_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for the Passphrase cancel button
        """
        passphrase_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when invalid passphrase is provided
        """
        passphrase_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Passphrase
        """
        passphrase_message: NotRequired[pulumi.Input[builtins.str]]
        passphrase_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for the Passphrase submit button
        """
        passphrase_title: NotRequired[pulumi.Input[builtins.str]]
        """
        Title for passphrase details page
        """
        privacy_policy_accept_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Prefix of the label of the link to go to Privacy Policy
        """
        privacy_policy_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when Privacy Policy not accepted
        """
        privacy_policy_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the link to go to Privacy Policy
        """
        privacy_policy_text: NotRequired[pulumi.Input[builtins.str]]
        """
        Text of the Privacy Policy
        """
        required_field_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label to denote required field
        """
        sign_in_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the button to signin
        """
        sms_carrier_default: NotRequired[pulumi.Input[builtins.str]]
        sms_carrier_error: NotRequired[pulumi.Input[builtins.str]]
        sms_carrier_field_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for mobile carrier drop-down list
        """
        sms_code_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for cancel confirmation code submission
        """
        sms_code_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when confirmation code is invalid
        """
        sms_code_field_label: NotRequired[pulumi.Input[builtins.str]]
        sms_code_message: NotRequired[pulumi.Input[builtins.str]]
        sms_code_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for confirmation code submit button
        """
        sms_code_title: NotRequired[pulumi.Input[builtins.str]]
        sms_country_field_label: NotRequired[pulumi.Input[builtins.str]]
        sms_country_format: NotRequired[pulumi.Input[builtins.str]]
        sms_have_access_code: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for checkbox to specify that the user has access code
        """
        sms_message_format: NotRequired[pulumi.Input[builtins.str]]
        """
        Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        """
        sms_number_cancel: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for canceling mobile details for SMS auth
        """
        sms_number_error: NotRequired[pulumi.Input[builtins.str]]
        sms_number_field_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for field to provide mobile number
        """
        sms_number_format: NotRequired[pulumi.Input[builtins.str]]
        sms_number_message: NotRequired[pulumi.Input[builtins.str]]
        sms_number_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for submit button for code generation
        """
        sms_number_title: NotRequired[pulumi.Input[builtins.str]]
        """
        Title for phone number details
        """
        sms_username_format: NotRequired[pulumi.Input[builtins.str]]
        sponsor_back_link: NotRequired[pulumi.Input[builtins.str]]
        sponsor_cancel: NotRequired[pulumi.Input[builtins.str]]
        sponsor_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Sponsor Email
        """
        sponsor_email_error: NotRequired[pulumi.Input[builtins.str]]
        sponsor_info_approved: NotRequired[pulumi.Input[builtins.str]]
        sponsor_info_denied: NotRequired[pulumi.Input[builtins.str]]
        sponsor_info_pending: NotRequired[pulumi.Input[builtins.str]]
        sponsor_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Label for Sponsor Name
        """
        sponsor_name_error: NotRequired[pulumi.Input[builtins.str]]
        sponsor_note_pending: NotRequired[pulumi.Input[builtins.str]]
        sponsor_request_access: NotRequired[pulumi.Input[builtins.str]]
        """
        Submit button label request Wifi Access and notify sponsor about guest request
        """
        sponsor_status_approved: NotRequired[pulumi.Input[builtins.str]]
        """
        Text to display if sponsor approves request
        """
        sponsor_status_denied: NotRequired[pulumi.Input[builtins.str]]
        """
        Text to display when sponsor denies request
        """
        sponsor_status_pending: NotRequired[pulumi.Input[builtins.str]]
        """
        Text to display if request is still pending
        """
        sponsor_submit: NotRequired[pulumi.Input[builtins.str]]
        """
        Submit button label to notify sponsor about guest request
        """
        sponsors_error: NotRequired[pulumi.Input[builtins.str]]
        sponsors_field_label: NotRequired[pulumi.Input[builtins.str]]
        tos_accept_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Prefix of the label of the link to go to tos
        """
        tos_error: NotRequired[pulumi.Input[builtins.str]]
        """
        Error message when tos not accepted
        """
        tos_link: NotRequired[pulumi.Input[builtins.str]]
        """
        Label of the link to go to tos
        """
        tos_text: NotRequired[pulumi.Input[builtins.str]]
        """
        Text of the Terms of Service
        """
elif False:
    WlanPortalTemplatePortalTemplateLocalesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanPortalTemplatePortalTemplateLocalesArgs:
    def __init__(__self__, *,
                 auth_button_amazon: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_azure: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_email: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_facebook: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_google: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_microsoft: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_passphrase: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_sms: Optional[pulumi.Input[builtins.str]] = None,
                 auth_button_sponsor: Optional[pulumi.Input[builtins.str]] = None,
                 auth_label: Optional[pulumi.Input[builtins.str]] = None,
                 back_link: Optional[pulumi.Input[builtins.str]] = None,
                 company_error: Optional[pulumi.Input[builtins.str]] = None,
                 company_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_access_domain_error: Optional[pulumi.Input[builtins.str]] = None,
                 email_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_error: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_message: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_submit: Optional[pulumi.Input[builtins.str]] = None,
                 email_code_title: Optional[pulumi.Input[builtins.str]] = None,
                 email_error: Optional[pulumi.Input[builtins.str]] = None,
                 email_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_label: Optional[pulumi.Input[builtins.str]] = None,
                 email_message: Optional[pulumi.Input[builtins.str]] = None,
                 email_submit: Optional[pulumi.Input[builtins.str]] = None,
                 email_title: Optional[pulumi.Input[builtins.str]] = None,
                 field1error: Optional[pulumi.Input[builtins.str]] = None,
                 field1label: Optional[pulumi.Input[builtins.str]] = None,
                 field2error: Optional[pulumi.Input[builtins.str]] = None,
                 field2label: Optional[pulumi.Input[builtins.str]] = None,
                 field3error: Optional[pulumi.Input[builtins.str]] = None,
                 field3label: Optional[pulumi.Input[builtins.str]] = None,
                 field4error: Optional[pulumi.Input[builtins.str]] = None,
                 field4label: Optional[pulumi.Input[builtins.str]] = None,
                 marketing_policy_link: Optional[pulumi.Input[builtins.str]] = None,
                 marketing_policy_opt_in: Optional[pulumi.Input[builtins.bool]] = None,
                 marketing_policy_opt_in_label: Optional[pulumi.Input[builtins.str]] = None,
                 marketing_policy_opt_in_text: Optional[pulumi.Input[builtins.str]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 name_error: Optional[pulumi.Input[builtins.str]] = None,
                 name_label: Optional[pulumi.Input[builtins.str]] = None,
                 optout_label: Optional[pulumi.Input[builtins.str]] = None,
                 page_title: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_error: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_label: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_message: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_submit: Optional[pulumi.Input[builtins.str]] = None,
                 passphrase_title: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_accept_label: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_error: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_link: Optional[pulumi.Input[builtins.str]] = None,
                 privacy_policy_text: Optional[pulumi.Input[builtins.str]] = None,
                 required_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sign_in_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_carrier_default: Optional[pulumi.Input[builtins.str]] = None,
                 sms_carrier_error: Optional[pulumi.Input[builtins.str]] = None,
                 sms_carrier_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_error: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_message: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_submit: Optional[pulumi.Input[builtins.str]] = None,
                 sms_code_title: Optional[pulumi.Input[builtins.str]] = None,
                 sms_country_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_country_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_have_access_code: Optional[pulumi.Input[builtins.str]] = None,
                 sms_message_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_error: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_format: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_message: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_submit: Optional[pulumi.Input[builtins.str]] = None,
                 sms_number_title: Optional[pulumi.Input[builtins.str]] = None,
                 sms_username_format: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_back_link: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_cancel: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_email: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_email_error: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_info_approved: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_info_denied: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_info_pending: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_name: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_name_error: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_note_pending: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_request_access: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_status_approved: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_status_denied: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_status_pending: Optional[pulumi.Input[builtins.str]] = None,
                 sponsor_submit: Optional[pulumi.Input[builtins.str]] = None,
                 sponsors_error: Optional[pulumi.Input[builtins.str]] = None,
                 sponsors_field_label: Optional[pulumi.Input[builtins.str]] = None,
                 tos_accept_label: Optional[pulumi.Input[builtins.str]] = None,
                 tos_error: Optional[pulumi.Input[builtins.str]] = None,
                 tos_link: Optional[pulumi.Input[builtins.str]] = None,
                 tos_text: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_button_amazon: Label for Amazon auth button
        :param pulumi.Input[builtins.str] auth_button_azure: Label for Azure auth button
        :param pulumi.Input[builtins.str] auth_button_email: Label for Email auth button
        :param pulumi.Input[builtins.str] auth_button_facebook: Label for Facebook auth button
        :param pulumi.Input[builtins.str] auth_button_google: Label for Google auth button
        :param pulumi.Input[builtins.str] auth_button_microsoft: Label for Microsoft auth button
        :param pulumi.Input[builtins.str] auth_button_passphrase: Label for passphrase auth button
        :param pulumi.Input[builtins.str] auth_button_sms: Label for SMS auth button
        :param pulumi.Input[builtins.str] auth_button_sponsor: Label for Sponsor auth button
        :param pulumi.Input[builtins.str] back_link: Label of the link to go back to /logon
        :param pulumi.Input[builtins.str] company_error: Error message when company not provided
        :param pulumi.Input[builtins.str] company_label: Label of company field
        :param pulumi.Input[builtins.str] email_access_domain_error: Error message when a user has valid social login but doesn't match specified email domains.
        :param pulumi.Input[builtins.str] email_cancel: Label for cancel confirmation code submission using email auth
        :param pulumi.Input[builtins.str] email_error: Error message when email not provided
        :param pulumi.Input[builtins.str] email_label: Label of email field
        :param pulumi.Input[builtins.str] email_submit: Label for confirmation code submit button using email auth
        :param pulumi.Input[builtins.str] email_title: Title for the Email registration
        :param pulumi.Input[builtins.str] field1error: Error message when field1 not provided
        :param pulumi.Input[builtins.str] field1label: Label of field1
        :param pulumi.Input[builtins.str] field2error: Error message when field2 not provided
        :param pulumi.Input[builtins.str] field2label: Label of field2
        :param pulumi.Input[builtins.str] field3error: Error message when field3 not provided
        :param pulumi.Input[builtins.str] field3label: Label of field3
        :param pulumi.Input[builtins.str] field4error: Error message when field4 not provided
        :param pulumi.Input[builtins.str] field4label: Label of field4
        :param pulumi.Input[builtins.str] marketing_policy_link: label of the link to go to /marketing_policy
        :param pulumi.Input[builtins.bool] marketing_policy_opt_in: Whether marketing policy optin is enabled
        :param pulumi.Input[builtins.str] marketing_policy_opt_in_label: label for marketing optin
        :param pulumi.Input[builtins.str] marketing_policy_opt_in_text: marketing policy text
        :param pulumi.Input[builtins.str] name_error: Error message when name not provided
        :param pulumi.Input[builtins.str] name_label: Label of name field
        :param pulumi.Input[builtins.str] optout_label: Label for Do Not Store My Personal Information
        :param pulumi.Input[builtins.str] passphrase_cancel: Label for the Passphrase cancel button
        :param pulumi.Input[builtins.str] passphrase_error: Error message when invalid passphrase is provided
        :param pulumi.Input[builtins.str] passphrase_label: Passphrase
        :param pulumi.Input[builtins.str] passphrase_submit: Label for the Passphrase submit button
        :param pulumi.Input[builtins.str] passphrase_title: Title for passphrase details page
        :param pulumi.Input[builtins.str] privacy_policy_accept_label: Prefix of the label of the link to go to Privacy Policy
        :param pulumi.Input[builtins.str] privacy_policy_error: Error message when Privacy Policy not accepted
        :param pulumi.Input[builtins.str] privacy_policy_link: Label of the link to go to Privacy Policy
        :param pulumi.Input[builtins.str] privacy_policy_text: Text of the Privacy Policy
        :param pulumi.Input[builtins.str] required_field_label: Label to denote required field
        :param pulumi.Input[builtins.str] sign_in_label: Label of the button to signin
        :param pulumi.Input[builtins.str] sms_carrier_field_label: Label for mobile carrier drop-down list
        :param pulumi.Input[builtins.str] sms_code_cancel: Label for cancel confirmation code submission
        :param pulumi.Input[builtins.str] sms_code_error: Error message when confirmation code is invalid
        :param pulumi.Input[builtins.str] sms_code_submit: Label for confirmation code submit button
        :param pulumi.Input[builtins.str] sms_have_access_code: Label for checkbox to specify that the user has access code
        :param pulumi.Input[builtins.str] sms_message_format: Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        :param pulumi.Input[builtins.str] sms_number_cancel: Label for canceling mobile details for SMS auth
        :param pulumi.Input[builtins.str] sms_number_field_label: Label for field to provide mobile number
        :param pulumi.Input[builtins.str] sms_number_submit: Label for submit button for code generation
        :param pulumi.Input[builtins.str] sms_number_title: Title for phone number details
        :param pulumi.Input[builtins.str] sponsor_email: Label for Sponsor Email
        :param pulumi.Input[builtins.str] sponsor_name: Label for Sponsor Name
        :param pulumi.Input[builtins.str] sponsor_request_access: Submit button label request Wifi Access and notify sponsor about guest request
        :param pulumi.Input[builtins.str] sponsor_status_approved: Text to display if sponsor approves request
        :param pulumi.Input[builtins.str] sponsor_status_denied: Text to display when sponsor denies request
        :param pulumi.Input[builtins.str] sponsor_status_pending: Text to display if request is still pending
        :param pulumi.Input[builtins.str] sponsor_submit: Submit button label to notify sponsor about guest request
        :param pulumi.Input[builtins.str] tos_accept_label: Prefix of the label of the link to go to tos
        :param pulumi.Input[builtins.str] tos_error: Error message when tos not accepted
        :param pulumi.Input[builtins.str] tos_link: Label of the link to go to tos
        :param pulumi.Input[builtins.str] tos_text: Text of the Terms of Service
        """
        if auth_button_amazon is not None:
            pulumi.set(__self__, "auth_button_amazon", auth_button_amazon)
        if auth_button_azure is not None:
            pulumi.set(__self__, "auth_button_azure", auth_button_azure)
        if auth_button_email is not None:
            pulumi.set(__self__, "auth_button_email", auth_button_email)
        if auth_button_facebook is not None:
            pulumi.set(__self__, "auth_button_facebook", auth_button_facebook)
        if auth_button_google is not None:
            pulumi.set(__self__, "auth_button_google", auth_button_google)
        if auth_button_microsoft is not None:
            pulumi.set(__self__, "auth_button_microsoft", auth_button_microsoft)
        if auth_button_passphrase is not None:
            pulumi.set(__self__, "auth_button_passphrase", auth_button_passphrase)
        if auth_button_sms is not None:
            pulumi.set(__self__, "auth_button_sms", auth_button_sms)
        if auth_button_sponsor is not None:
            pulumi.set(__self__, "auth_button_sponsor", auth_button_sponsor)
        if auth_label is not None:
            pulumi.set(__self__, "auth_label", auth_label)
        if back_link is not None:
            pulumi.set(__self__, "back_link", back_link)
        if company_error is not None:
            pulumi.set(__self__, "company_error", company_error)
        if company_label is not None:
            pulumi.set(__self__, "company_label", company_label)
        if email_access_domain_error is not None:
            pulumi.set(__self__, "email_access_domain_error", email_access_domain_error)
        if email_cancel is not None:
            pulumi.set(__self__, "email_cancel", email_cancel)
        if email_code_cancel is not None:
            pulumi.set(__self__, "email_code_cancel", email_code_cancel)
        if email_code_error is not None:
            pulumi.set(__self__, "email_code_error", email_code_error)
        if email_code_field_label is not None:
            pulumi.set(__self__, "email_code_field_label", email_code_field_label)
        if email_code_message is not None:
            pulumi.set(__self__, "email_code_message", email_code_message)
        if email_code_submit is not None:
            pulumi.set(__self__, "email_code_submit", email_code_submit)
        if email_code_title is not None:
            pulumi.set(__self__, "email_code_title", email_code_title)
        if email_error is not None:
            pulumi.set(__self__, "email_error", email_error)
        if email_field_label is not None:
            pulumi.set(__self__, "email_field_label", email_field_label)
        if email_label is not None:
            pulumi.set(__self__, "email_label", email_label)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_submit is not None:
            pulumi.set(__self__, "email_submit", email_submit)
        if email_title is not None:
            pulumi.set(__self__, "email_title", email_title)
        if field1error is not None:
            pulumi.set(__self__, "field1error", field1error)
        if field1label is not None:
            pulumi.set(__self__, "field1label", field1label)
        if field2error is not None:
            pulumi.set(__self__, "field2error", field2error)
        if field2label is not None:
            pulumi.set(__self__, "field2label", field2label)
        if field3error is not None:
            pulumi.set(__self__, "field3error", field3error)
        if field3label is not None:
            pulumi.set(__self__, "field3label", field3label)
        if field4error is not None:
            pulumi.set(__self__, "field4error", field4error)
        if field4label is not None:
            pulumi.set(__self__, "field4label", field4label)
        if marketing_policy_link is not None:
            pulumi.set(__self__, "marketing_policy_link", marketing_policy_link)
        if marketing_policy_opt_in is not None:
            pulumi.set(__self__, "marketing_policy_opt_in", marketing_policy_opt_in)
        if marketing_policy_opt_in_label is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_label", marketing_policy_opt_in_label)
        if marketing_policy_opt_in_text is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_text", marketing_policy_opt_in_text)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name_error is not None:
            pulumi.set(__self__, "name_error", name_error)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if optout_label is not None:
            pulumi.set(__self__, "optout_label", optout_label)
        if page_title is not None:
            pulumi.set(__self__, "page_title", page_title)
        if passphrase_cancel is not None:
            pulumi.set(__self__, "passphrase_cancel", passphrase_cancel)
        if passphrase_error is not None:
            pulumi.set(__self__, "passphrase_error", passphrase_error)
        if passphrase_label is not None:
            pulumi.set(__self__, "passphrase_label", passphrase_label)
        if passphrase_message is not None:
            pulumi.set(__self__, "passphrase_message", passphrase_message)
        if passphrase_submit is not None:
            pulumi.set(__self__, "passphrase_submit", passphrase_submit)
        if passphrase_title is not None:
            pulumi.set(__self__, "passphrase_title", passphrase_title)
        if privacy_policy_accept_label is not None:
            pulumi.set(__self__, "privacy_policy_accept_label", privacy_policy_accept_label)
        if privacy_policy_error is not None:
            pulumi.set(__self__, "privacy_policy_error", privacy_policy_error)
        if privacy_policy_link is not None:
            pulumi.set(__self__, "privacy_policy_link", privacy_policy_link)
        if privacy_policy_text is not None:
            pulumi.set(__self__, "privacy_policy_text", privacy_policy_text)
        if required_field_label is not None:
            pulumi.set(__self__, "required_field_label", required_field_label)
        if sign_in_label is not None:
            pulumi.set(__self__, "sign_in_label", sign_in_label)
        if sms_carrier_default is not None:
            pulumi.set(__self__, "sms_carrier_default", sms_carrier_default)
        if sms_carrier_error is not None:
            pulumi.set(__self__, "sms_carrier_error", sms_carrier_error)
        if sms_carrier_field_label is not None:
            pulumi.set(__self__, "sms_carrier_field_label", sms_carrier_field_label)
        if sms_code_cancel is not None:
            pulumi.set(__self__, "sms_code_cancel", sms_code_cancel)
        if sms_code_error is not None:
            pulumi.set(__self__, "sms_code_error", sms_code_error)
        if sms_code_field_label is not None:
            pulumi.set(__self__, "sms_code_field_label", sms_code_field_label)
        if sms_code_message is not None:
            pulumi.set(__self__, "sms_code_message", sms_code_message)
        if sms_code_submit is not None:
            pulumi.set(__self__, "sms_code_submit", sms_code_submit)
        if sms_code_title is not None:
            pulumi.set(__self__, "sms_code_title", sms_code_title)
        if sms_country_field_label is not None:
            pulumi.set(__self__, "sms_country_field_label", sms_country_field_label)
        if sms_country_format is not None:
            pulumi.set(__self__, "sms_country_format", sms_country_format)
        if sms_have_access_code is not None:
            pulumi.set(__self__, "sms_have_access_code", sms_have_access_code)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_number_cancel is not None:
            pulumi.set(__self__, "sms_number_cancel", sms_number_cancel)
        if sms_number_error is not None:
            pulumi.set(__self__, "sms_number_error", sms_number_error)
        if sms_number_field_label is not None:
            pulumi.set(__self__, "sms_number_field_label", sms_number_field_label)
        if sms_number_format is not None:
            pulumi.set(__self__, "sms_number_format", sms_number_format)
        if sms_number_message is not None:
            pulumi.set(__self__, "sms_number_message", sms_number_message)
        if sms_number_submit is not None:
            pulumi.set(__self__, "sms_number_submit", sms_number_submit)
        if sms_number_title is not None:
            pulumi.set(__self__, "sms_number_title", sms_number_title)
        if sms_username_format is not None:
            pulumi.set(__self__, "sms_username_format", sms_username_format)
        if sponsor_back_link is not None:
            pulumi.set(__self__, "sponsor_back_link", sponsor_back_link)
        if sponsor_cancel is not None:
            pulumi.set(__self__, "sponsor_cancel", sponsor_cancel)
        if sponsor_email is not None:
            pulumi.set(__self__, "sponsor_email", sponsor_email)
        if sponsor_email_error is not None:
            pulumi.set(__self__, "sponsor_email_error", sponsor_email_error)
        if sponsor_info_approved is not None:
            pulumi.set(__self__, "sponsor_info_approved", sponsor_info_approved)
        if sponsor_info_denied is not None:
            pulumi.set(__self__, "sponsor_info_denied", sponsor_info_denied)
        if sponsor_info_pending is not None:
            pulumi.set(__self__, "sponsor_info_pending", sponsor_info_pending)
        if sponsor_name is not None:
            pulumi.set(__self__, "sponsor_name", sponsor_name)
        if sponsor_name_error is not None:
            pulumi.set(__self__, "sponsor_name_error", sponsor_name_error)
        if sponsor_note_pending is not None:
            pulumi.set(__self__, "sponsor_note_pending", sponsor_note_pending)
        if sponsor_request_access is not None:
            pulumi.set(__self__, "sponsor_request_access", sponsor_request_access)
        if sponsor_status_approved is not None:
            pulumi.set(__self__, "sponsor_status_approved", sponsor_status_approved)
        if sponsor_status_denied is not None:
            pulumi.set(__self__, "sponsor_status_denied", sponsor_status_denied)
        if sponsor_status_pending is not None:
            pulumi.set(__self__, "sponsor_status_pending", sponsor_status_pending)
        if sponsor_submit is not None:
            pulumi.set(__self__, "sponsor_submit", sponsor_submit)
        if sponsors_error is not None:
            pulumi.set(__self__, "sponsors_error", sponsors_error)
        if sponsors_field_label is not None:
            pulumi.set(__self__, "sponsors_field_label", sponsors_field_label)
        if tos_accept_label is not None:
            pulumi.set(__self__, "tos_accept_label", tos_accept_label)
        if tos_error is not None:
            pulumi.set(__self__, "tos_error", tos_error)
        if tos_link is not None:
            pulumi.set(__self__, "tos_link", tos_link)
        if tos_text is not None:
            pulumi.set(__self__, "tos_text", tos_text)

    @property
    @pulumi.getter(name="authButtonAmazon")
    def auth_button_amazon(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Amazon auth button
        """
        return pulumi.get(self, "auth_button_amazon")

    @auth_button_amazon.setter
    def auth_button_amazon(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_amazon", value)

    @property
    @pulumi.getter(name="authButtonAzure")
    def auth_button_azure(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Azure auth button
        """
        return pulumi.get(self, "auth_button_azure")

    @auth_button_azure.setter
    def auth_button_azure(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_azure", value)

    @property
    @pulumi.getter(name="authButtonEmail")
    def auth_button_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Email auth button
        """
        return pulumi.get(self, "auth_button_email")

    @auth_button_email.setter
    def auth_button_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_email", value)

    @property
    @pulumi.getter(name="authButtonFacebook")
    def auth_button_facebook(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Facebook auth button
        """
        return pulumi.get(self, "auth_button_facebook")

    @auth_button_facebook.setter
    def auth_button_facebook(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_facebook", value)

    @property
    @pulumi.getter(name="authButtonGoogle")
    def auth_button_google(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Google auth button
        """
        return pulumi.get(self, "auth_button_google")

    @auth_button_google.setter
    def auth_button_google(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_google", value)

    @property
    @pulumi.getter(name="authButtonMicrosoft")
    def auth_button_microsoft(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Microsoft auth button
        """
        return pulumi.get(self, "auth_button_microsoft")

    @auth_button_microsoft.setter
    def auth_button_microsoft(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_microsoft", value)

    @property
    @pulumi.getter(name="authButtonPassphrase")
    def auth_button_passphrase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for passphrase auth button
        """
        return pulumi.get(self, "auth_button_passphrase")

    @auth_button_passphrase.setter
    def auth_button_passphrase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_passphrase", value)

    @property
    @pulumi.getter(name="authButtonSms")
    def auth_button_sms(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for SMS auth button
        """
        return pulumi.get(self, "auth_button_sms")

    @auth_button_sms.setter
    def auth_button_sms(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_sms", value)

    @property
    @pulumi.getter(name="authButtonSponsor")
    def auth_button_sponsor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Sponsor auth button
        """
        return pulumi.get(self, "auth_button_sponsor")

    @auth_button_sponsor.setter
    def auth_button_sponsor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_button_sponsor", value)

    @property
    @pulumi.getter(name="authLabel")
    def auth_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "auth_label")

    @auth_label.setter
    def auth_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_label", value)

    @property
    @pulumi.getter(name="backLink")
    def back_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the link to go back to /logon
        """
        return pulumi.get(self, "back_link")

    @back_link.setter
    def back_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "back_link", value)

    @property
    @pulumi.getter(name="companyError")
    def company_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when company not provided
        """
        return pulumi.get(self, "company_error")

    @company_error.setter
    def company_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "company_error", value)

    @property
    @pulumi.getter(name="companyLabel")
    def company_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of company field
        """
        return pulumi.get(self, "company_label")

    @company_label.setter
    def company_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "company_label", value)

    @property
    @pulumi.getter(name="emailAccessDomainError")
    def email_access_domain_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when a user has valid social login but doesn't match specified email domains.
        """
        return pulumi.get(self, "email_access_domain_error")

    @email_access_domain_error.setter
    def email_access_domain_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_access_domain_error", value)

    @property
    @pulumi.getter(name="emailCancel")
    def email_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for cancel confirmation code submission using email auth
        """
        return pulumi.get(self, "email_cancel")

    @email_cancel.setter
    def email_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_cancel", value)

    @property
    @pulumi.getter(name="emailCodeCancel")
    def email_code_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_cancel")

    @email_code_cancel.setter
    def email_code_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_cancel", value)

    @property
    @pulumi.getter(name="emailCodeError")
    def email_code_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_error")

    @email_code_error.setter
    def email_code_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_error", value)

    @property
    @pulumi.getter(name="emailCodeFieldLabel")
    def email_code_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_field_label")

    @email_code_field_label.setter
    def email_code_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_field_label", value)

    @property
    @pulumi.getter(name="emailCodeMessage")
    def email_code_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_message")

    @email_code_message.setter
    def email_code_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_message", value)

    @property
    @pulumi.getter(name="emailCodeSubmit")
    def email_code_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_submit")

    @email_code_submit.setter
    def email_code_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_submit", value)

    @property
    @pulumi.getter(name="emailCodeTitle")
    def email_code_title(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_code_title")

    @email_code_title.setter
    def email_code_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_code_title", value)

    @property
    @pulumi.getter(name="emailError")
    def email_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when email not provided
        """
        return pulumi.get(self, "email_error")

    @email_error.setter
    def email_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_error", value)

    @property
    @pulumi.getter(name="emailFieldLabel")
    def email_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_field_label")

    @email_field_label.setter
    def email_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_field_label", value)

    @property
    @pulumi.getter(name="emailLabel")
    def email_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of email field
        """
        return pulumi.get(self, "email_label")

    @email_label.setter
    def email_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_label", value)

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "email_message")

    @email_message.setter
    def email_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_message", value)

    @property
    @pulumi.getter(name="emailSubmit")
    def email_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for confirmation code submit button using email auth
        """
        return pulumi.get(self, "email_submit")

    @email_submit.setter
    def email_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_submit", value)

    @property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Title for the Email registration
        """
        return pulumi.get(self, "email_title")

    @email_title.setter
    def email_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_title", value)

    @property
    @pulumi.getter
    def field1error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field1 not provided
        """
        return pulumi.get(self, "field1error")

    @field1error.setter
    def field1error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field1error", value)

    @property
    @pulumi.getter
    def field1label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field1
        """
        return pulumi.get(self, "field1label")

    @field1label.setter
    def field1label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field1label", value)

    @property
    @pulumi.getter
    def field2error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field2 not provided
        """
        return pulumi.get(self, "field2error")

    @field2error.setter
    def field2error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field2error", value)

    @property
    @pulumi.getter
    def field2label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field2
        """
        return pulumi.get(self, "field2label")

    @field2label.setter
    def field2label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field2label", value)

    @property
    @pulumi.getter
    def field3error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field3 not provided
        """
        return pulumi.get(self, "field3error")

    @field3error.setter
    def field3error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field3error", value)

    @property
    @pulumi.getter
    def field3label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field3
        """
        return pulumi.get(self, "field3label")

    @field3label.setter
    def field3label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field3label", value)

    @property
    @pulumi.getter
    def field4error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when field4 not provided
        """
        return pulumi.get(self, "field4error")

    @field4error.setter
    def field4error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field4error", value)

    @property
    @pulumi.getter
    def field4label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of field4
        """
        return pulumi.get(self, "field4label")

    @field4label.setter
    def field4label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field4label", value)

    @property
    @pulumi.getter(name="marketingPolicyLink")
    def marketing_policy_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        label of the link to go to /marketing_policy
        """
        return pulumi.get(self, "marketing_policy_link")

    @marketing_policy_link.setter
    def marketing_policy_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "marketing_policy_link", value)

    @property
    @pulumi.getter(name="marketingPolicyOptIn")
    def marketing_policy_opt_in(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether marketing policy optin is enabled
        """
        return pulumi.get(self, "marketing_policy_opt_in")

    @marketing_policy_opt_in.setter
    def marketing_policy_opt_in(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "marketing_policy_opt_in", value)

    @property
    @pulumi.getter(name="marketingPolicyOptInLabel")
    def marketing_policy_opt_in_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        label for marketing optin
        """
        return pulumi.get(self, "marketing_policy_opt_in_label")

    @marketing_policy_opt_in_label.setter
    def marketing_policy_opt_in_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "marketing_policy_opt_in_label", value)

    @property
    @pulumi.getter(name="marketingPolicyOptInText")
    def marketing_policy_opt_in_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        marketing policy text
        """
        return pulumi.get(self, "marketing_policy_opt_in_text")

    @marketing_policy_opt_in_text.setter
    def marketing_policy_opt_in_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "marketing_policy_opt_in_text", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="nameError")
    def name_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when name not provided
        """
        return pulumi.get(self, "name_error")

    @name_error.setter
    def name_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_error", value)

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of name field
        """
        return pulumi.get(self, "name_label")

    @name_label.setter
    def name_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_label", value)

    @property
    @pulumi.getter(name="optoutLabel")
    def optout_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout_label")

    @optout_label.setter
    def optout_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "optout_label", value)

    @property
    @pulumi.getter(name="pageTitle")
    def page_title(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "page_title")

    @page_title.setter
    def page_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "page_title", value)

    @property
    @pulumi.getter(name="passphraseCancel")
    def passphrase_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for the Passphrase cancel button
        """
        return pulumi.get(self, "passphrase_cancel")

    @passphrase_cancel.setter
    def passphrase_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_cancel", value)

    @property
    @pulumi.getter(name="passphraseError")
    def passphrase_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when invalid passphrase is provided
        """
        return pulumi.get(self, "passphrase_error")

    @passphrase_error.setter
    def passphrase_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_error", value)

    @property
    @pulumi.getter(name="passphraseLabel")
    def passphrase_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Passphrase
        """
        return pulumi.get(self, "passphrase_label")

    @passphrase_label.setter
    def passphrase_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_label", value)

    @property
    @pulumi.getter(name="passphraseMessage")
    def passphrase_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "passphrase_message")

    @passphrase_message.setter
    def passphrase_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_message", value)

    @property
    @pulumi.getter(name="passphraseSubmit")
    def passphrase_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for the Passphrase submit button
        """
        return pulumi.get(self, "passphrase_submit")

    @passphrase_submit.setter
    def passphrase_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_submit", value)

    @property
    @pulumi.getter(name="passphraseTitle")
    def passphrase_title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Title for passphrase details page
        """
        return pulumi.get(self, "passphrase_title")

    @passphrase_title.setter
    def passphrase_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_title", value)

    @property
    @pulumi.getter(name="privacyPolicyAcceptLabel")
    def privacy_policy_accept_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prefix of the label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_accept_label")

    @privacy_policy_accept_label.setter
    def privacy_policy_accept_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_accept_label", value)

    @property
    @pulumi.getter(name="privacyPolicyError")
    def privacy_policy_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when Privacy Policy not accepted
        """
        return pulumi.get(self, "privacy_policy_error")

    @privacy_policy_error.setter
    def privacy_policy_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_error", value)

    @property
    @pulumi.getter(name="privacyPolicyLink")
    def privacy_policy_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_link")

    @privacy_policy_link.setter
    def privacy_policy_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_link", value)

    @property
    @pulumi.getter(name="privacyPolicyText")
    def privacy_policy_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text of the Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_text")

    @privacy_policy_text.setter
    def privacy_policy_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "privacy_policy_text", value)

    @property
    @pulumi.getter(name="requiredFieldLabel")
    def required_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label to denote required field
        """
        return pulumi.get(self, "required_field_label")

    @required_field_label.setter
    def required_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "required_field_label", value)

    @property
    @pulumi.getter(name="signInLabel")
    def sign_in_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the button to signin
        """
        return pulumi.get(self, "sign_in_label")

    @sign_in_label.setter
    def sign_in_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sign_in_label", value)

    @property
    @pulumi.getter(name="smsCarrierDefault")
    def sms_carrier_default(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_carrier_default")

    @sms_carrier_default.setter
    def sms_carrier_default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_carrier_default", value)

    @property
    @pulumi.getter(name="smsCarrierError")
    def sms_carrier_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_carrier_error")

    @sms_carrier_error.setter
    def sms_carrier_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_carrier_error", value)

    @property
    @pulumi.getter(name="smsCarrierFieldLabel")
    def sms_carrier_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for mobile carrier drop-down list
        """
        return pulumi.get(self, "sms_carrier_field_label")

    @sms_carrier_field_label.setter
    def sms_carrier_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_carrier_field_label", value)

    @property
    @pulumi.getter(name="smsCodeCancel")
    def sms_code_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for cancel confirmation code submission
        """
        return pulumi.get(self, "sms_code_cancel")

    @sms_code_cancel.setter
    def sms_code_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_cancel", value)

    @property
    @pulumi.getter(name="smsCodeError")
    def sms_code_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when confirmation code is invalid
        """
        return pulumi.get(self, "sms_code_error")

    @sms_code_error.setter
    def sms_code_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_error", value)

    @property
    @pulumi.getter(name="smsCodeFieldLabel")
    def sms_code_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_code_field_label")

    @sms_code_field_label.setter
    def sms_code_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_field_label", value)

    @property
    @pulumi.getter(name="smsCodeMessage")
    def sms_code_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_code_message")

    @sms_code_message.setter
    def sms_code_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_message", value)

    @property
    @pulumi.getter(name="smsCodeSubmit")
    def sms_code_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for confirmation code submit button
        """
        return pulumi.get(self, "sms_code_submit")

    @sms_code_submit.setter
    def sms_code_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_submit", value)

    @property
    @pulumi.getter(name="smsCodeTitle")
    def sms_code_title(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_code_title")

    @sms_code_title.setter
    def sms_code_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_code_title", value)

    @property
    @pulumi.getter(name="smsCountryFieldLabel")
    def sms_country_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_country_field_label")

    @sms_country_field_label.setter
    def sms_country_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_country_field_label", value)

    @property
    @pulumi.getter(name="smsCountryFormat")
    def sms_country_format(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_country_format")

    @sms_country_format.setter
    def sms_country_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_country_format", value)

    @property
    @pulumi.getter(name="smsHaveAccessCode")
    def sms_have_access_code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for checkbox to specify that the user has access code
        """
        return pulumi.get(self, "sms_have_access_code")

    @sms_have_access_code.setter
    def sms_have_access_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_have_access_code", value)

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        """
        return pulumi.get(self, "sms_message_format")

    @sms_message_format.setter
    def sms_message_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_message_format", value)

    @property
    @pulumi.getter(name="smsNumberCancel")
    def sms_number_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for canceling mobile details for SMS auth
        """
        return pulumi.get(self, "sms_number_cancel")

    @sms_number_cancel.setter
    def sms_number_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_cancel", value)

    @property
    @pulumi.getter(name="smsNumberError")
    def sms_number_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_number_error")

    @sms_number_error.setter
    def sms_number_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_error", value)

    @property
    @pulumi.getter(name="smsNumberFieldLabel")
    def sms_number_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for field to provide mobile number
        """
        return pulumi.get(self, "sms_number_field_label")

    @sms_number_field_label.setter
    def sms_number_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_field_label", value)

    @property
    @pulumi.getter(name="smsNumberFormat")
    def sms_number_format(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_number_format")

    @sms_number_format.setter
    def sms_number_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_format", value)

    @property
    @pulumi.getter(name="smsNumberMessage")
    def sms_number_message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_number_message")

    @sms_number_message.setter
    def sms_number_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_message", value)

    @property
    @pulumi.getter(name="smsNumberSubmit")
    def sms_number_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for submit button for code generation
        """
        return pulumi.get(self, "sms_number_submit")

    @sms_number_submit.setter
    def sms_number_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_submit", value)

    @property
    @pulumi.getter(name="smsNumberTitle")
    def sms_number_title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Title for phone number details
        """
        return pulumi.get(self, "sms_number_title")

    @sms_number_title.setter
    def sms_number_title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_number_title", value)

    @property
    @pulumi.getter(name="smsUsernameFormat")
    def sms_username_format(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sms_username_format")

    @sms_username_format.setter
    def sms_username_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sms_username_format", value)

    @property
    @pulumi.getter(name="sponsorBackLink")
    def sponsor_back_link(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_back_link")

    @sponsor_back_link.setter
    def sponsor_back_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_back_link", value)

    @property
    @pulumi.getter(name="sponsorCancel")
    def sponsor_cancel(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_cancel")

    @sponsor_cancel.setter
    def sponsor_cancel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_cancel", value)

    @property
    @pulumi.getter(name="sponsorEmail")
    def sponsor_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Sponsor Email
        """
        return pulumi.get(self, "sponsor_email")

    @sponsor_email.setter
    def sponsor_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_email", value)

    @property
    @pulumi.getter(name="sponsorEmailError")
    def sponsor_email_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_email_error")

    @sponsor_email_error.setter
    def sponsor_email_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_email_error", value)

    @property
    @pulumi.getter(name="sponsorInfoApproved")
    def sponsor_info_approved(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_info_approved")

    @sponsor_info_approved.setter
    def sponsor_info_approved(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_info_approved", value)

    @property
    @pulumi.getter(name="sponsorInfoDenied")
    def sponsor_info_denied(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_info_denied")

    @sponsor_info_denied.setter
    def sponsor_info_denied(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_info_denied", value)

    @property
    @pulumi.getter(name="sponsorInfoPending")
    def sponsor_info_pending(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_info_pending")

    @sponsor_info_pending.setter
    def sponsor_info_pending(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_info_pending", value)

    @property
    @pulumi.getter(name="sponsorName")
    def sponsor_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label for Sponsor Name
        """
        return pulumi.get(self, "sponsor_name")

    @sponsor_name.setter
    def sponsor_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_name", value)

    @property
    @pulumi.getter(name="sponsorNameError")
    def sponsor_name_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_name_error")

    @sponsor_name_error.setter
    def sponsor_name_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_name_error", value)

    @property
    @pulumi.getter(name="sponsorNotePending")
    def sponsor_note_pending(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsor_note_pending")

    @sponsor_note_pending.setter
    def sponsor_note_pending(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_note_pending", value)

    @property
    @pulumi.getter(name="sponsorRequestAccess")
    def sponsor_request_access(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Submit button label request Wifi Access and notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_request_access")

    @sponsor_request_access.setter
    def sponsor_request_access(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_request_access", value)

    @property
    @pulumi.getter(name="sponsorStatusApproved")
    def sponsor_status_approved(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text to display if sponsor approves request
        """
        return pulumi.get(self, "sponsor_status_approved")

    @sponsor_status_approved.setter
    def sponsor_status_approved(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_status_approved", value)

    @property
    @pulumi.getter(name="sponsorStatusDenied")
    def sponsor_status_denied(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text to display when sponsor denies request
        """
        return pulumi.get(self, "sponsor_status_denied")

    @sponsor_status_denied.setter
    def sponsor_status_denied(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_status_denied", value)

    @property
    @pulumi.getter(name="sponsorStatusPending")
    def sponsor_status_pending(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text to display if request is still pending
        """
        return pulumi.get(self, "sponsor_status_pending")

    @sponsor_status_pending.setter
    def sponsor_status_pending(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_status_pending", value)

    @property
    @pulumi.getter(name="sponsorSubmit")
    def sponsor_submit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Submit button label to notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_submit")

    @sponsor_submit.setter
    def sponsor_submit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsor_submit", value)

    @property
    @pulumi.getter(name="sponsorsError")
    def sponsors_error(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsors_error")

    @sponsors_error.setter
    def sponsors_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsors_error", value)

    @property
    @pulumi.getter(name="sponsorsFieldLabel")
    def sponsors_field_label(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sponsors_field_label")

    @sponsors_field_label.setter
    def sponsors_field_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sponsors_field_label", value)

    @property
    @pulumi.getter(name="tosAcceptLabel")
    def tos_accept_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prefix of the label of the link to go to tos
        """
        return pulumi.get(self, "tos_accept_label")

    @tos_accept_label.setter
    def tos_accept_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_accept_label", value)

    @property
    @pulumi.getter(name="tosError")
    def tos_error(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Error message when tos not accepted
        """
        return pulumi.get(self, "tos_error")

    @tos_error.setter
    def tos_error(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_error", value)

    @property
    @pulumi.getter(name="tosLink")
    def tos_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label of the link to go to tos
        """
        return pulumi.get(self, "tos_link")

    @tos_link.setter
    def tos_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_link", value)

    @property
    @pulumi.getter(name="tosText")
    def tos_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text of the Terms of Service
        """
        return pulumi.get(self, "tos_text")

    @tos_text.setter
    def tos_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tos_text", value)


if not MYPY:
    class WlanQosArgsDict(TypedDict):
        class_: NotRequired[pulumi.Input[builtins.str]]
        """
        enum: `background`, `best_effort`, `video`, `voice`
        """
        overwrite: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to overwrite QoS
        """
elif False:
    WlanQosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanQosArgs:
    def __init__(__self__, *,
                 class_: Optional[pulumi.Input[builtins.str]] = None,
                 overwrite: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] class_: enum: `background`, `best_effort`, `video`, `voice`
        :param pulumi.Input[builtins.bool] overwrite: Whether to overwrite QoS
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `background`, `best_effort`, `video`, `voice`
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to overwrite QoS
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "overwrite", value)


if not MYPY:
    class WlanRadsecArgsDict(TypedDict):
        coa_enabled: NotRequired[pulumi.Input[builtins.bool]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        idle_timeout: NotRequired[pulumi.Input[builtins.str]]
        mxcluster_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        """
        proxy_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        """
        server_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgsDict']]]]
        """
        List of RadSec Servers. Only if not Mist Edge.
        """
        use_mxedge: NotRequired[pulumi.Input[builtins.bool]]
        """
        use mxedge(s) as RadSec Proxy
        """
        use_site_mxedge: NotRequired[pulumi.Input[builtins.bool]]
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
elif False:
    WlanRadsecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanRadsecArgs:
    def __init__(__self__, *,
                 coa_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 idle_timeout: Optional[pulumi.Input[builtins.str]] = None,
                 mxcluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 proxy_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 server_name: Optional[pulumi.Input[builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]]] = None,
                 use_mxedge: Optional[pulumi.Input[builtins.bool]] = None,
                 use_site_mxedge: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] proxy_hosts: Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        :param pulumi.Input[builtins.str] server_name: Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]] servers: List of RadSec Servers. Only if not Mist Edge.
        :param pulumi.Input[builtins.bool] use_mxedge: use mxedge(s) as RadSec Proxy
        :param pulumi.Input[builtins.bool] use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if mxcluster_ids is not None:
            pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        if proxy_hosts is not None:
            pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if use_mxedge is not None:
            pulumi.set(__self__, "use_mxedge", use_mxedge)
        if use_site_mxedge is not None:
            pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "coa_enabled")

    @coa_enabled.setter
    def coa_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "coa_enabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @mxcluster_ids.setter
    def mxcluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "mxcluster_ids", value)

    @property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        """
        return pulumi.get(self, "proxy_hosts")

    @proxy_hosts.setter
    def proxy_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "proxy_hosts", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_name", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]]]:
        """
        List of RadSec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        use mxedge(s) as RadSec Proxy
        """
        return pulumi.get(self, "use_mxedge")

    @use_mxedge.setter
    def use_mxedge(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_mxedge", value)

    @property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")

    @use_site_mxedge.setter
    def use_site_mxedge(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_site_mxedge", value)


if not MYPY:
    class WlanRadsecServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.int]]
elif False:
    WlanRadsecServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanRadsecServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WlanRatesetArgsDict(TypedDict):
        eht: NotRequired[pulumi.Input[builtins.str]]
        """
        If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        """
        he: NotRequired[pulumi.Input[builtins.str]]
        """
        If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        """
        ht: NotRequired[pulumi.Input[builtins.str]]
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        """
        legacies: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append b at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
        """
        min_rssi: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum RSSI for client to connect, 0 means not enforcing
        """
        template: NotRequired[pulumi.Input[builtins.str]]
        """
        Data Rates template to apply. enum: 
          * `no-legacy`: no 11b
          * `compatible`: all, like before, default setting that Broadcom/Atheros used
          * `legacy-only`: disable 802.11n and 802.11ac
          * `high-density`: no 11b, no low rates
          * `custom`: user defined
        """
        vht: NotRequired[pulumi.Input[builtins.str]]
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
elif False:
    WlanRatesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanRatesetArgs:
    def __init__(__self__, *,
                 eht: Optional[pulumi.Input[builtins.str]] = None,
                 he: Optional[pulumi.Input[builtins.str]] = None,
                 ht: Optional[pulumi.Input[builtins.str]] = None,
                 legacies: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 min_rssi: Optional[pulumi.Input[builtins.int]] = None,
                 template: Optional[pulumi.Input[builtins.str]] = None,
                 vht: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] eht: If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        :param pulumi.Input[builtins.str] he: If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        :param pulumi.Input[builtins.str] ht: If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] legacies: if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append b at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
        :param pulumi.Input[builtins.int] min_rssi: Minimum RSSI for client to connect, 0 means not enforcing
        :param pulumi.Input[builtins.str] template: Data Rates template to apply. enum: 
                 * `no-legacy`: no 11b
                 * `compatible`: all, like before, default setting that Broadcom/Atheros used
                 * `legacy-only`: disable 802.11n and 802.11ac
                 * `high-density`: no 11b, no low rates
                 * `custom`: user defined
        :param pulumi.Input[builtins.str] vht: If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
        if eht is not None:
            pulumi.set(__self__, "eht", eht)
        if he is not None:
            pulumi.set(__self__, "he", he)
        if ht is not None:
            pulumi.set(__self__, "ht", ht)
        if legacies is not None:
            pulumi.set(__self__, "legacies", legacies)
        if min_rssi is not None:
            pulumi.set(__self__, "min_rssi", min_rssi)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if vht is not None:
            pulumi.set(__self__, "vht", vht)

    @property
    @pulumi.getter
    def eht(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        """
        return pulumi.get(self, "eht")

    @eht.setter
    def eht(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eht", value)

    @property
    @pulumi.getter
    def he(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        """
        return pulumi.get(self, "he")

    @he.setter
    def he(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "he", value)

    @property
    @pulumi.getter
    def ht(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        """
        return pulumi.get(self, "ht")

    @ht.setter
    def ht(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ht", value)

    @property
    @pulumi.getter
    def legacies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append b at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
        """
        return pulumi.get(self, "legacies")

    @legacies.setter
    def legacies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "legacies", value)

    @property
    @pulumi.getter(name="minRssi")
    def min_rssi(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum RSSI for client to connect, 0 means not enforcing
        """
        return pulumi.get(self, "min_rssi")

    @min_rssi.setter
    def min_rssi(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_rssi", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Data Rates template to apply. enum: 
          * `no-legacy`: no 11b
          * `compatible`: all, like before, default setting that Broadcom/Atheros used
          * `legacy-only`: disable 802.11n and 802.11ac
          * `high-density`: no 11b, no low rates
          * `custom`: user defined
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def vht(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
        return pulumi.get(self, "vht")

    @vht.setter
    def vht(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vht", value)


if not MYPY:
    class WlanScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        hours: NotRequired[pulumi.Input['WlanScheduleHoursArgsDict']]
        """
        Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
elif False:
    WlanScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 hours: Optional[pulumi.Input['WlanScheduleHoursArgs']] = None):
        """
        :param pulumi.Input['WlanScheduleHoursArgs'] hours: Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input['WlanScheduleHoursArgs']]:
        """
        Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input['WlanScheduleHoursArgs']]):
        pulumi.set(self, "hours", value)


if not MYPY:
    class WlanScheduleHoursArgsDict(TypedDict):
        fri: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        mon: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        sat: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        sun: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        thu: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        tue: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        wed: NotRequired[pulumi.Input[builtins.str]]
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
elif False:
    WlanScheduleHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlanScheduleHoursArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[builtins.str]] = None,
                 mon: Optional[pulumi.Input[builtins.str]] = None,
                 sat: Optional[pulumi.Input[builtins.str]] = None,
                 sun: Optional[pulumi.Input[builtins.str]] = None,
                 thu: Optional[pulumi.Input[builtins.str]] = None,
                 tue: Optional[pulumi.Input[builtins.str]] = None,
                 wed: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fri: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param pulumi.Input[builtins.str] mon: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param pulumi.Input[builtins.str] sat: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param pulumi.Input[builtins.str] sun: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param pulumi.Input[builtins.str] thu: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param pulumi.Input[builtins.str] tue: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param pulumi.Input[builtins.str] wed: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fri", value)

    @property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mon", value)

    @property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sat", value)

    @property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sun", value)

    @property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "thu", value)

    @property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tue", value)

    @property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "wed", value)


if not MYPY:
    class WlantemplateAppliesArgsDict(TypedDict):
        org_id: NotRequired[pulumi.Input[builtins.str]]
        site_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of site ids
        """
        sitegroup_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of sitegroup ids
        """
elif False:
    WlantemplateAppliesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlantemplateAppliesArgs:
    def __init__(__self__, *,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 site_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 sitegroup_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] site_ids: List of site ids
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sitegroup_ids: List of sitegroup ids
        """
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of site ids
        """
        return pulumi.get(self, "site_ids")

    @site_ids.setter
    def site_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "site_ids", value)

    @property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of sitegroup ids
        """
        return pulumi.get(self, "sitegroup_ids")

    @sitegroup_ids.setter
    def sitegroup_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sitegroup_ids", value)


if not MYPY:
    class WlantemplateExceptionsArgsDict(TypedDict):
        site_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of site ids
        """
        sitegroup_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of sitegroup ids
        """
elif False:
    WlantemplateExceptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WlantemplateExceptionsArgs:
    def __init__(__self__, *,
                 site_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 sitegroup_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] site_ids: List of site ids
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sitegroup_ids: List of sitegroup ids
        """
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)

    @property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of site ids
        """
        return pulumi.get(self, "site_ids")

    @site_ids.setter
    def site_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "site_ids", value)

    @property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of sitegroup ids
        """
        return pulumi.get(self, "sitegroup_ids")

    @sitegroup_ids.setter
    def sitegroup_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sitegroup_ids", value)


if not MYPY:
    class WxtagSpecArgsDict(TypedDict):
        port_range: NotRequired[pulumi.Input[builtins.str]]
        """
        Matched destination port, "0" means any
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Matched destination subnets and/or IP Addresses
        """
elif False:
    WxtagSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WxtagSpecArgs:
    def __init__(__self__, *,
                 port_range: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] port_range: Matched destination port, "0" means any
        :param pulumi.Input[builtins.str] protocol: tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnets: Matched destination subnets and/or IP Addresses
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Matched destination port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Matched destination subnets and/or IP Addresses
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subnets", value)


