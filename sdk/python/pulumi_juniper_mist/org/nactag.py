# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = ['NactagArgs', 'Nactag']

@pulumi.input_type
class NactagArgs:
    def __init__(__self__, *,
                 org_id: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 allow_usermac_override: Optional[pulumi.Input[builtins.bool]] = None,
                 egress_vlan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gbp_tag: Optional[pulumi.Input[builtins.str]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 match_all: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 radius_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 radius_group: Optional[pulumi.Input[builtins.str]] = None,
                 radius_vendor_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 session_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 username_attr: Optional[pulumi.Input[builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan: Optional[pulumi.Input[builtins.str]] = None):
        """
        The set of arguments for constructing a Nactag resource.
        :param pulumi.Input[builtins.str] type: enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
               `username_attr`, `vlan`
        :param pulumi.Input[builtins.bool] allow_usermac_override: Can be set to true to allow the override by usermac result
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] egress_vlan_names: If `type`==`egress_vlan_names`, list of egress vlans to return
        :param pulumi.Input[builtins.str] match: if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
               `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
               `usermac_label`
        :param pulumi.Input[builtins.bool] match_all: This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
               match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
               set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_attrs: If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
               the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
               that it is allowed to have more than one radius_attrs in the result of a given rule.
        :param pulumi.Input[builtins.str] radius_group: If `type`==`radius_group`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_vendor_attrs: If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
               "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
               not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        :param pulumi.Input[builtins.int] session_timeout: If `type`==`session_timeout, in seconds
        :param pulumi.Input[builtins.str] username_attr: enum: `automatic`, `cn`, `dns`, `email`, `upn`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: If `type`==`match`
        :param pulumi.Input[builtins.str] vlan: If `type`==`vlan`
        """
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "type", type)
        if allow_usermac_override is not None:
            pulumi.set(__self__, "allow_usermac_override", allow_usermac_override)
        if egress_vlan_names is not None:
            pulumi.set(__self__, "egress_vlan_names", egress_vlan_names)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if match_all is not None:
            pulumi.set(__self__, "match_all", match_all)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if radius_attrs is not None:
            pulumi.set(__self__, "radius_attrs", radius_attrs)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if radius_vendor_attrs is not None:
            pulumi.set(__self__, "radius_vendor_attrs", radius_vendor_attrs)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if username_attr is not None:
            pulumi.set(__self__, "username_attr", username_attr)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
        `username_attr`, `vlan`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowUsermacOverride")
    def allow_usermac_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can be set to true to allow the override by usermac result
        """
        return pulumi.get(self, "allow_usermac_override")

    @allow_usermac_override.setter
    def allow_usermac_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_usermac_override", value)

    @property
    @pulumi.getter(name="egressVlanNames")
    def egress_vlan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`egress_vlan_names`, list of egress vlans to return
        """
        return pulumi.get(self, "egress_vlan_names")

    @egress_vlan_names.setter
    def egress_vlan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "egress_vlan_names", value)

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gbp_tag")

    @gbp_tag.setter
    def gbp_tag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gbp_tag", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
        `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
        `usermac_label`
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="matchAll")
    def match_all(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
        match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
        set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        """
        return pulumi.get(self, "match_all")

    @match_all.setter
    def match_all(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "match_all", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="radiusAttrs")
    def radius_attrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
        the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
        that it is allowed to have more than one radius_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_attrs")

    @radius_attrs.setter
    def radius_attrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "radius_attrs", value)

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`radius_group`
        """
        return pulumi.get(self, "radius_group")

    @radius_group.setter
    def radius_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "radius_group", value)

    @property
    @pulumi.getter(name="radiusVendorAttrs")
    def radius_vendor_attrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
        "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
        not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_vendor_attrs")

    @radius_vendor_attrs.setter
    def radius_vendor_attrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "radius_vendor_attrs", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If `type`==`session_timeout, in seconds
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "session_timeout", value)

    @property
    @pulumi.getter(name="usernameAttr")
    def username_attr(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `automatic`, `cn`, `dns`, `email`, `upn`
        """
        return pulumi.get(self, "username_attr")

    @username_attr.setter
    def username_attr(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_attr", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`match`
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`vlan`
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan", value)


@pulumi.input_type
class _NactagState:
    def __init__(__self__, *,
                 allow_usermac_override: Optional[pulumi.Input[builtins.bool]] = None,
                 egress_vlan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gbp_tag: Optional[pulumi.Input[builtins.str]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 match_all: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 radius_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 radius_group: Optional[pulumi.Input[builtins.str]] = None,
                 radius_vendor_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 session_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 username_attr: Optional[pulumi.Input[builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan: Optional[pulumi.Input[builtins.str]] = None):
        """
        Input properties used for looking up and filtering Nactag resources.
        :param pulumi.Input[builtins.bool] allow_usermac_override: Can be set to true to allow the override by usermac result
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] egress_vlan_names: If `type`==`egress_vlan_names`, list of egress vlans to return
        :param pulumi.Input[builtins.str] match: if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
               `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
               `usermac_label`
        :param pulumi.Input[builtins.bool] match_all: This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
               match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
               set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_attrs: If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
               the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
               that it is allowed to have more than one radius_attrs in the result of a given rule.
        :param pulumi.Input[builtins.str] radius_group: If `type`==`radius_group`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_vendor_attrs: If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
               "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
               not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        :param pulumi.Input[builtins.int] session_timeout: If `type`==`session_timeout, in seconds
        :param pulumi.Input[builtins.str] type: enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
               `username_attr`, `vlan`
        :param pulumi.Input[builtins.str] username_attr: enum: `automatic`, `cn`, `dns`, `email`, `upn`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: If `type`==`match`
        :param pulumi.Input[builtins.str] vlan: If `type`==`vlan`
        """
        if allow_usermac_override is not None:
            pulumi.set(__self__, "allow_usermac_override", allow_usermac_override)
        if egress_vlan_names is not None:
            pulumi.set(__self__, "egress_vlan_names", egress_vlan_names)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if match_all is not None:
            pulumi.set(__self__, "match_all", match_all)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if radius_attrs is not None:
            pulumi.set(__self__, "radius_attrs", radius_attrs)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if radius_vendor_attrs is not None:
            pulumi.set(__self__, "radius_vendor_attrs", radius_vendor_attrs)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username_attr is not None:
            pulumi.set(__self__, "username_attr", username_attr)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="allowUsermacOverride")
    def allow_usermac_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Can be set to true to allow the override by usermac result
        """
        return pulumi.get(self, "allow_usermac_override")

    @allow_usermac_override.setter
    def allow_usermac_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_usermac_override", value)

    @property
    @pulumi.getter(name="egressVlanNames")
    def egress_vlan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`egress_vlan_names`, list of egress vlans to return
        """
        return pulumi.get(self, "egress_vlan_names")

    @egress_vlan_names.setter
    def egress_vlan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "egress_vlan_names", value)

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "gbp_tag")

    @gbp_tag.setter
    def gbp_tag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gbp_tag", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
        `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
        `usermac_label`
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="matchAll")
    def match_all(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
        match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
        set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        """
        return pulumi.get(self, "match_all")

    @match_all.setter
    def match_all(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "match_all", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter(name="radiusAttrs")
    def radius_attrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
        the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
        that it is allowed to have more than one radius_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_attrs")

    @radius_attrs.setter
    def radius_attrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "radius_attrs", value)

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`radius_group`
        """
        return pulumi.get(self, "radius_group")

    @radius_group.setter
    def radius_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "radius_group", value)

    @property
    @pulumi.getter(name="radiusVendorAttrs")
    def radius_vendor_attrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
        "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
        not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_vendor_attrs")

    @radius_vendor_attrs.setter
    def radius_vendor_attrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "radius_vendor_attrs", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If `type`==`session_timeout, in seconds
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "session_timeout", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
        `username_attr`, `vlan`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="usernameAttr")
    def username_attr(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        enum: `automatic`, `cn`, `dns`, `email`, `upn`
        """
        return pulumi.get(self, "username_attr")

    @username_attr.setter
    def username_attr(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_attr", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        If `type`==`match`
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If `type`==`vlan`
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vlan", value)


class Nactag(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_usermac_override: Optional[pulumi.Input[builtins.bool]] = None,
                 egress_vlan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gbp_tag: Optional[pulumi.Input[builtins.str]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 match_all: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 radius_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 radius_group: Optional[pulumi.Input[builtins.str]] = None,
                 radius_vendor_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 session_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 username_attr: Optional[pulumi.Input[builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan: Optional[pulumi.Input[builtins.str]] = None,
                 __props__=None):
        """
        This resource manages NAC Tags (Auth Policy Labels).

        The NAC Tags can be used in the NAC Rules to define the matching criteria or the returned RADIUS Attributes

        ## Example Usage

        ```python
        import pulumi
        import pulumi_juniper_mist as junipermist

        tag_one = junipermist.org.Nactag("tag_one",
            name="tag_one",
            type="match",
            match="client_mac",
            org_id=terraform_test["id"],
            values=["5c5b35*"])
        ```

        ## Import

        Using `pulumi import`, import `mist_org_nactag` with:

        NAC Tag can be imported by specifying the org_id and the nactag_id

        ```sh
        $ pulumi import junipermist:org/nactag:Nactag nactag_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] allow_usermac_override: Can be set to true to allow the override by usermac result
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] egress_vlan_names: If `type`==`egress_vlan_names`, list of egress vlans to return
        :param pulumi.Input[builtins.str] match: if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
               `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
               `usermac_label`
        :param pulumi.Input[builtins.bool] match_all: This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
               match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
               set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_attrs: If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
               the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
               that it is allowed to have more than one radius_attrs in the result of a given rule.
        :param pulumi.Input[builtins.str] radius_group: If `type`==`radius_group`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_vendor_attrs: If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
               "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
               not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        :param pulumi.Input[builtins.int] session_timeout: If `type`==`session_timeout, in seconds
        :param pulumi.Input[builtins.str] type: enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
               `username_attr`, `vlan`
        :param pulumi.Input[builtins.str] username_attr: enum: `automatic`, `cn`, `dns`, `email`, `upn`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: If `type`==`match`
        :param pulumi.Input[builtins.str] vlan: If `type`==`vlan`
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: NactagArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        This resource manages NAC Tags (Auth Policy Labels).

        The NAC Tags can be used in the NAC Rules to define the matching criteria or the returned RADIUS Attributes

        ## Example Usage

        ```python
        import pulumi
        import pulumi_juniper_mist as junipermist

        tag_one = junipermist.org.Nactag("tag_one",
            name="tag_one",
            type="match",
            match="client_mac",
            org_id=terraform_test["id"],
            values=["5c5b35*"])
        ```

        ## Import

        Using `pulumi import`, import `mist_org_nactag` with:

        NAC Tag can be imported by specifying the org_id and the nactag_id

        ```sh
        $ pulumi import junipermist:org/nactag:Nactag nactag_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param NactagArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(NactagArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_usermac_override: Optional[pulumi.Input[builtins.bool]] = None,
                 egress_vlan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gbp_tag: Optional[pulumi.Input[builtins.str]] = None,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 match_all: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 radius_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 radius_group: Optional[pulumi.Input[builtins.str]] = None,
                 radius_vendor_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 session_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 username_attr: Optional[pulumi.Input[builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vlan: Optional[pulumi.Input[builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = NactagArgs.__new__(NactagArgs)

            __props__.__dict__["allow_usermac_override"] = allow_usermac_override
            __props__.__dict__["egress_vlan_names"] = egress_vlan_names
            __props__.__dict__["gbp_tag"] = gbp_tag
            __props__.__dict__["match"] = match
            __props__.__dict__["match_all"] = match_all
            __props__.__dict__["name"] = name
            if org_id is None and not opts.urn:
                raise TypeError("Missing required property 'org_id'")
            __props__.__dict__["org_id"] = org_id
            __props__.__dict__["radius_attrs"] = radius_attrs
            __props__.__dict__["radius_group"] = radius_group
            __props__.__dict__["radius_vendor_attrs"] = radius_vendor_attrs
            __props__.__dict__["session_timeout"] = session_timeout
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["username_attr"] = username_attr
            __props__.__dict__["values"] = values
            __props__.__dict__["vlan"] = vlan
        super(Nactag, __self__).__init__(
            'junipermist:org/nactag:Nactag',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allow_usermac_override: Optional[pulumi.Input[builtins.bool]] = None,
            egress_vlan_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            gbp_tag: Optional[pulumi.Input[builtins.str]] = None,
            match: Optional[pulumi.Input[builtins.str]] = None,
            match_all: Optional[pulumi.Input[builtins.bool]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            org_id: Optional[pulumi.Input[builtins.str]] = None,
            radius_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            radius_group: Optional[pulumi.Input[builtins.str]] = None,
            radius_vendor_attrs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            session_timeout: Optional[pulumi.Input[builtins.int]] = None,
            type: Optional[pulumi.Input[builtins.str]] = None,
            username_attr: Optional[pulumi.Input[builtins.str]] = None,
            values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            vlan: Optional[pulumi.Input[builtins.str]] = None) -> 'Nactag':
        """
        Get an existing Nactag resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.bool] allow_usermac_override: Can be set to true to allow the override by usermac result
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] egress_vlan_names: If `type`==`egress_vlan_names`, list of egress vlans to return
        :param pulumi.Input[builtins.str] match: if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
               `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
               `usermac_label`
        :param pulumi.Input[builtins.bool] match_all: This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
               match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
               set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_attrs: If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
               the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
               that it is allowed to have more than one radius_attrs in the result of a given rule.
        :param pulumi.Input[builtins.str] radius_group: If `type`==`radius_group`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] radius_vendor_attrs: If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
               "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
               not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        :param pulumi.Input[builtins.int] session_timeout: If `type`==`session_timeout, in seconds
        :param pulumi.Input[builtins.str] type: enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
               `username_attr`, `vlan`
        :param pulumi.Input[builtins.str] username_attr: enum: `automatic`, `cn`, `dns`, `email`, `upn`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: If `type`==`match`
        :param pulumi.Input[builtins.str] vlan: If `type`==`vlan`
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _NactagState.__new__(_NactagState)

        __props__.__dict__["allow_usermac_override"] = allow_usermac_override
        __props__.__dict__["egress_vlan_names"] = egress_vlan_names
        __props__.__dict__["gbp_tag"] = gbp_tag
        __props__.__dict__["match"] = match
        __props__.__dict__["match_all"] = match_all
        __props__.__dict__["name"] = name
        __props__.__dict__["org_id"] = org_id
        __props__.__dict__["radius_attrs"] = radius_attrs
        __props__.__dict__["radius_group"] = radius_group
        __props__.__dict__["radius_vendor_attrs"] = radius_vendor_attrs
        __props__.__dict__["session_timeout"] = session_timeout
        __props__.__dict__["type"] = type
        __props__.__dict__["username_attr"] = username_attr
        __props__.__dict__["values"] = values
        __props__.__dict__["vlan"] = vlan
        return Nactag(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="allowUsermacOverride")
    def allow_usermac_override(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        Can be set to true to allow the override by usermac result
        """
        return pulumi.get(self, "allow_usermac_override")

    @property
    @pulumi.getter(name="egressVlanNames")
    def egress_vlan_names(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        If `type`==`egress_vlan_names`, list of egress vlans to return
        """
        return pulumi.get(self, "egress_vlan_names")

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> pulumi.Output[Optional[builtins.str]]:
        return pulumi.get(self, "gbp_tag")

    @property
    @pulumi.getter
    def match(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`,
        `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`,
        `usermac_label`
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="matchAll")
    def match_all(self) -> pulumi.Output[Optional[builtins.bool]]:
        """
        This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
        match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
        set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        """
        return pulumi.get(self, "match_all")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Output[builtins.str]:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="radiusAttrs")
    def radius_attrs(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". It is
        the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
        that it is allowed to have more than one radius_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_attrs")

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        If `type`==`radius_group`
        """
        return pulumi.get(self, "radius_group")

    @property
    @pulumi.getter(name="radiusVendorAttrs")
    def radius_vendor_attrs(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
        "radius_vendor_attrs". It is the responsibility of the user to provide a syntactically correct string, otherwise it may
        not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_vendor_attrs")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> pulumi.Output[Optional[builtins.int]]:
        """
        If `type`==`session_timeout, in seconds
        """
        return pulumi.get(self, "session_timeout")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[builtins.str]:
        """
        enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
        `username_attr`, `vlan`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="usernameAttr")
    def username_attr(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        enum: `automatic`, `cn`, `dns`, `email`, `upn`
        """
        return pulumi.get(self, "username_attr")

    @property
    @pulumi.getter
    def values(self) -> pulumi.Output[Optional[Sequence[builtins.str]]]:
        """
        If `type`==`match`
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def vlan(self) -> pulumi.Output[Optional[builtins.str]]:
        """
        If `type`==`vlan`
        """
        return pulumi.get(self, "vlan")

