# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ServiceArgs', 'Service']

@pulumi.input_type
class ServiceArgs:
    def __init__(__self__, *,
                 org_id: pulumi.Input[str],
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_subcategories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 failover_policy: Optional[pulumi.Input[str]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_jitter: Optional[pulumi.Input[str]] = None,
                 max_latency: Optional[pulumi.Input[str]] = None,
                 max_loss: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 sle_enabled: Optional[pulumi.Input[bool]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]]] = None,
                 ssr_relaxed_tcp_state_enforcement: Optional[pulumi.Input[bool]] = None,
                 traffic_class: Optional[pulumi.Input[str]] = None,
                 traffic_type: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a Service resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_categories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_subcategories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
               /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        :param pulumi.Input[str] failover_policy: enum: `non_revertable`, `none`, `revertable`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: if `type`==`custom`, web filtering
        :param pulumi.Input[bool] sle_enabled: whether to enable measure SLE
        :param pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]] specs: when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        :param pulumi.Input[str] traffic_class: when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        :param pulumi.Input[str] traffic_type: values from `/api/v1/consts/traffic_types`
        :param pulumi.Input[str] type: enum: `app_categories`, `apps`, `custom`, `urls`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] urls: when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        pulumi.set(__self__, "org_id", org_id)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if app_categories is not None:
            pulumi.set(__self__, "app_categories", app_categories)
        if app_subcategories is not None:
            pulumi.set(__self__, "app_subcategories", app_subcategories)
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if failover_policy is not None:
            pulumi.set(__self__, "failover_policy", failover_policy)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sle_enabled is not None:
            pulumi.set(__self__, "sle_enabled", sle_enabled)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if ssr_relaxed_tcp_state_enforcement is not None:
            pulumi.set(__self__, "ssr_relaxed_tcp_state_enforcement", ssr_relaxed_tcp_state_enforcement)
        if traffic_class is not None:
            pulumi.set(__self__, "traffic_class", traffic_class)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="appCategories")
    def app_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        """
        return pulumi.get(self, "app_categories")

    @app_categories.setter
    def app_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_categories", value)

    @property
    @pulumi.getter(name="appSubcategories")
    def app_subcategories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        """
        return pulumi.get(self, "app_subcategories")

    @app_subcategories.setter
    def app_subcategories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_subcategories", value)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
        /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="failoverPolicy")
    def failover_policy(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `non_revertable`, `none`, `revertable`
        """
        return pulumi.get(self, "failover_policy")

    @failover_policy.setter
    def failover_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failover_policy", value)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`custom`, web filtering
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_jitter")

    @max_jitter.setter
    def max_jitter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_jitter", value)

    @property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_latency", value)

    @property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_loss")

    @max_loss.setter
    def max_loss(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_loss", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sleEnabled")
    def sle_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable measure SLE
        """
        return pulumi.get(self, "sle_enabled")

    @sle_enabled.setter
    def sle_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sle_enabled", value)

    @property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]]]:
        """
        when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]]]):
        pulumi.set(self, "specs", value)

    @property
    @pulumi.getter(name="ssrRelaxedTcpStateEnforcement")
    def ssr_relaxed_tcp_state_enforcement(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ssr_relaxed_tcp_state_enforcement")

    @ssr_relaxed_tcp_state_enforcement.setter
    def ssr_relaxed_tcp_state_enforcement(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssr_relaxed_tcp_state_enforcement", value)

    @property
    @pulumi.getter(name="trafficClass")
    def traffic_class(self) -> Optional[pulumi.Input[str]]:
        """
        when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        """
        return pulumi.get(self, "traffic_class")

    @traffic_class.setter
    def traffic_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "traffic_class", value)

    @property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[pulumi.Input[str]]:
        """
        values from `/api/v1/consts/traffic_types`
        """
        return pulumi.get(self, "traffic_type")

    @traffic_type.setter
    def traffic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "traffic_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `app_categories`, `apps`, `custom`, `urls`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "urls", value)


@pulumi.input_type
class _ServiceState:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_subcategories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 failover_policy: Optional[pulumi.Input[str]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_jitter: Optional[pulumi.Input[str]] = None,
                 max_latency: Optional[pulumi.Input[str]] = None,
                 max_loss: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 sle_enabled: Optional[pulumi.Input[bool]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]]] = None,
                 ssr_relaxed_tcp_state_enforcement: Optional[pulumi.Input[bool]] = None,
                 traffic_class: Optional[pulumi.Input[str]] = None,
                 traffic_type: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Input properties used for looking up and filtering Service resources.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_categories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_subcategories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
               /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        :param pulumi.Input[str] failover_policy: enum: `non_revertable`, `none`, `revertable`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: if `type`==`custom`, web filtering
        :param pulumi.Input[bool] sle_enabled: whether to enable measure SLE
        :param pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]] specs: when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        :param pulumi.Input[str] traffic_class: when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        :param pulumi.Input[str] traffic_type: values from `/api/v1/consts/traffic_types`
        :param pulumi.Input[str] type: enum: `app_categories`, `apps`, `custom`, `urls`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] urls: when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if app_categories is not None:
            pulumi.set(__self__, "app_categories", app_categories)
        if app_subcategories is not None:
            pulumi.set(__self__, "app_subcategories", app_subcategories)
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if failover_policy is not None:
            pulumi.set(__self__, "failover_policy", failover_policy)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if sle_enabled is not None:
            pulumi.set(__self__, "sle_enabled", sle_enabled)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if ssr_relaxed_tcp_state_enforcement is not None:
            pulumi.set(__self__, "ssr_relaxed_tcp_state_enforcement", ssr_relaxed_tcp_state_enforcement)
        if traffic_class is not None:
            pulumi.set(__self__, "traffic_class", traffic_class)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="appCategories")
    def app_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        """
        return pulumi.get(self, "app_categories")

    @app_categories.setter
    def app_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_categories", value)

    @property
    @pulumi.getter(name="appSubcategories")
    def app_subcategories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        """
        return pulumi.get(self, "app_subcategories")

    @app_subcategories.setter
    def app_subcategories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_subcategories", value)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
        /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="failoverPolicy")
    def failover_policy(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `non_revertable`, `none`, `revertable`
        """
        return pulumi.get(self, "failover_policy")

    @failover_policy.setter
    def failover_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failover_policy", value)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`custom`, web filtering
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_jitter")

    @max_jitter.setter
    def max_jitter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_jitter", value)

    @property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_latency", value)

    @property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_loss")

    @max_loss.setter
    def max_loss(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_loss", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter(name="sleEnabled")
    def sle_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable measure SLE
        """
        return pulumi.get(self, "sle_enabled")

    @sle_enabled.setter
    def sle_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sle_enabled", value)

    @property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]]]:
        """
        when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceSpecArgs']]]]):
        pulumi.set(self, "specs", value)

    @property
    @pulumi.getter(name="ssrRelaxedTcpStateEnforcement")
    def ssr_relaxed_tcp_state_enforcement(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ssr_relaxed_tcp_state_enforcement")

    @ssr_relaxed_tcp_state_enforcement.setter
    def ssr_relaxed_tcp_state_enforcement(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssr_relaxed_tcp_state_enforcement", value)

    @property
    @pulumi.getter(name="trafficClass")
    def traffic_class(self) -> Optional[pulumi.Input[str]]:
        """
        when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        """
        return pulumi.get(self, "traffic_class")

    @traffic_class.setter
    def traffic_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "traffic_class", value)

    @property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[pulumi.Input[str]]:
        """
        values from `/api/v1/consts/traffic_types`
        """
        return pulumi.get(self, "traffic_type")

    @traffic_type.setter
    def traffic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "traffic_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `app_categories`, `apps`, `custom`, `urls`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "urls", value)


class Service(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_subcategories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 failover_policy: Optional[pulumi.Input[str]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_jitter: Optional[pulumi.Input[str]] = None,
                 max_latency: Optional[pulumi.Input[str]] = None,
                 max_loss: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 sle_enabled: Optional[pulumi.Input[bool]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServiceSpecArgs', 'ServiceSpecArgsDict']]]]] = None,
                 ssr_relaxed_tcp_state_enforcement: Optional[pulumi.Input[bool]] = None,
                 traffic_class: Optional[pulumi.Input[str]] = None,
                 traffic_type: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        This resource manages WAN Assurance Services (Applications).
        The Services are used in the `service_policies` from the Gateway configuration and Gateway templates, or can be used in the Org Service Policies (`org_servicepolicy` resource).

        ## Import

        Using `pulumi import`, import `mist_org_service` with:

        Org Service can be imported by specifying the org_id and the service_id

        ```sh
        $ pulumi import junipermist:org/service:Service service_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_categories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_subcategories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
               /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        :param pulumi.Input[str] failover_policy: enum: `non_revertable`, `none`, `revertable`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: if `type`==`custom`, web filtering
        :param pulumi.Input[bool] sle_enabled: whether to enable measure SLE
        :param pulumi.Input[Sequence[pulumi.Input[Union['ServiceSpecArgs', 'ServiceSpecArgsDict']]]] specs: when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        :param pulumi.Input[str] traffic_class: when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        :param pulumi.Input[str] traffic_type: values from `/api/v1/consts/traffic_types`
        :param pulumi.Input[str] type: enum: `app_categories`, `apps`, `custom`, `urls`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] urls: when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ServiceArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        This resource manages WAN Assurance Services (Applications).
        The Services are used in the `service_policies` from the Gateway configuration and Gateway templates, or can be used in the Org Service Policies (`org_servicepolicy` resource).

        ## Import

        Using `pulumi import`, import `mist_org_service` with:

        Org Service can be imported by specifying the org_id and the service_id

        ```sh
        $ pulumi import junipermist:org/service:Service service_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param ServiceArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ServiceArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_subcategories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 failover_policy: Optional[pulumi.Input[str]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_jitter: Optional[pulumi.Input[str]] = None,
                 max_latency: Optional[pulumi.Input[str]] = None,
                 max_loss: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 sle_enabled: Optional[pulumi.Input[bool]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServiceSpecArgs', 'ServiceSpecArgsDict']]]]] = None,
                 ssr_relaxed_tcp_state_enforcement: Optional[pulumi.Input[bool]] = None,
                 traffic_class: Optional[pulumi.Input[str]] = None,
                 traffic_type: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ServiceArgs.__new__(ServiceArgs)

            __props__.__dict__["addresses"] = addresses
            __props__.__dict__["app_categories"] = app_categories
            __props__.__dict__["app_subcategories"] = app_subcategories
            __props__.__dict__["apps"] = apps
            __props__.__dict__["description"] = description
            __props__.__dict__["dscp"] = dscp
            __props__.__dict__["failover_policy"] = failover_policy
            __props__.__dict__["hostnames"] = hostnames
            __props__.__dict__["max_jitter"] = max_jitter
            __props__.__dict__["max_latency"] = max_latency
            __props__.__dict__["max_loss"] = max_loss
            __props__.__dict__["name"] = name
            if org_id is None and not opts.urn:
                raise TypeError("Missing required property 'org_id'")
            __props__.__dict__["org_id"] = org_id
            __props__.__dict__["sle_enabled"] = sle_enabled
            __props__.__dict__["specs"] = specs
            __props__.__dict__["ssr_relaxed_tcp_state_enforcement"] = ssr_relaxed_tcp_state_enforcement
            __props__.__dict__["traffic_class"] = traffic_class
            __props__.__dict__["traffic_type"] = traffic_type
            __props__.__dict__["type"] = type
            __props__.__dict__["urls"] = urls
        super(Service, __self__).__init__(
            'junipermist:org/service:Service',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            app_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            app_subcategories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            description: Optional[pulumi.Input[str]] = None,
            dscp: Optional[pulumi.Input[str]] = None,
            failover_policy: Optional[pulumi.Input[str]] = None,
            hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            max_jitter: Optional[pulumi.Input[str]] = None,
            max_latency: Optional[pulumi.Input[str]] = None,
            max_loss: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            org_id: Optional[pulumi.Input[str]] = None,
            sle_enabled: Optional[pulumi.Input[bool]] = None,
            specs: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ServiceSpecArgs', 'ServiceSpecArgsDict']]]]] = None,
            ssr_relaxed_tcp_state_enforcement: Optional[pulumi.Input[bool]] = None,
            traffic_class: Optional[pulumi.Input[str]] = None,
            traffic_type: Optional[pulumi.Input[str]] = None,
            type: Optional[pulumi.Input[str]] = None,
            urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None) -> 'Service':
        """
        Get an existing Service resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_categories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_subcategories: when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
               /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        :param pulumi.Input[str] failover_policy: enum: `non_revertable`, `none`, `revertable`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: if `type`==`custom`, web filtering
        :param pulumi.Input[bool] sle_enabled: whether to enable measure SLE
        :param pulumi.Input[Sequence[pulumi.Input[Union['ServiceSpecArgs', 'ServiceSpecArgsDict']]]] specs: when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        :param pulumi.Input[str] traffic_class: when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        :param pulumi.Input[str] traffic_type: values from `/api/v1/consts/traffic_types`
        :param pulumi.Input[str] type: enum: `app_categories`, `apps`, `custom`, `urls`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] urls: when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ServiceState.__new__(_ServiceState)

        __props__.__dict__["addresses"] = addresses
        __props__.__dict__["app_categories"] = app_categories
        __props__.__dict__["app_subcategories"] = app_subcategories
        __props__.__dict__["apps"] = apps
        __props__.__dict__["description"] = description
        __props__.__dict__["dscp"] = dscp
        __props__.__dict__["failover_policy"] = failover_policy
        __props__.__dict__["hostnames"] = hostnames
        __props__.__dict__["max_jitter"] = max_jitter
        __props__.__dict__["max_latency"] = max_latency
        __props__.__dict__["max_loss"] = max_loss
        __props__.__dict__["name"] = name
        __props__.__dict__["org_id"] = org_id
        __props__.__dict__["sle_enabled"] = sle_enabled
        __props__.__dict__["specs"] = specs
        __props__.__dict__["ssr_relaxed_tcp_state_enforcement"] = ssr_relaxed_tcp_state_enforcement
        __props__.__dict__["traffic_class"] = traffic_class
        __props__.__dict__["traffic_type"] = traffic_type
        __props__.__dict__["type"] = type
        __props__.__dict__["urls"] = urls
        return Service(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Output[Sequence[str]]:
        """
        if `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="appCategories")
    def app_categories(self) -> pulumi.Output[Sequence[str]]:
        """
        when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_categories
        """
        return pulumi.get(self, "app_categories")

    @property
    @pulumi.getter(name="appSubcategories")
    def app_subcategories(self) -> pulumi.Output[Sequence[str]]:
        """
        when `type`==`app_categories`, list of application categories are available through /api/v1/const/app_subcategories
        """
        return pulumi.get(self, "app_subcategories")

    @property
    @pulumi.getter
    def apps(self) -> pulumi.Output[Sequence[str]]:
        """
        when `type`==`apps`, list of applications are available through: * /api/v1/const/applications *
        /api/v1/const/gateway_applications * /insight/top_app_by-bytes?wired=true
        """
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def dscp(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "dscp")

    @property
    @pulumi.getter(name="failoverPolicy")
    def failover_policy(self) -> pulumi.Output[str]:
        """
        enum: `non_revertable`, `none`, `revertable`
        """
        return pulumi.get(self, "failover_policy")

    @property
    @pulumi.getter
    def hostnames(self) -> pulumi.Output[Sequence[str]]:
        """
        if `type`==`custom`, web filtering
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "max_jitter")

    @property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "max_latency")

    @property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "max_loss")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="sleEnabled")
    def sle_enabled(self) -> pulumi.Output[bool]:
        """
        whether to enable measure SLE
        """
        return pulumi.get(self, "sle_enabled")

    @property
    @pulumi.getter
    def specs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceSpec']]]:
        """
        when `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        """
        return pulumi.get(self, "specs")

    @property
    @pulumi.getter(name="ssrRelaxedTcpStateEnforcement")
    def ssr_relaxed_tcp_state_enforcement(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "ssr_relaxed_tcp_state_enforcement")

    @property
    @pulumi.getter(name="trafficClass")
    def traffic_class(self) -> pulumi.Output[str]:
        """
        when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        """
        return pulumi.get(self, "traffic_class")

    @property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> pulumi.Output[str]:
        """
        values from `/api/v1/consts/traffic_types`
        """
        return pulumi.get(self, "traffic_type")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        enum: `app_categories`, `apps`, `custom`, `urls`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urls(self) -> pulumi.Output[Sequence[str]]:
        """
        when `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        return pulumi.get(self, "urls")

