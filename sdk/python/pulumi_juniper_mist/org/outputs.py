# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AlarmtemplateDelivery',
    'AlarmtemplateRules',
    'AlarmtemplateRulesDelivery',
    'ApitokenPrivilege',
    'DeviceprofileApAeroscout',
    'DeviceprofileApAirista',
    'DeviceprofileApBleConfig',
    'DeviceprofileApEslConfig',
    'DeviceprofileApIpConfig',
    'DeviceprofileApLacpConfig',
    'DeviceprofileApLed',
    'DeviceprofileApMesh',
    'DeviceprofileApPortConfig',
    'DeviceprofileApPortConfigDynamicVlan',
    'DeviceprofileApPortConfigMistNac',
    'DeviceprofileApPortConfigRadiusConfig',
    'DeviceprofileApPortConfigRadiusConfigAcctServer',
    'DeviceprofileApPortConfigRadiusConfigAuthServer',
    'DeviceprofileApPortConfigRadsec',
    'DeviceprofileApPortConfigRadsecServer',
    'DeviceprofileApPwrConfig',
    'DeviceprofileApRadioConfig',
    'DeviceprofileApRadioConfigBand24',
    'DeviceprofileApRadioConfigBand5',
    'DeviceprofileApRadioConfigBand5On24Radio',
    'DeviceprofileApRadioConfigBand6',
    'DeviceprofileApUplinkPortConfig',
    'DeviceprofileApUsbConfig',
    'DeviceprofileGatewayBgpConfig',
    'DeviceprofileGatewayBgpConfigNeighbors',
    'DeviceprofileGatewayDhcpdConfig',
    'DeviceprofileGatewayDhcpdConfigConfig',
    'DeviceprofileGatewayDhcpdConfigConfigFixedBindings',
    'DeviceprofileGatewayDhcpdConfigConfigOptions',
    'DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulated',
    'DeviceprofileGatewayExtraRoutes6',
    'DeviceprofileGatewayExtraRoutes',
    'DeviceprofileGatewayIdpProfiles',
    'DeviceprofileGatewayIdpProfilesOverwrite',
    'DeviceprofileGatewayIdpProfilesOverwriteMatching',
    'DeviceprofileGatewayIpConfigs',
    'DeviceprofileGatewayNetwork',
    'DeviceprofileGatewayNetworkInternalAccess',
    'DeviceprofileGatewayNetworkInternetAccess',
    'DeviceprofileGatewayNetworkInternetAccessDestinationNat',
    'DeviceprofileGatewayNetworkInternetAccessStaticNat',
    'DeviceprofileGatewayNetworkMulticast',
    'DeviceprofileGatewayNetworkMulticastGroups',
    'DeviceprofileGatewayNetworkTenants',
    'DeviceprofileGatewayNetworkVpnAccess',
    'DeviceprofileGatewayNetworkVpnAccessDestinationNat',
    'DeviceprofileGatewayNetworkVpnAccessSourceNat',
    'DeviceprofileGatewayNetworkVpnAccessStaticNat',
    'DeviceprofileGatewayOobIpConfig',
    'DeviceprofileGatewayOobIpConfigNode1',
    'DeviceprofileGatewayPathPreferences',
    'DeviceprofileGatewayPathPreferencesPath',
    'DeviceprofileGatewayPortConfig',
    'DeviceprofileGatewayPortConfigIpConfig',
    'DeviceprofileGatewayPortConfigTrafficShaping',
    'DeviceprofileGatewayPortConfigVpnPaths',
    'DeviceprofileGatewayPortConfigVpnPathsTrafficShaping',
    'DeviceprofileGatewayPortConfigWanExtraRoutes6',
    'DeviceprofileGatewayPortConfigWanExtraRoutes',
    'DeviceprofileGatewayPortConfigWanProbeOverride',
    'DeviceprofileGatewayPortConfigWanSourceNat',
    'DeviceprofileGatewayRoutingPolicies',
    'DeviceprofileGatewayRoutingPoliciesTerm',
    'DeviceprofileGatewayRoutingPoliciesTermActions',
    'DeviceprofileGatewayRoutingPoliciesTermMatching',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists',
    'DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla',
    'DeviceprofileGatewayServicePolicy',
    'DeviceprofileGatewayServicePolicyAntivirus',
    'DeviceprofileGatewayServicePolicyAppqoe',
    'DeviceprofileGatewayServicePolicyEwf',
    'DeviceprofileGatewayServicePolicyIdp',
    'DeviceprofileGatewayServicePolicySslProxy',
    'DeviceprofileGatewayTunnelConfigs',
    'DeviceprofileGatewayTunnelConfigsAutoProvision',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary',
    'DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary',
    'DeviceprofileGatewayTunnelConfigsIkeProposal',
    'DeviceprofileGatewayTunnelConfigsIpsecProposal',
    'DeviceprofileGatewayTunnelConfigsPrimary',
    'DeviceprofileGatewayTunnelConfigsProbe',
    'DeviceprofileGatewayTunnelConfigsSecondary',
    'DeviceprofileGatewayTunnelProviderOptions',
    'DeviceprofileGatewayTunnelProviderOptionsJse',
    'DeviceprofileGatewayTunnelProviderOptionsPrisma',
    'DeviceprofileGatewayTunnelProviderOptionsZscaler',
    'DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation',
    'DeviceprofileGatewayVrfConfig',
    'DeviceprofileGatewayVrfInstances',
    'EvpnTopologyEvpnOptions',
    'EvpnTopologyEvpnOptionsOverlay',
    'EvpnTopologyEvpnOptionsUnderlay',
    'EvpnTopologyEvpnOptionsVsInstances',
    'EvpnTopologySwitches',
    'GatewaytemplateBgpConfig',
    'GatewaytemplateBgpConfigNeighbors',
    'GatewaytemplateDhcpdConfig',
    'GatewaytemplateDhcpdConfigConfig',
    'GatewaytemplateDhcpdConfigConfigFixedBindings',
    'GatewaytemplateDhcpdConfigConfigOptions',
    'GatewaytemplateDhcpdConfigConfigVendorEncapsulated',
    'GatewaytemplateExtraRoutes6',
    'GatewaytemplateExtraRoutes',
    'GatewaytemplateIdpProfiles',
    'GatewaytemplateIdpProfilesOverwrite',
    'GatewaytemplateIdpProfilesOverwriteMatching',
    'GatewaytemplateIpConfigs',
    'GatewaytemplateNetwork',
    'GatewaytemplateNetworkInternalAccess',
    'GatewaytemplateNetworkInternetAccess',
    'GatewaytemplateNetworkInternetAccessDestinationNat',
    'GatewaytemplateNetworkInternetAccessStaticNat',
    'GatewaytemplateNetworkMulticast',
    'GatewaytemplateNetworkMulticastGroups',
    'GatewaytemplateNetworkTenants',
    'GatewaytemplateNetworkVpnAccess',
    'GatewaytemplateNetworkVpnAccessDestinationNat',
    'GatewaytemplateNetworkVpnAccessSourceNat',
    'GatewaytemplateNetworkVpnAccessStaticNat',
    'GatewaytemplateOobIpConfig',
    'GatewaytemplateOobIpConfigNode1',
    'GatewaytemplatePathPreferences',
    'GatewaytemplatePathPreferencesPath',
    'GatewaytemplatePortConfig',
    'GatewaytemplatePortConfigIpConfig',
    'GatewaytemplatePortConfigTrafficShaping',
    'GatewaytemplatePortConfigVpnPaths',
    'GatewaytemplatePortConfigVpnPathsTrafficShaping',
    'GatewaytemplatePortConfigWanExtraRoutes6',
    'GatewaytemplatePortConfigWanExtraRoutes',
    'GatewaytemplatePortConfigWanProbeOverride',
    'GatewaytemplatePortConfigWanSourceNat',
    'GatewaytemplateRoutingPolicies',
    'GatewaytemplateRoutingPoliciesTerm',
    'GatewaytemplateRoutingPoliciesTermActions',
    'GatewaytemplateRoutingPoliciesTermMatching',
    'GatewaytemplateRoutingPoliciesTermMatchingRouteExists',
    'GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla',
    'GatewaytemplateServicePolicy',
    'GatewaytemplateServicePolicyAntivirus',
    'GatewaytemplateServicePolicyAppqoe',
    'GatewaytemplateServicePolicyEwf',
    'GatewaytemplateServicePolicyIdp',
    'GatewaytemplateServicePolicySslProxy',
    'GatewaytemplateTunnelConfigs',
    'GatewaytemplateTunnelConfigsAutoProvision',
    'GatewaytemplateTunnelConfigsAutoProvisionLatlng',
    'GatewaytemplateTunnelConfigsAutoProvisionPrimary',
    'GatewaytemplateTunnelConfigsAutoProvisionSecondary',
    'GatewaytemplateTunnelConfigsIkeProposal',
    'GatewaytemplateTunnelConfigsIpsecProposal',
    'GatewaytemplateTunnelConfigsPrimary',
    'GatewaytemplateTunnelConfigsProbe',
    'GatewaytemplateTunnelConfigsSecondary',
    'GatewaytemplateTunnelProviderOptions',
    'GatewaytemplateTunnelProviderOptionsJse',
    'GatewaytemplateTunnelProviderOptionsPrisma',
    'GatewaytemplateTunnelProviderOptionsZscaler',
    'GatewaytemplateTunnelProviderOptionsZscalerSubLocation',
    'GatewaytemplateVrfConfig',
    'GatewaytemplateVrfInstances',
    'IdpprofileOverwrite',
    'IdpprofileOverwriteMatching',
    'InventoryInventory',
    'NacruleMatching',
    'NacruleNotMatching',
    'NetworkInternalAccess',
    'NetworkInternetAccess',
    'NetworkInternetAccessDestinationNat',
    'NetworkInternetAccessStaticNat',
    'NetworkMulticast',
    'NetworkMulticastGroups',
    'NetworkTenants',
    'NetworkVpnAccess',
    'NetworkVpnAccessDestinationNat',
    'NetworkVpnAccessSourceNat',
    'NetworkVpnAccessStaticNat',
    'NetworktemplateAclPolicy',
    'NetworktemplateAclPolicyAction',
    'NetworktemplateAclTags',
    'NetworktemplateAclTagsSpec',
    'NetworktemplateDhcpSnooping',
    'NetworktemplateExtraRoutes6',
    'NetworktemplateExtraRoutes6NextQualified',
    'NetworktemplateExtraRoutes',
    'NetworktemplateExtraRoutesNextQualified',
    'NetworktemplateMistNac',
    'NetworktemplateNetworks',
    'NetworktemplateOspfAreas',
    'NetworktemplateOspfAreasNetworks',
    'NetworktemplatePortMirroring',
    'NetworktemplatePortUsages',
    'NetworktemplatePortUsagesRule',
    'NetworktemplatePortUsagesStormControl',
    'NetworktemplateRadiusConfig',
    'NetworktemplateRadiusConfigAcctServer',
    'NetworktemplateRadiusConfigAuthServer',
    'NetworktemplateRemoteSyslog',
    'NetworktemplateRemoteSyslogArchive',
    'NetworktemplateRemoteSyslogConsole',
    'NetworktemplateRemoteSyslogConsoleContent',
    'NetworktemplateRemoteSyslogFile',
    'NetworktemplateRemoteSyslogFileArchive',
    'NetworktemplateRemoteSyslogFileContent',
    'NetworktemplateRemoteSyslogServer',
    'NetworktemplateRemoteSyslogServerContent',
    'NetworktemplateRemoteSyslogUser',
    'NetworktemplateRemoteSyslogUserContent',
    'NetworktemplateSnmpConfig',
    'NetworktemplateSnmpConfigClientList',
    'NetworktemplateSnmpConfigTrapGroup',
    'NetworktemplateSnmpConfigV2cConfig',
    'NetworktemplateSnmpConfigV3Config',
    'NetworktemplateSnmpConfigV3ConfigNotify',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilter',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterContent',
    'NetworktemplateSnmpConfigV3ConfigTargetAddress',
    'NetworktemplateSnmpConfigV3ConfigTargetParameter',
    'NetworktemplateSnmpConfigV3ConfigUsm',
    'NetworktemplateSnmpConfigV3ConfigUsmUser',
    'NetworktemplateSnmpConfigV3ConfigVacm',
    'NetworktemplateSnmpConfigV3ConfigVacmAccess',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent',
    'NetworktemplateSnmpConfigView',
    'NetworktemplateSwitchMatching',
    'NetworktemplateSwitchMatchingRule',
    'NetworktemplateSwitchMatchingRuleIpConfig',
    'NetworktemplateSwitchMatchingRuleOobIpConfig',
    'NetworktemplateSwitchMatchingRulePortConfig',
    'NetworktemplateSwitchMatchingRulePortMirroring',
    'NetworktemplateSwitchMgmt',
    'NetworktemplateSwitchMgmtLocalAccounts',
    'NetworktemplateSwitchMgmtProtectRe',
    'NetworktemplateSwitchMgmtProtectReCustom',
    'NetworktemplateSwitchMgmtTacacs',
    'NetworktemplateSwitchMgmtTacacsAcctServer',
    'NetworktemplateSwitchMgmtTacacsTacplusServer',
    'NetworktemplateVrfConfig',
    'NetworktemplateVrfInstances',
    'NetworktemplateVrfInstancesExtraRoutes6',
    'NetworktemplateVrfInstancesExtraRoutes',
    'RftemplateBand24',
    'RftemplateBand5',
    'RftemplateBand5On24Radio',
    'RftemplateBand6',
    'RftemplateModelSpecific',
    'RftemplateModelSpecificBand24',
    'RftemplateModelSpecificBand5',
    'RftemplateModelSpecificBand5On24Radio',
    'RftemplateModelSpecificBand6',
    'ServiceSpec',
    'ServicepolicyAamw',
    'ServicepolicyAntivirus',
    'ServicepolicyAppqoe',
    'ServicepolicyEwf',
    'ServicepolicyIdp',
    'ServicepolicySslProxy',
    'SettingApiPolicy',
    'SettingCelona',
    'SettingCloudshark',
    'SettingCradlepoint',
    'SettingDeviceCert',
    'SettingInstaller',
    'SettingJcloud',
    'SettingJcloudRa',
    'SettingJuniper',
    'SettingJuniperAccount',
    'SettingJunosShellAccess',
    'SettingMarvis',
    'SettingMarvisAutoOperations',
    'SettingMgmt',
    'SettingMistNac',
    'SettingMistNacIdp',
    'SettingMistNacServerCert',
    'SettingMxedgeMgmt',
    'SettingOpticPortConfig',
    'SettingPasswordPolicy',
    'SettingPcap',
    'SettingSecurity',
    'SettingSsr',
    'SettingSwitch',
    'SettingSwitchAutoUpgrade',
    'SettingSwitchMgmt',
    'SettingSyntheticTest',
    'SettingSyntheticTestCustomProbes',
    'SettingSyntheticTestLanNetwork',
    'SettingSyntheticTestVlan',
    'SettingSyntheticTestWanSpeedtest',
    'SettingVpnOptions',
    'SettingWanPma',
    'SettingWiredPma',
    'SettingWirelessPma',
    'SsoRolePrivilege',
    'VpnPathSelection',
    'VpnPaths',
    'VpnPathsPeerPaths',
    'VpnPathsTrafficShaping',
    'WlanAcctServer',
    'WlanAirwatch',
    'WlanAppLimit',
    'WlanAppQos',
    'WlanAppQosApps',
    'WlanAppQosOther',
    'WlanAuth',
    'WlanAuthServer',
    'WlanBonjour',
    'WlanBonjourServices',
    'WlanCiscoCwa',
    'WlanCoaServer',
    'WlanDnsServerRewrite',
    'WlanDynamicPsk',
    'WlanDynamicVlan',
    'WlanHotspot20',
    'WlanInjectDhcpOption82',
    'WlanMistNac',
    'WlanPortal',
    'WlanPortalTemplatePortalTemplate',
    'WlanPortalTemplatePortalTemplateLocales',
    'WlanQos',
    'WlanRadsec',
    'WlanRadsecServer',
    'WlanRateset',
    'WlanSchedule',
    'WlanScheduleHours',
    'WlantemplateApplies',
    'WlantemplateExceptions',
    'WxtagSpec',
    'GetAlarmtemplatesOrgAlarmtemplateResult',
    'GetAlarmtemplatesOrgAlarmtemplateDeliveryResult',
    'GetAlarmtemplatesOrgAlarmtemplateRulesResult',
    'GetAlarmtemplatesOrgAlarmtemplateRulesDeliveryResult',
    'GetAvprofilesOrgAvprofileResult',
    'GetDeviceprofilesApDeviceprofileResult',
    'GetDeviceprofilesGatewayDeviceprofileResult',
    'GetEvpnTopologiesOrgEvpnTopologyResult',
    'GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsResult',
    'GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsOverlayResult',
    'GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsUnderlayResult',
    'GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsVsInstancesResult',
    'GetGatewaytemplatesOrgGatewaytemplateResult',
    'GetIdpprofilesOrgIdpprofileResult',
    'GetIdpprofilesOrgIdpprofileOverwriteResult',
    'GetIdpprofilesOrgIdpprofileOverwriteMatchingResult',
    'GetInventoryOrgInventoryResult',
    'GetNacEndpointsOrgUsermacResult',
    'GetNacrulesOrgNacruleResult',
    'GetNactagsOrgNactagResult',
    'GetNetworksOrgNetworkResult',
    'GetNetworksOrgNetworkInternalAccessResult',
    'GetNetworksOrgNetworkInternetAccessResult',
    'GetNetworksOrgNetworkInternetAccessDestinationNatResult',
    'GetNetworksOrgNetworkInternetAccessStaticNatResult',
    'GetNetworksOrgNetworkMulticastResult',
    'GetNetworksOrgNetworkMulticastGroupsResult',
    'GetNetworksOrgNetworkTenantsResult',
    'GetNetworksOrgNetworkVpnAccessResult',
    'GetNetworksOrgNetworkVpnAccessDestinationNatResult',
    'GetNetworksOrgNetworkVpnAccessSourceNatResult',
    'GetNetworksOrgNetworkVpnAccessStaticNatResult',
    'GetNetworktemplatesOrgNetworktemplateResult',
    'GetPsksOrgPskResult',
    'GetRftemplatesOrgRftemplateResult',
    'GetServicepoliciesOrgServicepolicyResult',
    'GetServicepoliciesOrgServicepolicyAamwResult',
    'GetServicepoliciesOrgServicepolicyAntivirusResult',
    'GetServicepoliciesOrgServicepolicyAppqoeResult',
    'GetServicepoliciesOrgServicepolicyEwfResult',
    'GetServicepoliciesOrgServicepolicyIdpResult',
    'GetServicepoliciesOrgServicepolicySslProxyResult',
    'GetServicesOrgServiceResult',
    'GetServicesOrgServiceSpecResult',
    'GetSitegroupsOrgSitegroupResult',
    'GetSsoRolesOrgSsoRoleResult',
    'GetSsoRolesOrgSsoRolePrivilegeResult',
    'GetVpnsOrgVpnResult',
    'GetVpnsOrgVpnPathSelectionResult',
    'GetVpnsOrgVpnPathsResult',
    'GetVpnsOrgVpnPathsPeerPathsResult',
    'GetVpnsOrgVpnPathsTrafficShapingResult',
    'GetWebhooksOrgWebhookResult',
    'GetWlansOrgWlanResult',
    'GetWlansOrgWlanAcctServerResult',
    'GetWlansOrgWlanAirwatchResult',
    'GetWlansOrgWlanAppLimitResult',
    'GetWlansOrgWlanAppQosResult',
    'GetWlansOrgWlanAppQosAppsResult',
    'GetWlansOrgWlanAppQosOtherResult',
    'GetWlansOrgWlanAuthResult',
    'GetWlansOrgWlanAuthServerResult',
    'GetWlansOrgWlanBonjourResult',
    'GetWlansOrgWlanBonjourServicesResult',
    'GetWlansOrgWlanCiscoCwaResult',
    'GetWlansOrgWlanCoaServerResult',
    'GetWlansOrgWlanDnsServerRewriteResult',
    'GetWlansOrgWlanDynamicPskResult',
    'GetWlansOrgWlanDynamicVlanResult',
    'GetWlansOrgWlanHotspot20Result',
    'GetWlansOrgWlanInjectDhcpOption82Result',
    'GetWlansOrgWlanMistNacResult',
    'GetWlansOrgWlanPortalResult',
    'GetWlansOrgWlanQosResult',
    'GetWlansOrgWlanRadsecResult',
    'GetWlansOrgWlanRadsecServerResult',
    'GetWlansOrgWlanRatesetResult',
    'GetWlansOrgWlanScheduleResult',
    'GetWlansOrgWlanScheduleHoursResult',
    'GetWlantemplatesOrgWlantemplateResult',
    'GetWxtagsOrgWxtagResult',
    'GetWxtagsOrgWxtagSpecResult',
]

@pulumi.output_type
class AlarmtemplateDelivery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalEmails":
            suggest = "additional_emails"
        elif key == "toOrgAdmins":
            suggest = "to_org_admins"
        elif key == "toSiteAdmins":
            suggest = "to_site_admins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmtemplateDelivery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmtemplateDelivery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmtemplateDelivery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 additional_emails: Optional[Sequence[_builtins.str]] = None,
                 to_org_admins: Optional[_builtins.bool] = None,
                 to_site_admins: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable the alarm delivery via emails or not
        :param Sequence[_builtins.str] additional_emails: List of additional email string to deliver the alarms via emails
        :param _builtins.bool to_org_admins: Whether to deliver the alarms via emails to Org admins or not
        :param _builtins.bool to_site_admins: Whether to deliver the alarms via emails to Site admins or not
        """
        pulumi.set(__self__, "enabled", enabled)
        if additional_emails is not None:
            pulumi.set(__self__, "additional_emails", additional_emails)
        if to_org_admins is not None:
            pulumi.set(__self__, "to_org_admins", to_org_admins)
        if to_site_admins is not None:
            pulumi.set(__self__, "to_site_admins", to_site_admins)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the alarm delivery via emails or not
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="additionalEmails")
    def additional_emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of additional email string to deliver the alarms via emails
        """
        return pulumi.get(self, "additional_emails")

    @_builtins.property
    @pulumi.getter(name="toOrgAdmins")
    def to_org_admins(self) -> Optional[_builtins.bool]:
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        return pulumi.get(self, "to_org_admins")

    @_builtins.property
    @pulumi.getter(name="toSiteAdmins")
    def to_site_admins(self) -> Optional[_builtins.bool]:
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
        return pulumi.get(self, "to_site_admins")


@pulumi.output_type
class AlarmtemplateRules(dict):
    def __init__(__self__, *,
                 delivery: Optional['outputs.AlarmtemplateRulesDelivery'] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param 'AlarmtemplateRulesDeliveryArgs' delivery: Delivery object to configure the alarm delivery
        """
        if delivery is not None:
            pulumi.set(__self__, "delivery", delivery)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def delivery(self) -> Optional['outputs.AlarmtemplateRulesDelivery']:
        """
        Delivery object to configure the alarm delivery
        """
        return pulumi.get(self, "delivery")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AlarmtemplateRulesDelivery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalEmails":
            suggest = "additional_emails"
        elif key == "toOrgAdmins":
            suggest = "to_org_admins"
        elif key == "toSiteAdmins":
            suggest = "to_site_admins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmtemplateRulesDelivery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmtemplateRulesDelivery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmtemplateRulesDelivery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 additional_emails: Optional[Sequence[_builtins.str]] = None,
                 to_org_admins: Optional[_builtins.bool] = None,
                 to_site_admins: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable the alarm delivery via emails or not
        :param Sequence[_builtins.str] additional_emails: List of additional email string to deliver the alarms via emails
        :param _builtins.bool to_org_admins: Whether to deliver the alarms via emails to Org admins or not
        :param _builtins.bool to_site_admins: Whether to deliver the alarms via emails to Site admins or not
        """
        pulumi.set(__self__, "enabled", enabled)
        if additional_emails is not None:
            pulumi.set(__self__, "additional_emails", additional_emails)
        if to_org_admins is not None:
            pulumi.set(__self__, "to_org_admins", to_org_admins)
        if to_site_admins is not None:
            pulumi.set(__self__, "to_site_admins", to_site_admins)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the alarm delivery via emails or not
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="additionalEmails")
    def additional_emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of additional email string to deliver the alarms via emails
        """
        return pulumi.get(self, "additional_emails")

    @_builtins.property
    @pulumi.getter(name="toOrgAdmins")
    def to_org_admins(self) -> Optional[_builtins.bool]:
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        return pulumi.get(self, "to_org_admins")

    @_builtins.property
    @pulumi.getter(name="toSiteAdmins")
    def to_site_admins(self) -> Optional[_builtins.bool]:
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
        return pulumi.get(self, "to_site_admins")


@pulumi.output_type
class ApitokenPrivilege(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteId":
            suggest = "site_id"
        elif key == "sitegroupId":
            suggest = "sitegroup_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApitokenPrivilege. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApitokenPrivilege.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApitokenPrivilege.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: _builtins.str,
                 scope: _builtins.str,
                 site_id: Optional[_builtins.str] = None,
                 sitegroup_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str role: access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        :param _builtins.str scope: enum: `org`, `site`, `sitegroup`
        :param _builtins.str site_id: Required if `scope`==`site`
        :param _builtins.str sitegroup_id: Required if `scope`==`sitegroup`
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "scope", scope)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if sitegroup_id is not None:
            pulumi.set(__self__, "sitegroup_id", sitegroup_id)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        enum: `org`, `site`, `sitegroup`
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[_builtins.str]:
        """
        Required if `scope`==`site`
        """
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter(name="sitegroupId")
    def sitegroup_id(self) -> Optional[_builtins.str]:
        """
        Required if `scope`==`sitegroup`
        """
        return pulumi.get(self, "sitegroup_id")


@pulumi.output_type
class DeviceprofileApAeroscout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locateConnected":
            suggest = "locate_connected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApAeroscout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApAeroscout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApAeroscout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 locate_connected: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Whether to enable aeroscout config
        :param _builtins.str host: Required if enabled, aeroscout server host
        :param _builtins.bool locate_connected: Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if locate_connected is not None:
            pulumi.set(__self__, "locate_connected", locate_connected)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable aeroscout config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Required if enabled, aeroscout server host
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="locateConnected")
    def locate_connected(self) -> Optional[_builtins.bool]:
        """
        Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        return pulumi.get(self, "locate_connected")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class DeviceprofileApAirista(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Whether to enable Airista config
        :param _builtins.str host: Required if enabled, Airista server host
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Airista config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Required if enabled, Airista server host
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class DeviceprofileApBleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beaconEnabled":
            suggest = "beacon_enabled"
        elif key == "beaconRate":
            suggest = "beacon_rate"
        elif key == "beaconRateMode":
            suggest = "beacon_rate_mode"
        elif key == "beamDisableds":
            suggest = "beam_disableds"
        elif key == "customBlePacketEnabled":
            suggest = "custom_ble_packet_enabled"
        elif key == "customBlePacketFrame":
            suggest = "custom_ble_packet_frame"
        elif key == "customBlePacketFreqMsec":
            suggest = "custom_ble_packet_freq_msec"
        elif key == "eddystoneUidAdvPower":
            suggest = "eddystone_uid_adv_power"
        elif key == "eddystoneUidBeams":
            suggest = "eddystone_uid_beams"
        elif key == "eddystoneUidEnabled":
            suggest = "eddystone_uid_enabled"
        elif key == "eddystoneUidFreqMsec":
            suggest = "eddystone_uid_freq_msec"
        elif key == "eddystoneUidInstance":
            suggest = "eddystone_uid_instance"
        elif key == "eddystoneUidNamespace":
            suggest = "eddystone_uid_namespace"
        elif key == "eddystoneUrlAdvPower":
            suggest = "eddystone_url_adv_power"
        elif key == "eddystoneUrlBeams":
            suggest = "eddystone_url_beams"
        elif key == "eddystoneUrlEnabled":
            suggest = "eddystone_url_enabled"
        elif key == "eddystoneUrlFreqMsec":
            suggest = "eddystone_url_freq_msec"
        elif key == "eddystoneUrlUrl":
            suggest = "eddystone_url_url"
        elif key == "ibeaconAdvPower":
            suggest = "ibeacon_adv_power"
        elif key == "ibeaconBeams":
            suggest = "ibeacon_beams"
        elif key == "ibeaconEnabled":
            suggest = "ibeacon_enabled"
        elif key == "ibeaconFreqMsec":
            suggest = "ibeacon_freq_msec"
        elif key == "ibeaconMajor":
            suggest = "ibeacon_major"
        elif key == "ibeaconMinor":
            suggest = "ibeacon_minor"
        elif key == "ibeaconUuid":
            suggest = "ibeacon_uuid"
        elif key == "powerMode":
            suggest = "power_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApBleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApBleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApBleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 beacon_enabled: Optional[_builtins.bool] = None,
                 beacon_rate: Optional[_builtins.int] = None,
                 beacon_rate_mode: Optional[_builtins.str] = None,
                 beam_disableds: Optional[Sequence[_builtins.int]] = None,
                 custom_ble_packet_enabled: Optional[_builtins.bool] = None,
                 custom_ble_packet_frame: Optional[_builtins.str] = None,
                 custom_ble_packet_freq_msec: Optional[_builtins.int] = None,
                 eddystone_uid_adv_power: Optional[_builtins.int] = None,
                 eddystone_uid_beams: Optional[_builtins.str] = None,
                 eddystone_uid_enabled: Optional[_builtins.bool] = None,
                 eddystone_uid_freq_msec: Optional[_builtins.int] = None,
                 eddystone_uid_instance: Optional[_builtins.str] = None,
                 eddystone_uid_namespace: Optional[_builtins.str] = None,
                 eddystone_url_adv_power: Optional[_builtins.int] = None,
                 eddystone_url_beams: Optional[_builtins.str] = None,
                 eddystone_url_enabled: Optional[_builtins.bool] = None,
                 eddystone_url_freq_msec: Optional[_builtins.int] = None,
                 eddystone_url_url: Optional[_builtins.str] = None,
                 ibeacon_adv_power: Optional[_builtins.int] = None,
                 ibeacon_beams: Optional[_builtins.str] = None,
                 ibeacon_enabled: Optional[_builtins.bool] = None,
                 ibeacon_freq_msec: Optional[_builtins.int] = None,
                 ibeacon_major: Optional[_builtins.int] = None,
                 ibeacon_minor: Optional[_builtins.int] = None,
                 ibeacon_uuid: Optional[_builtins.str] = None,
                 power: Optional[_builtins.int] = None,
                 power_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.bool beacon_enabled: Whether Mist beacons is enabled
        :param _builtins.int beacon_rate: Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        :param _builtins.str beacon_rate_mode: enum: `custom`, `default`
        :param Sequence[_builtins.int] beam_disableds: List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        :param _builtins.bool custom_ble_packet_enabled: Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        :param _builtins.str custom_ble_packet_frame: The custom frame to be sent out in this beacon. The frame must be a hexstring
        :param _builtins.int custom_ble_packet_freq_msec: Frequency (msec) of data emitted by custom ble beacon
        :param _builtins.int eddystone_uid_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param _builtins.bool eddystone_uid_enabled: Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        :param _builtins.int eddystone_uid_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param _builtins.str eddystone_uid_instance: Eddystone-UID instance for the device
        :param _builtins.str eddystone_uid_namespace: Eddystone-UID namespace
        :param _builtins.int eddystone_url_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param _builtins.bool eddystone_url_enabled: Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        :param _builtins.int eddystone_url_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param _builtins.str eddystone_url_url: URL pointed by Eddystone-URL beacon
        :param _builtins.int ibeacon_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param _builtins.bool ibeacon_enabled: Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        :param _builtins.int ibeacon_freq_msec: Frequency (msec) of data emit for iBeacon
        :param _builtins.int ibeacon_major: Major number for iBeacon
        :param _builtins.int ibeacon_minor: Minor number for iBeacon
        :param _builtins.str ibeacon_uuid: Optional, if not specified, the same UUID as the beacon will be used
        :param _builtins.int power: Required if `power_mode`==`custom`; else use `power_mode` as default
        :param _builtins.str power_mode: enum: `custom`, `default`
        """
        if beacon_enabled is not None:
            pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        if beacon_rate is not None:
            pulumi.set(__self__, "beacon_rate", beacon_rate)
        if beacon_rate_mode is not None:
            pulumi.set(__self__, "beacon_rate_mode", beacon_rate_mode)
        if beam_disableds is not None:
            pulumi.set(__self__, "beam_disableds", beam_disableds)
        if custom_ble_packet_enabled is not None:
            pulumi.set(__self__, "custom_ble_packet_enabled", custom_ble_packet_enabled)
        if custom_ble_packet_frame is not None:
            pulumi.set(__self__, "custom_ble_packet_frame", custom_ble_packet_frame)
        if custom_ble_packet_freq_msec is not None:
            pulumi.set(__self__, "custom_ble_packet_freq_msec", custom_ble_packet_freq_msec)
        if eddystone_uid_adv_power is not None:
            pulumi.set(__self__, "eddystone_uid_adv_power", eddystone_uid_adv_power)
        if eddystone_uid_beams is not None:
            pulumi.set(__self__, "eddystone_uid_beams", eddystone_uid_beams)
        if eddystone_uid_enabled is not None:
            pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        if eddystone_uid_freq_msec is not None:
            pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        if eddystone_uid_instance is not None:
            pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        if eddystone_uid_namespace is not None:
            pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        if eddystone_url_adv_power is not None:
            pulumi.set(__self__, "eddystone_url_adv_power", eddystone_url_adv_power)
        if eddystone_url_beams is not None:
            pulumi.set(__self__, "eddystone_url_beams", eddystone_url_beams)
        if eddystone_url_enabled is not None:
            pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        if eddystone_url_freq_msec is not None:
            pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        if eddystone_url_url is not None:
            pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        if ibeacon_adv_power is not None:
            pulumi.set(__self__, "ibeacon_adv_power", ibeacon_adv_power)
        if ibeacon_beams is not None:
            pulumi.set(__self__, "ibeacon_beams", ibeacon_beams)
        if ibeacon_enabled is not None:
            pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        if ibeacon_freq_msec is not None:
            pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        if ibeacon_major is not None:
            pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        if ibeacon_minor is not None:
            pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        if ibeacon_uuid is not None:
            pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)

    @_builtins.property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether Mist beacons is enabled
        """
        return pulumi.get(self, "beacon_enabled")

    @_builtins.property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> Optional[_builtins.int]:
        """
        Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        return pulumi.get(self, "beacon_rate")

    @_builtins.property
    @pulumi.getter(name="beaconRateMode")
    def beacon_rate_mode(self) -> Optional[_builtins.str]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "beacon_rate_mode")

    @_builtins.property
    @pulumi.getter(name="beamDisableds")
    def beam_disableds(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        return pulumi.get(self, "beam_disableds")

    @_builtins.property
    @pulumi.getter(name="customBlePacketEnabled")
    def custom_ble_packet_enabled(self) -> Optional[_builtins.bool]:
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        return pulumi.get(self, "custom_ble_packet_enabled")

    @_builtins.property
    @pulumi.getter(name="customBlePacketFrame")
    def custom_ble_packet_frame(self) -> Optional[_builtins.str]:
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        return pulumi.get(self, "custom_ble_packet_frame")

    @_builtins.property
    @pulumi.getter(name="customBlePacketFreqMsec")
    def custom_ble_packet_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        return pulumi.get(self, "custom_ble_packet_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidAdvPower")
    def eddystone_uid_adv_power(self) -> Optional[_builtins.int]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_uid_adv_power")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidBeams")
    def eddystone_uid_beams(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "eddystone_uid_beams")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> Optional[_builtins.bool]:
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        return pulumi.get(self, "eddystone_uid_enabled")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> Optional[_builtins.str]:
        """
        Eddystone-UID instance for the device
        """
        return pulumi.get(self, "eddystone_uid_instance")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> Optional[_builtins.str]:
        """
        Eddystone-UID namespace
        """
        return pulumi.get(self, "eddystone_uid_namespace")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlAdvPower")
    def eddystone_url_adv_power(self) -> Optional[_builtins.int]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_url_adv_power")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlBeams")
    def eddystone_url_beams(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "eddystone_url_beams")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> Optional[_builtins.bool]:
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        return pulumi.get(self, "eddystone_url_enabled")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> Optional[_builtins.str]:
        """
        URL pointed by Eddystone-URL beacon
        """
        return pulumi.get(self, "eddystone_url_url")

    @_builtins.property
    @pulumi.getter(name="ibeaconAdvPower")
    def ibeacon_adv_power(self) -> Optional[_builtins.int]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "ibeacon_adv_power")

    @_builtins.property
    @pulumi.getter(name="ibeaconBeams")
    def ibeacon_beams(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ibeacon_beams")

    @_builtins.property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> Optional[_builtins.bool]:
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        return pulumi.get(self, "ibeacon_enabled")

    @_builtins.property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emit for iBeacon
        """
        return pulumi.get(self, "ibeacon_freq_msec")

    @_builtins.property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> Optional[_builtins.int]:
        """
        Major number for iBeacon
        """
        return pulumi.get(self, "ibeacon_major")

    @_builtins.property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> Optional[_builtins.int]:
        """
        Minor number for iBeacon
        """
        return pulumi.get(self, "ibeacon_minor")

    @_builtins.property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> Optional[_builtins.str]:
        """
        Optional, if not specified, the same UUID as the beacon will be used
        """
        return pulumi.get(self, "ibeacon_uuid")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Required if `power_mode`==`custom`; else use `power_mode` as default
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[_builtins.str]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "power_mode")


@pulumi.output_type
class DeviceprofileApEslConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCert":
            suggest = "verify_cert"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApEslConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApEslConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApEslConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cacert: Optional[_builtins.str] = None,
                 channel: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 verify_cert: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str cacert: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.int channel: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.bool enabled: usb_config is ignored if esl_config enabled
        :param _builtins.str host: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.int port: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.str type: note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        :param _builtins.bool verify_cert: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.int vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "cacert")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        usb_config is ignored if esl_config enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "verify_cert")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class DeviceprofileApIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.int] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] dns: If `type`==`static`
        :param Sequence[_builtins.str] dns_suffixes: Required if `type`==`static`
        :param _builtins.str gateway: Required if `type`==`static`
        :param _builtins.str ip: Required if `type`==`static`
        :param _builtins.str netmask: Required if `type`==`static`
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        :param _builtins.int vlan_id: Management VLAN id, default is 1 (untagged)
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Management VLAN id, default is 1 (untagged)
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class DeviceprofileApLacpConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileApLed(dict):
    def __init__(__self__, *,
                 brightness: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "brightness")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileApMesh(dict):
    def __init__(__self__, *,
                 bands: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 group: Optional[_builtins.int] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] bands: List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        :param _builtins.bool enabled: Whether mesh is enabled on this AP
        :param _builtins.int group: Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        :param _builtins.str role: enum: `base`, `remote`
        """
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether mesh is enabled on this AP
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.int]:
        """
        Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        enum: `base`, `remote`
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class DeviceprofileApPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicVlan":
            suggest = "dynamic_vlan"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "macAuthPreferred":
            suggest = "mac_auth_preferred"
        elif key == "macAuthProtocol":
            suggest = "mac_auth_protocol"
        elif key == "mistNac":
            suggest = "mist_nac"
        elif key == "mxTunnelId":
            suggest = "mx_tunnel_id"
        elif key == "mxtunnelName":
            suggest = "mxtunnel_name"
        elif key == "portAuth":
            suggest = "port_auth"
        elif key == "portVlanId":
            suggest = "port_vlan_id"
        elif key == "radiusConfig":
            suggest = "radius_config"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vlanIds":
            suggest = "vlan_ids"
        elif key == "wxtunnelId":
            suggest = "wxtunnel_id"
        elif key == "wxtunnelRemoteId":
            suggest = "wxtunnel_remote_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 dynamic_vlan: Optional['outputs.DeviceprofileApPortConfigDynamicVlan'] = None,
                 enable_mac_auth: Optional[_builtins.bool] = None,
                 forwarding: Optional[_builtins.str] = None,
                 mac_auth_preferred: Optional[_builtins.bool] = None,
                 mac_auth_protocol: Optional[_builtins.str] = None,
                 mist_nac: Optional['outputs.DeviceprofileApPortConfigMistNac'] = None,
                 mx_tunnel_id: Optional[_builtins.str] = None,
                 mxtunnel_name: Optional[_builtins.str] = None,
                 port_auth: Optional[_builtins.str] = None,
                 port_vlan_id: Optional[_builtins.int] = None,
                 radius_config: Optional['outputs.DeviceprofileApPortConfigRadiusConfig'] = None,
                 radsec: Optional['outputs.DeviceprofileApPortConfigRadsec'] = None,
                 vlan_id: Optional[_builtins.int] = None,
                 vlan_ids: Optional[Sequence[_builtins.int]] = None,
                 wxtunnel_id: Optional[_builtins.str] = None,
                 wxtunnel_remote_id: Optional[_builtins.str] = None):
        """
        :param 'DeviceprofileApPortConfigDynamicVlanArgs' dynamic_vlan: Optional dynamic vlan
        :param _builtins.str forwarding: enum: 
                 * `all`: local breakout, All VLANs
                 * `limited`: local breakout, only the VLANs configured in `port_vlan_id` and `vlan_ids`
                 * `mxtunnel`: central breakout to an Org Mist Edge (requires `mxtunnel_id`)
                 * `site_mxedge`: central breakout to a Site Mist Edge (requires `mxtunnel_name`)
                 * `wxtunnel`': central breakout to an Org WxTunnel (requires `wxtunnel_id`)
        :param _builtins.bool mac_auth_preferred: When `true`, we'll do dot1x then mac_auth. enable this to prefer mac_auth
        :param _builtins.str mac_auth_protocol: if `enable_mac_auth`==`true`, allows user to select an authentication protocol. enum: `eap-md5`, `eap-peap`, `pap`
        :param _builtins.str mx_tunnel_id: If `forwarding`==`mxtunnel`, vlan_ids comes from mxtunnel
        :param _builtins.str mxtunnel_name: If `forwarding`==`site_mxedge`, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        :param _builtins.str port_auth: When doing port auth. enum: `dot1x`, `none`
        :param _builtins.int port_vlan_id: If `forwarding`==`limited`
        :param 'DeviceprofileApPortConfigRadiusConfigArgs' radius_config: Junos Radius config
        :param 'DeviceprofileApPortConfigRadsecArgs' radsec: RadSec settings
        :param _builtins.int vlan_id: Optional to specify the vlan id for a tunnel if forwarding is for `wxtunnel`, `mxtunnel` or `site_mxedge`.
                 * if vlan_id is not specified then it will use first one in vlan_ids[] of the mxtunnel.
                 * if forwarding == site_mxedge, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        :param Sequence[_builtins.int] vlan_ids: If `forwarding`==`limited`
        :param _builtins.str wxtunnel_id: If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        :param _builtins.str wxtunnel_remote_id: If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dynamic_vlan is not None:
            pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if forwarding is not None:
            pulumi.set(__self__, "forwarding", forwarding)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mist_nac is not None:
            pulumi.set(__self__, "mist_nac", mist_nac)
        if mx_tunnel_id is not None:
            pulumi.set(__self__, "mx_tunnel_id", mx_tunnel_id)
        if mxtunnel_name is not None:
            pulumi.set(__self__, "mxtunnel_name", mxtunnel_name)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_vlan_id is not None:
            pulumi.set(__self__, "port_vlan_id", port_vlan_id)
        if radius_config is not None:
            pulumi.set(__self__, "radius_config", radius_config)
        if radsec is not None:
            pulumi.set(__self__, "radsec", radsec)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)
        if wxtunnel_id is not None:
            pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        if wxtunnel_remote_id is not None:
            pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> Optional['outputs.DeviceprofileApPortConfigDynamicVlan']:
        """
        Optional dynamic vlan
        """
        return pulumi.get(self, "dynamic_vlan")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter
    def forwarding(self) -> Optional[_builtins.str]:
        """
        enum: 
          * `all`: local breakout, All VLANs
          * `limited`: local breakout, only the VLANs configured in `port_vlan_id` and `vlan_ids`
          * `mxtunnel`: central breakout to an Org Mist Edge (requires `mxtunnel_id`)
          * `site_mxedge`: central breakout to a Site Mist Edge (requires `mxtunnel_name`)
          * `wxtunnel`': central breakout to an Org WxTunnel (requires `wxtunnel_id`)
        """
        return pulumi.get(self, "forwarding")

    @_builtins.property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[_builtins.bool]:
        """
        When `true`, we'll do dot1x then mac_auth. enable this to prefer mac_auth
        """
        return pulumi.get(self, "mac_auth_preferred")

    @_builtins.property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[_builtins.str]:
        """
        if `enable_mac_auth`==`true`, allows user to select an authentication protocol. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @_builtins.property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> Optional['outputs.DeviceprofileApPortConfigMistNac']:
        return pulumi.get(self, "mist_nac")

    @_builtins.property
    @pulumi.getter(name="mxTunnelId")
    def mx_tunnel_id(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`mxtunnel`, vlan_ids comes from mxtunnel
        """
        return pulumi.get(self, "mx_tunnel_id")

    @_builtins.property
    @pulumi.getter(name="mxtunnelName")
    def mxtunnel_name(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`site_mxedge`, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        """
        return pulumi.get(self, "mxtunnel_name")

    @_builtins.property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[_builtins.str]:
        """
        When doing port auth. enum: `dot1x`, `none`
        """
        return pulumi.get(self, "port_auth")

    @_builtins.property
    @pulumi.getter(name="portVlanId")
    def port_vlan_id(self) -> Optional[_builtins.int]:
        """
        If `forwarding`==`limited`
        """
        return pulumi.get(self, "port_vlan_id")

    @_builtins.property
    @pulumi.getter(name="radiusConfig")
    def radius_config(self) -> Optional['outputs.DeviceprofileApPortConfigRadiusConfig']:
        """
        Junos Radius config
        """
        return pulumi.get(self, "radius_config")

    @_builtins.property
    @pulumi.getter
    def radsec(self) -> Optional['outputs.DeviceprofileApPortConfigRadsec']:
        """
        RadSec settings
        """
        return pulumi.get(self, "radsec")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Optional to specify the vlan id for a tunnel if forwarding is for `wxtunnel`, `mxtunnel` or `site_mxedge`.
          * if vlan_id is not specified then it will use first one in vlan_ids[] of the mxtunnel.
          * if forwarding == site_mxedge, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        """
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        If `forwarding`==`limited`
        """
        return pulumi.get(self, "vlan_ids")

    @_builtins.property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        """
        return pulumi.get(self, "wxtunnel_id")

    @_builtins.property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        """
        return pulumi.get(self, "wxtunnel_remote_id")


@pulumi.output_type
class DeviceprofileApPortConfigDynamicVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultVlanId":
            suggest = "default_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfigDynamicVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfigDynamicVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfigDynamicVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_vlan_id: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None,
                 vlans: Optional[Mapping[str, _builtins.str]] = None):
        if default_vlan_id is not None:
            pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @_builtins.property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "default_vlan_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlans(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "vlans")


@pulumi.output_type
class DeviceprofileApPortConfigMistNac(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "fastDot1xTimers":
            suggest = "fast_dot1x_timers"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfigMistNac. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfigMistNac.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfigMistNac.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fast_dot1x_timers: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled.
        :param _builtins.int auth_servers_retries: Radius auth session retries. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "retries" are set to value of `auth_servers_timeout`. "max-requests" is also set when setting `auth_servers_retries` is set to default value to 3.
        :param _builtins.int auth_servers_timeout: Radius auth session timeout. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "quite-period" and "transmit-period" are set to half the value of `auth_servers_timeout`. "supplicant-timeout" is also set when setting `auth_servers_timeout` is set to default value of 10.
        :param _builtins.bool coa_enabled: Allows a RADIUS server to dynamically modify the authorization status of a user session.
        :param _builtins.int coa_port: the communication port used for “Change of Authorization” (CoA) messages
        :param _builtins.bool enabled: When enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed
        :param _builtins.bool fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from `auth_servers_timeout` and `auth_server_retries`.
        :param _builtins.str network: Which network the mist nac server resides in
        :param _builtins.str source_ip: In case there is a static IP for this network, we can specify it using source ip
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled.
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        Radius auth session retries. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "retries" are set to value of `auth_servers_timeout`. "max-requests" is also set when setting `auth_servers_retries` is set to default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        Radius auth session timeout. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "quite-period" and "transmit-period" are set to half the value of `auth_servers_timeout`. "supplicant-timeout" is also set when setting `auth_servers_timeout` is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        """
        Allows a RADIUS server to dynamically modify the authorization status of a user session.
        """
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.int]:
        """
        the communication port used for “Change of Authorization” (CoA) messages
        """
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[_builtins.bool]:
        """
        If set to true, sets default fast-timers with values calculated from `auth_servers_timeout` and `auth_server_retries`.
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Which network the mist nac server resides in
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        In case there is a static IP for this network, we can specify it using source ip
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class DeviceprofileApPortConfigRadiusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "acctServers":
            suggest = "acct_servers"
        elif key == "authServers":
            suggest = "auth_servers"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfigRadiusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfigRadiusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfigRadiusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 acct_servers: Optional[Sequence['outputs.DeviceprofileApPortConfigRadiusConfigAcctServer']] = None,
                 auth_servers: Optional[Sequence['outputs.DeviceprofileApPortConfigRadiusConfigAuthServer']] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.int] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param _builtins.int auth_servers_retries: radius auth session retries
        :param _builtins.int auth_servers_timeout: radius auth session timeout
        :param _builtins.str network: use `network`or `source_ip`, which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param _builtins.str source_ip: use `network`or `source_ip`
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.DeviceprofileApPortConfigRadiusConfigAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[Sequence['outputs.DeviceprofileApPortConfigRadiusConfigAuthServer']]:
        return pulumi.get(self, "auth_servers")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        use `network`or `source_ip`, which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class DeviceprofileApPortConfigRadiusConfigAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfigRadiusConfigAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfigRadiusConfigAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfigRadiusConfigAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class DeviceprofileApPortConfigRadiusConfigAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"
        elif key == "requireMessageAuthenticator":
            suggest = "require_message_authenticator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfigRadiusConfigAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfigRadiusConfigAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfigRadiusConfigAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 require_message_authenticator: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.bool require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[_builtins.bool]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")


@pulumi.output_type
class DeviceprofileApPortConfigRadsec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "mxclusterIds":
            suggest = "mxcluster_ids"
        elif key == "proxyHosts":
            suggest = "proxy_hosts"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "useMxedge":
            suggest = "use_mxedge"
        elif key == "useSiteMxedge":
            suggest = "use_site_mxedge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPortConfigRadsec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPortConfigRadsec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPortConfigRadsec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coa_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idle_timeout: Optional[_builtins.str] = None,
                 mxcluster_ids: Optional[Sequence[_builtins.str]] = None,
                 proxy_hosts: Optional[Sequence[_builtins.str]] = None,
                 server_name: Optional[_builtins.str] = None,
                 servers: Optional[Sequence['outputs.DeviceprofileApPortConfigRadsecServer']] = None,
                 use_mxedge: Optional[_builtins.bool] = None,
                 use_site_mxedge: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        :param Sequence[_builtins.str] proxy_hosts: Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        :param _builtins.str server_name: Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param Sequence['DeviceprofileApPortConfigRadsecServerArgs'] servers: List of RadSec Servers. Only if not Mist Edge.
        :param _builtins.bool use_mxedge: use mxedge(s) as RadSec Proxy
        :param _builtins.bool use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if mxcluster_ids is not None:
            pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        if proxy_hosts is not None:
            pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if use_mxedge is not None:
            pulumi.set(__self__, "use_mxedge", use_mxedge)
        if use_site_mxedge is not None:
            pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @_builtins.property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        """
        return pulumi.get(self, "proxy_hosts")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.DeviceprofileApPortConfigRadsecServer']]:
        """
        List of RadSec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> Optional[_builtins.bool]:
        """
        use mxedge(s) as RadSec Proxy
        """
        return pulumi.get(self, "use_mxedge")

    @_builtins.property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> Optional[_builtins.bool]:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")


@pulumi.output_type
class DeviceprofileApPortConfigRadsecServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class DeviceprofileApPwrConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferUsbOverWifi":
            suggest = "prefer_usb_over_wifi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApPwrConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApPwrConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApPwrConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base: Optional[_builtins.int] = None,
                 prefer_usb_over_wifi: Optional[_builtins.bool] = None):
        """
        :param _builtins.int base: Additional power to request during negotiating with PSE over PoE, in mW
        :param _builtins.bool prefer_usb_over_wifi: Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
        if base is not None:
            pulumi.set(__self__, "base", base)
        if prefer_usb_over_wifi is not None:
            pulumi.set(__self__, "prefer_usb_over_wifi", prefer_usb_over_wifi)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[_builtins.int]:
        """
        Additional power to request during negotiating with PSE over PoE, in mW
        """
        return pulumi.get(self, "base")

    @_builtins.property
    @pulumi.getter(name="preferUsbOverWifi")
    def prefer_usb_over_wifi(self) -> Optional[_builtins.bool]:
        """
        Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
        return pulumi.get(self, "prefer_usb_over_wifi")


@pulumi.output_type
class DeviceprofileApRadioConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain24":
            suggest = "ant_gain24"
        elif key == "antGain5":
            suggest = "ant_gain5"
        elif key == "antGain6":
            suggest = "ant_gain6"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "band24Usage":
            suggest = "band24_usage"
        elif key == "band5On24Radio":
            suggest = "band5_on24_radio"
        elif key == "fullAutomaticRrm":
            suggest = "full_automatic_rrm"
        elif key == "indoorUse":
            suggest = "indoor_use"
        elif key == "scanningEnabled":
            suggest = "scanning_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApRadioConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApRadioConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApRadioConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain24: Optional[_builtins.int] = None,
                 ant_gain5: Optional[_builtins.int] = None,
                 ant_gain6: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 band24: Optional['outputs.DeviceprofileApRadioConfigBand24'] = None,
                 band24_usage: Optional[_builtins.str] = None,
                 band5: Optional['outputs.DeviceprofileApRadioConfigBand5'] = None,
                 band5_on24_radio: Optional['outputs.DeviceprofileApRadioConfigBand5On24Radio'] = None,
                 band6: Optional['outputs.DeviceprofileApRadioConfigBand6'] = None,
                 full_automatic_rrm: Optional[_builtins.bool] = None,
                 indoor_use: Optional[_builtins.bool] = None,
                 scanning_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int ant_gain24: Antenna gain for 2.4G - for models with external antenna only
        :param _builtins.int ant_gain5: Antenna gain for 5G - for models with external antenna only
        :param _builtins.int ant_gain6: Antenna gain for 6G - for models with external antenna only
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param 'DeviceprofileApRadioConfigBand24Args' band24: Radio Band AP settings
        :param _builtins.str band24_usage: enum: `24`, `5`, `6`, `auto`
        :param 'DeviceprofileApRadioConfigBand5Args' band5: Radio Band AP settings
        :param 'DeviceprofileApRadioConfigBand5On24RadioArgs' band5_on24_radio: Radio Band AP settings
        :param 'DeviceprofileApRadioConfigBand6Args' band6: Radio Band AP settings
        :param _builtins.bool full_automatic_rrm: Let RRM control everything, only the `channels` and `ant_gain` will be honored (i.e. disabled/bandwidth/power/band_24_usage are all controlled by RRM)
        :param _builtins.bool indoor_use: To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        :param _builtins.bool scanning_enabled: Whether scanning radio is enabled
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain24 is not None:
            pulumi.set(__self__, "ant_gain24", ant_gain24)
        if ant_gain5 is not None:
            pulumi.set(__self__, "ant_gain5", ant_gain5)
        if ant_gain6 is not None:
            pulumi.set(__self__, "ant_gain6", ant_gain6)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if band24 is not None:
            pulumi.set(__self__, "band24", band24)
        if band24_usage is not None:
            pulumi.set(__self__, "band24_usage", band24_usage)
        if band5 is not None:
            pulumi.set(__self__, "band5", band5)
        if band5_on24_radio is not None:
            pulumi.set(__self__, "band5_on24_radio", band5_on24_radio)
        if band6 is not None:
            pulumi.set(__self__, "band6", band6)
        if full_automatic_rrm is not None:
            pulumi.set(__self__, "full_automatic_rrm", full_automatic_rrm)
        if indoor_use is not None:
            pulumi.set(__self__, "indoor_use", indoor_use)
        if scanning_enabled is not None:
            pulumi.set(__self__, "scanning_enabled", scanning_enabled)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain24")
    def ant_gain24(self) -> Optional[_builtins.int]:
        """
        Antenna gain for 2.4G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain24")

    @_builtins.property
    @pulumi.getter(name="antGain5")
    def ant_gain5(self) -> Optional[_builtins.int]:
        """
        Antenna gain for 5G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain5")

    @_builtins.property
    @pulumi.getter(name="antGain6")
    def ant_gain6(self) -> Optional[_builtins.int]:
        """
        Antenna gain for 6G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain6")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def band24(self) -> Optional['outputs.DeviceprofileApRadioConfigBand24']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band24")

    @_builtins.property
    @pulumi.getter(name="band24Usage")
    def band24_usage(self) -> Optional[_builtins.str]:
        """
        enum: `24`, `5`, `6`, `auto`
        """
        return pulumi.get(self, "band24_usage")

    @_builtins.property
    @pulumi.getter
    def band5(self) -> Optional['outputs.DeviceprofileApRadioConfigBand5']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5")

    @_builtins.property
    @pulumi.getter(name="band5On24Radio")
    def band5_on24_radio(self) -> Optional['outputs.DeviceprofileApRadioConfigBand5On24Radio']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5_on24_radio")

    @_builtins.property
    @pulumi.getter
    def band6(self) -> Optional['outputs.DeviceprofileApRadioConfigBand6']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band6")

    @_builtins.property
    @pulumi.getter(name="fullAutomaticRrm")
    def full_automatic_rrm(self) -> Optional[_builtins.bool]:
        """
        Let RRM control everything, only the `channels` and `ant_gain` will be honored (i.e. disabled/bandwidth/power/band_24_usage are all controlled by RRM)
        """
        return pulumi.get(self, "full_automatic_rrm")

    @_builtins.property
    @pulumi.getter(name="indoorUse")
    def indoor_use(self) -> Optional[_builtins.bool]:
        """
        To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        """
        return pulumi.get(self, "indoor_use")

    @_builtins.property
    @pulumi.getter(name="scanningEnabled")
    def scanning_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether scanning radio is enabled
        """
        return pulumi.get(self, "scanning_enabled")


@pulumi.output_type
class DeviceprofileApRadioConfigBand24(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApRadioConfigBand24. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApRadioConfigBand24.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApRadioConfigBand24.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class DeviceprofileApRadioConfigBand5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApRadioConfigBand5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApRadioConfigBand5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApRadioConfigBand5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class DeviceprofileApRadioConfigBand5On24Radio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApRadioConfigBand5On24Radio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApRadioConfigBand5On24Radio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApRadioConfigBand5On24Radio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class DeviceprofileApRadioConfigBand6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"
        elif key == "standardPower":
            suggest = "standard_power"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApRadioConfigBand6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApRadioConfigBand6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApRadioConfigBand6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None,
                 standard_power: Optional[_builtins.bool] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        :param _builtins.bool standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @_builtins.property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[_builtins.bool]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")


@pulumi.output_type
class DeviceprofileApUplinkPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepWlansUpIfDown":
            suggest = "keep_wlans_up_if_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApUplinkPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApUplinkPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApUplinkPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dot1x: Optional[_builtins.bool] = None,
                 keep_wlans_up_if_down: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool dot1x: Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param _builtins.bool keep_wlans_up_if_down: By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @_builtins.property
    @pulumi.getter
    def dot1x(self) -> Optional[_builtins.bool]:
        """
        Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @_builtins.property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[_builtins.bool]:
        """
        By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")


@pulumi.output_type
class DeviceprofileApUsbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCert":
            suggest = "verify_cert"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileApUsbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileApUsbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileApUsbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cacert: Optional[_builtins.str] = None,
                 channel: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 verify_cert: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str cacert: Only if `type`==`imagotag`
        :param _builtins.int channel: Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        :param _builtins.bool enabled: Whether to enable any usb config
        :param _builtins.str host: Only if `type`==`imagotag`
        :param _builtins.int port: Only if `type`==`imagotag`
        :param _builtins.str type: usb config type. enum: `hanshow`, `imagotag`, `solum`
        :param _builtins.bool verify_cert: Only if `type`==`imagotag`, whether to turn on SSL verification
        :param _builtins.int vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "cacert")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable any usb config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        usb config type. enum: `hanshow`, `imagotag`, `solum`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`imagotag`, whether to turn on SSL verification
        """
        return pulumi.get(self, "verify_cert")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class DeviceprofileGatewayBgpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authKey":
            suggest = "auth_key"
        elif key == "bfdMinimumInterval":
            suggest = "bfd_minimum_interval"
        elif key == "bfdMultiplier":
            suggest = "bfd_multiplier"
        elif key == "disableBfd":
            suggest = "disable_bfd"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "extendedV4Nexthop":
            suggest = "extended_v4_nexthop"
        elif key == "gracefulRestartTime":
            suggest = "graceful_restart_time"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "import":
            suggest = "import_"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "localAs":
            suggest = "local_as"
        elif key == "neighborAs":
            suggest = "neighbor_as"
        elif key == "noPrivateAs":
            suggest = "no_private_as"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "tunnelName":
            suggest = "tunnel_name"
        elif key == "vpnName":
            suggest = "vpn_name"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayBgpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayBgpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayBgpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 auth_key: Optional[_builtins.str] = None,
                 bfd_minimum_interval: Optional[_builtins.int] = None,
                 bfd_multiplier: Optional[_builtins.int] = None,
                 disable_bfd: Optional[_builtins.bool] = None,
                 export: Optional[_builtins.str] = None,
                 export_policy: Optional[_builtins.str] = None,
                 extended_v4_nexthop: Optional[_builtins.bool] = None,
                 graceful_restart_time: Optional[_builtins.int] = None,
                 hold_time: Optional[_builtins.int] = None,
                 import_: Optional[_builtins.str] = None,
                 import_policy: Optional[_builtins.str] = None,
                 local_as: Optional[_builtins.str] = None,
                 neighbor_as: Optional[_builtins.str] = None,
                 neighbors: Optional[Mapping[str, 'outputs.DeviceprofileGatewayBgpConfigNeighbors']] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 no_private_as: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 tunnel_name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpn_name: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str via: enum: `lan`, `tunnel`, `vpn`, `wan`
        :param _builtins.str auth_key: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`
        :param _builtins.int bfd_minimum_interval: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_multiplier is configured alone. Default:
                 * 1000 if `type`==`external`
                 * 350 `type`==`internal`
        :param _builtins.int bfd_multiplier: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_minimum_interval_is_configured alone
        :param _builtins.bool disable_bfd: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BFD provides faster path failure detection and is enabled by default
        :param _builtins.str export_policy: Default export policies if no per-neighbor policies defined
        :param _builtins.bool extended_v4_nexthop: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        :param _builtins.int graceful_restart_time: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. `0` means disable
        :param _builtins.int hold_time: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default is 90.
        :param _builtins.str import_policy: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default import policies if no per-neighbor policies defined
        :param _builtins.str local_as: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BGPLocal AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param _builtins.str neighbor_as: Neighbor AS. If `type`==`internal`, must be equal to `local_as`. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param Mapping[str, 'DeviceprofileGatewayBgpConfigNeighborsArgs'] neighbors: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If per-neighbor as is desired. Property key is the neighbor address
        :param Sequence[_builtins.str] networks: Optional if `via`==`lan`. List of networks where we expect BGP neighbor to connect to/from
        :param _builtins.bool no_private_as: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If true, we will not advertise private ASNs (AS 64512-65534) to this neighbor
        :param _builtins.bool no_readvertise_to_overlay: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, we'll re-advertise all learned BGP routers toward overlay
        :param _builtins.str tunnel_name: Optional if `via`==`tunnel`
        :param _builtins.str type: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. enum: `external`, `internal`
        :param _builtins.str vpn_name: Optional if `via`==`vpn`
        :param _builtins.str wan_name: Optional if `via`==`wan`
        """
        pulumi.set(__self__, "via", via)
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if bfd_multiplier is not None:
            pulumi.set(__self__, "bfd_multiplier", bfd_multiplier)
        if disable_bfd is not None:
            pulumi.set(__self__, "disable_bfd", disable_bfd)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if extended_v4_nexthop is not None:
            pulumi.set(__self__, "extended_v4_nexthop", extended_v4_nexthop)
        if graceful_restart_time is not None:
            pulumi.set(__self__, "graceful_restart_time", graceful_restart_time)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if no_private_as is not None:
            pulumi.set(__self__, "no_private_as", no_private_as)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if tunnel_name is not None:
            pulumi.set(__self__, "tunnel_name", tunnel_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpn_name is not None:
            pulumi.set(__self__, "vpn_name", vpn_name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`
        """
        return pulumi.get(self, "auth_key")

    @_builtins.property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        return pulumi.get(self, "bfd_minimum_interval")

    @_builtins.property
    @pulumi.getter(name="bfdMultiplier")
    def bfd_multiplier(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_minimum_interval_is_configured alone
        """
        return pulumi.get(self, "bfd_multiplier")

    @_builtins.property
    @pulumi.getter(name="disableBfd")
    def disable_bfd(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BFD provides faster path failure detection and is enabled by default
        """
        return pulumi.get(self, "disable_bfd")

    @_builtins.property
    @pulumi.getter
    def export(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        """
        Default export policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="extendedV4Nexthop")
    def extended_v4_nexthop(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        return pulumi.get(self, "extended_v4_nexthop")

    @_builtins.property
    @pulumi.getter(name="gracefulRestartTime")
    def graceful_restart_time(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. `0` means disable
        """
        return pulumi.get(self, "graceful_restart_time")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default is 90.
        """
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default import policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[_builtins.str]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BGPLocal AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "local_as")

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[_builtins.str]:
        """
        Neighbor AS. If `type`==`internal`, must be equal to `local_as`. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayBgpConfigNeighbors']]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If per-neighbor as is desired. Property key is the neighbor address
        """
        return pulumi.get(self, "neighbors")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `via`==`lan`. List of networks where we expect BGP neighbor to connect to/from
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="noPrivateAs")
    def no_private_as(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If true, we will not advertise private ASNs (AS 64512-65534) to this neighbor
        """
        return pulumi.get(self, "no_private_as")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, we'll re-advertise all learned BGP routers toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`tunnel`
        """
        return pulumi.get(self, "tunnel_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. enum: `external`, `internal`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpnName")
    def vpn_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`vpn`
        """
        return pulumi.get(self, "vpn_name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`wan`
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class DeviceprofileGatewayBgpConfigNeighbors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neighborAs":
            suggest = "neighbor_as"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "multihopTtl":
            suggest = "multihop_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayBgpConfigNeighbors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayBgpConfigNeighbors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayBgpConfigNeighbors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 neighbor_as: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 export_policy: Optional[_builtins.str] = None,
                 hold_time: Optional[_builtins.int] = None,
                 import_policy: Optional[_builtins.str] = None,
                 multihop_ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param _builtins.bool disabled: If true, the BGP session to this neighbor will be administratively disabled/shutdown
        :param _builtins.int multihop_ttl: Assuming BGP neighbor is directly connected
        """
        pulumi.set(__self__, "neighbor_as", neighbor_as)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if multihop_ttl is not None:
            pulumi.set(__self__, "multihop_ttl", multihop_ttl)

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> _builtins.str:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="multihopTtl")
    def multihop_ttl(self) -> Optional[_builtins.int]:
        """
        Assuming BGP neighbor is directly connected
        """
        return pulumi.get(self, "multihop_ttl")


@pulumi.output_type
class DeviceprofileGatewayDhcpdConfig(dict):
    def __init__(__self__, *,
                 config: Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfig']] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, 'DeviceprofileGatewayDhcpdConfigConfigArgs'] config: Property key is the network name
        :param _builtins.bool enabled: If set to `false`, disable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfig']]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to `false`, disable the DHCP server
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileGatewayDhcpdConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"
        elif key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "fixedBindings":
            suggest = "fixed_bindings"
        elif key == "ip6End":
            suggest = "ip6_end"
        elif key == "ip6Start":
            suggest = "ip6_start"
        elif key == "ipEnd":
            suggest = "ip_end"
        elif key == "ipStart":
            suggest = "ip_start"
        elif key == "leaseTime":
            suggest = "lease_time"
        elif key == "serverIdOverride":
            suggest = "server_id_override"
        elif key == "vendorEncapsulated":
            suggest = "vendor_encapsulated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayDhcpdConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayDhcpdConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayDhcpdConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 fixed_bindings: Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfigFixedBindings']] = None,
                 gateway: Optional[_builtins.str] = None,
                 ip6_end: Optional[_builtins.str] = None,
                 ip6_start: Optional[_builtins.str] = None,
                 ip_end: Optional[_builtins.str] = None,
                 ip_start: Optional[_builtins.str] = None,
                 lease_time: Optional[_builtins.int] = None,
                 options: Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfigOptions']] = None,
                 server_id_override: Optional[_builtins.bool] = None,
                 servers: Optional[Sequence[_builtins.str]] = None,
                 serversv6s: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None,
                 vendor_encapsulated: Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulated']] = None):
        """
        :param Sequence[_builtins.str] dns_servers: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param Sequence[_builtins.str] dns_suffixes: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param Mapping[str, 'DeviceprofileGatewayDhcpdConfigConfigFixedBindingsArgs'] fixed_bindings: If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        :param _builtins.str gateway: If `type`==`local` - optional, `ip` will be used if not provided
        :param _builtins.str ip6_end: If `type6`==`local`
        :param _builtins.str ip6_start: If `type6`==`local`
        :param _builtins.str ip_end: If `type`==`local`
        :param _builtins.str ip_start: If `type`==`local`
        :param _builtins.int lease_time: In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param Mapping[str, 'DeviceprofileGatewayDhcpdConfigConfigOptionsArgs'] options: If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        :param _builtins.bool server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param Sequence[_builtins.str] servers: If `type`==`relay`
        :param Sequence[_builtins.str] serversv6s: If `type6`==`relay`
        :param _builtins.str type: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param _builtins.str type6: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param Mapping[str, 'DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulatedArgs'] vendor_encapsulated: If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip6_end is not None:
            pulumi.set(__self__, "ip6_end", ip6_end)
        if ip6_start is not None:
            pulumi.set(__self__, "ip6_start", ip6_start)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if serversv6s is not None:
            pulumi.set(__self__, "serversv6s", serversv6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapsulated is not None:
            pulumi.set(__self__, "vendor_encapsulated", vendor_encapsulated)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    @_utilities.deprecated("""Configuring `dns_suffix` is deprecated and will not be supported in the future, please configure Code 15 or Code 119 in Server `options` instead""")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfigFixedBindings']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter(name="ip6End")
    def ip6_end(self) -> Optional[_builtins.str]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip6_end")

    @_builtins.property
    @pulumi.getter(name="ip6Start")
    def ip6_start(self) -> Optional[_builtins.str]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip6_start")

    @_builtins.property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[_builtins.str]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_end")

    @_builtins.property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[_builtins.str]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_start")

    @_builtins.property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[_builtins.int]:
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfigOptions']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[_builtins.bool]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def serversv6s(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type6`==`relay`
        """
        return pulumi.get(self, "serversv6s")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vendorEncapsulated")
    def vendor_encapsulated(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulated']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
        return pulumi.get(self, "vendor_encapsulated")


@pulumi.output_type
class DeviceprofileGatewayDhcpdConfigConfigFixedBindings(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DeviceprofileGatewayDhcpdConfigConfigOptions(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulated(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DeviceprofileGatewayExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        return pulumi.get(self, "via")


@pulumi.output_type
class DeviceprofileGatewayExtraRoutes(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        return pulumi.get(self, "via")


@pulumi.output_type
class DeviceprofileGatewayIdpProfiles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseProfile":
            suggest = "base_profile"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayIdpProfiles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayIdpProfiles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayIdpProfiles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_profile: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 org_id: Optional[_builtins.str] = None,
                 overwrites: Optional[Sequence['outputs.DeviceprofileGatewayIdpProfilesOverwrite']] = None):
        """
        :param _builtins.str base_profile: enum: `critical`, `standard`, `strict`
        """
        if base_profile is not None:
            pulumi.set(__self__, "base_profile", base_profile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)

    @_builtins.property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[Sequence['outputs.DeviceprofileGatewayIdpProfilesOverwrite']]:
        return pulumi.get(self, "overwrites")


@pulumi.output_type
class DeviceprofileGatewayIdpProfilesOverwrite(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 matching: Optional['outputs.DeviceprofileGatewayIdpProfilesOverwriteMatching'] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.DeviceprofileGatewayIdpProfilesOverwriteMatching']:
        return pulumi.get(self, "matching")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DeviceprofileGatewayIdpProfilesOverwriteMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackNames":
            suggest = "attack_names"
        elif key == "dstSubnets":
            suggest = "dst_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayIdpProfilesOverwriteMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayIdpProfilesOverwriteMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayIdpProfilesOverwriteMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attack_names: Optional[Sequence[_builtins.str]] = None,
                 dst_subnets: Optional[Sequence[_builtins.str]] = None,
                 severities: Optional[Sequence[_builtins.str]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "attack_names")

    @_builtins.property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dst_subnets")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "severities")


@pulumi.output_type
class DeviceprofileGatewayIpConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryIps":
            suggest = "secondary_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayIpConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayIpConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayIpConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 secondary_ips: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] secondary_ips: Optional list of secondary IPs in CIDR format
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if secondary_ips is not None:
            pulumi.set(__self__, "secondary_ips", secondary_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter(name="secondaryIps")
    def secondary_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional list of secondary IPs in CIDR format
        """
        return pulumi.get(self, "secondary_ips")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class DeviceprofileGatewayNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disallowMistServices":
            suggest = "disallow_mist_services"
        elif key == "internalAccess":
            suggest = "internal_access"
        elif key == "internetAccess":
            suggest = "internet_access"
        elif key == "routedForNetworks":
            suggest = "routed_for_networks"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vpnAccess":
            suggest = "vpn_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subnet: _builtins.str,
                 disallow_mist_services: Optional[_builtins.bool] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 internal_access: Optional['outputs.DeviceprofileGatewayNetworkInternalAccess'] = None,
                 internet_access: Optional['outputs.DeviceprofileGatewayNetworkInternetAccess'] = None,
                 isolation: Optional[_builtins.bool] = None,
                 multicast: Optional['outputs.DeviceprofileGatewayNetworkMulticast'] = None,
                 routed_for_networks: Optional[Sequence[_builtins.str]] = None,
                 subnet6: Optional[_builtins.str] = None,
                 tenants: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkTenants']] = None,
                 vlan_id: Optional[_builtins.str] = None,
                 vpn_access: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkVpnAccess']] = None):
        """
        :param _builtins.bool disallow_mist_services: Whether to disallow Mist Devices in the network
        :param 'DeviceprofileGatewayNetworkInternetAccessArgs' internet_access: Whether this network has direct internet access
        :param _builtins.bool isolation: Whether to allow clients in the network to talk to each other
        :param 'DeviceprofileGatewayNetworkMulticastArgs' multicast: Whether to enable multicast support (only PIM-sparse mode is supported)
        :param Sequence[_builtins.str] routed_for_networks: For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param Mapping[str, 'DeviceprofileGatewayNetworkTenantsArgs'] tenants: Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        :param Mapping[str, 'DeviceprofileGatewayNetworkVpnAccessArgs'] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        if disallow_mist_services is not None:
            pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if internal_access is not None:
            pulumi.set(__self__, "internal_access", internal_access)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if routed_for_networks is not None:
            pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_access is not None:
            pulumi.set(__self__, "vpn_access", vpn_access)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> Optional[_builtins.bool]:
        """
        Whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> Optional['outputs.DeviceprofileGatewayNetworkInternalAccess']:
        return pulumi.get(self, "internal_access")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional['outputs.DeviceprofileGatewayNetworkInternetAccess']:
        """
        Whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[_builtins.bool]:
        """
        Whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional['outputs.DeviceprofileGatewayNetworkMulticast']:
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @_builtins.property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @_builtins.property
    @pulumi.getter
    def subnet6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet6")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkTenants']]:
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "tenants")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkVpnAccess']]:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")


@pulumi.output_type
class DeviceprofileGatewayNetworkInternalAccess(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileGatewayNetworkInternetAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createSimpleServicePolicy":
            suggest = "create_simple_service_policy"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "staticNat":
            suggest = "static_nat"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkInternetAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkInternetAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkInternetAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_simple_service_policy: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkInternetAccessDestinationNat']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 restricted: Optional[_builtins.bool] = None,
                 static_nat: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkInternetAccessStaticNat']] = None):
        """
        :param Mapping[str, 'DeviceprofileGatewayNetworkInternetAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.bool restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param Mapping[str, 'DeviceprofileGatewayNetworkInternetAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @_builtins.property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_simple_service_policy")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkInternetAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def restricted(self) -> Optional[_builtins.bool]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkInternetAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")


@pulumi.output_type
class DeviceprofileGatewayNetworkInternetAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkInternetAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkInternetAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkInternetAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class DeviceprofileGatewayNetworkInternetAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkInternetAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkInternetAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkInternetAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class DeviceprofileGatewayNetworkMulticast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableIgmp":
            suggest = "disable_igmp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkMulticast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkMulticast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkMulticast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_igmp: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 groups: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkMulticastGroups']] = None):
        """
        :param _builtins.bool disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param Mapping[str, 'DeviceprofileGatewayNetworkMulticastGroupsArgs'] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[_builtins.bool]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkMulticastGroups']]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class DeviceprofileGatewayNetworkMulticastGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rpIp":
            suggest = "rp_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkMulticastGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkMulticastGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkMulticastGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rp_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @_builtins.property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[_builtins.str]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")


@pulumi.output_type
class DeviceprofileGatewayNetworkTenants(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[_builtins.str]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "addresses")


@pulumi.output_type
class DeviceprofileGatewayNetworkVpnAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedSubnet":
            suggest = "advertised_subnet"
        elif key == "allowPing":
            suggest = "allow_ping"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "natPool":
            suggest = "nat_pool"
        elif key == "noReadvertiseToLanBgp":
            suggest = "no_readvertise_to_lan_bgp"
        elif key == "noReadvertiseToLanOspf":
            suggest = "no_readvertise_to_lan_ospf"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "otherVrfs":
            suggest = "other_vrfs"
        elif key == "sourceNat":
            suggest = "source_nat"
        elif key == "staticNat":
            suggest = "static_nat"
        elif key == "summarizedSubnet":
            suggest = "summarized_subnet"
        elif key == "summarizedSubnetToLanBgp":
            suggest = "summarized_subnet_to_lan_bgp"
        elif key == "summarizedSubnetToLanOspf":
            suggest = "summarized_subnet_to_lan_ospf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkVpnAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkVpnAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkVpnAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_subnet: Optional[_builtins.str] = None,
                 allow_ping: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkVpnAccessDestinationNat']] = None,
                 nat_pool: Optional[_builtins.str] = None,
                 no_readvertise_to_lan_bgp: Optional[_builtins.bool] = None,
                 no_readvertise_to_lan_ospf: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 other_vrfs: Optional[Sequence[_builtins.str]] = None,
                 routed: Optional[_builtins.bool] = None,
                 source_nat: Optional['outputs.DeviceprofileGatewayNetworkVpnAccessSourceNat'] = None,
                 static_nat: Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkVpnAccessStaticNat']] = None,
                 summarized_subnet: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_bgp: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_ospf: Optional[_builtins.str] = None):
        """
        :param _builtins.str advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param _builtins.bool allow_ping: Whether to allow ping from vpn into this routed network
        :param Mapping[str, 'DeviceprofileGatewayNetworkVpnAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.str nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param _builtins.bool no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.bool no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param _builtins.bool no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param Sequence[_builtins.str] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param _builtins.bool routed: Whether this network is routable
        :param 'DeviceprofileGatewayNetworkVpnAccessSourceNatArgs' source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param Mapping[str, 'DeviceprofileGatewayNetworkVpnAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param _builtins.str summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.str summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @_builtins.property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[_builtins.str]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @_builtins.property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[_builtins.bool]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkVpnAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @_builtins.property
    @pulumi.getter
    def routed(self) -> Optional[_builtins.bool]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @_builtins.property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional['outputs.DeviceprofileGatewayNetworkVpnAccessSourceNat']:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayNetworkVpnAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[_builtins.str]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[_builtins.str]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[_builtins.str]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")


@pulumi.output_type
class DeviceprofileGatewayNetworkVpnAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkVpnAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkVpnAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkVpnAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class DeviceprofileGatewayNetworkVpnAccessSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIp":
            suggest = "external_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkVpnAccessSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkVpnAccessSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkVpnAccessSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_ip: Optional[_builtins.str] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @_builtins.property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_ip")


@pulumi.output_type
class DeviceprofileGatewayNetworkVpnAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayNetworkVpnAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayNetworkVpnAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayNetworkVpnAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class DeviceprofileGatewayOobIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayOobIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayOobIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayOobIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 node1: Optional['outputs.DeviceprofileGatewayOobIpConfigNode1'] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: If `type`==`static`
        :param _builtins.str ip: If `type`==`static`
        :param _builtins.str netmask: If `type`==`static`
        :param 'DeviceprofileGatewayOobIpConfigNode1Args' node1: For HA Cluster, node1 can have different IP Config
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if node1 is not None:
            pulumi.set(__self__, "node1", node1)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def node1(self) -> Optional['outputs.DeviceprofileGatewayOobIpConfigNode1']:
        """
        For HA Cluster, node1 can have different IP Config
        """
        return pulumi.get(self, "node1")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class DeviceprofileGatewayOobIpConfigNode1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayOobIpConfigNode1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayOobIpConfigNode1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayOobIpConfigNode1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: If `type`==`static`
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class DeviceprofileGatewayPathPreferences(dict):
    def __init__(__self__, *,
                 paths: Optional[Sequence['outputs.DeviceprofileGatewayPathPreferencesPath']] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.str strategy: enum: `ecmp`, `ordered`, `weighted`
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence['outputs.DeviceprofileGatewayPathPreferencesPath']]:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class DeviceprofileGatewayPathPreferencesPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayIp":
            suggest = "gateway_ip"
        elif key == "internetAccess":
            suggest = "internet_access"
        elif key == "targetIps":
            suggest = "target_ips"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPathPreferencesPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPathPreferencesPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPathPreferencesPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 cost: Optional[_builtins.int] = None,
                 disabled: Optional[_builtins.bool] = None,
                 gateway_ip: Optional[_builtins.str] = None,
                 internet_access: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 target_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `local`, `tunnel`, `vpn`, `wan`
        :param _builtins.bool disabled: For SSR Only. `true`, if this specific path is undesired
        :param _builtins.str gateway_ip: Only if `type`==`local`, if a different gateway is desired
        :param _builtins.bool internet_access: Only if `type`==`vpn`, if this vpn path can be used for internet
        :param _builtins.str name: Required when 
                 * `type`==`vpn`: the name of the VPN Path to use 
                 * `type`==`wan`: the name of the WAN interface to use
        :param Sequence[_builtins.str] networks: Required when `type`==`local`
        :param Sequence[_builtins.str] target_ips: If `type`==`local`, if destination IP is to be replaced
        :param _builtins.str wan_name: Optional if `type`==`vpn`
        """
        pulumi.set(__self__, "type", type)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        return pulumi.get(self, "gateway_ip")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `type`==`local`
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        return pulumi.get(self, "target_ips")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        Optional if `type`==`vpn`
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class DeviceprofileGatewayPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeDisableLacp":
            suggest = "ae_disable_lacp"
        elif key == "aeIdx":
            suggest = "ae_idx"
        elif key == "aeLacpForceUp":
            suggest = "ae_lacp_force_up"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dslType":
            suggest = "dsl_type"
        elif key == "dslVci":
            suggest = "dsl_vci"
        elif key == "dslVpi":
            suggest = "dsl_vpi"
        elif key == "ipConfig":
            suggest = "ip_config"
        elif key == "lteApn":
            suggest = "lte_apn"
        elif key == "lteAuth":
            suggest = "lte_auth"
        elif key == "lteBackup":
            suggest = "lte_backup"
        elif key == "ltePassword":
            suggest = "lte_password"
        elif key == "lteUsername":
            suggest = "lte_username"
        elif key == "outerVlanId":
            suggest = "outer_vlan_id"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "preserveDscp":
            suggest = "preserve_dscp"
        elif key == "redundantGroup":
            suggest = "redundant_group"
        elif key == "rethIdx":
            suggest = "reth_idx"
        elif key == "rethNode":
            suggest = "reth_node"
        elif key == "rethNodes":
            suggest = "reth_nodes"
        elif key == "ssrNoVirtualMac":
            suggest = "ssr_no_virtual_mac"
        elif key == "svrPortRange":
            suggest = "svr_port_range"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vpnPaths":
            suggest = "vpn_paths"
        elif key == "wanArpPolicer":
            suggest = "wan_arp_policer"
        elif key == "wanDisableSpeedtest":
            suggest = "wan_disable_speedtest"
        elif key == "wanExtIp":
            suggest = "wan_ext_ip"
        elif key == "wanExtraRoutes":
            suggest = "wan_extra_routes"
        elif key == "wanExtraRoutes6":
            suggest = "wan_extra_routes6"
        elif key == "wanNetworks":
            suggest = "wan_networks"
        elif key == "wanProbeOverride":
            suggest = "wan_probe_override"
        elif key == "wanSourceNat":
            suggest = "wan_source_nat"
        elif key == "wanType":
            suggest = "wan_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: _builtins.str,
                 ae_disable_lacp: Optional[_builtins.bool] = None,
                 ae_idx: Optional[_builtins.str] = None,
                 ae_lacp_force_up: Optional[_builtins.bool] = None,
                 aggregated: Optional[_builtins.bool] = None,
                 critical: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 dsl_type: Optional[_builtins.str] = None,
                 dsl_vci: Optional[_builtins.int] = None,
                 dsl_vpi: Optional[_builtins.int] = None,
                 duplex: Optional[_builtins.str] = None,
                 ip_config: Optional['outputs.DeviceprofileGatewayPortConfigIpConfig'] = None,
                 lte_apn: Optional[_builtins.str] = None,
                 lte_auth: Optional[_builtins.str] = None,
                 lte_backup: Optional[_builtins.bool] = None,
                 lte_password: Optional[_builtins.str] = None,
                 lte_username: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 outer_vlan_id: Optional[_builtins.int] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_network: Optional[_builtins.str] = None,
                 preserve_dscp: Optional[_builtins.bool] = None,
                 redundant: Optional[_builtins.bool] = None,
                 redundant_group: Optional[_builtins.int] = None,
                 reth_idx: Optional[_builtins.str] = None,
                 reth_node: Optional[_builtins.str] = None,
                 reth_nodes: Optional[Sequence[_builtins.str]] = None,
                 speed: Optional[_builtins.str] = None,
                 ssr_no_virtual_mac: Optional[_builtins.bool] = None,
                 svr_port_range: Optional[_builtins.str] = None,
                 traffic_shaping: Optional['outputs.DeviceprofileGatewayPortConfigTrafficShaping'] = None,
                 vlan_id: Optional[_builtins.str] = None,
                 vpn_paths: Optional[Mapping[str, 'outputs.DeviceprofileGatewayPortConfigVpnPaths']] = None,
                 wan_arp_policer: Optional[_builtins.str] = None,
                 wan_disable_speedtest: Optional[_builtins.bool] = None,
                 wan_ext_ip: Optional[_builtins.str] = None,
                 wan_extra_routes: Optional[Mapping[str, 'outputs.DeviceprofileGatewayPortConfigWanExtraRoutes']] = None,
                 wan_extra_routes6: Optional[Mapping[str, 'outputs.DeviceprofileGatewayPortConfigWanExtraRoutes6']] = None,
                 wan_networks: Optional[Sequence[_builtins.str]] = None,
                 wan_probe_override: Optional['outputs.DeviceprofileGatewayPortConfigWanProbeOverride'] = None,
                 wan_source_nat: Optional['outputs.DeviceprofileGatewayPortConfigWanSourceNat'] = None,
                 wan_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        :param _builtins.bool ae_disable_lacp: If `aggregated`==`true`. To disable LCP support for the AE interface
        :param _builtins.str ae_idx: If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        :param _builtins.bool ae_lacp_force_up: For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        :param _builtins.bool critical: To generate port up/down alarm, set it to true
        :param _builtins.str description: Interface Description. Can be a variable (i.e. "{{myvar}}")
        :param _builtins.bool disabled: Port admin up (true) / down (false)
        :param _builtins.str dsl_type: if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        :param _builtins.int dsl_vci: If `wan_type`==`dsl`, 16 bit int
        :param _builtins.int dsl_vpi: If `wan_type`==`dsl`, 8 bit int
        :param _builtins.str duplex: enum: `auto`, `full`, `half`
        :param 'DeviceprofileGatewayPortConfigIpConfigArgs' ip_config: Junos IP Config
        :param _builtins.str lte_apn: If `wan_type`==`lte`
        :param _builtins.str lte_auth: if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        :param _builtins.str lte_password: If `wan_type`==`lte`
        :param _builtins.str lte_username: If `wan_type`==`lte`
        :param _builtins.str name: Name that we'll use to derive config
        :param Sequence[_builtins.str] networks: if `usage`==`lan`, name of the `org.Network` resource
        :param _builtins.int outer_vlan_id: For Q-in-Q
        :param _builtins.str port_network: Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        :param _builtins.bool preserve_dscp: Whether to preserve dscp when sending traffic over VPN (SSR-only)
        :param _builtins.bool redundant: If HA mode
        :param _builtins.int redundant_group: If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        :param _builtins.str reth_idx: For SRX only and if HA Mode
        :param _builtins.str reth_node: If HA mode
        :param Sequence[_builtins.str] reth_nodes: SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        :param _builtins.bool ssr_no_virtual_mac: When SSR is running as VM, this is required on certain hosting platforms
        :param _builtins.str svr_port_range: For SSR only
        :param Mapping[str, 'DeviceprofileGatewayPortConfigVpnPathsArgs'] vpn_paths: Property key is the VPN name
        :param _builtins.str wan_arp_policer: Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        :param _builtins.bool wan_disable_speedtest: If `wan_type`==`wan`, disable speedtest
        :param _builtins.str wan_ext_ip: Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        :param Mapping[str, 'DeviceprofileGatewayPortConfigWanExtraRoutesArgs'] wan_extra_routes: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        :param Mapping[str, 'DeviceprofileGatewayPortConfigWanExtraRoutes6Args'] wan_extra_routes6: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        :param Sequence[_builtins.str] wan_networks: Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        :param 'DeviceprofileGatewayPortConfigWanProbeOverrideArgs' wan_probe_override: Only if `usage`==`wan`
        :param 'DeviceprofileGatewayPortConfigWanSourceNatArgs' wan_source_nat: Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        :param _builtins.str wan_type: Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_force_up is not None:
            pulumi.set(__self__, "ae_lacp_force_up", ae_lacp_force_up)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dsl_type is not None:
            pulumi.set(__self__, "dsl_type", dsl_type)
        if dsl_vci is not None:
            pulumi.set(__self__, "dsl_vci", dsl_vci)
        if dsl_vpi is not None:
            pulumi.set(__self__, "dsl_vpi", dsl_vpi)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if lte_apn is not None:
            pulumi.set(__self__, "lte_apn", lte_apn)
        if lte_auth is not None:
            pulumi.set(__self__, "lte_auth", lte_auth)
        if lte_backup is not None:
            pulumi.set(__self__, "lte_backup", lte_backup)
        if lte_password is not None:
            pulumi.set(__self__, "lte_password", lte_password)
        if lte_username is not None:
            pulumi.set(__self__, "lte_username", lte_username)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if outer_vlan_id is not None:
            pulumi.set(__self__, "outer_vlan_id", outer_vlan_id)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if preserve_dscp is not None:
            pulumi.set(__self__, "preserve_dscp", preserve_dscp)
        if redundant is not None:
            pulumi.set(__self__, "redundant", redundant)
        if redundant_group is not None:
            pulumi.set(__self__, "redundant_group", redundant_group)
        if reth_idx is not None:
            pulumi.set(__self__, "reth_idx", reth_idx)
        if reth_node is not None:
            pulumi.set(__self__, "reth_node", reth_node)
        if reth_nodes is not None:
            pulumi.set(__self__, "reth_nodes", reth_nodes)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssr_no_virtual_mac is not None:
            pulumi.set(__self__, "ssr_no_virtual_mac", ssr_no_virtual_mac)
        if svr_port_range is not None:
            pulumi.set(__self__, "svr_port_range", svr_port_range)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)
        if wan_arp_policer is not None:
            pulumi.set(__self__, "wan_arp_policer", wan_arp_policer)
        if wan_disable_speedtest is not None:
            pulumi.set(__self__, "wan_disable_speedtest", wan_disable_speedtest)
        if wan_ext_ip is not None:
            pulumi.set(__self__, "wan_ext_ip", wan_ext_ip)
        if wan_extra_routes is not None:
            pulumi.set(__self__, "wan_extra_routes", wan_extra_routes)
        if wan_extra_routes6 is not None:
            pulumi.set(__self__, "wan_extra_routes6", wan_extra_routes6)
        if wan_networks is not None:
            pulumi.set(__self__, "wan_networks", wan_networks)
        if wan_probe_override is not None:
            pulumi.set(__self__, "wan_probe_override", wan_probe_override)
        if wan_source_nat is not None:
            pulumi.set(__self__, "wan_source_nat", wan_source_nat)
        if wan_type is not None:
            pulumi.set(__self__, "wan_type", wan_type)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[_builtins.bool]:
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @_builtins.property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[_builtins.str]:
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        return pulumi.get(self, "ae_idx")

    @_builtins.property
    @pulumi.getter(name="aeLacpForceUp")
    def ae_lacp_force_up(self) -> Optional[_builtins.bool]:
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        return pulumi.get(self, "ae_lacp_force_up")

    @_builtins.property
    @pulumi.getter
    def aggregated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aggregated")

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[_builtins.bool]:
        """
        To generate port up/down alarm, set it to true
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Port admin up (true) / down (false)
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="dslType")
    def dsl_type(self) -> Optional[_builtins.str]:
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        return pulumi.get(self, "dsl_type")

    @_builtins.property
    @pulumi.getter(name="dslVci")
    def dsl_vci(self) -> Optional[_builtins.int]:
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        return pulumi.get(self, "dsl_vci")

    @_builtins.property
    @pulumi.getter(name="dslVpi")
    def dsl_vpi(self) -> Optional[_builtins.int]:
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        return pulumi.get(self, "dsl_vpi")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional['outputs.DeviceprofileGatewayPortConfigIpConfig']:
        """
        Junos IP Config
        """
        return pulumi.get(self, "ip_config")

    @_builtins.property
    @pulumi.getter(name="lteApn")
    def lte_apn(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_apn")

    @_builtins.property
    @pulumi.getter(name="lteAuth")
    def lte_auth(self) -> Optional[_builtins.str]:
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "lte_auth")

    @_builtins.property
    @pulumi.getter(name="lteBackup")
    def lte_backup(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "lte_backup")

    @_builtins.property
    @pulumi.getter(name="ltePassword")
    def lte_password(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_password")

    @_builtins.property
    @pulumi.getter(name="lteUsername")
    def lte_username(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_username")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name that we'll use to derive config
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="outerVlanId")
    def outer_vlan_id(self) -> Optional[_builtins.int]:
        """
        For Q-in-Q
        """
        return pulumi.get(self, "outer_vlan_id")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter(name="preserveDscp")
    def preserve_dscp(self) -> Optional[_builtins.bool]:
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        return pulumi.get(self, "preserve_dscp")

    @_builtins.property
    @pulumi.getter
    def redundant(self) -> Optional[_builtins.bool]:
        """
        If HA mode
        """
        return pulumi.get(self, "redundant")

    @_builtins.property
    @pulumi.getter(name="redundantGroup")
    def redundant_group(self) -> Optional[_builtins.int]:
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        return pulumi.get(self, "redundant_group")

    @_builtins.property
    @pulumi.getter(name="rethIdx")
    def reth_idx(self) -> Optional[_builtins.str]:
        """
        For SRX only and if HA Mode
        """
        return pulumi.get(self, "reth_idx")

    @_builtins.property
    @pulumi.getter(name="rethNode")
    def reth_node(self) -> Optional[_builtins.str]:
        """
        If HA mode
        """
        return pulumi.get(self, "reth_node")

    @_builtins.property
    @pulumi.getter(name="rethNodes")
    def reth_nodes(self) -> Optional[Sequence[_builtins.str]]:
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        return pulumi.get(self, "reth_nodes")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="ssrNoVirtualMac")
    def ssr_no_virtual_mac(self) -> Optional[_builtins.bool]:
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        return pulumi.get(self, "ssr_no_virtual_mac")

    @_builtins.property
    @pulumi.getter(name="svrPortRange")
    def svr_port_range(self) -> Optional[_builtins.str]:
        """
        For SSR only
        """
        return pulumi.get(self, "svr_port_range")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.DeviceprofileGatewayPortConfigTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayPortConfigVpnPaths']]:
        """
        Property key is the VPN name
        """
        return pulumi.get(self, "vpn_paths")

    @_builtins.property
    @pulumi.getter(name="wanArpPolicer")
    def wan_arp_policer(self) -> Optional[_builtins.str]:
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        return pulumi.get(self, "wan_arp_policer")

    @_builtins.property
    @pulumi.getter(name="wanDisableSpeedtest")
    def wan_disable_speedtest(self) -> Optional[_builtins.bool]:
        """
        If `wan_type`==`wan`, disable speedtest
        """
        return pulumi.get(self, "wan_disable_speedtest")

    @_builtins.property
    @pulumi.getter(name="wanExtIp")
    def wan_ext_ip(self) -> Optional[_builtins.str]:
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        return pulumi.get(self, "wan_ext_ip")

    @_builtins.property
    @pulumi.getter(name="wanExtraRoutes")
    def wan_extra_routes(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayPortConfigWanExtraRoutes']]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        return pulumi.get(self, "wan_extra_routes")

    @_builtins.property
    @pulumi.getter(name="wanExtraRoutes6")
    def wan_extra_routes6(self) -> Optional[Mapping[str, 'outputs.DeviceprofileGatewayPortConfigWanExtraRoutes6']]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        return pulumi.get(self, "wan_extra_routes6")

    @_builtins.property
    @pulumi.getter(name="wanNetworks")
    def wan_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        return pulumi.get(self, "wan_networks")

    @_builtins.property
    @pulumi.getter(name="wanProbeOverride")
    def wan_probe_override(self) -> Optional['outputs.DeviceprofileGatewayPortConfigWanProbeOverride']:
        """
        Only if `usage`==`wan`
        """
        return pulumi.get(self, "wan_probe_override")

    @_builtins.property
    @pulumi.getter(name="wanSourceNat")
    def wan_source_nat(self) -> Optional['outputs.DeviceprofileGatewayPortConfigWanSourceNat']:
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        return pulumi.get(self, "wan_source_nat")

    @_builtins.property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> Optional[_builtins.str]:
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        return pulumi.get(self, "wan_type")


@pulumi.output_type
class DeviceprofileGatewayPortConfigIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "poserPassword":
            suggest = "poser_password"
        elif key == "pppoeAuth":
            suggest = "pppoe_auth"
        elif key == "pppoeUsername":
            suggest = "pppoe_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfigIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfigIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfigIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 poser_password: Optional[_builtins.str] = None,
                 pppoe_auth: Optional[_builtins.str] = None,
                 pppoe_username: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dns: Except for out-of_band interface (vme/em0/fxp0)
        :param Sequence[_builtins.str] dns_suffixes: Except for out-of_band interface (vme/em0/fxp0)
        :param _builtins.str gateway: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str gateway6: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IPv6 Address (i.e. "2001:db8::1") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str ip: Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str ip6: Interface IPv6 Address (i.e. "2001:db8::123") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str netmask6: Used only if `subnet` is not specified in `networks`. Interface IPv6 Netmask (i.e. "/64") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str network: Optional, the network to be used for mgmt
        :param _builtins.str poser_password: If `type`==`pppoe`
        :param _builtins.str pppoe_auth: if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        :param _builtins.str pppoe_username: If `type`==`pppoe`
        :param _builtins.str type: enum: `dhcp`, `pppoe`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if poser_password is not None:
            pulumi.set(__self__, "poser_password", poser_password)
        if pppoe_auth is not None:
            pulumi.set(__self__, "pppoe_auth", pppoe_auth)
        if pppoe_username is not None:
            pulumi.set(__self__, "pppoe_username", pppoe_username)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IPv6 Address (i.e. "2001:db8::1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        """
        Interface IPv6 Address (i.e. "2001:db8::123") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`. Interface IPv6 Netmask (i.e. "/64") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="poserPassword")
    def poser_password(self) -> Optional[_builtins.str]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "poser_password")

    @_builtins.property
    @pulumi.getter(name="pppoeAuth")
    def pppoe_auth(self) -> Optional[_builtins.str]:
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "pppoe_auth")

    @_builtins.property
    @pulumi.getter(name="pppoeUsername")
    def pppoe_username(self) -> Optional[_builtins.str]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "pppoe_username")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `pppoe`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class DeviceprofileGatewayPortConfigTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfigTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfigTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfigTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param _builtins.int max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class DeviceprofileGatewayPortConfigVpnPaths(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdProfile":
            suggest = "bfd_profile"
        elif key == "bfdUseTunnelMode":
            suggest = "bfd_use_tunnel_mode"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfigVpnPaths. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfigVpnPaths.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfigVpnPaths.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_profile: Optional[_builtins.str] = None,
                 bfd_use_tunnel_mode: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None,
                 role: Optional[_builtins.str] = None,
                 traffic_shaping: Optional['outputs.DeviceprofileGatewayPortConfigVpnPathsTrafficShaping'] = None):
        """
        :param _builtins.str bfd_profile: Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        :param _builtins.bool bfd_use_tunnel_mode: Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        :param _builtins.int preference: Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        :param _builtins.str role: If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @_builtins.property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[_builtins.str]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @_builtins.property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[_builtins.bool]:
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.DeviceprofileGatewayPortConfigVpnPathsTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")


@pulumi.output_type
class DeviceprofileGatewayPortConfigVpnPathsTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfigVpnPathsTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfigVpnPathsTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfigVpnPathsTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param _builtins.int max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class DeviceprofileGatewayPortConfigWanExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "via")


@pulumi.output_type
class DeviceprofileGatewayPortConfigWanExtraRoutes(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "via")


@pulumi.output_type
class DeviceprofileGatewayPortConfigWanProbeOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeProfile":
            suggest = "probe_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfigWanProbeOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfigWanProbeOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfigWanProbeOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip6s: Optional[Sequence[_builtins.str]] = None,
                 ips: Optional[Sequence[_builtins.str]] = None,
                 probe_profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str probe_profile: enum: `broadband`, `lte`
        """
        if ip6s is not None:
            pulumi.set(__self__, "ip6s", ip6s)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if probe_profile is not None:
            pulumi.set(__self__, "probe_profile", probe_profile)

    @_builtins.property
    @pulumi.getter
    def ip6s(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip6s")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="probeProfile")
    def probe_profile(self) -> Optional[_builtins.str]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "probe_profile")


@pulumi.output_type
class DeviceprofileGatewayPortConfigWanSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natPool":
            suggest = "nat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayPortConfigWanSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayPortConfigWanSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayPortConfigWanSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 nat_pool: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Or to disable the source-nat
        :param _builtins.str nat_pool: If alternative nat_pool is desired
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Or to disable the source-nat
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If alternative nat_pool is desired
        """
        return pulumi.get(self, "nat_pool")


@pulumi.output_type
class DeviceprofileGatewayRoutingPolicies(dict):
    def __init__(__self__, *,
                 terms: Optional[Sequence['outputs.DeviceprofileGatewayRoutingPoliciesTerm']] = None):
        """
        :param Sequence['DeviceprofileGatewayRoutingPoliciesTermArgs'] terms: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @_builtins.property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.DeviceprofileGatewayRoutingPoliciesTerm']]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "terms")


@pulumi.output_type
class DeviceprofileGatewayRoutingPoliciesTerm(dict):
    def __init__(__self__, *,
                 actions: Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermActions'] = None,
                 matching: Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermMatching'] = None):
        """
        :param 'DeviceprofileGatewayRoutingPoliciesTermActionsArgs' actions: When used as import policy
        :param 'DeviceprofileGatewayRoutingPoliciesTermMatchingArgs' matching: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermActions']:
        """
        When used as import policy
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermMatching']:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "matching")


@pulumi.output_type
class DeviceprofileGatewayRoutingPoliciesTermActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addCommunities":
            suggest = "add_communities"
        elif key == "addTargetVrfs":
            suggest = "add_target_vrfs"
        elif key == "excludeAsPaths":
            suggest = "exclude_as_paths"
        elif key == "excludeCommunities":
            suggest = "exclude_communities"
        elif key == "exportCommunities":
            suggest = "export_communities"
        elif key == "localPreference":
            suggest = "local_preference"
        elif key == "prependAsPaths":
            suggest = "prepend_as_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayRoutingPoliciesTermActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept: Optional[_builtins.bool] = None,
                 add_communities: Optional[Sequence[_builtins.str]] = None,
                 add_target_vrfs: Optional[Sequence[_builtins.str]] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 exclude_as_paths: Optional[Sequence[_builtins.str]] = None,
                 exclude_communities: Optional[Sequence[_builtins.str]] = None,
                 export_communities: Optional[Sequence[_builtins.str]] = None,
                 local_preference: Optional[_builtins.str] = None,
                 prepend_as_paths: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] add_target_vrfs: For SSR, hub decides how VRF routes are leaked on spoke
        :param Sequence[_builtins.str] communities: When used as export policy, optional
        :param Sequence[_builtins.str] exclude_as_paths: When used as export policy, optional. To exclude certain AS
        :param Sequence[_builtins.str] export_communities: When used as export policy, optional
        :param _builtins.str local_preference: Optional, for an import policy, local_preference can be changed
        :param Sequence[_builtins.str] prepend_as_paths: When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if add_communities is not None:
            pulumi.set(__self__, "add_communities", add_communities)
        if add_target_vrfs is not None:
            pulumi.set(__self__, "add_target_vrfs", add_target_vrfs)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if exclude_as_paths is not None:
            pulumi.set(__self__, "exclude_as_paths", exclude_as_paths)
        if exclude_communities is not None:
            pulumi.set(__self__, "exclude_communities", exclude_communities)
        if export_communities is not None:
            pulumi.set(__self__, "export_communities", export_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if prepend_as_paths is not None:
            pulumi.set(__self__, "prepend_as_paths", prepend_as_paths)

    @_builtins.property
    @pulumi.getter
    def accept(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "accept")

    @_builtins.property
    @pulumi.getter(name="addCommunities")
    def add_communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "add_communities")

    @_builtins.property
    @pulumi.getter(name="addTargetVrfs")
    def add_target_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        return pulumi.get(self, "add_target_vrfs")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter(name="excludeAsPaths")
    def exclude_as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional. To exclude certain AS
        """
        return pulumi.get(self, "exclude_as_paths")

    @_builtins.property
    @pulumi.getter(name="excludeCommunities")
    def exclude_communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_communities")

    @_builtins.property
    @pulumi.getter(name="exportCommunities")
    def export_communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "export_communities")

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[_builtins.str]:
        """
        Optional, for an import policy, local_preference can be changed
        """
        return pulumi.get(self, "local_preference")

    @_builtins.property
    @pulumi.getter(name="prependAsPaths")
    def prepend_as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        return pulumi.get(self, "prepend_as_paths")


@pulumi.output_type
class DeviceprofileGatewayRoutingPoliciesTermMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asPaths":
            suggest = "as_paths"
        elif key == "routeExists":
            suggest = "route_exists"
        elif key == "vpnNeighborMacs":
            suggest = "vpn_neighbor_macs"
        elif key == "vpnPathSla":
            suggest = "vpn_path_sla"
        elif key == "vpnPaths":
            suggest = "vpn_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayRoutingPoliciesTermMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_paths: Optional[Sequence[_builtins.str]] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 prefixes: Optional[Sequence[_builtins.str]] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 route_exists: Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists'] = None,
                 vpn_neighbor_macs: Optional[Sequence[_builtins.str]] = None,
                 vpn_path_sla: Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla'] = None,
                 vpn_paths: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] as_paths: takes regular expression
        :param Sequence[_builtins.str] prefixes: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        :param Sequence[_builtins.str] protocols: `direct`, `bgp`, `osp`, `static`, `aggregate`...
        :param Sequence[_builtins.str] vpn_neighbor_macs: overlay-facing criteria (used for bgp_config where via=vpn)
        :param Sequence[_builtins.str] vpn_paths: overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_exists is not None:
            pulumi.set(__self__, "route_exists", route_exists)
        if vpn_neighbor_macs is not None:
            pulumi.set(__self__, "vpn_neighbor_macs", vpn_neighbor_macs)
        if vpn_path_sla is not None:
            pulumi.set(__self__, "vpn_path_sla", vpn_path_sla)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        takes regular expression
        """
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "prefixes")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeExists")
    def route_exists(self) -> Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists']:
        return pulumi.get(self, "route_exists")

    @_builtins.property
    @pulumi.getter(name="vpnNeighborMacs")
    def vpn_neighbor_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        return pulumi.get(self, "vpn_neighbor_macs")

    @_builtins.property
    @pulumi.getter(name="vpnPathSla")
    def vpn_path_sla(self) -> Optional['outputs.DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla']:
        return pulumi.get(self, "vpn_path_sla")

    @_builtins.property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        return pulumi.get(self, "vpn_paths")


@pulumi.output_type
class DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vrfName":
            suggest = "vrf_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route: Optional[_builtins.str] = None,
                 vrf_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str vrf_name: Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        if route is not None:
            pulumi.set(__self__, "route", route)
        if vrf_name is not None:
            pulumi.set(__self__, "vrf_name", vrf_name)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> Optional[_builtins.str]:
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        return pulumi.get(self, "vrf_name")


@pulumi.output_type
class DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxJitter":
            suggest = "max_jitter"
        elif key == "maxLatency":
            suggest = "max_latency"
        elif key == "maxLoss":
            suggest = "max_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_jitter: Optional[_builtins.int] = None,
                 max_latency: Optional[_builtins.int] = None,
                 max_loss: Optional[_builtins.int] = None):
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)

    @_builtins.property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_jitter")

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_latency")

    @_builtins.property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_loss")


@pulumi.output_type
class DeviceprofileGatewayServicePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localRouting":
            suggest = "local_routing"
        elif key == "pathPreference":
            suggest = "path_preference"
        elif key == "servicepolicyId":
            suggest = "servicepolicy_id"
        elif key == "sslProxy":
            suggest = "ssl_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayServicePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayServicePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayServicePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 antivirus: Optional['outputs.DeviceprofileGatewayServicePolicyAntivirus'] = None,
                 appqoe: Optional['outputs.DeviceprofileGatewayServicePolicyAppqoe'] = None,
                 ewfs: Optional[Sequence['outputs.DeviceprofileGatewayServicePolicyEwf']] = None,
                 idp: Optional['outputs.DeviceprofileGatewayServicePolicyIdp'] = None,
                 local_routing: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path_preference: Optional[_builtins.str] = None,
                 servicepolicy_id: Optional[_builtins.str] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 ssl_proxy: Optional['outputs.DeviceprofileGatewayServicePolicySslProxy'] = None,
                 tenants: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str action: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        :param 'DeviceprofileGatewayServicePolicyAntivirusArgs' antivirus: For SRX-only
        :param 'DeviceprofileGatewayServicePolicyAppqoeArgs' appqoe: For SRX Only
        :param _builtins.bool local_routing: access within the same VRF
        :param _builtins.str name: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        :param _builtins.str path_preference: By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        :param _builtins.str servicepolicy_id: Used to link servicepolicy defined at org level and overwrite some attributes
        :param Sequence[_builtins.str] services: Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        :param 'DeviceprofileGatewayServicePolicySslProxyArgs' ssl_proxy: For SRX-only
        :param Sequence[_builtins.str] tenants: Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if appqoe is not None:
            pulumi.set(__self__, "appqoe", appqoe)
        if ewfs is not None:
            pulumi.set(__self__, "ewfs", ewfs)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if local_routing is not None:
            pulumi.set(__self__, "local_routing", local_routing)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_preference is not None:
            pulumi.set(__self__, "path_preference", path_preference)
        if servicepolicy_id is not None:
            pulumi.set(__self__, "servicepolicy_id", servicepolicy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssl_proxy is not None:
            pulumi.set(__self__, "ssl_proxy", ssl_proxy)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional['outputs.DeviceprofileGatewayServicePolicyAntivirus']:
        """
        For SRX-only
        """
        return pulumi.get(self, "antivirus")

    @_builtins.property
    @pulumi.getter
    def appqoe(self) -> Optional['outputs.DeviceprofileGatewayServicePolicyAppqoe']:
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @_builtins.property
    @pulumi.getter
    def ewfs(self) -> Optional[Sequence['outputs.DeviceprofileGatewayServicePolicyEwf']]:
        return pulumi.get(self, "ewfs")

    @_builtins.property
    @pulumi.getter
    def idp(self) -> Optional['outputs.DeviceprofileGatewayServicePolicyIdp']:
        return pulumi.get(self, "idp")

    @_builtins.property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> Optional[_builtins.bool]:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> Optional[_builtins.str]:
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @_builtins.property
    @pulumi.getter(name="servicepolicyId")
    def servicepolicy_id(self) -> Optional[_builtins.str]:
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        return pulumi.get(self, "servicepolicy_id")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sslProxy")
    def ssl_proxy(self) -> Optional['outputs.DeviceprofileGatewayServicePolicySslProxy']:
        """
        For SRX-only
        """
        return pulumi.get(self, "ssl_proxy")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        return pulumi.get(self, "tenants")


@pulumi.output_type
class DeviceprofileGatewayServicePolicyAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avprofileId":
            suggest = "avprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayServicePolicyAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayServicePolicyAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayServicePolicyAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avprofile_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[_builtins.str]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class DeviceprofileGatewayServicePolicyAppqoe(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileGatewayServicePolicyEwf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "blockMessage":
            suggest = "block_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayServicePolicyEwf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayServicePolicyEwf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayServicePolicyEwf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 block_message: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "block_message")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class DeviceprofileGatewayServicePolicyIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "idpprofileId":
            suggest = "idpprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayServicePolicyIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayServicePolicyIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayServicePolicyIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idpprofile_id: Optional[_builtins.str] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param _builtins.str profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[_builtins.str]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class DeviceprofileGatewayServicePolicySslProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ciphersCategory":
            suggest = "ciphers_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayServicePolicySslProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayServicePolicySslProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayServicePolicySslProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers_category: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[_builtins.str]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoProvision":
            suggest = "auto_provision"
        elif key == "ikeLifetime":
            suggest = "ike_lifetime"
        elif key == "ikeMode":
            suggest = "ike_mode"
        elif key == "ikeProposals":
            suggest = "ike_proposals"
        elif key == "ipsecLifetime":
            suggest = "ipsec_lifetime"
        elif key == "ipsecProposals":
            suggest = "ipsec_proposals"
        elif key == "localId":
            suggest = "local_id"
        elif key == "localSubnets":
            suggest = "local_subnets"
        elif key == "remoteSubnets":
            suggest = "remote_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_provision: Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvision'] = None,
                 ike_lifetime: Optional[_builtins.int] = None,
                 ike_mode: Optional[_builtins.str] = None,
                 ike_proposals: Optional[Sequence['outputs.DeviceprofileGatewayTunnelConfigsIkeProposal']] = None,
                 ipsec_lifetime: Optional[_builtins.int] = None,
                 ipsec_proposals: Optional[Sequence['outputs.DeviceprofileGatewayTunnelConfigsIpsecProposal']] = None,
                 local_id: Optional[_builtins.str] = None,
                 local_subnets: Optional[Sequence[_builtins.str]] = None,
                 mode: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 primary: Optional['outputs.DeviceprofileGatewayTunnelConfigsPrimary'] = None,
                 probe: Optional['outputs.DeviceprofileGatewayTunnelConfigsProbe'] = None,
                 protocol: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 psk: Optional[_builtins.str] = None,
                 remote_subnets: Optional[Sequence[_builtins.str]] = None,
                 secondary: Optional['outputs.DeviceprofileGatewayTunnelConfigsSecondary'] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param 'DeviceprofileGatewayTunnelConfigsAutoProvisionArgs' auto_provision: Auto Provisioning configuration for the tunne. This takes precedence over the `primary` and `secondary` nodes.
        :param _builtins.int ike_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param _builtins.str ike_mode: Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        :param Sequence['DeviceprofileGatewayTunnelConfigsIkeProposalArgs'] ike_proposals: If `provider`==`custom-ipsec`
        :param _builtins.int ipsec_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param Sequence['DeviceprofileGatewayTunnelConfigsIpsecProposalArgs'] ipsec_proposals: Only if  `provider`==`custom-ipsec`
        :param _builtins.str local_id: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param Sequence[_builtins.str] local_subnets: List of Local protected subnet for policy-based IPSec negotiation
        :param _builtins.str mode: Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        :param Sequence[_builtins.str] networks: If `provider`==`custom-ipsec` or `provider`==`prisma-ipsec`, networks reachable via this tunnel
        :param 'DeviceprofileGatewayTunnelConfigsPrimaryArgs' primary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param 'DeviceprofileGatewayTunnelConfigsProbeArgs' probe: Only if `provider`==`custom-ipsec`
        :param _builtins.str protocol: Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        :param _builtins.str provider: Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `prisma-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        :param _builtins.str psk: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param Sequence[_builtins.str] remote_subnets: List of Remote protected subnet for policy-based IPSec negotiation
        :param 'DeviceprofileGatewayTunnelConfigsSecondaryArgs' secondary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param _builtins.str version: Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        if auto_provision is not None:
            pulumi.set(__self__, "auto_provision", auto_provision)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_mode is not None:
            pulumi.set(__self__, "ike_mode", ike_mode)
        if ike_proposals is not None:
            pulumi.set(__self__, "ike_proposals", ike_proposals)
        if ipsec_lifetime is not None:
            pulumi.set(__self__, "ipsec_lifetime", ipsec_lifetime)
        if ipsec_proposals is not None:
            pulumi.set(__self__, "ipsec_proposals", ipsec_proposals)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if local_subnets is not None:
            pulumi.set(__self__, "local_subnets", local_subnets)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if probe is not None:
            pulumi.set(__self__, "probe", probe)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if remote_subnets is not None:
            pulumi.set(__self__, "remote_subnets", remote_subnets)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvision']:
        """
        Auto Provisioning configuration for the tunne. This takes precedence over the `primary` and `secondary` nodes.
        """
        return pulumi.get(self, "auto_provision")

    @_builtins.property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[_builtins.int]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ike_lifetime")

    @_builtins.property
    @pulumi.getter(name="ikeMode")
    def ike_mode(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        return pulumi.get(self, "ike_mode")

    @_builtins.property
    @pulumi.getter(name="ikeProposals")
    def ike_proposals(self) -> Optional[Sequence['outputs.DeviceprofileGatewayTunnelConfigsIkeProposal']]:
        """
        If `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ike_proposals")

    @_builtins.property
    @pulumi.getter(name="ipsecLifetime")
    def ipsec_lifetime(self) -> Optional[_builtins.int]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ipsec_lifetime")

    @_builtins.property
    @pulumi.getter(name="ipsecProposals")
    def ipsec_proposals(self) -> Optional[Sequence['outputs.DeviceprofileGatewayTunnelConfigsIpsecProposal']]:
        """
        Only if  `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ipsec_proposals")

    @_builtins.property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "local_id")

    @_builtins.property
    @pulumi.getter(name="localSubnets")
    def local_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Local protected subnet for policy-based IPSec negotiation
        """
        return pulumi.get(self, "local_subnets")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `provider`==`custom-ipsec` or `provider`==`prisma-ipsec`, networks reachable via this tunnel
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsPrimary']:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def probe(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsProbe']:
        """
        Only if `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "probe")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `prisma-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "psk")

    @_builtins.property
    @pulumi.getter(name="remoteSubnets")
    def remote_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Remote protected subnet for policy-based IPSec negotiation
        """
        return pulumi.get(self, "remote_subnets")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsSecondary']:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsAutoProvision(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConnection":
            suggest = "service_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsAutoProvision. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsAutoProvision.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsAutoProvision.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider: _builtins.str,
                 enabled: Optional[_builtins.bool] = None,
                 latlng: Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng'] = None,
                 primary: Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary'] = None,
                 region: Optional[_builtins.str] = None,
                 secondary: Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary'] = None,
                 service_connection: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider: enum: `jse-ipsec`, `zscaler-ipsec`
        :param _builtins.bool enabled: Enable auto provisioning for the tunnel. If enabled, the `primary` and `secondary` nodes will be ignored.
        :param 'DeviceprofileGatewayTunnelConfigsAutoProvisionLatlngArgs' latlng: API override for POP selection
        :param _builtins.str region: API override for POP selection in the case user wants to override the auto discovery of remote network location and force the tunnel to use the specified peer location.
        :param _builtins.str service_connection: if `provider`==`prisma-ipsec`. By default, we'll use the location of the site to determine the optimal Remote Network location, optionally, service_connection can be considered, then we'll also consider this along with the site location. Define service_connection if the traffic is to be routed to a specific service connection. This field takes a service connection name that is configured in the Prisma cloud, Prisma Access Setup > Service Connections.
        """
        pulumi.set(__self__, "provider", provider)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if latlng is not None:
            pulumi.set(__self__, "latlng", latlng)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if service_connection is not None:
            pulumi.set(__self__, "service_connection", service_connection)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable auto provisioning for the tunnel. If enabled, the `primary` and `secondary` nodes will be ignored.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def latlng(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng']:
        """
        API override for POP selection
        """
        return pulumi.get(self, "latlng")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary']:
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        API override for POP selection in the case user wants to override the auto discovery of remote network location and force the tunnel to use the specified peer location.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary']:
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter(name="serviceConnection")
    def service_connection(self) -> Optional[_builtins.str]:
        """
        if `provider`==`prisma-ipsec`. By default, we'll use the location of the site to determine the optimal Remote Network location, optionally, service_connection can be considered, then we'll also consider this along with the site location. Define service_connection if the traffic is to be routed to a specific service connection. This field takes a service connection name that is configured in the Prisma cloud, Prisma Access Setup > Service Connections.
        """
        return pulumi.get(self, "service_connection")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        return pulumi.get(self, "lng")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIps":
            suggest = "probe_ips"
        elif key == "wanNames":
            suggest = "wan_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIps":
            suggest = "probe_ips"
        elif key == "wanNames":
            suggest = "wan_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsIkeProposal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authAlgo":
            suggest = "auth_algo"
        elif key == "dhGroup":
            suggest = "dh_group"
        elif key == "encAlgo":
            suggest = "enc_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsIkeProposal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsIkeProposal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsIkeProposal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_algo: Optional[_builtins.str] = None,
                 dh_group: Optional[_builtins.str] = None,
                 enc_algo: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_algo: enum: `md5`, `sha1`, `sha2`
        :param _builtins.str dh_group: enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param _builtins.str enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[_builtins.str]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[_builtins.str]:
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @_builtins.property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[_builtins.str]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsIpsecProposal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authAlgo":
            suggest = "auth_algo"
        elif key == "dhGroup":
            suggest = "dh_group"
        elif key == "encAlgo":
            suggest = "enc_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsIpsecProposal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsIpsecProposal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsIpsecProposal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_algo: Optional[_builtins.str] = None,
                 dh_group: Optional[_builtins.str] = None,
                 enc_algo: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_algo: enum: `md5`, `sha1`, `sha2`
        :param _builtins.str dh_group: Only if `provider`==`custom-ipsec`. enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param _builtins.str enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[_builtins.str]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @_builtins.property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[_builtins.str]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanNames":
            suggest = "wan_names"
        elif key == "internalIps":
            suggest = "internal_ips"
        elif key == "probeIps":
            suggest = "probe_ips"
        elif key == "remoteIds":
            suggest = "remote_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 wan_names: Sequence[_builtins.str],
                 internal_ips: Optional[Sequence[_builtins.str]] = None,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 remote_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param Sequence[_builtins.str] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "wan_names")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsProbe(dict):
    def __init__(__self__, *,
                 interval: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int interval: How often to trigger the probe
        :param _builtins.int threshold: Number of consecutive misses before declaring the tunnel down
        :param _builtins.int timeout: Time within which to complete the connectivity check
        :param _builtins.str type: enum: `http`, `icmp`
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        How often to trigger the probe
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive misses before declaring the tunnel down
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Time within which to complete the connectivity check
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DeviceprofileGatewayTunnelConfigsSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanNames":
            suggest = "wan_names"
        elif key == "internalIps":
            suggest = "internal_ips"
        elif key == "probeIps":
            suggest = "probe_ips"
        elif key == "remoteIds":
            suggest = "remote_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelConfigsSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelConfigsSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelConfigsSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 wan_names: Sequence[_builtins.str],
                 internal_ips: Optional[Sequence[_builtins.str]] = None,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 remote_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param Sequence[_builtins.str] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "wan_names")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")


@pulumi.output_type
class DeviceprofileGatewayTunnelProviderOptions(dict):
    def __init__(__self__, *,
                 jse: Optional['outputs.DeviceprofileGatewayTunnelProviderOptionsJse'] = None,
                 prisma: Optional['outputs.DeviceprofileGatewayTunnelProviderOptionsPrisma'] = None,
                 zscaler: Optional['outputs.DeviceprofileGatewayTunnelProviderOptionsZscaler'] = None):
        """
        :param 'DeviceprofileGatewayTunnelProviderOptionsJseArgs' jse: For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        :param 'DeviceprofileGatewayTunnelProviderOptionsZscalerArgs' zscaler: For zscaler-ipsec and zscaler-gre
        """
        if jse is not None:
            pulumi.set(__self__, "jse", jse)
        if prisma is not None:
            pulumi.set(__self__, "prisma", prisma)
        if zscaler is not None:
            pulumi.set(__self__, "zscaler", zscaler)

    @_builtins.property
    @pulumi.getter
    def jse(self) -> Optional['outputs.DeviceprofileGatewayTunnelProviderOptionsJse']:
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        return pulumi.get(self, "jse")

    @_builtins.property
    @pulumi.getter
    def prisma(self) -> Optional['outputs.DeviceprofileGatewayTunnelProviderOptionsPrisma']:
        return pulumi.get(self, "prisma")

    @_builtins.property
    @pulumi.getter
    def zscaler(self) -> Optional['outputs.DeviceprofileGatewayTunnelProviderOptionsZscaler']:
        """
        For zscaler-ipsec and zscaler-gre
        """
        return pulumi.get(self, "zscaler")


@pulumi.output_type
class DeviceprofileGatewayTunnelProviderOptionsJse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numUsers":
            suggest = "num_users"
        elif key == "orgName":
            suggest = "org_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelProviderOptionsJse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsJse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsJse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_users: Optional[_builtins.int] = None,
                 org_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str org_name: JSE Organization name
        """
        if num_users is not None:
            pulumi.set(__self__, "num_users", num_users)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)

    @_builtins.property
    @pulumi.getter(name="numUsers")
    def num_users(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_users")

    @_builtins.property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[_builtins.str]:
        """
        JSE Organization name
        """
        return pulumi.get(self, "org_name")


@pulumi.output_type
class DeviceprofileGatewayTunnelProviderOptionsPrisma(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountName":
            suggest = "service_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelProviderOptionsPrisma. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsPrisma.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsPrisma.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_name: For prisma-ipsec, service account name to used for tunnel auto provisioning
        """
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)

    @_builtins.property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[_builtins.str]:
        """
        For prisma-ipsec, service account name to used for tunnel auto provisioning
        """
        return pulumi.get(self, "service_account_name")


@pulumi.output_type
class DeviceprofileGatewayTunnelProviderOptionsZscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aupBlockInternetUntilAccepted":
            suggest = "aup_block_internet_until_accepted"
        elif key == "aupEnabled":
            suggest = "aup_enabled"
        elif key == "aupForceSslInspection":
            suggest = "aup_force_ssl_inspection"
        elif key == "aupTimeoutInDays":
            suggest = "aup_timeout_in_days"
        elif key == "authRequired":
            suggest = "auth_required"
        elif key == "cautionEnabled":
            suggest = "caution_enabled"
        elif key == "dnBandwidth":
            suggest = "dn_bandwidth"
        elif key == "idleTimeInMinutes":
            suggest = "idle_time_in_minutes"
        elif key == "ofwEnabled":
            suggest = "ofw_enabled"
        elif key == "subLocations":
            suggest = "sub_locations"
        elif key == "surrogateIp":
            suggest = "surrogate_ip"
        elif key == "surrogateIpEnforcedForKnownBrowsers":
            suggest = "surrogate_ip_enforced_for_known_browsers"
        elif key == "surrogateRefreshTimeInMinutes":
            suggest = "surrogate_refresh_time_in_minutes"
        elif key == "upBandwidth":
            suggest = "up_bandwidth"
        elif key == "xffForwardEnabled":
            suggest = "xff_forward_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelProviderOptionsZscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsZscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsZscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[_builtins.bool] = None,
                 aup_enabled: Optional[_builtins.bool] = None,
                 aup_force_ssl_inspection: Optional[_builtins.bool] = None,
                 aup_timeout_in_days: Optional[_builtins.int] = None,
                 auth_required: Optional[_builtins.bool] = None,
                 caution_enabled: Optional[_builtins.bool] = None,
                 dn_bandwidth: Optional[_builtins.float] = None,
                 idle_time_in_minutes: Optional[_builtins.int] = None,
                 ofw_enabled: Optional[_builtins.bool] = None,
                 sub_locations: Optional[Sequence['outputs.DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation']] = None,
                 surrogate_ip: Optional[_builtins.bool] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[_builtins.bool] = None,
                 surrogate_refresh_time_in_minutes: Optional[_builtins.int] = None,
                 up_bandwidth: Optional[_builtins.float] = None,
                 xff_forward_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param _builtins.bool aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param _builtins.int aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param _builtins.bool auth_required: Enable this option to enforce user authentication
        :param _builtins.bool caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param _builtins.float dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.int idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param _builtins.bool ofw_enabled: If `true`, enable the firewall control option
        :param Sequence['DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocationArgs'] sub_locations: `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        :param _builtins.bool surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param _builtins.bool surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param _builtins.int surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param _builtins.float up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.bool xff_forward_enabled: Location uses proxy chaining to forward traffic
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if sub_locations is not None:
            pulumi.set(__self__, "sub_locations", sub_locations)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)
        if xff_forward_enabled is not None:
            pulumi.set(__self__, "xff_forward_enabled", xff_forward_enabled)

    @_builtins.property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @_builtins.property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @_builtins.property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[_builtins.bool]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @_builtins.property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[_builtins.int]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @_builtins.property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[_builtins.bool]:
        """
        Enable this option to enforce user authentication
        """
        return pulumi.get(self, "auth_required")

    @_builtins.property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @_builtins.property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @_builtins.property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @_builtins.property
    @pulumi.getter(name="subLocations")
    def sub_locations(self) -> Optional[Sequence['outputs.DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation']]:
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        return pulumi.get(self, "sub_locations")

    @_builtins.property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @_builtins.property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @_builtins.property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @_builtins.property
    @pulumi.getter(name="xffForwardEnabled")
    def xff_forward_enabled(self) -> Optional[_builtins.bool]:
        """
        Location uses proxy chaining to forward traffic
        """
        return pulumi.get(self, "xff_forward_enabled")


@pulumi.output_type
class DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aupBlockInternetUntilAccepted":
            suggest = "aup_block_internet_until_accepted"
        elif key == "aupEnabled":
            suggest = "aup_enabled"
        elif key == "aupForceSslInspection":
            suggest = "aup_force_ssl_inspection"
        elif key == "aupTimeoutInDays":
            suggest = "aup_timeout_in_days"
        elif key == "authRequired":
            suggest = "auth_required"
        elif key == "cautionEnabled":
            suggest = "caution_enabled"
        elif key == "dnBandwidth":
            suggest = "dn_bandwidth"
        elif key == "idleTimeInMinutes":
            suggest = "idle_time_in_minutes"
        elif key == "ofwEnabled":
            suggest = "ofw_enabled"
        elif key == "surrogateIp":
            suggest = "surrogate_ip"
        elif key == "surrogateIpEnforcedForKnownBrowsers":
            suggest = "surrogate_ip_enforced_for_known_browsers"
        elif key == "surrogateRefreshTimeInMinutes":
            suggest = "surrogate_refresh_time_in_minutes"
        elif key == "upBandwidth":
            suggest = "up_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[_builtins.bool] = None,
                 aup_enabled: Optional[_builtins.bool] = None,
                 aup_force_ssl_inspection: Optional[_builtins.bool] = None,
                 aup_timeout_in_days: Optional[_builtins.int] = None,
                 auth_required: Optional[_builtins.bool] = None,
                 caution_enabled: Optional[_builtins.bool] = None,
                 dn_bandwidth: Optional[_builtins.float] = None,
                 idle_time_in_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 ofw_enabled: Optional[_builtins.bool] = None,
                 surrogate_ip: Optional[_builtins.bool] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[_builtins.bool] = None,
                 surrogate_refresh_time_in_minutes: Optional[_builtins.int] = None,
                 up_bandwidth: Optional[_builtins.float] = None):
        """
        :param _builtins.bool aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param _builtins.bool aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param _builtins.int aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param _builtins.bool auth_required: Enable this option to authenticate users
        :param _builtins.bool caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param _builtins.float dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.int idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param _builtins.str name: Network name
        :param _builtins.bool ofw_enabled: If `true`, enable the firewall control option
        :param _builtins.bool surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param _builtins.bool surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param _builtins.int surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param _builtins.float up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)

    @_builtins.property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @_builtins.property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @_builtins.property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[_builtins.bool]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @_builtins.property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[_builtins.int]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @_builtins.property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[_builtins.bool]:
        """
        Enable this option to authenticate users
        """
        return pulumi.get(self, "auth_required")

    @_builtins.property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @_builtins.property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @_builtins.property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @_builtins.property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @_builtins.property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @_builtins.property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")


@pulumi.output_type
class DeviceprofileGatewayVrfConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeviceprofileGatewayVrfInstances(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[_builtins.str]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class EvpnTopologyEvpnOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoLoopbackSubnet":
            suggest = "auto_loopback_subnet"
        elif key == "autoLoopbackSubnet6":
            suggest = "auto_loopback_subnet6"
        elif key == "autoRouterIdSubnet":
            suggest = "auto_router_id_subnet"
        elif key == "autoRouterIdSubnet6":
            suggest = "auto_router_id_subnet6"
        elif key == "coreAsBorder":
            suggest = "core_as_border"
        elif key == "enableInbandZtp":
            suggest = "enable_inband_ztp"
        elif key == "perVlanVgaV4Mac":
            suggest = "per_vlan_vga_v4_mac"
        elif key == "perVlanVgaV6Mac":
            suggest = "per_vlan_vga_v6_mac"
        elif key == "routedAt":
            suggest = "routed_at"
        elif key == "vsInstances":
            suggest = "vs_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvpnTopologyEvpnOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvpnTopologyEvpnOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvpnTopologyEvpnOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_loopback_subnet: Optional[_builtins.str] = None,
                 auto_loopback_subnet6: Optional[_builtins.str] = None,
                 auto_router_id_subnet: Optional[_builtins.str] = None,
                 auto_router_id_subnet6: Optional[_builtins.str] = None,
                 core_as_border: Optional[_builtins.bool] = None,
                 enable_inband_ztp: Optional[_builtins.bool] = None,
                 overlay: Optional['outputs.EvpnTopologyEvpnOptionsOverlay'] = None,
                 per_vlan_vga_v4_mac: Optional[_builtins.bool] = None,
                 per_vlan_vga_v6_mac: Optional[_builtins.bool] = None,
                 routed_at: Optional[_builtins.str] = None,
                 underlay: Optional['outputs.EvpnTopologyEvpnOptionsUnderlay'] = None,
                 vs_instances: Optional[Mapping[str, 'outputs.EvpnTopologyEvpnOptionsVsInstances']] = None):
        """
        :param _builtins.str auto_loopback_subnet: Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        :param _builtins.str auto_loopback_subnet6: Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        :param _builtins.str auto_router_id_subnet: Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        :param _builtins.str auto_router_id_subnet6: Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        :param _builtins.bool core_as_border: Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        :param _builtins.bool enable_inband_ztp: if the mangement traffic goes inbnd, during installation, only the border/core switches are connected to the Internet to allow initial configuration to be pushed down and leave the downstream access switches stay in the Factory Default state enabling inband-ztp allows upstream switches to use LLDP to assign IP and gives Internet to downstream switches in that state
        :param _builtins.bool per_vlan_vga_v4_mac: Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        :param _builtins.bool per_vlan_vga_v6_mac: Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        :param _builtins.str routed_at: optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        :param Mapping[str, 'EvpnTopologyEvpnOptionsVsInstancesArgs'] vs_instances: Optional, for EX9200 only to segregate virtual-switches
        """
        if auto_loopback_subnet is not None:
            pulumi.set(__self__, "auto_loopback_subnet", auto_loopback_subnet)
        if auto_loopback_subnet6 is not None:
            pulumi.set(__self__, "auto_loopback_subnet6", auto_loopback_subnet6)
        if auto_router_id_subnet is not None:
            pulumi.set(__self__, "auto_router_id_subnet", auto_router_id_subnet)
        if auto_router_id_subnet6 is not None:
            pulumi.set(__self__, "auto_router_id_subnet6", auto_router_id_subnet6)
        if core_as_border is not None:
            pulumi.set(__self__, "core_as_border", core_as_border)
        if enable_inband_ztp is not None:
            pulumi.set(__self__, "enable_inband_ztp", enable_inband_ztp)
        if overlay is not None:
            pulumi.set(__self__, "overlay", overlay)
        if per_vlan_vga_v4_mac is not None:
            pulumi.set(__self__, "per_vlan_vga_v4_mac", per_vlan_vga_v4_mac)
        if per_vlan_vga_v6_mac is not None:
            pulumi.set(__self__, "per_vlan_vga_v6_mac", per_vlan_vga_v6_mac)
        if routed_at is not None:
            pulumi.set(__self__, "routed_at", routed_at)
        if underlay is not None:
            pulumi.set(__self__, "underlay", underlay)
        if vs_instances is not None:
            pulumi.set(__self__, "vs_instances", vs_instances)

    @_builtins.property
    @pulumi.getter(name="autoLoopbackSubnet")
    def auto_loopback_subnet(self) -> Optional[_builtins.str]:
        """
        Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        """
        return pulumi.get(self, "auto_loopback_subnet")

    @_builtins.property
    @pulumi.getter(name="autoLoopbackSubnet6")
    def auto_loopback_subnet6(self) -> Optional[_builtins.str]:
        """
        Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
        """
        return pulumi.get(self, "auto_loopback_subnet6")

    @_builtins.property
    @pulumi.getter(name="autoRouterIdSubnet")
    def auto_router_id_subnet(self) -> Optional[_builtins.str]:
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        return pulumi.get(self, "auto_router_id_subnet")

    @_builtins.property
    @pulumi.getter(name="autoRouterIdSubnet6")
    def auto_router_id_subnet6(self) -> Optional[_builtins.str]:
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        return pulumi.get(self, "auto_router_id_subnet6")

    @_builtins.property
    @pulumi.getter(name="coreAsBorder")
    def core_as_border(self) -> Optional[_builtins.bool]:
        """
        Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        """
        return pulumi.get(self, "core_as_border")

    @_builtins.property
    @pulumi.getter(name="enableInbandZtp")
    def enable_inband_ztp(self) -> Optional[_builtins.bool]:
        """
        if the mangement traffic goes inbnd, during installation, only the border/core switches are connected to the Internet to allow initial configuration to be pushed down and leave the downstream access switches stay in the Factory Default state enabling inband-ztp allows upstream switches to use LLDP to assign IP and gives Internet to downstream switches in that state
        """
        return pulumi.get(self, "enable_inband_ztp")

    @_builtins.property
    @pulumi.getter
    def overlay(self) -> Optional['outputs.EvpnTopologyEvpnOptionsOverlay']:
        return pulumi.get(self, "overlay")

    @_builtins.property
    @pulumi.getter(name="perVlanVgaV4Mac")
    def per_vlan_vga_v4_mac(self) -> Optional[_builtins.bool]:
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        """
        return pulumi.get(self, "per_vlan_vga_v4_mac")

    @_builtins.property
    @pulumi.getter(name="perVlanVgaV6Mac")
    def per_vlan_vga_v6_mac(self) -> Optional[_builtins.bool]:
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
        """
        return pulumi.get(self, "per_vlan_vga_v6_mac")

    @_builtins.property
    @pulumi.getter(name="routedAt")
    def routed_at(self) -> Optional[_builtins.str]:
        """
        optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        """
        return pulumi.get(self, "routed_at")

    @_builtins.property
    @pulumi.getter
    def underlay(self) -> Optional['outputs.EvpnTopologyEvpnOptionsUnderlay']:
        return pulumi.get(self, "underlay")

    @_builtins.property
    @pulumi.getter(name="vsInstances")
    def vs_instances(self) -> Optional[Mapping[str, 'outputs.EvpnTopologyEvpnOptionsVsInstances']]:
        """
        Optional, for EX9200 only to segregate virtual-switches
        """
        return pulumi.get(self, "vs_instances")


@pulumi.output_type
class EvpnTopologyEvpnOptionsOverlay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "as":
            suggest = "as_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvpnTopologyEvpnOptionsOverlay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvpnTopologyEvpnOptionsOverlay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvpnTopologyEvpnOptionsOverlay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_: Optional[_builtins.int] = None):
        """
        :param _builtins.int as_: Overlay BGP Local AS Number
        """
        if as_ is not None:
            pulumi.set(__self__, "as_", as_)

    @_builtins.property
    @pulumi.getter(name="as")
    def as_(self) -> Optional[_builtins.int]:
        """
        Overlay BGP Local AS Number
        """
        return pulumi.get(self, "as_")


@pulumi.output_type
class EvpnTopologyEvpnOptionsUnderlay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asBase":
            suggest = "as_base"
        elif key == "routedIdPrefix":
            suggest = "routed_id_prefix"
        elif key == "useIpv6":
            suggest = "use_ipv6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvpnTopologyEvpnOptionsUnderlay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvpnTopologyEvpnOptionsUnderlay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvpnTopologyEvpnOptionsUnderlay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_base: Optional[_builtins.int] = None,
                 routed_id_prefix: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None,
                 use_ipv6: Optional[_builtins.bool] = None):
        """
        :param _builtins.int as_base: Underlay BGP Base AS Number
        :param _builtins.str subnet: Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        :param _builtins.bool use_ipv6: If v6 is desired for underlay
        """
        if as_base is not None:
            pulumi.set(__self__, "as_base", as_base)
        if routed_id_prefix is not None:
            pulumi.set(__self__, "routed_id_prefix", routed_id_prefix)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if use_ipv6 is not None:
            pulumi.set(__self__, "use_ipv6", use_ipv6)

    @_builtins.property
    @pulumi.getter(name="asBase")
    def as_base(self) -> Optional[_builtins.int]:
        """
        Underlay BGP Base AS Number
        """
        return pulumi.get(self, "as_base")

    @_builtins.property
    @pulumi.getter(name="routedIdPrefix")
    def routed_id_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "routed_id_prefix")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="useIpv6")
    def use_ipv6(self) -> Optional[_builtins.bool]:
        """
        If v6 is desired for underlay
        """
        return pulumi.get(self, "use_ipv6")


@pulumi.output_type
class EvpnTopologyEvpnOptionsVsInstances(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[_builtins.str]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class EvpnTopologySwitches(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceprofileId":
            suggest = "deviceprofile_id"
        elif key == "evpnId":
            suggest = "evpn_id"
        elif key == "routerId":
            suggest = "router_id"
        elif key == "siteId":
            suggest = "site_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EvpnTopologySwitches. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EvpnTopologySwitches.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EvpnTopologySwitches.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: _builtins.str,
                 deviceprofile_id: Optional[_builtins.str] = None,
                 evpn_id: Optional[_builtins.int] = None,
                 mac: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 pod: Optional[_builtins.int] = None,
                 pods: Optional[Sequence[_builtins.int]] = None,
                 router_id: Optional[_builtins.str] = None,
                 site_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str role: use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
        :param _builtins.int pod: Optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
                 * for CLOS, to group dist / access switches into pods
                 * for ERB/CRB, to group dist / esilag-access into pods
        :param Sequence[_builtins.int] pods: By default, core switches are assumed to be connecting all pods. 
               if you want to limit the pods, you can specify pods.
        """
        pulumi.set(__self__, "role", role)
        if deviceprofile_id is not None:
            pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        if evpn_id is not None:
            pulumi.set(__self__, "evpn_id", evpn_id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deviceprofile_id")

    @_builtins.property
    @pulumi.getter(name="evpnId")
    def evpn_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "evpn_id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def pod(self) -> Optional[_builtins.int]:
        """
        Optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
          * for CLOS, to group dist / access switches into pods
          * for ERB/CRB, to group dist / esilag-access into pods
        """
        return pulumi.get(self, "pod")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[Sequence[_builtins.int]]:
        """
        By default, core switches are assumed to be connecting all pods. 
        if you want to limit the pods, you can specify pods.
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "router_id")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "site_id")


@pulumi.output_type
class GatewaytemplateBgpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authKey":
            suggest = "auth_key"
        elif key == "bfdMinimumInterval":
            suggest = "bfd_minimum_interval"
        elif key == "bfdMultiplier":
            suggest = "bfd_multiplier"
        elif key == "disableBfd":
            suggest = "disable_bfd"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "extendedV4Nexthop":
            suggest = "extended_v4_nexthop"
        elif key == "gracefulRestartTime":
            suggest = "graceful_restart_time"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "import":
            suggest = "import_"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "localAs":
            suggest = "local_as"
        elif key == "neighborAs":
            suggest = "neighbor_as"
        elif key == "noPrivateAs":
            suggest = "no_private_as"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "tunnelName":
            suggest = "tunnel_name"
        elif key == "vpnName":
            suggest = "vpn_name"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateBgpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateBgpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateBgpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 auth_key: Optional[_builtins.str] = None,
                 bfd_minimum_interval: Optional[_builtins.int] = None,
                 bfd_multiplier: Optional[_builtins.int] = None,
                 disable_bfd: Optional[_builtins.bool] = None,
                 export: Optional[_builtins.str] = None,
                 export_policy: Optional[_builtins.str] = None,
                 extended_v4_nexthop: Optional[_builtins.bool] = None,
                 graceful_restart_time: Optional[_builtins.int] = None,
                 hold_time: Optional[_builtins.int] = None,
                 import_: Optional[_builtins.str] = None,
                 import_policy: Optional[_builtins.str] = None,
                 local_as: Optional[_builtins.str] = None,
                 neighbor_as: Optional[_builtins.str] = None,
                 neighbors: Optional[Mapping[str, 'outputs.GatewaytemplateBgpConfigNeighbors']] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 no_private_as: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 tunnel_name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpn_name: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str via: enum: `lan`, `tunnel`, `vpn`, `wan`
        :param _builtins.str auth_key: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`
        :param _builtins.int bfd_minimum_interval: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_multiplier is configured alone. Default:
                 * 1000 if `type`==`external`
                 * 350 `type`==`internal`
        :param _builtins.int bfd_multiplier: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_minimum_interval_is_configured alone
        :param _builtins.bool disable_bfd: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BFD provides faster path failure detection and is enabled by default
        :param _builtins.str export_policy: Default export policies if no per-neighbor policies defined
        :param _builtins.bool extended_v4_nexthop: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        :param _builtins.int graceful_restart_time: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. `0` means disable
        :param _builtins.int hold_time: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default is 90.
        :param _builtins.str import_policy: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default import policies if no per-neighbor policies defined
        :param _builtins.str local_as: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BGPLocal AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param _builtins.str neighbor_as: Neighbor AS. If `type`==`internal`, must be equal to `local_as`. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param Mapping[str, 'GatewaytemplateBgpConfigNeighborsArgs'] neighbors: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If per-neighbor as is desired. Property key is the neighbor address
        :param Sequence[_builtins.str] networks: Optional if `via`==`lan`. List of networks where we expect BGP neighbor to connect to/from
        :param _builtins.bool no_private_as: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If true, we will not advertise private ASNs (AS 64512-65534) to this neighbor
        :param _builtins.bool no_readvertise_to_overlay: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, we'll re-advertise all learned BGP routers toward overlay
        :param _builtins.str tunnel_name: Optional if `via`==`tunnel`
        :param _builtins.str type: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. enum: `external`, `internal`
        :param _builtins.str vpn_name: Optional if `via`==`vpn`
        :param _builtins.str wan_name: Optional if `via`==`wan`
        """
        pulumi.set(__self__, "via", via)
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if bfd_multiplier is not None:
            pulumi.set(__self__, "bfd_multiplier", bfd_multiplier)
        if disable_bfd is not None:
            pulumi.set(__self__, "disable_bfd", disable_bfd)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if extended_v4_nexthop is not None:
            pulumi.set(__self__, "extended_v4_nexthop", extended_v4_nexthop)
        if graceful_restart_time is not None:
            pulumi.set(__self__, "graceful_restart_time", graceful_restart_time)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if no_private_as is not None:
            pulumi.set(__self__, "no_private_as", no_private_as)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if tunnel_name is not None:
            pulumi.set(__self__, "tunnel_name", tunnel_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpn_name is not None:
            pulumi.set(__self__, "vpn_name", vpn_name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`
        """
        return pulumi.get(self, "auth_key")

    @_builtins.property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        return pulumi.get(self, "bfd_minimum_interval")

    @_builtins.property
    @pulumi.getter(name="bfdMultiplier")
    def bfd_multiplier(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_minimum_interval_is_configured alone
        """
        return pulumi.get(self, "bfd_multiplier")

    @_builtins.property
    @pulumi.getter(name="disableBfd")
    def disable_bfd(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BFD provides faster path failure detection and is enabled by default
        """
        return pulumi.get(self, "disable_bfd")

    @_builtins.property
    @pulumi.getter
    def export(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        """
        Default export policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="extendedV4Nexthop")
    def extended_v4_nexthop(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        return pulumi.get(self, "extended_v4_nexthop")

    @_builtins.property
    @pulumi.getter(name="gracefulRestartTime")
    def graceful_restart_time(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. `0` means disable
        """
        return pulumi.get(self, "graceful_restart_time")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default is 90.
        """
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default import policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[_builtins.str]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BGPLocal AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "local_as")

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[_builtins.str]:
        """
        Neighbor AS. If `type`==`internal`, must be equal to `local_as`. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateBgpConfigNeighbors']]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If per-neighbor as is desired. Property key is the neighbor address
        """
        return pulumi.get(self, "neighbors")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `via`==`lan`. List of networks where we expect BGP neighbor to connect to/from
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="noPrivateAs")
    def no_private_as(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If true, we will not advertise private ASNs (AS 64512-65534) to this neighbor
        """
        return pulumi.get(self, "no_private_as")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, we'll re-advertise all learned BGP routers toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`tunnel`
        """
        return pulumi.get(self, "tunnel_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. enum: `external`, `internal`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpnName")
    def vpn_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`vpn`
        """
        return pulumi.get(self, "vpn_name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`wan`
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewaytemplateBgpConfigNeighbors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neighborAs":
            suggest = "neighbor_as"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "multihopTtl":
            suggest = "multihop_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateBgpConfigNeighbors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateBgpConfigNeighbors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateBgpConfigNeighbors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 neighbor_as: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 export_policy: Optional[_builtins.str] = None,
                 hold_time: Optional[_builtins.int] = None,
                 import_policy: Optional[_builtins.str] = None,
                 multihop_ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param _builtins.bool disabled: If true, the BGP session to this neighbor will be administratively disabled/shutdown
        :param _builtins.int multihop_ttl: Assuming BGP neighbor is directly connected
        """
        pulumi.set(__self__, "neighbor_as", neighbor_as)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if multihop_ttl is not None:
            pulumi.set(__self__, "multihop_ttl", multihop_ttl)

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> _builtins.str:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="multihopTtl")
    def multihop_ttl(self) -> Optional[_builtins.int]:
        """
        Assuming BGP neighbor is directly connected
        """
        return pulumi.get(self, "multihop_ttl")


@pulumi.output_type
class GatewaytemplateDhcpdConfig(dict):
    def __init__(__self__, *,
                 config: Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfig']] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, 'GatewaytemplateDhcpdConfigConfigArgs'] config: Property key is the network name
        :param _builtins.bool enabled: If set to `false`, disable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfig']]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to `false`, disable the DHCP server
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewaytemplateDhcpdConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"
        elif key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "fixedBindings":
            suggest = "fixed_bindings"
        elif key == "ip6End":
            suggest = "ip6_end"
        elif key == "ip6Start":
            suggest = "ip6_start"
        elif key == "ipEnd":
            suggest = "ip_end"
        elif key == "ipStart":
            suggest = "ip_start"
        elif key == "leaseTime":
            suggest = "lease_time"
        elif key == "serverIdOverride":
            suggest = "server_id_override"
        elif key == "vendorEncapsulated":
            suggest = "vendor_encapsulated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateDhcpdConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateDhcpdConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateDhcpdConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 fixed_bindings: Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfigFixedBindings']] = None,
                 gateway: Optional[_builtins.str] = None,
                 ip6_end: Optional[_builtins.str] = None,
                 ip6_start: Optional[_builtins.str] = None,
                 ip_end: Optional[_builtins.str] = None,
                 ip_start: Optional[_builtins.str] = None,
                 lease_time: Optional[_builtins.int] = None,
                 options: Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfigOptions']] = None,
                 server_id_override: Optional[_builtins.bool] = None,
                 servers: Optional[Sequence[_builtins.str]] = None,
                 serversv6s: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None,
                 vendor_encapsulated: Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfigVendorEncapsulated']] = None):
        """
        :param Sequence[_builtins.str] dns_servers: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param Sequence[_builtins.str] dns_suffixes: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param Mapping[str, 'GatewaytemplateDhcpdConfigConfigFixedBindingsArgs'] fixed_bindings: If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        :param _builtins.str gateway: If `type`==`local` - optional, `ip` will be used if not provided
        :param _builtins.str ip6_end: If `type6`==`local`
        :param _builtins.str ip6_start: If `type6`==`local`
        :param _builtins.str ip_end: If `type`==`local`
        :param _builtins.str ip_start: If `type`==`local`
        :param _builtins.int lease_time: In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param Mapping[str, 'GatewaytemplateDhcpdConfigConfigOptionsArgs'] options: If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        :param _builtins.bool server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param Sequence[_builtins.str] servers: If `type`==`relay`
        :param Sequence[_builtins.str] serversv6s: If `type6`==`relay`
        :param _builtins.str type: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param _builtins.str type6: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param Mapping[str, 'GatewaytemplateDhcpdConfigConfigVendorEncapsulatedArgs'] vendor_encapsulated: If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip6_end is not None:
            pulumi.set(__self__, "ip6_end", ip6_end)
        if ip6_start is not None:
            pulumi.set(__self__, "ip6_start", ip6_start)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if serversv6s is not None:
            pulumi.set(__self__, "serversv6s", serversv6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapsulated is not None:
            pulumi.set(__self__, "vendor_encapsulated", vendor_encapsulated)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    @_utilities.deprecated("""Configuring `dns_suffix` is deprecated and will not be supported in the future, please configure Code 15 or Code 119 in Server `options` instead""")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfigFixedBindings']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter(name="ip6End")
    def ip6_end(self) -> Optional[_builtins.str]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip6_end")

    @_builtins.property
    @pulumi.getter(name="ip6Start")
    def ip6_start(self) -> Optional[_builtins.str]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip6_start")

    @_builtins.property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[_builtins.str]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_end")

    @_builtins.property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[_builtins.str]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_start")

    @_builtins.property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[_builtins.int]:
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfigOptions']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[_builtins.bool]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def serversv6s(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type6`==`relay`
        """
        return pulumi.get(self, "serversv6s")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vendorEncapsulated")
    def vendor_encapsulated(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateDhcpdConfigConfigVendorEncapsulated']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
        return pulumi.get(self, "vendor_encapsulated")


@pulumi.output_type
class GatewaytemplateDhcpdConfigConfigFixedBindings(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewaytemplateDhcpdConfigConfigOptions(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewaytemplateDhcpdConfigConfigVendorEncapsulated(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewaytemplateExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewaytemplateExtraRoutes(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewaytemplateIdpProfiles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseProfile":
            suggest = "base_profile"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateIdpProfiles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateIdpProfiles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateIdpProfiles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_profile: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 org_id: Optional[_builtins.str] = None,
                 overwrites: Optional[Sequence['outputs.GatewaytemplateIdpProfilesOverwrite']] = None):
        """
        :param _builtins.str base_profile: enum: `critical`, `standard`, `strict`
        """
        if base_profile is not None:
            pulumi.set(__self__, "base_profile", base_profile)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)

    @_builtins.property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[Sequence['outputs.GatewaytemplateIdpProfilesOverwrite']]:
        return pulumi.get(self, "overwrites")


@pulumi.output_type
class GatewaytemplateIdpProfilesOverwrite(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 matching: Optional['outputs.GatewaytemplateIdpProfilesOverwriteMatching'] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.GatewaytemplateIdpProfilesOverwriteMatching']:
        return pulumi.get(self, "matching")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewaytemplateIdpProfilesOverwriteMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackNames":
            suggest = "attack_names"
        elif key == "dstSubnets":
            suggest = "dst_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateIdpProfilesOverwriteMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateIdpProfilesOverwriteMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateIdpProfilesOverwriteMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attack_names: Optional[Sequence[_builtins.str]] = None,
                 dst_subnets: Optional[Sequence[_builtins.str]] = None,
                 severities: Optional[Sequence[_builtins.str]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "attack_names")

    @_builtins.property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dst_subnets")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "severities")


@pulumi.output_type
class GatewaytemplateIpConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryIps":
            suggest = "secondary_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateIpConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateIpConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateIpConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 secondary_ips: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] secondary_ips: Optional list of secondary IPs in CIDR format
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if secondary_ips is not None:
            pulumi.set(__self__, "secondary_ips", secondary_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter(name="secondaryIps")
    def secondary_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional list of secondary IPs in CIDR format
        """
        return pulumi.get(self, "secondary_ips")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class GatewaytemplateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disallowMistServices":
            suggest = "disallow_mist_services"
        elif key == "internalAccess":
            suggest = "internal_access"
        elif key == "internetAccess":
            suggest = "internet_access"
        elif key == "routedForNetworks":
            suggest = "routed_for_networks"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vpnAccess":
            suggest = "vpn_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subnet: _builtins.str,
                 disallow_mist_services: Optional[_builtins.bool] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 internal_access: Optional['outputs.GatewaytemplateNetworkInternalAccess'] = None,
                 internet_access: Optional['outputs.GatewaytemplateNetworkInternetAccess'] = None,
                 isolation: Optional[_builtins.bool] = None,
                 multicast: Optional['outputs.GatewaytemplateNetworkMulticast'] = None,
                 routed_for_networks: Optional[Sequence[_builtins.str]] = None,
                 subnet6: Optional[_builtins.str] = None,
                 tenants: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkTenants']] = None,
                 vlan_id: Optional[_builtins.str] = None,
                 vpn_access: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkVpnAccess']] = None):
        """
        :param _builtins.bool disallow_mist_services: Whether to disallow Mist Devices in the network
        :param 'GatewaytemplateNetworkInternetAccessArgs' internet_access: Whether this network has direct internet access
        :param _builtins.bool isolation: Whether to allow clients in the network to talk to each other
        :param 'GatewaytemplateNetworkMulticastArgs' multicast: Whether to enable multicast support (only PIM-sparse mode is supported)
        :param Sequence[_builtins.str] routed_for_networks: For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param Mapping[str, 'GatewaytemplateNetworkTenantsArgs'] tenants: Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        :param Mapping[str, 'GatewaytemplateNetworkVpnAccessArgs'] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        if disallow_mist_services is not None:
            pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if internal_access is not None:
            pulumi.set(__self__, "internal_access", internal_access)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if routed_for_networks is not None:
            pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_access is not None:
            pulumi.set(__self__, "vpn_access", vpn_access)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> Optional[_builtins.bool]:
        """
        Whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> Optional['outputs.GatewaytemplateNetworkInternalAccess']:
        return pulumi.get(self, "internal_access")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional['outputs.GatewaytemplateNetworkInternetAccess']:
        """
        Whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[_builtins.bool]:
        """
        Whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional['outputs.GatewaytemplateNetworkMulticast']:
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @_builtins.property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @_builtins.property
    @pulumi.getter
    def subnet6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet6")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkTenants']]:
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "tenants")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkVpnAccess']]:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")


@pulumi.output_type
class GatewaytemplateNetworkInternalAccess(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewaytemplateNetworkInternetAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createSimpleServicePolicy":
            suggest = "create_simple_service_policy"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "staticNat":
            suggest = "static_nat"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkInternetAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkInternetAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkInternetAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_simple_service_policy: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkInternetAccessDestinationNat']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 restricted: Optional[_builtins.bool] = None,
                 static_nat: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkInternetAccessStaticNat']] = None):
        """
        :param Mapping[str, 'GatewaytemplateNetworkInternetAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.bool restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param Mapping[str, 'GatewaytemplateNetworkInternetAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @_builtins.property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_simple_service_policy")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkInternetAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def restricted(self) -> Optional[_builtins.bool]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkInternetAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")


@pulumi.output_type
class GatewaytemplateNetworkInternetAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkInternetAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkInternetAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkInternetAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewaytemplateNetworkInternetAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkInternetAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkInternetAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkInternetAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewaytemplateNetworkMulticast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableIgmp":
            suggest = "disable_igmp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkMulticast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkMulticast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkMulticast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_igmp: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 groups: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkMulticastGroups']] = None):
        """
        :param _builtins.bool disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param Mapping[str, 'GatewaytemplateNetworkMulticastGroupsArgs'] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[_builtins.bool]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkMulticastGroups']]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class GatewaytemplateNetworkMulticastGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rpIp":
            suggest = "rp_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkMulticastGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkMulticastGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkMulticastGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rp_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @_builtins.property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[_builtins.str]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")


@pulumi.output_type
class GatewaytemplateNetworkTenants(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[_builtins.str]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "addresses")


@pulumi.output_type
class GatewaytemplateNetworkVpnAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedSubnet":
            suggest = "advertised_subnet"
        elif key == "allowPing":
            suggest = "allow_ping"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "natPool":
            suggest = "nat_pool"
        elif key == "noReadvertiseToLanBgp":
            suggest = "no_readvertise_to_lan_bgp"
        elif key == "noReadvertiseToLanOspf":
            suggest = "no_readvertise_to_lan_ospf"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "otherVrfs":
            suggest = "other_vrfs"
        elif key == "sourceNat":
            suggest = "source_nat"
        elif key == "staticNat":
            suggest = "static_nat"
        elif key == "summarizedSubnet":
            suggest = "summarized_subnet"
        elif key == "summarizedSubnetToLanBgp":
            suggest = "summarized_subnet_to_lan_bgp"
        elif key == "summarizedSubnetToLanOspf":
            suggest = "summarized_subnet_to_lan_ospf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkVpnAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkVpnAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkVpnAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_subnet: Optional[_builtins.str] = None,
                 allow_ping: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkVpnAccessDestinationNat']] = None,
                 nat_pool: Optional[_builtins.str] = None,
                 no_readvertise_to_lan_bgp: Optional[_builtins.bool] = None,
                 no_readvertise_to_lan_ospf: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 other_vrfs: Optional[Sequence[_builtins.str]] = None,
                 routed: Optional[_builtins.bool] = None,
                 source_nat: Optional['outputs.GatewaytemplateNetworkVpnAccessSourceNat'] = None,
                 static_nat: Optional[Mapping[str, 'outputs.GatewaytemplateNetworkVpnAccessStaticNat']] = None,
                 summarized_subnet: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_bgp: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_ospf: Optional[_builtins.str] = None):
        """
        :param _builtins.str advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param _builtins.bool allow_ping: Whether to allow ping from vpn into this routed network
        :param Mapping[str, 'GatewaytemplateNetworkVpnAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.str nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param _builtins.bool no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.bool no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param _builtins.bool no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param Sequence[_builtins.str] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param _builtins.bool routed: Whether this network is routable
        :param 'GatewaytemplateNetworkVpnAccessSourceNatArgs' source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param Mapping[str, 'GatewaytemplateNetworkVpnAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param _builtins.str summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.str summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @_builtins.property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[_builtins.str]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @_builtins.property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[_builtins.bool]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkVpnAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @_builtins.property
    @pulumi.getter
    def routed(self) -> Optional[_builtins.bool]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @_builtins.property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional['outputs.GatewaytemplateNetworkVpnAccessSourceNat']:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.GatewaytemplateNetworkVpnAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[_builtins.str]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[_builtins.str]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[_builtins.str]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")


@pulumi.output_type
class GatewaytemplateNetworkVpnAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkVpnAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkVpnAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkVpnAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewaytemplateNetworkVpnAccessSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIp":
            suggest = "external_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkVpnAccessSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkVpnAccessSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkVpnAccessSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_ip: Optional[_builtins.str] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @_builtins.property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_ip")


@pulumi.output_type
class GatewaytemplateNetworkVpnAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateNetworkVpnAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateNetworkVpnAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateNetworkVpnAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewaytemplateOobIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateOobIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateOobIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateOobIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 node1: Optional['outputs.GatewaytemplateOobIpConfigNode1'] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: If `type`==`static`
        :param _builtins.str ip: If `type`==`static`
        :param _builtins.str netmask: If `type`==`static`
        :param 'GatewaytemplateOobIpConfigNode1Args' node1: For HA Cluster, node1 can have different IP Config
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if node1 is not None:
            pulumi.set(__self__, "node1", node1)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def node1(self) -> Optional['outputs.GatewaytemplateOobIpConfigNode1']:
        """
        For HA Cluster, node1 can have different IP Config
        """
        return pulumi.get(self, "node1")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GatewaytemplateOobIpConfigNode1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateOobIpConfigNode1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateOobIpConfigNode1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateOobIpConfigNode1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: If `type`==`static`
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GatewaytemplatePathPreferences(dict):
    def __init__(__self__, *,
                 paths: Optional[Sequence['outputs.GatewaytemplatePathPreferencesPath']] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.str strategy: enum: `ecmp`, `ordered`, `weighted`
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence['outputs.GatewaytemplatePathPreferencesPath']]:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GatewaytemplatePathPreferencesPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayIp":
            suggest = "gateway_ip"
        elif key == "internetAccess":
            suggest = "internet_access"
        elif key == "targetIps":
            suggest = "target_ips"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePathPreferencesPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePathPreferencesPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePathPreferencesPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 cost: Optional[_builtins.int] = None,
                 disabled: Optional[_builtins.bool] = None,
                 gateway_ip: Optional[_builtins.str] = None,
                 internet_access: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 target_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `local`, `tunnel`, `vpn`, `wan`
        :param _builtins.bool disabled: For SSR Only. `true`, if this specific path is undesired
        :param _builtins.str gateway_ip: Only if `type`==`local`, if a different gateway is desired
        :param _builtins.bool internet_access: Only if `type`==`vpn`, if this vpn path can be used for internet
        :param _builtins.str name: Required when 
                 * `type`==`vpn`: the name of the VPN Path to use 
                 * `type`==`wan`: the name of the WAN interface to use
        :param Sequence[_builtins.str] networks: Required when `type`==`local`
        :param Sequence[_builtins.str] target_ips: If `type`==`local`, if destination IP is to be replaced
        :param _builtins.str wan_name: Optional if `type`==`vpn`
        """
        pulumi.set(__self__, "type", type)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        return pulumi.get(self, "gateway_ip")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `type`==`local`
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        return pulumi.get(self, "target_ips")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        Optional if `type`==`vpn`
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewaytemplatePortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeDisableLacp":
            suggest = "ae_disable_lacp"
        elif key == "aeIdx":
            suggest = "ae_idx"
        elif key == "aeLacpForceUp":
            suggest = "ae_lacp_force_up"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dslType":
            suggest = "dsl_type"
        elif key == "dslVci":
            suggest = "dsl_vci"
        elif key == "dslVpi":
            suggest = "dsl_vpi"
        elif key == "ipConfig":
            suggest = "ip_config"
        elif key == "lteApn":
            suggest = "lte_apn"
        elif key == "lteAuth":
            suggest = "lte_auth"
        elif key == "lteBackup":
            suggest = "lte_backup"
        elif key == "ltePassword":
            suggest = "lte_password"
        elif key == "lteUsername":
            suggest = "lte_username"
        elif key == "outerVlanId":
            suggest = "outer_vlan_id"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "preserveDscp":
            suggest = "preserve_dscp"
        elif key == "redundantGroup":
            suggest = "redundant_group"
        elif key == "rethIdx":
            suggest = "reth_idx"
        elif key == "rethNode":
            suggest = "reth_node"
        elif key == "rethNodes":
            suggest = "reth_nodes"
        elif key == "ssrNoVirtualMac":
            suggest = "ssr_no_virtual_mac"
        elif key == "svrPortRange":
            suggest = "svr_port_range"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vpnPaths":
            suggest = "vpn_paths"
        elif key == "wanArpPolicer":
            suggest = "wan_arp_policer"
        elif key == "wanDisableSpeedtest":
            suggest = "wan_disable_speedtest"
        elif key == "wanExtIp":
            suggest = "wan_ext_ip"
        elif key == "wanExtraRoutes":
            suggest = "wan_extra_routes"
        elif key == "wanExtraRoutes6":
            suggest = "wan_extra_routes6"
        elif key == "wanNetworks":
            suggest = "wan_networks"
        elif key == "wanProbeOverride":
            suggest = "wan_probe_override"
        elif key == "wanSourceNat":
            suggest = "wan_source_nat"
        elif key == "wanType":
            suggest = "wan_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: _builtins.str,
                 ae_disable_lacp: Optional[_builtins.bool] = None,
                 ae_idx: Optional[_builtins.str] = None,
                 ae_lacp_force_up: Optional[_builtins.bool] = None,
                 aggregated: Optional[_builtins.bool] = None,
                 critical: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 dsl_type: Optional[_builtins.str] = None,
                 dsl_vci: Optional[_builtins.int] = None,
                 dsl_vpi: Optional[_builtins.int] = None,
                 duplex: Optional[_builtins.str] = None,
                 ip_config: Optional['outputs.GatewaytemplatePortConfigIpConfig'] = None,
                 lte_apn: Optional[_builtins.str] = None,
                 lte_auth: Optional[_builtins.str] = None,
                 lte_backup: Optional[_builtins.bool] = None,
                 lte_password: Optional[_builtins.str] = None,
                 lte_username: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 outer_vlan_id: Optional[_builtins.int] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_network: Optional[_builtins.str] = None,
                 preserve_dscp: Optional[_builtins.bool] = None,
                 redundant: Optional[_builtins.bool] = None,
                 redundant_group: Optional[_builtins.int] = None,
                 reth_idx: Optional[_builtins.str] = None,
                 reth_node: Optional[_builtins.str] = None,
                 reth_nodes: Optional[Sequence[_builtins.str]] = None,
                 speed: Optional[_builtins.str] = None,
                 ssr_no_virtual_mac: Optional[_builtins.bool] = None,
                 svr_port_range: Optional[_builtins.str] = None,
                 traffic_shaping: Optional['outputs.GatewaytemplatePortConfigTrafficShaping'] = None,
                 vlan_id: Optional[_builtins.str] = None,
                 vpn_paths: Optional[Mapping[str, 'outputs.GatewaytemplatePortConfigVpnPaths']] = None,
                 wan_arp_policer: Optional[_builtins.str] = None,
                 wan_disable_speedtest: Optional[_builtins.bool] = None,
                 wan_ext_ip: Optional[_builtins.str] = None,
                 wan_extra_routes: Optional[Mapping[str, 'outputs.GatewaytemplatePortConfigWanExtraRoutes']] = None,
                 wan_extra_routes6: Optional[Mapping[str, 'outputs.GatewaytemplatePortConfigWanExtraRoutes6']] = None,
                 wan_networks: Optional[Sequence[_builtins.str]] = None,
                 wan_probe_override: Optional['outputs.GatewaytemplatePortConfigWanProbeOverride'] = None,
                 wan_source_nat: Optional['outputs.GatewaytemplatePortConfigWanSourceNat'] = None,
                 wan_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        :param _builtins.bool ae_disable_lacp: If `aggregated`==`true`. To disable LCP support for the AE interface
        :param _builtins.str ae_idx: If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        :param _builtins.bool ae_lacp_force_up: For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        :param _builtins.bool critical: To generate port up/down alarm, set it to true
        :param _builtins.str description: Interface Description. Can be a variable (i.e. "{{myvar}}")
        :param _builtins.bool disabled: Port admin up (true) / down (false)
        :param _builtins.str dsl_type: if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        :param _builtins.int dsl_vci: If `wan_type`==`dsl`, 16 bit int
        :param _builtins.int dsl_vpi: If `wan_type`==`dsl`, 8 bit int
        :param _builtins.str duplex: enum: `auto`, `full`, `half`
        :param 'GatewaytemplatePortConfigIpConfigArgs' ip_config: Junos IP Config
        :param _builtins.str lte_apn: If `wan_type`==`lte`
        :param _builtins.str lte_auth: if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        :param _builtins.str lte_password: If `wan_type`==`lte`
        :param _builtins.str lte_username: If `wan_type`==`lte`
        :param _builtins.str name: Name that we'll use to derive config
        :param Sequence[_builtins.str] networks: if `usage`==`lan`, name of the `org.Network` resource
        :param _builtins.int outer_vlan_id: For Q-in-Q
        :param _builtins.str port_network: Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        :param _builtins.bool preserve_dscp: Whether to preserve dscp when sending traffic over VPN (SSR-only)
        :param _builtins.bool redundant: If HA mode
        :param _builtins.int redundant_group: If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        :param _builtins.str reth_idx: For SRX only and if HA Mode
        :param _builtins.str reth_node: If HA mode
        :param Sequence[_builtins.str] reth_nodes: SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        :param _builtins.bool ssr_no_virtual_mac: When SSR is running as VM, this is required on certain hosting platforms
        :param _builtins.str svr_port_range: For SSR only
        :param Mapping[str, 'GatewaytemplatePortConfigVpnPathsArgs'] vpn_paths: Property key is the VPN name
        :param _builtins.str wan_arp_policer: Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        :param _builtins.bool wan_disable_speedtest: If `wan_type`==`wan`, disable speedtest
        :param _builtins.str wan_ext_ip: Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        :param Mapping[str, 'GatewaytemplatePortConfigWanExtraRoutesArgs'] wan_extra_routes: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        :param Mapping[str, 'GatewaytemplatePortConfigWanExtraRoutes6Args'] wan_extra_routes6: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        :param Sequence[_builtins.str] wan_networks: Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        :param 'GatewaytemplatePortConfigWanProbeOverrideArgs' wan_probe_override: Only if `usage`==`wan`
        :param 'GatewaytemplatePortConfigWanSourceNatArgs' wan_source_nat: Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        :param _builtins.str wan_type: Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_force_up is not None:
            pulumi.set(__self__, "ae_lacp_force_up", ae_lacp_force_up)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dsl_type is not None:
            pulumi.set(__self__, "dsl_type", dsl_type)
        if dsl_vci is not None:
            pulumi.set(__self__, "dsl_vci", dsl_vci)
        if dsl_vpi is not None:
            pulumi.set(__self__, "dsl_vpi", dsl_vpi)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if lte_apn is not None:
            pulumi.set(__self__, "lte_apn", lte_apn)
        if lte_auth is not None:
            pulumi.set(__self__, "lte_auth", lte_auth)
        if lte_backup is not None:
            pulumi.set(__self__, "lte_backup", lte_backup)
        if lte_password is not None:
            pulumi.set(__self__, "lte_password", lte_password)
        if lte_username is not None:
            pulumi.set(__self__, "lte_username", lte_username)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if outer_vlan_id is not None:
            pulumi.set(__self__, "outer_vlan_id", outer_vlan_id)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if preserve_dscp is not None:
            pulumi.set(__self__, "preserve_dscp", preserve_dscp)
        if redundant is not None:
            pulumi.set(__self__, "redundant", redundant)
        if redundant_group is not None:
            pulumi.set(__self__, "redundant_group", redundant_group)
        if reth_idx is not None:
            pulumi.set(__self__, "reth_idx", reth_idx)
        if reth_node is not None:
            pulumi.set(__self__, "reth_node", reth_node)
        if reth_nodes is not None:
            pulumi.set(__self__, "reth_nodes", reth_nodes)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssr_no_virtual_mac is not None:
            pulumi.set(__self__, "ssr_no_virtual_mac", ssr_no_virtual_mac)
        if svr_port_range is not None:
            pulumi.set(__self__, "svr_port_range", svr_port_range)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)
        if wan_arp_policer is not None:
            pulumi.set(__self__, "wan_arp_policer", wan_arp_policer)
        if wan_disable_speedtest is not None:
            pulumi.set(__self__, "wan_disable_speedtest", wan_disable_speedtest)
        if wan_ext_ip is not None:
            pulumi.set(__self__, "wan_ext_ip", wan_ext_ip)
        if wan_extra_routes is not None:
            pulumi.set(__self__, "wan_extra_routes", wan_extra_routes)
        if wan_extra_routes6 is not None:
            pulumi.set(__self__, "wan_extra_routes6", wan_extra_routes6)
        if wan_networks is not None:
            pulumi.set(__self__, "wan_networks", wan_networks)
        if wan_probe_override is not None:
            pulumi.set(__self__, "wan_probe_override", wan_probe_override)
        if wan_source_nat is not None:
            pulumi.set(__self__, "wan_source_nat", wan_source_nat)
        if wan_type is not None:
            pulumi.set(__self__, "wan_type", wan_type)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[_builtins.bool]:
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @_builtins.property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[_builtins.str]:
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        return pulumi.get(self, "ae_idx")

    @_builtins.property
    @pulumi.getter(name="aeLacpForceUp")
    def ae_lacp_force_up(self) -> Optional[_builtins.bool]:
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        return pulumi.get(self, "ae_lacp_force_up")

    @_builtins.property
    @pulumi.getter
    def aggregated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aggregated")

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[_builtins.bool]:
        """
        To generate port up/down alarm, set it to true
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Port admin up (true) / down (false)
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="dslType")
    def dsl_type(self) -> Optional[_builtins.str]:
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        return pulumi.get(self, "dsl_type")

    @_builtins.property
    @pulumi.getter(name="dslVci")
    def dsl_vci(self) -> Optional[_builtins.int]:
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        return pulumi.get(self, "dsl_vci")

    @_builtins.property
    @pulumi.getter(name="dslVpi")
    def dsl_vpi(self) -> Optional[_builtins.int]:
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        return pulumi.get(self, "dsl_vpi")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional['outputs.GatewaytemplatePortConfigIpConfig']:
        """
        Junos IP Config
        """
        return pulumi.get(self, "ip_config")

    @_builtins.property
    @pulumi.getter(name="lteApn")
    def lte_apn(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_apn")

    @_builtins.property
    @pulumi.getter(name="lteAuth")
    def lte_auth(self) -> Optional[_builtins.str]:
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "lte_auth")

    @_builtins.property
    @pulumi.getter(name="lteBackup")
    def lte_backup(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "lte_backup")

    @_builtins.property
    @pulumi.getter(name="ltePassword")
    def lte_password(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_password")

    @_builtins.property
    @pulumi.getter(name="lteUsername")
    def lte_username(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_username")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name that we'll use to derive config
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="outerVlanId")
    def outer_vlan_id(self) -> Optional[_builtins.int]:
        """
        For Q-in-Q
        """
        return pulumi.get(self, "outer_vlan_id")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter(name="preserveDscp")
    def preserve_dscp(self) -> Optional[_builtins.bool]:
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        return pulumi.get(self, "preserve_dscp")

    @_builtins.property
    @pulumi.getter
    def redundant(self) -> Optional[_builtins.bool]:
        """
        If HA mode
        """
        return pulumi.get(self, "redundant")

    @_builtins.property
    @pulumi.getter(name="redundantGroup")
    def redundant_group(self) -> Optional[_builtins.int]:
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        return pulumi.get(self, "redundant_group")

    @_builtins.property
    @pulumi.getter(name="rethIdx")
    def reth_idx(self) -> Optional[_builtins.str]:
        """
        For SRX only and if HA Mode
        """
        return pulumi.get(self, "reth_idx")

    @_builtins.property
    @pulumi.getter(name="rethNode")
    def reth_node(self) -> Optional[_builtins.str]:
        """
        If HA mode
        """
        return pulumi.get(self, "reth_node")

    @_builtins.property
    @pulumi.getter(name="rethNodes")
    def reth_nodes(self) -> Optional[Sequence[_builtins.str]]:
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        return pulumi.get(self, "reth_nodes")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="ssrNoVirtualMac")
    def ssr_no_virtual_mac(self) -> Optional[_builtins.bool]:
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        return pulumi.get(self, "ssr_no_virtual_mac")

    @_builtins.property
    @pulumi.getter(name="svrPortRange")
    def svr_port_range(self) -> Optional[_builtins.str]:
        """
        For SSR only
        """
        return pulumi.get(self, "svr_port_range")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.GatewaytemplatePortConfigTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[Mapping[str, 'outputs.GatewaytemplatePortConfigVpnPaths']]:
        """
        Property key is the VPN name
        """
        return pulumi.get(self, "vpn_paths")

    @_builtins.property
    @pulumi.getter(name="wanArpPolicer")
    def wan_arp_policer(self) -> Optional[_builtins.str]:
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        return pulumi.get(self, "wan_arp_policer")

    @_builtins.property
    @pulumi.getter(name="wanDisableSpeedtest")
    def wan_disable_speedtest(self) -> Optional[_builtins.bool]:
        """
        If `wan_type`==`wan`, disable speedtest
        """
        return pulumi.get(self, "wan_disable_speedtest")

    @_builtins.property
    @pulumi.getter(name="wanExtIp")
    def wan_ext_ip(self) -> Optional[_builtins.str]:
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        return pulumi.get(self, "wan_ext_ip")

    @_builtins.property
    @pulumi.getter(name="wanExtraRoutes")
    def wan_extra_routes(self) -> Optional[Mapping[str, 'outputs.GatewaytemplatePortConfigWanExtraRoutes']]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        return pulumi.get(self, "wan_extra_routes")

    @_builtins.property
    @pulumi.getter(name="wanExtraRoutes6")
    def wan_extra_routes6(self) -> Optional[Mapping[str, 'outputs.GatewaytemplatePortConfigWanExtraRoutes6']]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        return pulumi.get(self, "wan_extra_routes6")

    @_builtins.property
    @pulumi.getter(name="wanNetworks")
    def wan_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        return pulumi.get(self, "wan_networks")

    @_builtins.property
    @pulumi.getter(name="wanProbeOverride")
    def wan_probe_override(self) -> Optional['outputs.GatewaytemplatePortConfigWanProbeOverride']:
        """
        Only if `usage`==`wan`
        """
        return pulumi.get(self, "wan_probe_override")

    @_builtins.property
    @pulumi.getter(name="wanSourceNat")
    def wan_source_nat(self) -> Optional['outputs.GatewaytemplatePortConfigWanSourceNat']:
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        return pulumi.get(self, "wan_source_nat")

    @_builtins.property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> Optional[_builtins.str]:
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        return pulumi.get(self, "wan_type")


@pulumi.output_type
class GatewaytemplatePortConfigIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "poserPassword":
            suggest = "poser_password"
        elif key == "pppoeAuth":
            suggest = "pppoe_auth"
        elif key == "pppoeUsername":
            suggest = "pppoe_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfigIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfigIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfigIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 poser_password: Optional[_builtins.str] = None,
                 pppoe_auth: Optional[_builtins.str] = None,
                 pppoe_username: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dns: Except for out-of_band interface (vme/em0/fxp0)
        :param Sequence[_builtins.str] dns_suffixes: Except for out-of_band interface (vme/em0/fxp0)
        :param _builtins.str gateway: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str gateway6: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IPv6 Address (i.e. "2001:db8::1") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str ip: Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str ip6: Interface IPv6 Address (i.e. "2001:db8::123") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str netmask6: Used only if `subnet` is not specified in `networks`. Interface IPv6 Netmask (i.e. "/64") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str network: Optional, the network to be used for mgmt
        :param _builtins.str poser_password: If `type`==`pppoe`
        :param _builtins.str pppoe_auth: if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        :param _builtins.str pppoe_username: If `type`==`pppoe`
        :param _builtins.str type: enum: `dhcp`, `pppoe`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if poser_password is not None:
            pulumi.set(__self__, "poser_password", poser_password)
        if pppoe_auth is not None:
            pulumi.set(__self__, "pppoe_auth", pppoe_auth)
        if pppoe_username is not None:
            pulumi.set(__self__, "pppoe_username", pppoe_username)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IPv6 Address (i.e. "2001:db8::1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        """
        Interface IPv6 Address (i.e. "2001:db8::123") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`. Interface IPv6 Netmask (i.e. "/64") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="poserPassword")
    def poser_password(self) -> Optional[_builtins.str]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "poser_password")

    @_builtins.property
    @pulumi.getter(name="pppoeAuth")
    def pppoe_auth(self) -> Optional[_builtins.str]:
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "pppoe_auth")

    @_builtins.property
    @pulumi.getter(name="pppoeUsername")
    def pppoe_username(self) -> Optional[_builtins.str]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "pppoe_username")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `pppoe`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class GatewaytemplatePortConfigTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfigTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfigTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfigTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param _builtins.int max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class GatewaytemplatePortConfigVpnPaths(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdProfile":
            suggest = "bfd_profile"
        elif key == "bfdUseTunnelMode":
            suggest = "bfd_use_tunnel_mode"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfigVpnPaths. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfigVpnPaths.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfigVpnPaths.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_profile: Optional[_builtins.str] = None,
                 bfd_use_tunnel_mode: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None,
                 role: Optional[_builtins.str] = None,
                 traffic_shaping: Optional['outputs.GatewaytemplatePortConfigVpnPathsTrafficShaping'] = None):
        """
        :param _builtins.str bfd_profile: Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        :param _builtins.bool bfd_use_tunnel_mode: Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        :param _builtins.int preference: Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        :param _builtins.str role: If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @_builtins.property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[_builtins.str]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @_builtins.property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[_builtins.bool]:
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.GatewaytemplatePortConfigVpnPathsTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")


@pulumi.output_type
class GatewaytemplatePortConfigVpnPathsTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfigVpnPathsTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfigVpnPathsTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfigVpnPathsTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param _builtins.int max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class GatewaytemplatePortConfigWanExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewaytemplatePortConfigWanExtraRoutes(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewaytemplatePortConfigWanProbeOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeProfile":
            suggest = "probe_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfigWanProbeOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfigWanProbeOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfigWanProbeOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip6s: Optional[Sequence[_builtins.str]] = None,
                 ips: Optional[Sequence[_builtins.str]] = None,
                 probe_profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str probe_profile: enum: `broadband`, `lte`
        """
        if ip6s is not None:
            pulumi.set(__self__, "ip6s", ip6s)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if probe_profile is not None:
            pulumi.set(__self__, "probe_profile", probe_profile)

    @_builtins.property
    @pulumi.getter
    def ip6s(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip6s")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="probeProfile")
    def probe_profile(self) -> Optional[_builtins.str]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "probe_profile")


@pulumi.output_type
class GatewaytemplatePortConfigWanSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natPool":
            suggest = "nat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplatePortConfigWanSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplatePortConfigWanSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplatePortConfigWanSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 nat_pool: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Or to disable the source-nat
        :param _builtins.str nat_pool: If alternative nat_pool is desired
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Or to disable the source-nat
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If alternative nat_pool is desired
        """
        return pulumi.get(self, "nat_pool")


@pulumi.output_type
class GatewaytemplateRoutingPolicies(dict):
    def __init__(__self__, *,
                 terms: Optional[Sequence['outputs.GatewaytemplateRoutingPoliciesTerm']] = None):
        """
        :param Sequence['GatewaytemplateRoutingPoliciesTermArgs'] terms: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @_builtins.property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GatewaytemplateRoutingPoliciesTerm']]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "terms")


@pulumi.output_type
class GatewaytemplateRoutingPoliciesTerm(dict):
    def __init__(__self__, *,
                 actions: Optional['outputs.GatewaytemplateRoutingPoliciesTermActions'] = None,
                 matching: Optional['outputs.GatewaytemplateRoutingPoliciesTermMatching'] = None):
        """
        :param 'GatewaytemplateRoutingPoliciesTermActionsArgs' actions: When used as import policy
        :param 'GatewaytemplateRoutingPoliciesTermMatchingArgs' matching: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GatewaytemplateRoutingPoliciesTermActions']:
        """
        When used as import policy
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.GatewaytemplateRoutingPoliciesTermMatching']:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "matching")


@pulumi.output_type
class GatewaytemplateRoutingPoliciesTermActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addCommunities":
            suggest = "add_communities"
        elif key == "addTargetVrfs":
            suggest = "add_target_vrfs"
        elif key == "excludeAsPaths":
            suggest = "exclude_as_paths"
        elif key == "excludeCommunities":
            suggest = "exclude_communities"
        elif key == "exportCommunities":
            suggest = "export_communities"
        elif key == "localPreference":
            suggest = "local_preference"
        elif key == "prependAsPaths":
            suggest = "prepend_as_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateRoutingPoliciesTermActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateRoutingPoliciesTermActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateRoutingPoliciesTermActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept: Optional[_builtins.bool] = None,
                 add_communities: Optional[Sequence[_builtins.str]] = None,
                 add_target_vrfs: Optional[Sequence[_builtins.str]] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 exclude_as_paths: Optional[Sequence[_builtins.str]] = None,
                 exclude_communities: Optional[Sequence[_builtins.str]] = None,
                 export_communities: Optional[Sequence[_builtins.str]] = None,
                 local_preference: Optional[_builtins.str] = None,
                 prepend_as_paths: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] add_target_vrfs: For SSR, hub decides how VRF routes are leaked on spoke
        :param Sequence[_builtins.str] communities: When used as export policy, optional
        :param Sequence[_builtins.str] exclude_as_paths: When used as export policy, optional. To exclude certain AS
        :param Sequence[_builtins.str] export_communities: When used as export policy, optional
        :param _builtins.str local_preference: Optional, for an import policy, local_preference can be changed
        :param Sequence[_builtins.str] prepend_as_paths: When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if add_communities is not None:
            pulumi.set(__self__, "add_communities", add_communities)
        if add_target_vrfs is not None:
            pulumi.set(__self__, "add_target_vrfs", add_target_vrfs)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if exclude_as_paths is not None:
            pulumi.set(__self__, "exclude_as_paths", exclude_as_paths)
        if exclude_communities is not None:
            pulumi.set(__self__, "exclude_communities", exclude_communities)
        if export_communities is not None:
            pulumi.set(__self__, "export_communities", export_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if prepend_as_paths is not None:
            pulumi.set(__self__, "prepend_as_paths", prepend_as_paths)

    @_builtins.property
    @pulumi.getter
    def accept(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "accept")

    @_builtins.property
    @pulumi.getter(name="addCommunities")
    def add_communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "add_communities")

    @_builtins.property
    @pulumi.getter(name="addTargetVrfs")
    def add_target_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        return pulumi.get(self, "add_target_vrfs")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter(name="excludeAsPaths")
    def exclude_as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional. To exclude certain AS
        """
        return pulumi.get(self, "exclude_as_paths")

    @_builtins.property
    @pulumi.getter(name="excludeCommunities")
    def exclude_communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_communities")

    @_builtins.property
    @pulumi.getter(name="exportCommunities")
    def export_communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "export_communities")

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[_builtins.str]:
        """
        Optional, for an import policy, local_preference can be changed
        """
        return pulumi.get(self, "local_preference")

    @_builtins.property
    @pulumi.getter(name="prependAsPaths")
    def prepend_as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        return pulumi.get(self, "prepend_as_paths")


@pulumi.output_type
class GatewaytemplateRoutingPoliciesTermMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asPaths":
            suggest = "as_paths"
        elif key == "routeExists":
            suggest = "route_exists"
        elif key == "vpnNeighborMacs":
            suggest = "vpn_neighbor_macs"
        elif key == "vpnPathSla":
            suggest = "vpn_path_sla"
        elif key == "vpnPaths":
            suggest = "vpn_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateRoutingPoliciesTermMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateRoutingPoliciesTermMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateRoutingPoliciesTermMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_paths: Optional[Sequence[_builtins.str]] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 prefixes: Optional[Sequence[_builtins.str]] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 route_exists: Optional['outputs.GatewaytemplateRoutingPoliciesTermMatchingRouteExists'] = None,
                 vpn_neighbor_macs: Optional[Sequence[_builtins.str]] = None,
                 vpn_path_sla: Optional['outputs.GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla'] = None,
                 vpn_paths: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] as_paths: takes regular expression
        :param Sequence[_builtins.str] prefixes: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        :param Sequence[_builtins.str] protocols: `direct`, `bgp`, `osp`, `static`, `aggregate`...
        :param Sequence[_builtins.str] vpn_neighbor_macs: overlay-facing criteria (used for bgp_config where via=vpn)
        :param Sequence[_builtins.str] vpn_paths: overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_exists is not None:
            pulumi.set(__self__, "route_exists", route_exists)
        if vpn_neighbor_macs is not None:
            pulumi.set(__self__, "vpn_neighbor_macs", vpn_neighbor_macs)
        if vpn_path_sla is not None:
            pulumi.set(__self__, "vpn_path_sla", vpn_path_sla)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        takes regular expression
        """
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "prefixes")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeExists")
    def route_exists(self) -> Optional['outputs.GatewaytemplateRoutingPoliciesTermMatchingRouteExists']:
        return pulumi.get(self, "route_exists")

    @_builtins.property
    @pulumi.getter(name="vpnNeighborMacs")
    def vpn_neighbor_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        return pulumi.get(self, "vpn_neighbor_macs")

    @_builtins.property
    @pulumi.getter(name="vpnPathSla")
    def vpn_path_sla(self) -> Optional['outputs.GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla']:
        return pulumi.get(self, "vpn_path_sla")

    @_builtins.property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        return pulumi.get(self, "vpn_paths")


@pulumi.output_type
class GatewaytemplateRoutingPoliciesTermMatchingRouteExists(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vrfName":
            suggest = "vrf_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateRoutingPoliciesTermMatchingRouteExists. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateRoutingPoliciesTermMatchingRouteExists.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateRoutingPoliciesTermMatchingRouteExists.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route: Optional[_builtins.str] = None,
                 vrf_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str vrf_name: Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        if route is not None:
            pulumi.set(__self__, "route", route)
        if vrf_name is not None:
            pulumi.set(__self__, "vrf_name", vrf_name)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> Optional[_builtins.str]:
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        return pulumi.get(self, "vrf_name")


@pulumi.output_type
class GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxJitter":
            suggest = "max_jitter"
        elif key == "maxLatency":
            suggest = "max_latency"
        elif key == "maxLoss":
            suggest = "max_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_jitter: Optional[_builtins.int] = None,
                 max_latency: Optional[_builtins.int] = None,
                 max_loss: Optional[_builtins.int] = None):
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)

    @_builtins.property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_jitter")

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_latency")

    @_builtins.property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_loss")


@pulumi.output_type
class GatewaytemplateServicePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localRouting":
            suggest = "local_routing"
        elif key == "pathPreference":
            suggest = "path_preference"
        elif key == "servicepolicyId":
            suggest = "servicepolicy_id"
        elif key == "sslProxy":
            suggest = "ssl_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateServicePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateServicePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateServicePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 antivirus: Optional['outputs.GatewaytemplateServicePolicyAntivirus'] = None,
                 appqoe: Optional['outputs.GatewaytemplateServicePolicyAppqoe'] = None,
                 ewfs: Optional[Sequence['outputs.GatewaytemplateServicePolicyEwf']] = None,
                 idp: Optional['outputs.GatewaytemplateServicePolicyIdp'] = None,
                 local_routing: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path_preference: Optional[_builtins.str] = None,
                 servicepolicy_id: Optional[_builtins.str] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 ssl_proxy: Optional['outputs.GatewaytemplateServicePolicySslProxy'] = None,
                 tenants: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str action: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        :param 'GatewaytemplateServicePolicyAntivirusArgs' antivirus: For SRX-only
        :param 'GatewaytemplateServicePolicyAppqoeArgs' appqoe: For SRX Only
        :param _builtins.bool local_routing: access within the same VRF
        :param _builtins.str name: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        :param _builtins.str path_preference: By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        :param _builtins.str servicepolicy_id: Used to link servicepolicy defined at org level and overwrite some attributes
        :param Sequence[_builtins.str] services: Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        :param 'GatewaytemplateServicePolicySslProxyArgs' ssl_proxy: For SRX-only
        :param Sequence[_builtins.str] tenants: Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if appqoe is not None:
            pulumi.set(__self__, "appqoe", appqoe)
        if ewfs is not None:
            pulumi.set(__self__, "ewfs", ewfs)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if local_routing is not None:
            pulumi.set(__self__, "local_routing", local_routing)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_preference is not None:
            pulumi.set(__self__, "path_preference", path_preference)
        if servicepolicy_id is not None:
            pulumi.set(__self__, "servicepolicy_id", servicepolicy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssl_proxy is not None:
            pulumi.set(__self__, "ssl_proxy", ssl_proxy)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional['outputs.GatewaytemplateServicePolicyAntivirus']:
        """
        For SRX-only
        """
        return pulumi.get(self, "antivirus")

    @_builtins.property
    @pulumi.getter
    def appqoe(self) -> Optional['outputs.GatewaytemplateServicePolicyAppqoe']:
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @_builtins.property
    @pulumi.getter
    def ewfs(self) -> Optional[Sequence['outputs.GatewaytemplateServicePolicyEwf']]:
        return pulumi.get(self, "ewfs")

    @_builtins.property
    @pulumi.getter
    def idp(self) -> Optional['outputs.GatewaytemplateServicePolicyIdp']:
        return pulumi.get(self, "idp")

    @_builtins.property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> Optional[_builtins.bool]:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> Optional[_builtins.str]:
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @_builtins.property
    @pulumi.getter(name="servicepolicyId")
    def servicepolicy_id(self) -> Optional[_builtins.str]:
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        return pulumi.get(self, "servicepolicy_id")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sslProxy")
    def ssl_proxy(self) -> Optional['outputs.GatewaytemplateServicePolicySslProxy']:
        """
        For SRX-only
        """
        return pulumi.get(self, "ssl_proxy")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        return pulumi.get(self, "tenants")


@pulumi.output_type
class GatewaytemplateServicePolicyAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avprofileId":
            suggest = "avprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateServicePolicyAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateServicePolicyAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateServicePolicyAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avprofile_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[_builtins.str]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GatewaytemplateServicePolicyAppqoe(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewaytemplateServicePolicyEwf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "blockMessage":
            suggest = "block_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateServicePolicyEwf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateServicePolicyEwf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateServicePolicyEwf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 block_message: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "block_message")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GatewaytemplateServicePolicyIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "idpprofileId":
            suggest = "idpprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateServicePolicyIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateServicePolicyIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateServicePolicyIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idpprofile_id: Optional[_builtins.str] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param _builtins.str profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[_builtins.str]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GatewaytemplateServicePolicySslProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ciphersCategory":
            suggest = "ciphers_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateServicePolicySslProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateServicePolicySslProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateServicePolicySslProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers_category: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[_builtins.str]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewaytemplateTunnelConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoProvision":
            suggest = "auto_provision"
        elif key == "ikeLifetime":
            suggest = "ike_lifetime"
        elif key == "ikeMode":
            suggest = "ike_mode"
        elif key == "ikeProposals":
            suggest = "ike_proposals"
        elif key == "ipsecLifetime":
            suggest = "ipsec_lifetime"
        elif key == "ipsecProposals":
            suggest = "ipsec_proposals"
        elif key == "localId":
            suggest = "local_id"
        elif key == "localSubnets":
            suggest = "local_subnets"
        elif key == "remoteSubnets":
            suggest = "remote_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_provision: Optional['outputs.GatewaytemplateTunnelConfigsAutoProvision'] = None,
                 ike_lifetime: Optional[_builtins.int] = None,
                 ike_mode: Optional[_builtins.str] = None,
                 ike_proposals: Optional[Sequence['outputs.GatewaytemplateTunnelConfigsIkeProposal']] = None,
                 ipsec_lifetime: Optional[_builtins.int] = None,
                 ipsec_proposals: Optional[Sequence['outputs.GatewaytemplateTunnelConfigsIpsecProposal']] = None,
                 local_id: Optional[_builtins.str] = None,
                 local_subnets: Optional[Sequence[_builtins.str]] = None,
                 mode: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 primary: Optional['outputs.GatewaytemplateTunnelConfigsPrimary'] = None,
                 probe: Optional['outputs.GatewaytemplateTunnelConfigsProbe'] = None,
                 protocol: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 psk: Optional[_builtins.str] = None,
                 remote_subnets: Optional[Sequence[_builtins.str]] = None,
                 secondary: Optional['outputs.GatewaytemplateTunnelConfigsSecondary'] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param 'GatewaytemplateTunnelConfigsAutoProvisionArgs' auto_provision: Auto Provisioning configuration for the tunne. This takes precedence over the `primary` and `secondary` nodes.
        :param _builtins.int ike_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param _builtins.str ike_mode: Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        :param Sequence['GatewaytemplateTunnelConfigsIkeProposalArgs'] ike_proposals: If `provider`==`custom-ipsec`
        :param _builtins.int ipsec_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param Sequence['GatewaytemplateTunnelConfigsIpsecProposalArgs'] ipsec_proposals: Only if  `provider`==`custom-ipsec`
        :param _builtins.str local_id: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param Sequence[_builtins.str] local_subnets: List of Local protected subnet for policy-based IPSec negotiation
        :param _builtins.str mode: Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        :param Sequence[_builtins.str] networks: If `provider`==`custom-ipsec` or `provider`==`prisma-ipsec`, networks reachable via this tunnel
        :param 'GatewaytemplateTunnelConfigsPrimaryArgs' primary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param 'GatewaytemplateTunnelConfigsProbeArgs' probe: Only if `provider`==`custom-ipsec`
        :param _builtins.str protocol: Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        :param _builtins.str provider: Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `prisma-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        :param _builtins.str psk: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param Sequence[_builtins.str] remote_subnets: List of Remote protected subnet for policy-based IPSec negotiation
        :param 'GatewaytemplateTunnelConfigsSecondaryArgs' secondary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param _builtins.str version: Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        if auto_provision is not None:
            pulumi.set(__self__, "auto_provision", auto_provision)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_mode is not None:
            pulumi.set(__self__, "ike_mode", ike_mode)
        if ike_proposals is not None:
            pulumi.set(__self__, "ike_proposals", ike_proposals)
        if ipsec_lifetime is not None:
            pulumi.set(__self__, "ipsec_lifetime", ipsec_lifetime)
        if ipsec_proposals is not None:
            pulumi.set(__self__, "ipsec_proposals", ipsec_proposals)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if local_subnets is not None:
            pulumi.set(__self__, "local_subnets", local_subnets)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if probe is not None:
            pulumi.set(__self__, "probe", probe)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if remote_subnets is not None:
            pulumi.set(__self__, "remote_subnets", remote_subnets)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> Optional['outputs.GatewaytemplateTunnelConfigsAutoProvision']:
        """
        Auto Provisioning configuration for the tunne. This takes precedence over the `primary` and `secondary` nodes.
        """
        return pulumi.get(self, "auto_provision")

    @_builtins.property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[_builtins.int]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ike_lifetime")

    @_builtins.property
    @pulumi.getter(name="ikeMode")
    def ike_mode(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        return pulumi.get(self, "ike_mode")

    @_builtins.property
    @pulumi.getter(name="ikeProposals")
    def ike_proposals(self) -> Optional[Sequence['outputs.GatewaytemplateTunnelConfigsIkeProposal']]:
        """
        If `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ike_proposals")

    @_builtins.property
    @pulumi.getter(name="ipsecLifetime")
    def ipsec_lifetime(self) -> Optional[_builtins.int]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ipsec_lifetime")

    @_builtins.property
    @pulumi.getter(name="ipsecProposals")
    def ipsec_proposals(self) -> Optional[Sequence['outputs.GatewaytemplateTunnelConfigsIpsecProposal']]:
        """
        Only if  `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ipsec_proposals")

    @_builtins.property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "local_id")

    @_builtins.property
    @pulumi.getter(name="localSubnets")
    def local_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Local protected subnet for policy-based IPSec negotiation
        """
        return pulumi.get(self, "local_subnets")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `provider`==`custom-ipsec` or `provider`==`prisma-ipsec`, networks reachable via this tunnel
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.GatewaytemplateTunnelConfigsPrimary']:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def probe(self) -> Optional['outputs.GatewaytemplateTunnelConfigsProbe']:
        """
        Only if `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "probe")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `prisma-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "psk")

    @_builtins.property
    @pulumi.getter(name="remoteSubnets")
    def remote_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Remote protected subnet for policy-based IPSec negotiation
        """
        return pulumi.get(self, "remote_subnets")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.GatewaytemplateTunnelConfigsSecondary']:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GatewaytemplateTunnelConfigsAutoProvision(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConnection":
            suggest = "service_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsAutoProvision. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsAutoProvision.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsAutoProvision.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider: _builtins.str,
                 enabled: Optional[_builtins.bool] = None,
                 latlng: Optional['outputs.GatewaytemplateTunnelConfigsAutoProvisionLatlng'] = None,
                 primary: Optional['outputs.GatewaytemplateTunnelConfigsAutoProvisionPrimary'] = None,
                 region: Optional[_builtins.str] = None,
                 secondary: Optional['outputs.GatewaytemplateTunnelConfigsAutoProvisionSecondary'] = None,
                 service_connection: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider: enum: `jse-ipsec`, `zscaler-ipsec`
        :param _builtins.bool enabled: Enable auto provisioning for the tunnel. If enabled, the `primary` and `secondary` nodes will be ignored.
        :param 'GatewaytemplateTunnelConfigsAutoProvisionLatlngArgs' latlng: API override for POP selection
        :param _builtins.str region: API override for POP selection in the case user wants to override the auto discovery of remote network location and force the tunnel to use the specified peer location.
        :param _builtins.str service_connection: if `provider`==`prisma-ipsec`. By default, we'll use the location of the site to determine the optimal Remote Network location, optionally, service_connection can be considered, then we'll also consider this along with the site location. Define service_connection if the traffic is to be routed to a specific service connection. This field takes a service connection name that is configured in the Prisma cloud, Prisma Access Setup > Service Connections.
        """
        pulumi.set(__self__, "provider", provider)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if latlng is not None:
            pulumi.set(__self__, "latlng", latlng)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if service_connection is not None:
            pulumi.set(__self__, "service_connection", service_connection)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable auto provisioning for the tunnel. If enabled, the `primary` and `secondary` nodes will be ignored.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def latlng(self) -> Optional['outputs.GatewaytemplateTunnelConfigsAutoProvisionLatlng']:
        """
        API override for POP selection
        """
        return pulumi.get(self, "latlng")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.GatewaytemplateTunnelConfigsAutoProvisionPrimary']:
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        API override for POP selection in the case user wants to override the auto discovery of remote network location and force the tunnel to use the specified peer location.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.GatewaytemplateTunnelConfigsAutoProvisionSecondary']:
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter(name="serviceConnection")
    def service_connection(self) -> Optional[_builtins.str]:
        """
        if `provider`==`prisma-ipsec`. By default, we'll use the location of the site to determine the optimal Remote Network location, optionally, service_connection can be considered, then we'll also consider this along with the site location. Define service_connection if the traffic is to be routed to a specific service connection. This field takes a service connection name that is configured in the Prisma cloud, Prisma Access Setup > Service Connections.
        """
        return pulumi.get(self, "service_connection")


@pulumi.output_type
class GatewaytemplateTunnelConfigsAutoProvisionLatlng(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        return pulumi.get(self, "lng")


@pulumi.output_type
class GatewaytemplateTunnelConfigsAutoProvisionPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIps":
            suggest = "probe_ips"
        elif key == "wanNames":
            suggest = "wan_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsAutoProvisionPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsAutoProvisionPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsAutoProvisionPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")


@pulumi.output_type
class GatewaytemplateTunnelConfigsAutoProvisionSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIps":
            suggest = "probe_ips"
        elif key == "wanNames":
            suggest = "wan_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsAutoProvisionSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsAutoProvisionSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsAutoProvisionSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")


@pulumi.output_type
class GatewaytemplateTunnelConfigsIkeProposal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authAlgo":
            suggest = "auth_algo"
        elif key == "dhGroup":
            suggest = "dh_group"
        elif key == "encAlgo":
            suggest = "enc_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsIkeProposal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsIkeProposal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsIkeProposal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_algo: Optional[_builtins.str] = None,
                 dh_group: Optional[_builtins.str] = None,
                 enc_algo: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_algo: enum: `md5`, `sha1`, `sha2`
        :param _builtins.str dh_group: enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param _builtins.str enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[_builtins.str]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[_builtins.str]:
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @_builtins.property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[_builtins.str]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")


@pulumi.output_type
class GatewaytemplateTunnelConfigsIpsecProposal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authAlgo":
            suggest = "auth_algo"
        elif key == "dhGroup":
            suggest = "dh_group"
        elif key == "encAlgo":
            suggest = "enc_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsIpsecProposal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsIpsecProposal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsIpsecProposal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_algo: Optional[_builtins.str] = None,
                 dh_group: Optional[_builtins.str] = None,
                 enc_algo: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_algo: enum: `md5`, `sha1`, `sha2`
        :param _builtins.str dh_group: Only if `provider`==`custom-ipsec`. enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param _builtins.str enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[_builtins.str]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @_builtins.property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[_builtins.str]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")


@pulumi.output_type
class GatewaytemplateTunnelConfigsPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanNames":
            suggest = "wan_names"
        elif key == "internalIps":
            suggest = "internal_ips"
        elif key == "probeIps":
            suggest = "probe_ips"
        elif key == "remoteIds":
            suggest = "remote_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 wan_names: Sequence[_builtins.str],
                 internal_ips: Optional[Sequence[_builtins.str]] = None,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 remote_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param Sequence[_builtins.str] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "wan_names")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")


@pulumi.output_type
class GatewaytemplateTunnelConfigsProbe(dict):
    def __init__(__self__, *,
                 interval: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int interval: How often to trigger the probe
        :param _builtins.int threshold: Number of consecutive misses before declaring the tunnel down
        :param _builtins.int timeout: Time within which to complete the connectivity check
        :param _builtins.str type: enum: `http`, `icmp`
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        How often to trigger the probe
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive misses before declaring the tunnel down
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Time within which to complete the connectivity check
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewaytemplateTunnelConfigsSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanNames":
            suggest = "wan_names"
        elif key == "internalIps":
            suggest = "internal_ips"
        elif key == "probeIps":
            suggest = "probe_ips"
        elif key == "remoteIds":
            suggest = "remote_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelConfigsSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelConfigsSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelConfigsSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 wan_names: Sequence[_builtins.str],
                 internal_ips: Optional[Sequence[_builtins.str]] = None,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 remote_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param Sequence[_builtins.str] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "wan_names")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")


@pulumi.output_type
class GatewaytemplateTunnelProviderOptions(dict):
    def __init__(__self__, *,
                 jse: Optional['outputs.GatewaytemplateTunnelProviderOptionsJse'] = None,
                 prisma: Optional['outputs.GatewaytemplateTunnelProviderOptionsPrisma'] = None,
                 zscaler: Optional['outputs.GatewaytemplateTunnelProviderOptionsZscaler'] = None):
        """
        :param 'GatewaytemplateTunnelProviderOptionsJseArgs' jse: For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        :param 'GatewaytemplateTunnelProviderOptionsZscalerArgs' zscaler: For zscaler-ipsec and zscaler-gre
        """
        if jse is not None:
            pulumi.set(__self__, "jse", jse)
        if prisma is not None:
            pulumi.set(__self__, "prisma", prisma)
        if zscaler is not None:
            pulumi.set(__self__, "zscaler", zscaler)

    @_builtins.property
    @pulumi.getter
    def jse(self) -> Optional['outputs.GatewaytemplateTunnelProviderOptionsJse']:
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        return pulumi.get(self, "jse")

    @_builtins.property
    @pulumi.getter
    def prisma(self) -> Optional['outputs.GatewaytemplateTunnelProviderOptionsPrisma']:
        return pulumi.get(self, "prisma")

    @_builtins.property
    @pulumi.getter
    def zscaler(self) -> Optional['outputs.GatewaytemplateTunnelProviderOptionsZscaler']:
        """
        For zscaler-ipsec and zscaler-gre
        """
        return pulumi.get(self, "zscaler")


@pulumi.output_type
class GatewaytemplateTunnelProviderOptionsJse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numUsers":
            suggest = "num_users"
        elif key == "orgName":
            suggest = "org_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelProviderOptionsJse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelProviderOptionsJse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelProviderOptionsJse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_users: Optional[_builtins.int] = None,
                 org_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str org_name: JSE Organization name
        """
        if num_users is not None:
            pulumi.set(__self__, "num_users", num_users)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)

    @_builtins.property
    @pulumi.getter(name="numUsers")
    def num_users(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_users")

    @_builtins.property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[_builtins.str]:
        """
        JSE Organization name
        """
        return pulumi.get(self, "org_name")


@pulumi.output_type
class GatewaytemplateTunnelProviderOptionsPrisma(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountName":
            suggest = "service_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelProviderOptionsPrisma. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelProviderOptionsPrisma.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelProviderOptionsPrisma.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_name: For prisma-ipsec, service account name to used for tunnel auto provisioning
        """
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)

    @_builtins.property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[_builtins.str]:
        """
        For prisma-ipsec, service account name to used for tunnel auto provisioning
        """
        return pulumi.get(self, "service_account_name")


@pulumi.output_type
class GatewaytemplateTunnelProviderOptionsZscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aupBlockInternetUntilAccepted":
            suggest = "aup_block_internet_until_accepted"
        elif key == "aupEnabled":
            suggest = "aup_enabled"
        elif key == "aupForceSslInspection":
            suggest = "aup_force_ssl_inspection"
        elif key == "aupTimeoutInDays":
            suggest = "aup_timeout_in_days"
        elif key == "authRequired":
            suggest = "auth_required"
        elif key == "cautionEnabled":
            suggest = "caution_enabled"
        elif key == "dnBandwidth":
            suggest = "dn_bandwidth"
        elif key == "idleTimeInMinutes":
            suggest = "idle_time_in_minutes"
        elif key == "ofwEnabled":
            suggest = "ofw_enabled"
        elif key == "subLocations":
            suggest = "sub_locations"
        elif key == "surrogateIp":
            suggest = "surrogate_ip"
        elif key == "surrogateIpEnforcedForKnownBrowsers":
            suggest = "surrogate_ip_enforced_for_known_browsers"
        elif key == "surrogateRefreshTimeInMinutes":
            suggest = "surrogate_refresh_time_in_minutes"
        elif key == "upBandwidth":
            suggest = "up_bandwidth"
        elif key == "xffForwardEnabled":
            suggest = "xff_forward_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelProviderOptionsZscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelProviderOptionsZscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelProviderOptionsZscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[_builtins.bool] = None,
                 aup_enabled: Optional[_builtins.bool] = None,
                 aup_force_ssl_inspection: Optional[_builtins.bool] = None,
                 aup_timeout_in_days: Optional[_builtins.int] = None,
                 auth_required: Optional[_builtins.bool] = None,
                 caution_enabled: Optional[_builtins.bool] = None,
                 dn_bandwidth: Optional[_builtins.float] = None,
                 idle_time_in_minutes: Optional[_builtins.int] = None,
                 ofw_enabled: Optional[_builtins.bool] = None,
                 sub_locations: Optional[Sequence['outputs.GatewaytemplateTunnelProviderOptionsZscalerSubLocation']] = None,
                 surrogate_ip: Optional[_builtins.bool] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[_builtins.bool] = None,
                 surrogate_refresh_time_in_minutes: Optional[_builtins.int] = None,
                 up_bandwidth: Optional[_builtins.float] = None,
                 xff_forward_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param _builtins.bool aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param _builtins.int aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param _builtins.bool auth_required: Enable this option to enforce user authentication
        :param _builtins.bool caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param _builtins.float dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.int idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param _builtins.bool ofw_enabled: If `true`, enable the firewall control option
        :param Sequence['GatewaytemplateTunnelProviderOptionsZscalerSubLocationArgs'] sub_locations: `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        :param _builtins.bool surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param _builtins.bool surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param _builtins.int surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param _builtins.float up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.bool xff_forward_enabled: Location uses proxy chaining to forward traffic
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if sub_locations is not None:
            pulumi.set(__self__, "sub_locations", sub_locations)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)
        if xff_forward_enabled is not None:
            pulumi.set(__self__, "xff_forward_enabled", xff_forward_enabled)

    @_builtins.property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @_builtins.property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @_builtins.property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[_builtins.bool]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @_builtins.property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[_builtins.int]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @_builtins.property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[_builtins.bool]:
        """
        Enable this option to enforce user authentication
        """
        return pulumi.get(self, "auth_required")

    @_builtins.property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @_builtins.property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @_builtins.property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @_builtins.property
    @pulumi.getter(name="subLocations")
    def sub_locations(self) -> Optional[Sequence['outputs.GatewaytemplateTunnelProviderOptionsZscalerSubLocation']]:
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        return pulumi.get(self, "sub_locations")

    @_builtins.property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @_builtins.property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @_builtins.property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @_builtins.property
    @pulumi.getter(name="xffForwardEnabled")
    def xff_forward_enabled(self) -> Optional[_builtins.bool]:
        """
        Location uses proxy chaining to forward traffic
        """
        return pulumi.get(self, "xff_forward_enabled")


@pulumi.output_type
class GatewaytemplateTunnelProviderOptionsZscalerSubLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aupBlockInternetUntilAccepted":
            suggest = "aup_block_internet_until_accepted"
        elif key == "aupEnabled":
            suggest = "aup_enabled"
        elif key == "aupForceSslInspection":
            suggest = "aup_force_ssl_inspection"
        elif key == "aupTimeoutInDays":
            suggest = "aup_timeout_in_days"
        elif key == "authRequired":
            suggest = "auth_required"
        elif key == "cautionEnabled":
            suggest = "caution_enabled"
        elif key == "dnBandwidth":
            suggest = "dn_bandwidth"
        elif key == "idleTimeInMinutes":
            suggest = "idle_time_in_minutes"
        elif key == "ofwEnabled":
            suggest = "ofw_enabled"
        elif key == "surrogateIp":
            suggest = "surrogate_ip"
        elif key == "surrogateIpEnforcedForKnownBrowsers":
            suggest = "surrogate_ip_enforced_for_known_browsers"
        elif key == "surrogateRefreshTimeInMinutes":
            suggest = "surrogate_refresh_time_in_minutes"
        elif key == "upBandwidth":
            suggest = "up_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaytemplateTunnelProviderOptionsZscalerSubLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaytemplateTunnelProviderOptionsZscalerSubLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaytemplateTunnelProviderOptionsZscalerSubLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[_builtins.bool] = None,
                 aup_enabled: Optional[_builtins.bool] = None,
                 aup_force_ssl_inspection: Optional[_builtins.bool] = None,
                 aup_timeout_in_days: Optional[_builtins.int] = None,
                 auth_required: Optional[_builtins.bool] = None,
                 caution_enabled: Optional[_builtins.bool] = None,
                 dn_bandwidth: Optional[_builtins.float] = None,
                 idle_time_in_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 ofw_enabled: Optional[_builtins.bool] = None,
                 surrogate_ip: Optional[_builtins.bool] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[_builtins.bool] = None,
                 surrogate_refresh_time_in_minutes: Optional[_builtins.int] = None,
                 up_bandwidth: Optional[_builtins.float] = None):
        """
        :param _builtins.bool aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param _builtins.bool aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param _builtins.int aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param _builtins.bool auth_required: Enable this option to authenticate users
        :param _builtins.bool caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param _builtins.float dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.int idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param _builtins.str name: Network name
        :param _builtins.bool ofw_enabled: If `true`, enable the firewall control option
        :param _builtins.bool surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param _builtins.bool surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param _builtins.int surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param _builtins.float up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)

    @_builtins.property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @_builtins.property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @_builtins.property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[_builtins.bool]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @_builtins.property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[_builtins.int]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @_builtins.property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[_builtins.bool]:
        """
        Enable this option to authenticate users
        """
        return pulumi.get(self, "auth_required")

    @_builtins.property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @_builtins.property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @_builtins.property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @_builtins.property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @_builtins.property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @_builtins.property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")


@pulumi.output_type
class GatewaytemplateVrfConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewaytemplateVrfInstances(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[_builtins.str]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class IdpprofileOverwrite(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 action: Optional[_builtins.str] = None,
                 matching: Optional['outputs.IdpprofileOverwriteMatching'] = None):
        """
        :param _builtins.str action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.IdpprofileOverwriteMatching']:
        return pulumi.get(self, "matching")


@pulumi.output_type
class IdpprofileOverwriteMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackNames":
            suggest = "attack_names"
        elif key == "dstSubnets":
            suggest = "dst_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdpprofileOverwriteMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdpprofileOverwriteMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdpprofileOverwriteMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attack_names: Optional[Sequence[_builtins.str]] = None,
                 dst_subnets: Optional[Sequence[_builtins.str]] = None,
                 severities: Optional[Sequence[_builtins.str]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "attack_names")

    @_builtins.property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dst_subnets")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "severities")


@pulumi.output_type
class InventoryInventory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimCode":
            suggest = "claim_code"
        elif key == "deviceprofileId":
            suggest = "deviceprofile_id"
        elif key == "orgId":
            suggest = "org_id"
        elif key == "siteId":
            suggest = "site_id"
        elif key == "unclaimWhenDestroyed":
            suggest = "unclaim_when_destroyed"
        elif key == "vcMac":
            suggest = "vc_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InventoryInventory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InventoryInventory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InventoryInventory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim_code: Optional[_builtins.str] = None,
                 deviceprofile_id: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 mac: Optional[_builtins.str] = None,
                 model: Optional[_builtins.str] = None,
                 org_id: Optional[_builtins.str] = None,
                 serial: Optional[_builtins.str] = None,
                 site_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 unclaim_when_destroyed: Optional[_builtins.bool] = None,
                 vc_mac: Optional[_builtins.str] = None):
        """
        :param _builtins.str claim_code: device claim code
        :param _builtins.str deviceprofile_id: deviceprofile id if assigned, null if not assigned
        :param _builtins.str hostname: hostname reported by the device
        :param _builtins.str id: device id
        :param _builtins.str mac: device MAC address
        :param _builtins.str model: device model
        :param _builtins.str serial: device serial
        :param _builtins.str site_id: Site ID. Used to assign device to a Site
        :param _builtins.str type: enum: `ap`, `gateway`, `switch`
        :param _builtins.bool unclaim_when_destroyed: Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
        :param _builtins.str vc_mac: if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
        if claim_code is not None:
            pulumi.set(__self__, "claim_code", claim_code)
        if deviceprofile_id is not None:
            pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unclaim_when_destroyed is not None:
            pulumi.set(__self__, "unclaim_when_destroyed", unclaim_when_destroyed)
        if vc_mac is not None:
            pulumi.set(__self__, "vc_mac", vc_mac)

    @_builtins.property
    @pulumi.getter(name="claimCode")
    def claim_code(self) -> Optional[_builtins.str]:
        """
        device claim code
        """
        return pulumi.get(self, "claim_code")

    @_builtins.property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> Optional[_builtins.str]:
        """
        deviceprofile id if assigned, null if not assigned
        """
        return pulumi.get(self, "deviceprofile_id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        hostname reported by the device
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        device id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> Optional[_builtins.str]:
        """
        device MAC address
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        device model
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> Optional[_builtins.str]:
        """
        device serial
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[_builtins.str]:
        """
        Site ID. Used to assign device to a Site
        """
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `ap`, `gateway`, `switch`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unclaimWhenDestroyed")
    def unclaim_when_destroyed(self) -> Optional[_builtins.bool]:
        """
        Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
        """
        return pulumi.get(self, "unclaim_when_destroyed")

    @_builtins.property
    @pulumi.getter(name="vcMac")
    def vc_mac(self) -> Optional[_builtins.str]:
        """
        if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
        return pulumi.get(self, "vc_mac")


@pulumi.output_type
class NacruleMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "portTypes":
            suggest = "port_types"
        elif key == "siteIds":
            suggest = "site_ids"
        elif key == "sitegroupIds":
            suggest = "sitegroup_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NacruleMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NacruleMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NacruleMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: Optional[_builtins.str] = None,
                 families: Optional[Sequence[_builtins.str]] = None,
                 mfgs: Optional[Sequence[_builtins.str]] = None,
                 models: Optional[Sequence[_builtins.str]] = None,
                 nactags: Optional[Sequence[_builtins.str]] = None,
                 os_types: Optional[Sequence[_builtins.str]] = None,
                 port_types: Optional[Sequence[_builtins.str]] = None,
                 site_ids: Optional[Sequence[_builtins.str]] = None,
                 sitegroup_ids: Optional[Sequence[_builtins.str]] = None,
                 vendors: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str auth_type: enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `eap-peap`
        :param Sequence[_builtins.str] families: List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        :param Sequence[_builtins.str] mfgs: List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        :param Sequence[_builtins.str] models: List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        :param Sequence[_builtins.str] os_types: List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        :param Sequence[_builtins.str] site_ids: List of site ids to match
        :param Sequence[_builtins.str] sitegroup_ids: List of sitegroup ids to match
        :param Sequence[_builtins.str] vendors: List of vendors to match
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if families is not None:
            pulumi.set(__self__, "families", families)
        if mfgs is not None:
            pulumi.set(__self__, "mfgs", mfgs)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if nactags is not None:
            pulumi.set(__self__, "nactags", nactags)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if port_types is not None:
            pulumi.set(__self__, "port_types", port_types)
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `eap-peap`
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def families(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        """
        return pulumi.get(self, "families")

    @_builtins.property
    @pulumi.getter
    def mfgs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        """
        return pulumi.get(self, "mfgs")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def nactags(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "nactags")

    @_builtins.property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        """
        return pulumi.get(self, "os_types")

    @_builtins.property
    @pulumi.getter(name="portTypes")
    def port_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "port_types")

    @_builtins.property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of site ids to match
        """
        return pulumi.get(self, "site_ids")

    @_builtins.property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of sitegroup ids to match
        """
        return pulumi.get(self, "sitegroup_ids")

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of vendors to match
        """
        return pulumi.get(self, "vendors")


@pulumi.output_type
class NacruleNotMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "osTypes":
            suggest = "os_types"
        elif key == "portTypes":
            suggest = "port_types"
        elif key == "siteIds":
            suggest = "site_ids"
        elif key == "sitegroupIds":
            suggest = "sitegroup_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NacruleNotMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NacruleNotMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NacruleNotMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: Optional[_builtins.str] = None,
                 families: Optional[Sequence[_builtins.str]] = None,
                 mfgs: Optional[Sequence[_builtins.str]] = None,
                 models: Optional[Sequence[_builtins.str]] = None,
                 nactags: Optional[Sequence[_builtins.str]] = None,
                 os_types: Optional[Sequence[_builtins.str]] = None,
                 port_types: Optional[Sequence[_builtins.str]] = None,
                 site_ids: Optional[Sequence[_builtins.str]] = None,
                 sitegroup_ids: Optional[Sequence[_builtins.str]] = None,
                 vendors: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str auth_type: enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `eap-peap`
        :param Sequence[_builtins.str] families: List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        :param Sequence[_builtins.str] mfgs: List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        :param Sequence[_builtins.str] models: List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        :param Sequence[_builtins.str] os_types: List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        :param Sequence[_builtins.str] site_ids: List of site ids to match
        :param Sequence[_builtins.str] sitegroup_ids: List of sitegroup ids to match
        :param Sequence[_builtins.str] vendors: List of vendors to match
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if families is not None:
            pulumi.set(__self__, "families", families)
        if mfgs is not None:
            pulumi.set(__self__, "mfgs", mfgs)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if nactags is not None:
            pulumi.set(__self__, "nactags", nactags)
        if os_types is not None:
            pulumi.set(__self__, "os_types", os_types)
        if port_types is not None:
            pulumi.set(__self__, "port_types", port_types)
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)
        if vendors is not None:
            pulumi.set(__self__, "vendors", vendors)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `eap-peap`
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def families(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device families to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed family values
        """
        return pulumi.get(self, "families")

    @_builtins.property
    @pulumi.getter
    def mfgs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device models to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed model values
        """
        return pulumi.get(self, "mfgs")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device manufacturers to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed mfg values
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def nactags(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "nactags")

    @_builtins.property
    @pulumi.getter(name="osTypes")
    def os_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of client device os types to match. Refer to [List Fingerprint Types]]($e/Constants%20Definitions/listFingerprintTypes) for allowed os_type values
        """
        return pulumi.get(self, "os_types")

    @_builtins.property
    @pulumi.getter(name="portTypes")
    def port_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "port_types")

    @_builtins.property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of site ids to match
        """
        return pulumi.get(self, "site_ids")

    @_builtins.property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of sitegroup ids to match
        """
        return pulumi.get(self, "sitegroup_ids")

    @_builtins.property
    @pulumi.getter
    def vendors(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of vendors to match
        """
        return pulumi.get(self, "vendors")


@pulumi.output_type
class NetworkInternalAccess(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkInternetAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createSimpleServicePolicy":
            suggest = "create_simple_service_policy"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "staticNat":
            suggest = "static_nat"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInternetAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInternetAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInternetAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_simple_service_policy: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.NetworkInternetAccessDestinationNat']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 restricted: Optional[_builtins.bool] = None,
                 static_nat: Optional[Mapping[str, 'outputs.NetworkInternetAccessStaticNat']] = None):
        """
        :param Mapping[str, 'NetworkInternetAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.bool restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param Mapping[str, 'NetworkInternetAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @_builtins.property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_simple_service_policy")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.NetworkInternetAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def restricted(self) -> Optional[_builtins.bool]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.NetworkInternetAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")


@pulumi.output_type
class NetworkInternetAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInternetAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInternetAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInternetAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class NetworkInternetAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInternetAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInternetAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInternetAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class NetworkMulticast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableIgmp":
            suggest = "disable_igmp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkMulticast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkMulticast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkMulticast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_igmp: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 groups: Optional[Mapping[str, 'outputs.NetworkMulticastGroups']] = None):
        """
        :param _builtins.bool disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param Mapping[str, 'NetworkMulticastGroupsArgs'] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[_builtins.bool]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Mapping[str, 'outputs.NetworkMulticastGroups']]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class NetworkMulticastGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rpIp":
            suggest = "rp_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkMulticastGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkMulticastGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkMulticastGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rp_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @_builtins.property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[_builtins.str]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")


@pulumi.output_type
class NetworkTenants(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[_builtins.str]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "addresses")


@pulumi.output_type
class NetworkVpnAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedSubnet":
            suggest = "advertised_subnet"
        elif key == "allowPing":
            suggest = "allow_ping"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "natPool":
            suggest = "nat_pool"
        elif key == "noReadvertiseToLanBgp":
            suggest = "no_readvertise_to_lan_bgp"
        elif key == "noReadvertiseToLanOspf":
            suggest = "no_readvertise_to_lan_ospf"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "otherVrfs":
            suggest = "other_vrfs"
        elif key == "sourceNat":
            suggest = "source_nat"
        elif key == "staticNat":
            suggest = "static_nat"
        elif key == "summarizedSubnet":
            suggest = "summarized_subnet"
        elif key == "summarizedSubnetToLanBgp":
            suggest = "summarized_subnet_to_lan_bgp"
        elif key == "summarizedSubnetToLanOspf":
            suggest = "summarized_subnet_to_lan_ospf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVpnAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVpnAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVpnAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_subnet: Optional[_builtins.str] = None,
                 allow_ping: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.NetworkVpnAccessDestinationNat']] = None,
                 nat_pool: Optional[_builtins.str] = None,
                 no_readvertise_to_lan_bgp: Optional[_builtins.bool] = None,
                 no_readvertise_to_lan_ospf: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 other_vrfs: Optional[Sequence[_builtins.str]] = None,
                 routed: Optional[_builtins.bool] = None,
                 source_nat: Optional['outputs.NetworkVpnAccessSourceNat'] = None,
                 static_nat: Optional[Mapping[str, 'outputs.NetworkVpnAccessStaticNat']] = None,
                 summarized_subnet: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_bgp: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_ospf: Optional[_builtins.str] = None):
        """
        :param _builtins.str advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param _builtins.bool allow_ping: Whether to allow ping from vpn into this routed network
        :param Mapping[str, 'NetworkVpnAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.str nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param _builtins.bool no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.bool no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param _builtins.bool no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param Sequence[_builtins.str] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param _builtins.bool routed: Whether this network is routable
        :param 'NetworkVpnAccessSourceNatArgs' source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param Mapping[str, 'NetworkVpnAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param _builtins.str summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.str summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @_builtins.property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[_builtins.str]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @_builtins.property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[_builtins.bool]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.NetworkVpnAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @_builtins.property
    @pulumi.getter
    def routed(self) -> Optional[_builtins.bool]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @_builtins.property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional['outputs.NetworkVpnAccessSourceNat']:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.NetworkVpnAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[_builtins.str]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[_builtins.str]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[_builtins.str]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")


@pulumi.output_type
class NetworkVpnAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVpnAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVpnAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVpnAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworkVpnAccessSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIp":
            suggest = "external_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVpnAccessSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVpnAccessSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVpnAccessSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_ip: Optional[_builtins.str] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @_builtins.property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_ip")


@pulumi.output_type
class NetworkVpnAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkVpnAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkVpnAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkVpnAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworktemplateAclPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "srcTags":
            suggest = "src_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.NetworktemplateAclPolicyAction']] = None,
                 name: Optional[_builtins.str] = None,
                 src_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['NetworktemplateAclPolicyActionArgs'] actions: ACL Policy Actions:
                 - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
                 - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        :param Sequence[_builtins.str] src_tags: ACL Policy Source Tags:
                 - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
                 - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_tags is not None:
            pulumi.set(__self__, "src_tags", src_tags)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.NetworktemplateAclPolicyAction']]:
        """
        ACL Policy Actions:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="srcTags")
    def src_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        ACL Policy Source Tags:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "src_tags")


@pulumi.output_type
class NetworktemplateAclPolicyAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstTag":
            suggest = "dst_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclPolicyAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclPolicyAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclPolicyAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dst_tag: _builtins.str,
                 action: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: enum: `allow`, `deny`
        """
        pulumi.set(__self__, "dst_tag", dst_tag)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter(name="dstTag")
    def dst_tag(self) -> _builtins.str:
        return pulumi.get(self, "dst_tag")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class NetworktemplateAclTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "etherTypes":
            suggest = "ether_types"
        elif key == "gbpTag":
            suggest = "gbp_tag"
        elif key == "portUsage":
            suggest = "port_usage"
        elif key == "radiusGroup":
            suggest = "radius_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 ether_types: Optional[Sequence[_builtins.str]] = None,
                 gbp_tag: Optional[_builtins.int] = None,
                 macs: Optional[Sequence[_builtins.str]] = None,
                 network: Optional[_builtins.str] = None,
                 port_usage: Optional[_builtins.str] = None,
                 radius_group: Optional[_builtins.str] = None,
                 specs: Optional[Sequence['outputs.NetworktemplateAclTagsSpec']] = None,
                 subnets: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: enum: 
                 * `any`: matching anything not identified
                 * `dynamic_gbp`: from the gbp_tag received from RADIUS
                 * `gbp_resource`: can only be used in `dst_tags`
                 * `mac`
                 * `network`
                 * `port_usage`
                 * `radius_group`
                 * `resource`: can only be used in `dst_tags`
                 * `static_gbp`: applying gbp tag against matching conditions
                 * `subnet`'
        :param Sequence[_builtins.str] ether_types: Can only be used under dst tags.
        :param _builtins.int gbp_tag: Required if
                 - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
                 - `type`==`gbp_resource`
                 - `type`==`static_gbp` (applying gbp tag against matching conditions)
        :param Sequence[_builtins.str] macs: Required if 
               - `type`==`mac`
               - `type`==`static_gbp` if from matching mac
        :param _builtins.str network: If:
                 * `type`==`mac` (optional. default is `any`)
                 * `type`==`subnet` (optional. default is `any`)
                 * `type`==`network`
                 * `type`==`resource` (optional. default is `any`)
                 * `type`==`static_gbp` if from matching network (vlan)
        :param _builtins.str port_usage: Required if `type`==`port_usage`
        :param _builtins.str radius_group: Required if:
                 * `type`==`radius_group`
                 * `type`==`static_gbp`
               if from matching radius_group
        :param Sequence['NetworktemplateAclTagsSpecArgs'] specs: If `type`==`resource`, `type`==`radius_group`, `type`==`port_usage` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        :param Sequence[_builtins.str] subnets: If 
               - `type`==`subnet` 
               - `type`==`resource` (optional. default is `any`)
               - `type`==`static_gbp` if from matching subnet
        """
        pulumi.set(__self__, "type", type)
        if ether_types is not None:
            pulumi.set(__self__, "ether_types", ether_types)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if macs is not None:
            pulumi.set(__self__, "macs", macs)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port_usage is not None:
            pulumi.set(__self__, "port_usage", port_usage)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: 
          * `any`: matching anything not identified
          * `dynamic_gbp`: from the gbp_tag received from RADIUS
          * `gbp_resource`: can only be used in `dst_tags`
          * `mac`
          * `network`
          * `port_usage`
          * `radius_group`
          * `resource`: can only be used in `dst_tags`
          * `static_gbp`: applying gbp tag against matching conditions
          * `subnet`'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="etherTypes")
    def ether_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Can only be used under dst tags.
        """
        return pulumi.get(self, "ether_types")

    @_builtins.property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[_builtins.int]:
        """
        Required if
          - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
          - `type`==`gbp_resource`
          - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        return pulumi.get(self, "gbp_tag")

    @_builtins.property
    @pulumi.getter
    def macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        return pulumi.get(self, "macs")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        If:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`port_usage`
        """
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[_builtins.str]:
        """
        Required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        return pulumi.get(self, "radius_group")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Optional[Sequence['outputs.NetworktemplateAclTagsSpec']]:
        """
        If `type`==`resource`, `type`==`radius_group`, `type`==`port_usage` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        If 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class NetworktemplateAclTagsSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclTagsSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclTagsSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclTagsSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_range: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_range: Matched dst port, "0" means any
        :param _builtins.str protocol: `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        Matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class NetworktemplateDhcpSnooping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "enableArpSpoofCheck":
            suggest = "enable_arp_spoof_check"
        elif key == "enableIpSourceGuard":
            suggest = "enable_ip_source_guard"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateDhcpSnooping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateDhcpSnooping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateDhcpSnooping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_networks: Optional[_builtins.bool] = None,
                 enable_arp_spoof_check: Optional[_builtins.bool] = None,
                 enable_ip_source_guard: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 networks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enable_arp_spoof_check: Enable for dynamic ARP inspection check
        :param _builtins.bool enable_ip_source_guard: Enable for check for forging source IP address
        :param Sequence[_builtins.str] networks: If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_ip_source_guard is not None:
            pulumi.set(__self__, "enable_ip_source_guard", enable_ip_source_guard)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all_networks")

    @_builtins.property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[_builtins.bool]:
        """
        Enable for dynamic ARP inspection check
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @_builtins.property
    @pulumi.getter(name="enableIpSourceGuard")
    def enable_ip_source_guard(self) -> Optional[_builtins.bool]:
        """
        Enable for check for forging source IP address
        """
        return pulumi.get(self, "enable_ip_source_guard")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class NetworktemplateExtraRoutes6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextQualified":
            suggest = "next_qualified"
        elif key == "noResolve":
            suggest = "no_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateExtraRoutes6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateExtraRoutes6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateExtraRoutes6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 discard: Optional[_builtins.bool] = None,
                 metric: Optional[_builtins.int] = None,
                 next_qualified: Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutes6NextQualified']] = None,
                 no_resolve: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None):
        """
        :param _builtins.str via: Next-hop IP Address
        :param _builtins.bool discard: This takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        Next-hop IP Address
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.bool]:
        """
        This takes precedence
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutes6NextQualified']]:
        return pulumi.get(self, "next_qualified")

    @_builtins.property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_resolve")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateExtraRoutes6NextQualified(dict):
    def __init__(__self__, *,
                 metric: Optional[_builtins.int] = None,
                 preference: Optional[_builtins.int] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateExtraRoutes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextQualified":
            suggest = "next_qualified"
        elif key == "noResolve":
            suggest = "no_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateExtraRoutes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateExtraRoutes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateExtraRoutes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 discard: Optional[_builtins.bool] = None,
                 metric: Optional[_builtins.int] = None,
                 next_qualified: Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutesNextQualified']] = None,
                 no_resolve: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None):
        """
        :param _builtins.str via: Next-hop IP Address
        :param _builtins.bool discard: This takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        Next-hop IP Address
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.bool]:
        """
        This takes precedence
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutesNextQualified']]:
        return pulumi.get(self, "next_qualified")

    @_builtins.property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_resolve")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateExtraRoutesNextQualified(dict):
    def __init__(__self__, *,
                 metric: Optional[_builtins.int] = None,
                 preference: Optional[_builtins.int] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateMistNac(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network")


@pulumi.output_type
class NetworktemplateNetworks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"
        elif key == "isolationVlanId":
            suggest = "isolation_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateNetworks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateNetworks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateNetworks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_id: _builtins.str,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 isolation: Optional[_builtins.bool] = None,
                 isolation_vlan_id: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None,
                 subnet6: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        :param _builtins.str gateway6: Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        :param _builtins.bool isolation: whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set. See also `inter_isolation_network_link` and `community_vlan_id` in port_usage
        :param _builtins.str subnet: Optional for pure switching, required when L3 / routing features are used
        :param _builtins.str subnet6: Optional for pure switching, required when L3 / routing features are used
        """
        pulumi.set(__self__, "vlan_id", vlan_id)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if isolation_vlan_id is not None:
            pulumi.set(__self__, "isolation_vlan_id", isolation_vlan_id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        """
        Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        """
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[_builtins.bool]:
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set. See also `inter_isolation_network_link` and `community_vlan_id` in port_usage
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter(name="isolationVlanId")
    def isolation_vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "isolation_vlan_id")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def subnet6(self) -> Optional[_builtins.str]:
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet6")


@pulumi.output_type
class NetworktemplateOspfAreas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeLoopback":
            suggest = "include_loopback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateOspfAreas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateOspfAreas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateOspfAreas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 networks: Mapping[str, 'outputs.NetworktemplateOspfAreasNetworks'],
                 include_loopback: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: OSPF type. enum: `default`, `nssa`, `stub`
        """
        pulumi.set(__self__, "networks", networks)
        if include_loopback is not None:
            pulumi.set(__self__, "include_loopback", include_loopback)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Mapping[str, 'outputs.NetworktemplateOspfAreasNetworks']:
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="includeLoopback")
    def include_loopback(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_loopback")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        OSPF type. enum: `default`, `nssa`, `stub`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworktemplateOspfAreasNetworks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authKeys":
            suggest = "auth_keys"
        elif key == "authPassword":
            suggest = "auth_password"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "bfdMinimumInterval":
            suggest = "bfd_minimum_interval"
        elif key == "deadInterval":
            suggest = "dead_interval"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "helloInterval":
            suggest = "hello_interval"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateOspfAreasNetworks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateOspfAreasNetworks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateOspfAreasNetworks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_keys: Optional[Mapping[str, _builtins.str]] = None,
                 auth_password: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 bfd_minimum_interval: Optional[_builtins.int] = None,
                 dead_interval: Optional[_builtins.int] = None,
                 export_policy: Optional[_builtins.str] = None,
                 hello_interval: Optional[_builtins.int] = None,
                 import_policy: Optional[_builtins.str] = None,
                 interface_type: Optional[_builtins.str] = None,
                 metric: Optional[_builtins.int] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 passive: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] auth_keys: Required if `auth_type`==`md5`. Property key is the key number
        :param _builtins.str auth_password: Required if `auth_type`==`password`, the password, max length is 8
        :param _builtins.str auth_type: auth type. enum: `md5`, `none`, `password`
        :param _builtins.str interface_type: interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        :param _builtins.bool no_readvertise_to_overlay: By default, we'll re-advertise all learned OSPF routes toward overlay
        :param _builtins.bool passive: Whether to send OSPF-Hello
        """
        if auth_keys is not None:
            pulumi.set(__self__, "auth_keys", auth_keys)
        if auth_password is not None:
            pulumi.set(__self__, "auth_password", auth_password)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if dead_interval is not None:
            pulumi.set(__self__, "dead_interval", dead_interval)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)

    @_builtins.property
    @pulumi.getter(name="authKeys")
    def auth_keys(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Required if `auth_type`==`md5`. Property key is the key number
        """
        return pulumi.get(self, "auth_keys")

    @_builtins.property
    @pulumi.getter(name="authPassword")
    def auth_password(self) -> Optional[_builtins.str]:
        """
        Required if `auth_type`==`password`, the password, max length is 8
        """
        return pulumi.get(self, "auth_password")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        auth type. enum: `md5`, `none`, `password`
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "bfd_minimum_interval")

    @_builtins.property
    @pulumi.getter(name="deadInterval")
    def dead_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "dead_interval")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hello_interval")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[_builtins.str]:
        """
        interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        """
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        By default, we'll re-advertise all learned OSPF routes toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[_builtins.bool]:
        """
        Whether to send OSPF-Hello
        """
        return pulumi.get(self, "passive")


@pulumi.output_type
class NetworktemplatePortMirroring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputNetworksIngresses":
            suggest = "input_networks_ingresses"
        elif key == "inputPortIdsEgresses":
            suggest = "input_port_ids_egresses"
        elif key == "inputPortIdsIngresses":
            suggest = "input_port_ids_ingresses"
        elif key == "outputIpAddress":
            suggest = "output_ip_address"
        elif key == "outputNetwork":
            suggest = "output_network"
        elif key == "outputPortId":
            suggest = "output_port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortMirroring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortMirroring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortMirroring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_networks_ingresses: Optional[Sequence[_builtins.str]] = None,
                 input_port_ids_egresses: Optional[Sequence[_builtins.str]] = None,
                 input_port_ids_ingresses: Optional[Sequence[_builtins.str]] = None,
                 output_ip_address: Optional[_builtins.str] = None,
                 output_network: Optional[_builtins.str] = None,
                 output_port_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] input_networks_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[_builtins.str] input_port_ids_egresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[_builtins.str] input_port_ids_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param _builtins.str output_ip_address: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        :param _builtins.str output_network: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        :param _builtins.str output_port_id: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_ip_address is not None:
            pulumi.set(__self__, "output_ip_address", output_ip_address)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @_builtins.property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @_builtins.property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @_builtins.property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @_builtins.property
    @pulumi.getter(name="outputIpAddress")
    def output_ip_address(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_ip_address")

    @_builtins.property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @_builtins.property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")


@pulumi.output_type
class NetworktemplatePortUsages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "allowDhcpd":
            suggest = "allow_dhcpd"
        elif key == "allowMultipleSupplicants":
            suggest = "allow_multiple_supplicants"
        elif key == "bypassAuthWhenServerDown":
            suggest = "bypass_auth_when_server_down"
        elif key == "bypassAuthWhenServerDownForUnknownClient":
            suggest = "bypass_auth_when_server_down_for_unknown_client"
        elif key == "communityVlanId":
            suggest = "community_vlan_id"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicVlanNetworks":
            suggest = "dynamic_vlan_networks"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "enableQos":
            suggest = "enable_qos"
        elif key == "guestNetwork":
            suggest = "guest_network"
        elif key == "interIsolationNetworkLink":
            suggest = "inter_isolation_network_link"
        elif key == "interSwitchLink":
            suggest = "inter_switch_link"
        elif key == "macAuthOnly":
            suggest = "mac_auth_only"
        elif key == "macAuthPreferred":
            suggest = "mac_auth_preferred"
        elif key == "macAuthProtocol":
            suggest = "mac_auth_protocol"
        elif key == "macLimit":
            suggest = "mac_limit"
        elif key == "persistMac":
            suggest = "persist_mac"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portAuth":
            suggest = "port_auth"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "reauthInterval":
            suggest = "reauth_interval"
        elif key == "resetDefaultWhen":
            suggest = "reset_default_when"
        elif key == "serverFailNetwork":
            suggest = "server_fail_network"
        elif key == "serverRejectNetwork":
            suggest = "server_reject_network"
        elif key == "stormControl":
            suggest = "storm_control"
        elif key == "stpEdge":
            suggest = "stp_edge"
        elif key == "stpNoRootPort":
            suggest = "stp_no_root_port"
        elif key == "stpP2p":
            suggest = "stp_p2p"
        elif key == "uiEvpntopoId":
            suggest = "ui_evpntopo_id"
        elif key == "useVstp":
            suggest = "use_vstp"
        elif key == "voipNetwork":
            suggest = "voip_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortUsages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortUsages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortUsages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_networks: Optional[_builtins.bool] = None,
                 allow_dhcpd: Optional[_builtins.bool] = None,
                 allow_multiple_supplicants: Optional[_builtins.bool] = None,
                 bypass_auth_when_server_down: Optional[_builtins.bool] = None,
                 bypass_auth_when_server_down_for_unknown_client: Optional[_builtins.bool] = None,
                 community_vlan_id: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 duplex: Optional[_builtins.str] = None,
                 dynamic_vlan_networks: Optional[Sequence[_builtins.str]] = None,
                 enable_mac_auth: Optional[_builtins.bool] = None,
                 enable_qos: Optional[_builtins.bool] = None,
                 guest_network: Optional[_builtins.str] = None,
                 inter_isolation_network_link: Optional[_builtins.bool] = None,
                 inter_switch_link: Optional[_builtins.bool] = None,
                 mac_auth_only: Optional[_builtins.bool] = None,
                 mac_auth_preferred: Optional[_builtins.bool] = None,
                 mac_auth_protocol: Optional[_builtins.str] = None,
                 mac_limit: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 persist_mac: Optional[_builtins.bool] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_auth: Optional[_builtins.str] = None,
                 port_network: Optional[_builtins.str] = None,
                 reauth_interval: Optional[_builtins.str] = None,
                 reset_default_when: Optional[_builtins.str] = None,
                 rules: Optional[Sequence['outputs.NetworktemplatePortUsagesRule']] = None,
                 server_fail_network: Optional[_builtins.str] = None,
                 server_reject_network: Optional[_builtins.str] = None,
                 speed: Optional[_builtins.str] = None,
                 storm_control: Optional['outputs.NetworktemplatePortUsagesStormControl'] = None,
                 stp_edge: Optional[_builtins.bool] = None,
                 stp_no_root_port: Optional[_builtins.bool] = None,
                 stp_p2p: Optional[_builtins.bool] = None,
                 ui_evpntopo_id: Optional[_builtins.str] = None,
                 use_vstp: Optional[_builtins.bool] = None,
                 voip_network: Optional[_builtins.str] = None):
        """
        :param _builtins.bool all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param _builtins.bool allow_dhcpd: Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        :param _builtins.bool allow_multiple_supplicants: Only if `mode`!=`dynamic`
        :param _builtins.bool bypass_auth_when_server_down: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param _builtins.bool bypass_auth_when_server_down_for_unknown_client: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param _builtins.int community_vlan_id: Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
        :param _builtins.str description: Only if `mode`!=`dynamic`
        :param _builtins.bool disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param _builtins.bool disabled: Only if `mode`!=`dynamic` whether the port is disabled
        :param _builtins.str duplex: Only if `mode`!=`dynamic`, link connection mode. enum: `auto`, `full`, `half`
        :param Sequence[_builtins.str] dynamic_vlan_networks: Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param _builtins.bool enable_mac_auth: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        :param _builtins.bool enable_qos: Only if `mode`!=`dynamic`
        :param _builtins.str guest_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param _builtins.bool inter_isolation_network_link: `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        :param _builtins.bool inter_switch_link: Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param _builtins.bool mac_auth_only: Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        :param _builtins.bool mac_auth_preferred: Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        :param _builtins.str mac_auth_protocol: Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param _builtins.str mac_limit: Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        :param _builtins.str mode: `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        :param _builtins.str mtu: Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        :param Sequence[_builtins.str] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param _builtins.bool persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param _builtins.bool poe_disabled: Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        :param _builtins.str port_auth: Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        :param _builtins.str port_network: Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        :param _builtins.str reauth_interval: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        :param _builtins.str reset_default_when: Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        :param Sequence['NetworktemplatePortUsagesRuleArgs'] rules: Only if `mode`==`dynamic`
        :param _builtins.str server_fail_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        :param _builtins.str server_reject_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        :param _builtins.str speed: Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        :param 'NetworktemplatePortUsagesStormControlArgs' storm_control: Switch storm control. Only if `mode`!=`dynamic`
        :param _builtins.bool stp_edge: Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        :param _builtins.str ui_evpntopo_id: Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
        :param _builtins.bool use_vstp: If this is connected to a vstp network
        :param _builtins.str voip_network: Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unknown_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unknown_client", bypass_auth_when_server_down_for_unknown_client)
        if community_vlan_id is not None:
            pulumi.set(__self__, "community_vlan_id", community_vlan_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_isolation_network_link is not None:
            pulumi.set(__self__, "inter_isolation_network_link", inter_isolation_network_link)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if reset_default_when is not None:
            pulumi.set(__self__, "reset_default_when", reset_default_when)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if server_fail_network is not None:
            pulumi.set(__self__, "server_fail_network", server_fail_network)
        if server_reject_network is not None:
            pulumi.set(__self__, "server_reject_network", server_reject_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if stp_no_root_port is not None:
            pulumi.set(__self__, "stp_no_root_port", stp_no_root_port)
        if stp_p2p is not None:
            pulumi.set(__self__, "stp_p2p", stp_p2p)
        if ui_evpntopo_id is not None:
            pulumi.set(__self__, "ui_evpntopo_id", ui_evpntopo_id)
        if use_vstp is not None:
            pulumi.set(__self__, "use_vstp", use_vstp)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @_builtins.property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @_builtins.property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @_builtins.property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "allow_multiple_supplicants")

    @_builtins.property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @_builtins.property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnknownClient")
    def bypass_auth_when_server_down_for_unknown_client(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unknown_client")

    @_builtins.property
    @pulumi.getter(name="communityVlanId")
    def community_vlan_id(self) -> Optional[_builtins.int]:
        """
        Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
        """
        return pulumi.get(self, "community_vlan_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic`, link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "enable_qos")

    @_builtins.property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @_builtins.property
    @pulumi.getter(name="interIsolationNetworkLink")
    def inter_isolation_network_link(self) -> Optional[_builtins.bool]:
        """
        `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_isolation_network_link")

    @_builtins.property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @_builtins.property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @_builtins.property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        return pulumi.get(self, "mac_auth_preferred")

    @_builtins.property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @_builtins.property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        """
        return pulumi.get(self, "mac_limit")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        """
        return pulumi.get(self, "reauth_interval")

    @_builtins.property
    @pulumi.getter(name="resetDefaultWhen")
    def reset_default_when(self) -> Optional[_builtins.str]:
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        return pulumi.get(self, "reset_default_when")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.NetworktemplatePortUsagesRule']]:
        """
        Only if `mode`==`dynamic`
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="serverFailNetwork")
    def server_fail_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        return pulumi.get(self, "server_fail_network")

    @_builtins.property
    @pulumi.getter(name="serverRejectNetwork")
    def server_reject_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "server_reject_network")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional['outputs.NetworktemplatePortUsagesStormControl']:
        """
        Switch storm control. Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "storm_control")

    @_builtins.property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @_builtins.property
    @pulumi.getter(name="stpNoRootPort")
    def stp_no_root_port(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stp_no_root_port")

    @_builtins.property
    @pulumi.getter(name="stpP2p")
    def stp_p2p(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stp_p2p")

    @_builtins.property
    @pulumi.getter(name="uiEvpntopoId")
    def ui_evpntopo_id(self) -> Optional[_builtins.str]:
        """
        Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
        """
        return pulumi.get(self, "ui_evpntopo_id")

    @_builtins.property
    @pulumi.getter(name="useVstp")
    def use_vstp(self) -> Optional[_builtins.bool]:
        """
        If this is connected to a vstp network
        """
        return pulumi.get(self, "use_vstp")

    @_builtins.property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")


@pulumi.output_type
class NetworktemplatePortUsagesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "equalsAnies":
            suggest = "equals_anies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortUsagesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortUsagesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortUsagesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 src: _builtins.str,
                 equals: Optional[_builtins.str] = None,
                 equals_anies: Optional[Sequence[_builtins.str]] = None,
                 expression: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None):
        """
        :param _builtins.str src: enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        :param Sequence[_builtins.str] equals_anies: Use `equals_any` to match any item in a list
        :param _builtins.str expression: "[0:3]":"abcdef" > "abc"
               "split(.)[1]": "a.b.c" > "b"
               "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        :param _builtins.str usage: `port_usage` name
        """
        pulumi.set(__self__, "src", src)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if equals_anies is not None:
            pulumi.set(__self__, "equals_anies", equals_anies)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @_builtins.property
    @pulumi.getter
    def src(self) -> _builtins.str:
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        return pulumi.get(self, "src")

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "equals")

    @_builtins.property
    @pulumi.getter(name="equalsAnies")
    def equals_anies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Use `equals_any` to match any item in a list
        """
        return pulumi.get(self, "equals_anies")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        `port_usage` name
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class NetworktemplatePortUsagesStormControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePort":
            suggest = "disable_port"
        elif key == "noBroadcast":
            suggest = "no_broadcast"
        elif key == "noMulticast":
            suggest = "no_multicast"
        elif key == "noRegisteredMulticast":
            suggest = "no_registered_multicast"
        elif key == "noUnknownUnicast":
            suggest = "no_unknown_unicast"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortUsagesStormControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortUsagesStormControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortUsagesStormControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_port: Optional[_builtins.bool] = None,
                 no_broadcast: Optional[_builtins.bool] = None,
                 no_multicast: Optional[_builtins.bool] = None,
                 no_registered_multicast: Optional[_builtins.bool] = None,
                 no_unknown_unicast: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disable_port: Whether to disable the port when storm control is triggered
        :param _builtins.bool no_broadcast: Whether to disable storm control on broadcast traffic
        :param _builtins.bool no_multicast: Whether to disable storm control on multicast traffic
        :param _builtins.bool no_registered_multicast: Whether to disable storm control on registered multicast traffic
        :param _builtins.bool no_unknown_unicast: Whether to disable storm control on unknown unicast traffic
        :param _builtins.int percentage: Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if disable_port is not None:
            pulumi.set(__self__, "disable_port", disable_port)
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="disablePort")
    def disable_port(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the port when storm control is triggered
        """
        return pulumi.get(self, "disable_port")

    @_builtins.property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @_builtins.property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @_builtins.property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @_builtins.property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class NetworktemplateRadiusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctImmediateUpdate":
            suggest = "acct_immediate_update"
        elif key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "acctServers":
            suggest = "acct_servers"
        elif key == "authServerSelection":
            suggest = "auth_server_selection"
        elif key == "authServers":
            suggest = "auth_servers"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "fastDot1xTimers":
            suggest = "fast_dot1x_timers"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRadiusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRadiusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRadiusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_immediate_update: Optional[_builtins.bool] = None,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 acct_servers: Optional[Sequence['outputs.NetworktemplateRadiusConfigAcctServer']] = None,
                 auth_server_selection: Optional[_builtins.str] = None,
                 auth_servers: Optional[Sequence['outputs.NetworktemplateRadiusConfigAuthServer']] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.str] = None,
                 fast_dot1x_timers: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param _builtins.str auth_server_selection: enum: `ordered`, `unordered`
        :param _builtins.int auth_servers_retries: Radius auth session retries
        :param _builtins.int auth_servers_timeout: Radius auth session timeout
        :param _builtins.str network: Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param _builtins.str source_ip: Use `network`or `source_ip`
        """
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "acct_immediate_update")

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.NetworktemplateRadiusConfigAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[_builtins.str]:
        """
        enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @_builtins.property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[Sequence['outputs.NetworktemplateRadiusConfigAuthServer']]:
        return pulumi.get(self, "auth_servers")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        Radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        Radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fast_dot1x_timers")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        Use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class NetworktemplateRadiusConfigAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRadiusConfigAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRadiusConfigAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRadiusConfigAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworktemplateRadiusConfigAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"
        elif key == "requireMessageAuthenticator":
            suggest = "require_message_authenticator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRadiusConfigAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRadiusConfigAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRadiusConfigAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 require_message_authenticator: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.bool require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[_builtins.bool]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")


@pulumi.output_type
class NetworktemplateRemoteSyslog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendToAllServers":
            suggest = "send_to_all_servers"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRemoteSyslog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRemoteSyslog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRemoteSyslog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional['outputs.NetworktemplateRemoteSyslogArchive'] = None,
                 cacerts: Optional[Sequence[_builtins.str]] = None,
                 console: Optional['outputs.NetworktemplateRemoteSyslogConsole'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 files: Optional[Sequence['outputs.NetworktemplateRemoteSyslogFile']] = None,
                 network: Optional[_builtins.str] = None,
                 send_to_all_servers: Optional[_builtins.bool] = None,
                 servers: Optional[Sequence['outputs.NetworktemplateRemoteSyslogServer']] = None,
                 time_format: Optional[_builtins.str] = None,
                 users: Optional[Sequence['outputs.NetworktemplateRemoteSyslogUser']] = None):
        """
        :param _builtins.str network: If source_address is configured, will use the vlan firstly otherwise use source_ip
        :param _builtins.str time_format: enum: `millisecond`, `year`, `year millisecond`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if cacerts is not None:
            pulumi.set(__self__, "cacerts", cacerts)
        if console is not None:
            pulumi.set(__self__, "console", console)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if send_to_all_servers is not None:
            pulumi.set(__self__, "send_to_all_servers", send_to_all_servers)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional['outputs.NetworktemplateRemoteSyslogArchive']:
        return pulumi.get(self, "archive")

    @_builtins.property
    @pulumi.getter
    def cacerts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cacerts")

    @_builtins.property
    @pulumi.getter
    def console(self) -> Optional['outputs.NetworktemplateRemoteSyslogConsole']:
        return pulumi.get(self, "console")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogFile']]:
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sendToAllServers")
    def send_to_all_servers(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "send_to_all_servers")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogServer']]:
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class NetworktemplateRemoteSyslogArchive(dict):
    def __init__(__self__, *,
                 files: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "size")


@pulumi.output_type
class NetworktemplateRemoteSyslogConsole(dict):
    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogConsoleContent']] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogConsoleContent']]:
        return pulumi.get(self, "contents")


@pulumi.output_type
class NetworktemplateRemoteSyslogConsoleContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateRemoteSyslogFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableTls":
            suggest = "enable_tls"
        elif key == "explicitPriority":
            suggest = "explicit_priority"
        elif key == "structuredData":
            suggest = "structured_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRemoteSyslogFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRemoteSyslogFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRemoteSyslogFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional['outputs.NetworktemplateRemoteSyslogFileArchive'] = None,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogFileContent']] = None,
                 enable_tls: Optional[_builtins.bool] = None,
                 explicit_priority: Optional[_builtins.bool] = None,
                 file: Optional[_builtins.str] = None,
                 match: Optional[_builtins.str] = None,
                 structured_data: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_tls: Only if `protocol`==`tcp`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if enable_tls is not None:
            pulumi.set(__self__, "enable_tls", enable_tls)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional['outputs.NetworktemplateRemoteSyslogFileArchive']:
        return pulumi.get(self, "archive")

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogFileContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="enableTls")
    def enable_tls(self) -> Optional[_builtins.bool]:
        """
        Only if `protocol`==`tcp`
        """
        return pulumi.get(self, "enable_tls")

    @_builtins.property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "explicit_priority")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "structured_data")


@pulumi.output_type
class NetworktemplateRemoteSyslogFileArchive(dict):
    def __init__(__self__, *,
                 files: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "size")


@pulumi.output_type
class NetworktemplateRemoteSyslogFileContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateRemoteSyslogServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "explicitPriority":
            suggest = "explicit_priority"
        elif key == "routingInstance":
            suggest = "routing_instance"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "structuredData":
            suggest = "structured_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRemoteSyslogServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRemoteSyslogServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRemoteSyslogServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogServerContent']] = None,
                 explicit_priority: Optional[_builtins.bool] = None,
                 facility: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 match: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 routing_instance: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 source_address: Optional[_builtins.str] = None,
                 structured_data: Optional[_builtins.bool] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str protocol: enum: `tcp`, `udp`
        :param _builtins.str server_name: Name of the server
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        :param _builtins.str source_address: If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routing_instance is not None:
            pulumi.set(__self__, "routing_instance", routing_instance)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogServerContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "explicit_priority")

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        enum: `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="routingInstance")
    def routing_instance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "routing_instance")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Name of the server
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "structured_data")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class NetworktemplateRemoteSyslogServerContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateRemoteSyslogUser(dict):
    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogUserContent']] = None,
                 match: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogUserContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class NetworktemplateRemoteSyslogUserContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateSnmpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientLists":
            suggest = "client_lists"
        elif key == "engineId":
            suggest = "engine_id"
        elif key == "engineIdType":
            suggest = "engine_id_type"
        elif key == "trapGroups":
            suggest = "trap_groups"
        elif key == "v2cConfigs":
            suggest = "v2c_configs"
        elif key == "v3Config":
            suggest = "v3_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_lists: Optional[Sequence['outputs.NetworktemplateSnmpConfigClientList']] = None,
                 contact: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 engine_id: Optional[_builtins.str] = None,
                 engine_id_type: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 trap_groups: Optional[Sequence['outputs.NetworktemplateSnmpConfigTrapGroup']] = None,
                 v2c_configs: Optional[Sequence['outputs.NetworktemplateSnmpConfigV2cConfig']] = None,
                 v3_config: Optional['outputs.NetworktemplateSnmpConfigV3Config'] = None,
                 views: Optional[Sequence['outputs.NetworktemplateSnmpConfigView']] = None):
        """
        :param _builtins.str engine_id_type: enum: `local`, `use_mac_address`
        """
        if client_lists is not None:
            pulumi.set(__self__, "client_lists", client_lists)
        if contact is not None:
            pulumi.set(__self__, "contact", contact)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if engine_id_type is not None:
            pulumi.set(__self__, "engine_id_type", engine_id_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if trap_groups is not None:
            pulumi.set(__self__, "trap_groups", trap_groups)
        if v2c_configs is not None:
            pulumi.set(__self__, "v2c_configs", v2c_configs)
        if v3_config is not None:
            pulumi.set(__self__, "v3_config", v3_config)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter(name="clientLists")
    def client_lists(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigClientList']]:
        return pulumi.get(self, "client_lists")

    @_builtins.property
    @pulumi.getter
    def contact(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "contact")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "engine_id")

    @_builtins.property
    @pulumi.getter(name="engineIdType")
    def engine_id_type(self) -> Optional[_builtins.str]:
        """
        enum: `local`, `use_mac_address`
        """
        return pulumi.get(self, "engine_id_type")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="trapGroups")
    def trap_groups(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigTrapGroup']]:
        return pulumi.get(self, "trap_groups")

    @_builtins.property
    @pulumi.getter(name="v2cConfigs")
    def v2c_configs(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV2cConfig']]:
        return pulumi.get(self, "v2c_configs")

    @_builtins.property
    @pulumi.getter(name="v3Config")
    def v3_config(self) -> Optional['outputs.NetworktemplateSnmpConfigV3Config']:
        return pulumi.get(self, "v3_config")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class NetworktemplateSnmpConfigClientList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientListName":
            suggest = "client_list_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigClientList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigClientList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigClientList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_list_name: Optional[_builtins.str] = None,
                 clients: Optional[Sequence[_builtins.str]] = None):
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_list_name")

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "clients")


@pulumi.output_type
class NetworktemplateSnmpConfigTrapGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigTrapGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigTrapGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigTrapGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Optional[Sequence[_builtins.str]] = None,
                 group_name: Optional[_builtins.str] = None,
                 targets: Optional[Sequence[_builtins.str]] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str group_name: Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        :param _builtins.str version: enum: `all`, `v1`, `v2`
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "targets")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        enum: `all`, `v1`, `v2`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NetworktemplateSnmpConfigV2cConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientListName":
            suggest = "client_list_name"
        elif key == "communityName":
            suggest = "community_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV2cConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV2cConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV2cConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization: Optional[_builtins.str] = None,
                 client_list_name: Optional[_builtins.str] = None,
                 community_name: Optional[_builtins.str] = None,
                 view: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_list_name: Client_list_name here should refer to client_list above
        :param _builtins.str view: View name here should be defined in views above
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[_builtins.str]:
        """
        Client_list_name here should refer to client_list above
        """
        return pulumi.get(self, "client_list_name")

    @_builtins.property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "community_name")

    @_builtins.property
    @pulumi.getter
    def view(self) -> Optional[_builtins.str]:
        """
        View name here should be defined in views above
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class NetworktemplateSnmpConfigV3Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyFilters":
            suggest = "notify_filters"
        elif key == "targetAddresses":
            suggest = "target_addresses"
        elif key == "targetParameters":
            suggest = "target_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notifies: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotify']] = None,
                 notify_filters: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilter']] = None,
                 target_addresses: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetAddress']] = None,
                 target_parameters: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetParameter']] = None,
                 usms: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigUsm']] = None,
                 vacm: Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacm'] = None):
        if notifies is not None:
            pulumi.set(__self__, "notifies", notifies)
        if notify_filters is not None:
            pulumi.set(__self__, "notify_filters", notify_filters)
        if target_addresses is not None:
            pulumi.set(__self__, "target_addresses", target_addresses)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)
        if usms is not None:
            pulumi.set(__self__, "usms", usms)
        if vacm is not None:
            pulumi.set(__self__, "vacm", vacm)

    @_builtins.property
    @pulumi.getter
    def notifies(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotify']]:
        return pulumi.get(self, "notifies")

    @_builtins.property
    @pulumi.getter(name="notifyFilters")
    def notify_filters(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilter']]:
        return pulumi.get(self, "notify_filters")

    @_builtins.property
    @pulumi.getter(name="targetAddresses")
    def target_addresses(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetAddress']]:
        return pulumi.get(self, "target_addresses")

    @_builtins.property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetParameter']]:
        return pulumi.get(self, "target_parameters")

    @_builtins.property
    @pulumi.getter
    def usms(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigUsm']]:
        return pulumi.get(self, "usms")

    @_builtins.property
    @pulumi.getter
    def vacm(self) -> Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacm']:
        return pulumi.get(self, "vacm")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigNotify(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 tag: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str type: enum: `inform`, `trap`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `inform`, `trap`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileName":
            suggest = "profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigNotifyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigNotifyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigNotifyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent']] = None,
                 profile_name: Optional[_builtins.str] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profile_name")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilterContent(dict):
    def __init__(__self__, *,
                 oid: _builtins.str,
                 include: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "oid", oid)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @_builtins.property
    @pulumi.getter
    def oid(self) -> _builtins.str:
        return pulumi.get(self, "oid")

    @_builtins.property
    @pulumi.getter
    def include(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigTargetAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressMask":
            suggest = "address_mask"
        elif key == "targetAddressName":
            suggest = "target_address_name"
        elif key == "tagList":
            suggest = "tag_list"
        elif key == "targetParameters":
            suggest = "target_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigTargetAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 address_mask: _builtins.str,
                 target_address_name: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 tag_list: Optional[_builtins.str] = None,
                 target_parameters: Optional[_builtins.str] = None):
        """
        :param _builtins.str tag_list: Refer to notify tag, can be multiple with blank
        :param _builtins.str target_parameters: Refer to notify target parameters name
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "address_mask", address_mask)
        pulumi.set(__self__, "target_address_name", target_address_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressMask")
    def address_mask(self) -> _builtins.str:
        return pulumi.get(self, "address_mask")

    @_builtins.property
    @pulumi.getter(name="targetAddressName")
    def target_address_name(self) -> _builtins.str:
        return pulumi.get(self, "target_address_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[_builtins.str]:
        """
        Refer to notify tag, can be multiple with blank
        """
        return pulumi.get(self, "tag_list")

    @_builtins.property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[_builtins.str]:
        """
        Refer to notify target parameters name
        """
        return pulumi.get(self, "target_parameters")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigTargetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageProcessingModel":
            suggest = "message_processing_model"
        elif key == "notifyFilter":
            suggest = "notify_filter"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "securityModel":
            suggest = "security_model"
        elif key == "securityName":
            suggest = "security_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigTargetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_processing_model: _builtins.str,
                 name: _builtins.str,
                 notify_filter: Optional[_builtins.str] = None,
                 security_level: Optional[_builtins.str] = None,
                 security_model: Optional[_builtins.str] = None,
                 security_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str message_processing_model: enum: `v1`, `v2c`, `v3`
        :param _builtins.str notify_filter: Refer to profile-name in notify_filter
        :param _builtins.str security_level: enum: `authentication`, `none`, `privacy`
        :param _builtins.str security_model: enum: `usm`, `v1`, `v2c`
        :param _builtins.str security_name: Refer to security_name in usm
        """
        pulumi.set(__self__, "message_processing_model", message_processing_model)
        pulumi.set(__self__, "name", name)
        if notify_filter is not None:
            pulumi.set(__self__, "notify_filter", notify_filter)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @_builtins.property
    @pulumi.getter(name="messageProcessingModel")
    def message_processing_model(self) -> _builtins.str:
        """
        enum: `v1`, `v2c`, `v3`
        """
        return pulumi.get(self, "message_processing_model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifyFilter")
    def notify_filter(self) -> Optional[_builtins.str]:
        """
        Refer to profile-name in notify_filter
        """
        return pulumi.get(self, "notify_filter")

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[_builtins.str]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @_builtins.property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[_builtins.str]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @_builtins.property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[_builtins.str]:
        """
        Refer to security_name in usm
        """
        return pulumi.get(self, "security_name")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigUsm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engineType":
            suggest = "engine_type"
        elif key == "remoteEngineId":
            suggest = "remote_engine_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigUsm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine_type: _builtins.str,
                 remote_engine_id: Optional[_builtins.str] = None,
                 users: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigUsmUser']] = None):
        """
        :param _builtins.str engine_type: enum: `local_engine`, `remote_engine`
        :param _builtins.str remote_engine_id: Required only if `engine_type`==`remote_engine`
        """
        pulumi.set(__self__, "engine_type", engine_type)
        if remote_engine_id is not None:
            pulumi.set(__self__, "remote_engine_id", remote_engine_id)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> _builtins.str:
        """
        enum: `local_engine`, `remote_engine`
        """
        return pulumi.get(self, "engine_type")

    @_builtins.property
    @pulumi.getter(name="remoteEngineId")
    def remote_engine_id(self) -> Optional[_builtins.str]:
        """
        Required only if `engine_type`==`remote_engine`
        """
        return pulumi.get(self, "remote_engine_id")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigUsmUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigUsmUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationPassword":
            suggest = "authentication_password"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "encryptionPassword":
            suggest = "encryption_password"
        elif key == "encryptionType":
            suggest = "encryption_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigUsmUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsmUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsmUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_password: Optional[_builtins.str] = None,
                 authentication_type: Optional[_builtins.str] = None,
                 encryption_password: Optional[_builtins.str] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str authentication_password: Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        :param _builtins.str authentication_type: sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        :param _builtins.str encryption_password: Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        :param _builtins.str encryption_type: enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        if authentication_password is not None:
            pulumi.set(__self__, "authentication_password", authentication_password)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="authenticationPassword")
    def authentication_password(self) -> Optional[_builtins.str]:
        """
        Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        return pulumi.get(self, "authentication_password")

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[_builtins.str]:
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        """
        return pulumi.get(self, "authentication_type")

    @_builtins.property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[_builtins.str]:
        """
        Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        return pulumi.get(self, "encryption_password")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityToGroup":
            suggest = "security_to_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accesses: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccess']] = None,
                 security_to_group: Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup'] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if security_to_group is not None:
            pulumi.set(__self__, "security_to_group", security_to_group)

    @_builtins.property
    @pulumi.getter
    def accesses(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccess']]:
        return pulumi.get(self, "accesses")

    @_builtins.property
    @pulumi.getter(name="securityToGroup")
    def security_to_group(self) -> Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup']:
        return pulumi.get(self, "security_to_group")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "prefixLists":
            suggest = "prefix_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 prefix_lists: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList']] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList']]:
        return pulumi.get(self, "prefix_lists")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextPrefix":
            suggest = "context_prefix"
        elif key == "notifyView":
            suggest = "notify_view"
        elif key == "readView":
            suggest = "read_view"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "securityModel":
            suggest = "security_model"
        elif key == "writeView":
            suggest = "write_view"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_prefix: Optional[_builtins.str] = None,
                 notify_view: Optional[_builtins.str] = None,
                 read_view: Optional[_builtins.str] = None,
                 security_level: Optional[_builtins.str] = None,
                 security_model: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 write_view: Optional[_builtins.str] = None):
        """
        :param _builtins.str context_prefix: Only required if `type`==`context_prefix`
        :param _builtins.str notify_view: Refer to view name
        :param _builtins.str read_view: Refer to view name
        :param _builtins.str security_level: enum: `authentication`, `none`, `privacy`
        :param _builtins.str security_model: enum: `any`, `usm`, `v1`, `v2c`
        :param _builtins.str type: enum: `context_prefix`, `default_context_prefix`
        :param _builtins.str write_view: Refer to view name
        """
        if context_prefix is not None:
            pulumi.set(__self__, "context_prefix", context_prefix)
        if notify_view is not None:
            pulumi.set(__self__, "notify_view", notify_view)
        if read_view is not None:
            pulumi.set(__self__, "read_view", read_view)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if write_view is not None:
            pulumi.set(__self__, "write_view", write_view)

    @_builtins.property
    @pulumi.getter(name="contextPrefix")
    def context_prefix(self) -> Optional[_builtins.str]:
        """
        Only required if `type`==`context_prefix`
        """
        return pulumi.get(self, "context_prefix")

    @_builtins.property
    @pulumi.getter(name="notifyView")
    def notify_view(self) -> Optional[_builtins.str]:
        """
        Refer to view name
        """
        return pulumi.get(self, "notify_view")

    @_builtins.property
    @pulumi.getter(name="readView")
    def read_view(self) -> Optional[_builtins.str]:
        """
        Refer to view name
        """
        return pulumi.get(self, "read_view")

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[_builtins.str]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @_builtins.property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="writeView")
    def write_view(self) -> Optional[_builtins.str]:
        """
        Refer to view name
        """
        return pulumi.get(self, "write_view")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityModel":
            suggest = "security_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent']] = None,
                 security_model: Optional[_builtins.str] = None):
        """
        :param _builtins.str security_model: enum: `usm`, `v1`, `v2c`
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[_builtins.str]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityName":
            suggest = "security_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[_builtins.str] = None,
                 security_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: Refer to group_name under access
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Refer to group_name under access
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_name")


@pulumi.output_type
class NetworktemplateSnmpConfigView(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewName":
            suggest = "view_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigView. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigView.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigView.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include: Optional[_builtins.bool] = None,
                 oid: Optional[_builtins.str] = None,
                 view_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool include: If the root oid configured is included
        """
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @_builtins.property
    @pulumi.getter
    def include(self) -> Optional[_builtins.bool]:
        """
        If the root oid configured is included
        """
        return pulumi.get(self, "include")

    @_builtins.property
    @pulumi.getter
    def oid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oid")

    @_builtins.property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "view_name")


@pulumi.output_type
class NetworktemplateSwitchMatching(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 rules: Optional[Sequence['outputs.NetworktemplateSwitchMatchingRule']] = None):
        """
        :param Sequence['NetworktemplateSwitchMatchingRuleArgs'] rules: list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMatchingRule']]:
        """
        list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class NetworktemplateSwitchMatchingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalConfigCmds":
            suggest = "additional_config_cmds"
        elif key == "ipConfig":
            suggest = "ip_config"
        elif key == "matchModel":
            suggest = "match_model"
        elif key == "matchName":
            suggest = "match_name"
        elif key == "matchNameOffset":
            suggest = "match_name_offset"
        elif key == "matchRole":
            suggest = "match_role"
        elif key == "oobIpConfig":
            suggest = "oob_ip_config"
        elif key == "portConfig":
            suggest = "port_config"
        elif key == "portMirroring":
            suggest = "port_mirroring"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_config_cmds: Optional[Sequence[_builtins.str]] = None,
                 ip_config: Optional['outputs.NetworktemplateSwitchMatchingRuleIpConfig'] = None,
                 match_model: Optional[_builtins.str] = None,
                 match_name: Optional[_builtins.str] = None,
                 match_name_offset: Optional[_builtins.int] = None,
                 match_role: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 oob_ip_config: Optional['outputs.NetworktemplateSwitchMatchingRuleOobIpConfig'] = None,
                 port_config: Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortConfig']] = None,
                 port_mirroring: Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortMirroring']] = None):
        """
        :param Sequence[_builtins.str] additional_config_cmds: additional CLI commands to append to the generated Junos config. **Note**: no check is done
        :param 'NetworktemplateSwitchMatchingRuleIpConfigArgs' ip_config: In-Band Management interface configuration
        :param _builtins.str match_model: string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes
        :param _builtins.str match_name: string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes
        :param _builtins.int match_name_offset: first character of the switch name to compare to the `match_name` value
        :param _builtins.str match_role: string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes
        :param _builtins.str name: Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list
        :param 'NetworktemplateSwitchMatchingRuleOobIpConfigArgs' oob_ip_config: Out-of-Band Management interface configuration
        :param Mapping[str, 'NetworktemplateSwitchMatchingRulePortConfigArgs'] port_config: Property key is the port name or range (e.g. "ge-0/0/0-10")
        :param Mapping[str, 'NetworktemplateSwitchMatchingRulePortMirroringArgs'] port_mirroring: Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed
        """
        if additional_config_cmds is not None:
            pulumi.set(__self__, "additional_config_cmds", additional_config_cmds)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if match_model is not None:
            pulumi.set(__self__, "match_model", match_model)
        if match_name is not None:
            pulumi.set(__self__, "match_name", match_name)
        if match_name_offset is not None:
            pulumi.set(__self__, "match_name_offset", match_name_offset)
        if match_role is not None:
            pulumi.set(__self__, "match_role", match_role)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if oob_ip_config is not None:
            pulumi.set(__self__, "oob_ip_config", oob_ip_config)
        if port_config is not None:
            pulumi.set(__self__, "port_config", port_config)
        if port_mirroring is not None:
            pulumi.set(__self__, "port_mirroring", port_mirroring)

    @_builtins.property
    @pulumi.getter(name="additionalConfigCmds")
    def additional_config_cmds(self) -> Optional[Sequence[_builtins.str]]:
        """
        additional CLI commands to append to the generated Junos config. **Note**: no check is done
        """
        return pulumi.get(self, "additional_config_cmds")

    @_builtins.property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional['outputs.NetworktemplateSwitchMatchingRuleIpConfig']:
        """
        In-Band Management interface configuration
        """
        return pulumi.get(self, "ip_config")

    @_builtins.property
    @pulumi.getter(name="matchModel")
    def match_model(self) -> Optional[_builtins.str]:
        """
        string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes
        """
        return pulumi.get(self, "match_model")

    @_builtins.property
    @pulumi.getter(name="matchName")
    def match_name(self) -> Optional[_builtins.str]:
        """
        string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes
        """
        return pulumi.get(self, "match_name")

    @_builtins.property
    @pulumi.getter(name="matchNameOffset")
    def match_name_offset(self) -> Optional[_builtins.int]:
        """
        first character of the switch name to compare to the `match_name` value
        """
        return pulumi.get(self, "match_name_offset")

    @_builtins.property
    @pulumi.getter(name="matchRole")
    def match_role(self) -> Optional[_builtins.str]:
        """
        string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes
        """
        return pulumi.get(self, "match_role")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oobIpConfig")
    def oob_ip_config(self) -> Optional['outputs.NetworktemplateSwitchMatchingRuleOobIpConfig']:
        """
        Out-of-Band Management interface configuration
        """
        return pulumi.get(self, "oob_ip_config")

    @_builtins.property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortConfig']]:
        """
        Property key is the port name or range (e.g. "ge-0/0/0-10")
        """
        return pulumi.get(self, "port_config")

    @_builtins.property
    @pulumi.getter(name="portMirroring")
    def port_mirroring(self) -> Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortMirroring']]:
        """
        Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed
        """
        return pulumi.get(self, "port_mirroring")


@pulumi.output_type
class NetworktemplateSwitchMatchingRuleIpConfig(dict):
    def __init__(__self__, *,
                 network: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str network: VLAN Name for the management interface
        :param _builtins.str type: enum: `dhcp`, `static`
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        VLAN Name for the management interface
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworktemplateSwitchMatchingRuleOobIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRuleOobIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRuleOobIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRuleOobIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")


@pulumi.output_type
class NetworktemplateSwitchMatchingRulePortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeDisableLacp":
            suggest = "ae_disable_lacp"
        elif key == "aeIdx":
            suggest = "ae_idx"
        elif key == "aeLacpSlow":
            suggest = "ae_lacp_slow"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicUsage":
            suggest = "dynamic_usage"
        elif key == "noLocalOverwrite":
            suggest = "no_local_overwrite"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portNetwork":
            suggest = "port_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRulePortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRulePortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRulePortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: _builtins.str,
                 ae_disable_lacp: Optional[_builtins.bool] = None,
                 ae_idx: Optional[_builtins.int] = None,
                 ae_lacp_slow: Optional[_builtins.bool] = None,
                 aggregated: Optional[_builtins.bool] = None,
                 critical: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 duplex: Optional[_builtins.str] = None,
                 dynamic_usage: Optional[_builtins.str] = None,
                 esilag: Optional[_builtins.bool] = None,
                 mtu: Optional[_builtins.int] = None,
                 no_local_overwrite: Optional[_builtins.bool] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_network: Optional[_builtins.str] = None,
                 speed: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: Port usage name. For Q-in-Q, use `vlan_tunnel`. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param _builtins.bool ae_disable_lacp: To disable LACP support for the AE interface
        :param _builtins.int ae_idx: Users could force to use the designated AE name
        :param _builtins.bool ae_lacp_slow: To use fast timeout
        :param _builtins.bool critical: To generate port up/down alarm
        :param _builtins.bool disable_autoneg: If `speed` and `duplex` are specified, whether to disable autonegotiation
        :param _builtins.str duplex: enum: `auto`, `full`, `half`
        :param _builtins.str dynamic_usage: Enable dynamic usage for this port. Set to `dynamic` to enable.
        :param _builtins.int mtu: Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param _builtins.bool no_local_overwrite: Prevent helpdesk to override the port config
        :param _builtins.str port_network: Required if `usage`==`vlan_tunnel`. Q-in-Q tunneling using All-in-one bundling. This also enables standard L2PT for interfaces that are not encapsulation tunnel interfaces and uses MAC rewrite operation. [View more information](https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/q-in-q.html#id-understanding-qinq-tunneling-and-vlan-translation)
        :param _builtins.str speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_slow is not None:
            pulumi.set(__self__, "ae_lacp_slow", ae_lacp_slow)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_usage is not None:
            pulumi.set(__self__, "dynamic_usage", dynamic_usage)
        if esilag is not None:
            pulumi.set(__self__, "esilag", esilag)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if no_local_overwrite is not None:
            pulumi.set(__self__, "no_local_overwrite", no_local_overwrite)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        Port usage name. For Q-in-Q, use `vlan_tunnel`. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[_builtins.bool]:
        """
        To disable LACP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @_builtins.property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[_builtins.int]:
        """
        Users could force to use the designated AE name
        """
        return pulumi.get(self, "ae_idx")

    @_builtins.property
    @pulumi.getter(name="aeLacpSlow")
    def ae_lacp_slow(self) -> Optional[_builtins.bool]:
        """
        To use fast timeout
        """
        return pulumi.get(self, "ae_lacp_slow")

    @_builtins.property
    @pulumi.getter
    def aggregated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aggregated")

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[_builtins.bool]:
        """
        To generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        """
        If `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="dynamicUsage")
    def dynamic_usage(self) -> Optional[_builtins.str]:
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        return pulumi.get(self, "dynamic_usage")

    @_builtins.property
    @pulumi.getter
    def esilag(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "esilag")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        """
        Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter(name="noLocalOverwrite")
    def no_local_overwrite(self) -> Optional[_builtins.bool]:
        """
        Prevent helpdesk to override the port config
        """
        return pulumi.get(self, "no_local_overwrite")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Required if `usage`==`vlan_tunnel`. Q-in-Q tunneling using All-in-one bundling. This also enables standard L2PT for interfaces that are not encapsulation tunnel interfaces and uses MAC rewrite operation. [View more information](https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/q-in-q.html#id-understanding-qinq-tunneling-and-vlan-translation)
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class NetworktemplateSwitchMatchingRulePortMirroring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputNetworksIngresses":
            suggest = "input_networks_ingresses"
        elif key == "inputPortIdsEgresses":
            suggest = "input_port_ids_egresses"
        elif key == "inputPortIdsIngresses":
            suggest = "input_port_ids_ingresses"
        elif key == "outputIpAddress":
            suggest = "output_ip_address"
        elif key == "outputNetwork":
            suggest = "output_network"
        elif key == "outputPortId":
            suggest = "output_port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRulePortMirroring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRulePortMirroring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRulePortMirroring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_networks_ingresses: Optional[Sequence[_builtins.str]] = None,
                 input_port_ids_egresses: Optional[Sequence[_builtins.str]] = None,
                 input_port_ids_ingresses: Optional[Sequence[_builtins.str]] = None,
                 output_ip_address: Optional[_builtins.str] = None,
                 output_network: Optional[_builtins.str] = None,
                 output_port_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] input_networks_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[_builtins.str] input_port_ids_egresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[_builtins.str] input_port_ids_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param _builtins.str output_ip_address: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        :param _builtins.str output_network: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        :param _builtins.str output_port_id: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_ip_address is not None:
            pulumi.set(__self__, "output_ip_address", output_ip_address)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @_builtins.property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @_builtins.property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @_builtins.property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @_builtins.property
    @pulumi.getter(name="outputIpAddress")
    def output_ip_address(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_ip_address")

    @_builtins.property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @_builtins.property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")


@pulumi.output_type
class NetworktemplateSwitchMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apAffinityThreshold":
            suggest = "ap_affinity_threshold"
        elif key == "cliBanner":
            suggest = "cli_banner"
        elif key == "cliIdleTimeout":
            suggest = "cli_idle_timeout"
        elif key == "configRevertTimer":
            suggest = "config_revert_timer"
        elif key == "dhcpOptionFqdn":
            suggest = "dhcp_option_fqdn"
        elif key == "disableOobDownAlarm":
            suggest = "disable_oob_down_alarm"
        elif key == "fipsEnabled":
            suggest = "fips_enabled"
        elif key == "localAccounts":
            suggest = "local_accounts"
        elif key == "mxedgeProxyHost":
            suggest = "mxedge_proxy_host"
        elif key == "mxedgeProxyPort":
            suggest = "mxedge_proxy_port"
        elif key == "protectRe":
            suggest = "protect_re"
        elif key == "removeExistingConfigs":
            suggest = "remove_existing_configs"
        elif key == "rootPassword":
            suggest = "root_password"
        elif key == "useMxedgeProxy":
            suggest = "use_mxedge_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[_builtins.int] = None,
                 cli_banner: Optional[_builtins.str] = None,
                 cli_idle_timeout: Optional[_builtins.int] = None,
                 config_revert_timer: Optional[_builtins.int] = None,
                 dhcp_option_fqdn: Optional[_builtins.bool] = None,
                 disable_oob_down_alarm: Optional[_builtins.bool] = None,
                 fips_enabled: Optional[_builtins.bool] = None,
                 local_accounts: Optional[Mapping[str, 'outputs.NetworktemplateSwitchMgmtLocalAccounts']] = None,
                 mxedge_proxy_host: Optional[_builtins.str] = None,
                 mxedge_proxy_port: Optional[_builtins.str] = None,
                 protect_re: Optional['outputs.NetworktemplateSwitchMgmtProtectRe'] = None,
                 remove_existing_configs: Optional[_builtins.bool] = None,
                 root_password: Optional[_builtins.str] = None,
                 tacacs: Optional['outputs.NetworktemplateSwitchMgmtTacacs'] = None,
                 use_mxedge_proxy: Optional[_builtins.bool] = None):
        """
        :param _builtins.int ap_affinity_threshold: AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        :param _builtins.str cli_banner: Set Banners for switches. Allows markup formatting
        :param _builtins.int cli_idle_timeout: Sets timeout for switches
        :param _builtins.int config_revert_timer: Rollback timer for commit confirmed
        :param _builtins.bool dhcp_option_fqdn: Enable to provide the FQDN with DHCP option 81
        :param Mapping[str, 'NetworktemplateSwitchMgmtLocalAccountsArgs'] local_accounts: Property key is the user name. For Local user authentication
        :param _builtins.str mxedge_proxy_host: IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        :param _builtins.str mxedge_proxy_port: Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        :param 'NetworktemplateSwitchMgmtProtectReArgs' protect_re: Restrict inbound-traffic to host
               when enabled, all traffic that is not essential to our operation will be dropped 
               e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        :param _builtins.bool remove_existing_configs: By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        :param _builtins.bool use_mxedge_proxy: To use mxedge as proxy
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)
        if cli_banner is not None:
            pulumi.set(__self__, "cli_banner", cli_banner)
        if cli_idle_timeout is not None:
            pulumi.set(__self__, "cli_idle_timeout", cli_idle_timeout)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if dhcp_option_fqdn is not None:
            pulumi.set(__self__, "dhcp_option_fqdn", dhcp_option_fqdn)
        if disable_oob_down_alarm is not None:
            pulumi.set(__self__, "disable_oob_down_alarm", disable_oob_down_alarm)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if local_accounts is not None:
            pulumi.set(__self__, "local_accounts", local_accounts)
        if mxedge_proxy_host is not None:
            pulumi.set(__self__, "mxedge_proxy_host", mxedge_proxy_host)
        if mxedge_proxy_port is not None:
            pulumi.set(__self__, "mxedge_proxy_port", mxedge_proxy_port)
        if protect_re is not None:
            pulumi.set(__self__, "protect_re", protect_re)
        if remove_existing_configs is not None:
            pulumi.set(__self__, "remove_existing_configs", remove_existing_configs)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if tacacs is not None:
            pulumi.set(__self__, "tacacs", tacacs)
        if use_mxedge_proxy is not None:
            pulumi.set(__self__, "use_mxedge_proxy", use_mxedge_proxy)

    @_builtins.property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[_builtins.int]:
        """
        AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")

    @_builtins.property
    @pulumi.getter(name="cliBanner")
    def cli_banner(self) -> Optional[_builtins.str]:
        """
        Set Banners for switches. Allows markup formatting
        """
        return pulumi.get(self, "cli_banner")

    @_builtins.property
    @pulumi.getter(name="cliIdleTimeout")
    def cli_idle_timeout(self) -> Optional[_builtins.int]:
        """
        Sets timeout for switches
        """
        return pulumi.get(self, "cli_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[_builtins.int]:
        """
        Rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @_builtins.property
    @pulumi.getter(name="dhcpOptionFqdn")
    def dhcp_option_fqdn(self) -> Optional[_builtins.bool]:
        """
        Enable to provide the FQDN with DHCP option 81
        """
        return pulumi.get(self, "dhcp_option_fqdn")

    @_builtins.property
    @pulumi.getter(name="disableOobDownAlarm")
    def disable_oob_down_alarm(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_oob_down_alarm")

    @_builtins.property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fips_enabled")

    @_builtins.property
    @pulumi.getter(name="localAccounts")
    def local_accounts(self) -> Optional[Mapping[str, 'outputs.NetworktemplateSwitchMgmtLocalAccounts']]:
        """
        Property key is the user name. For Local user authentication
        """
        return pulumi.get(self, "local_accounts")

    @_builtins.property
    @pulumi.getter(name="mxedgeProxyHost")
    def mxedge_proxy_host(self) -> Optional[_builtins.str]:
        """
        IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        """
        return pulumi.get(self, "mxedge_proxy_host")

    @_builtins.property
    @pulumi.getter(name="mxedgeProxyPort")
    def mxedge_proxy_port(self) -> Optional[_builtins.str]:
        """
        Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        """
        return pulumi.get(self, "mxedge_proxy_port")

    @_builtins.property
    @pulumi.getter(name="protectRe")
    def protect_re(self) -> Optional['outputs.NetworktemplateSwitchMgmtProtectRe']:
        """
        Restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "protect_re")

    @_builtins.property
    @pulumi.getter(name="removeExistingConfigs")
    def remove_existing_configs(self) -> Optional[_builtins.bool]:
        """
        By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        """
        return pulumi.get(self, "remove_existing_configs")

    @_builtins.property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "root_password")

    @_builtins.property
    @pulumi.getter
    def tacacs(self) -> Optional['outputs.NetworktemplateSwitchMgmtTacacs']:
        return pulumi.get(self, "tacacs")

    @_builtins.property
    @pulumi.getter(name="useMxedgeProxy")
    def use_mxedge_proxy(self) -> Optional[_builtins.bool]:
        """
        To use mxedge as proxy
        """
        return pulumi.get(self, "use_mxedge_proxy")


@pulumi.output_type
class NetworktemplateSwitchMgmtLocalAccounts(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param _builtins.str role: enum: `admin`, `helpdesk`, `none`, `read`
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class NetworktemplateSwitchMgmtProtectRe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedServices":
            suggest = "allowed_services"
        elif key == "hitCount":
            suggest = "hit_count"
        elif key == "trustedHosts":
            suggest = "trusted_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmtProtectRe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmtProtectRe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmtProtectRe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_services: Optional[Sequence[_builtins.str]] = None,
                 customs: Optional[Sequence['outputs.NetworktemplateSwitchMgmtProtectReCustom']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 hit_count: Optional[_builtins.bool] = None,
                 trusted_hosts: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allowed_services: optionally, services we'll allow. enum: `icmp`, `ssh`
        :param _builtins.bool enabled: When enabled, all traffic that is not essential to our operation will be dropped
               e.g. ntp / dns / traffic to mist will be allowed by default
                    if dhcpd is enabled, we'll make sure it works
        :param _builtins.bool hit_count: Whether to enable hit count for Protect_RE policy
        :param Sequence[_builtins.str] trusted_hosts: host/subnets we'll allow traffic to/from
        """
        if allowed_services is not None:
            pulumi.set(__self__, "allowed_services", allowed_services)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hit_count is not None:
            pulumi.set(__self__, "hit_count", hit_count)
        if trusted_hosts is not None:
            pulumi.set(__self__, "trusted_hosts", trusted_hosts)

    @_builtins.property
    @pulumi.getter(name="allowedServices")
    def allowed_services(self) -> Optional[Sequence[_builtins.str]]:
        """
        optionally, services we'll allow. enum: `icmp`, `ssh`
        """
        return pulumi.get(self, "allowed_services")

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMgmtProtectReCustom']]:
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="hitCount")
    def hit_count(self) -> Optional[_builtins.bool]:
        """
        Whether to enable hit count for Protect_RE policy
        """
        return pulumi.get(self, "hit_count")

    @_builtins.property
    @pulumi.getter(name="trustedHosts")
    def trusted_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        host/subnets we'll allow traffic to/from
        """
        return pulumi.get(self, "trusted_hosts")


@pulumi.output_type
class NetworktemplateSwitchMgmtProtectReCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmtProtectReCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmtProtectReCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmtProtectReCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnets: Sequence[_builtins.str],
                 port_range: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_range: matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        :param _builtins.str protocol: enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        pulumi.set(__self__, "subnets", subnets)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class NetworktemplateSwitchMgmtTacacs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctServers":
            suggest = "acct_servers"
        elif key == "defaultRole":
            suggest = "default_role"
        elif key == "tacplusServers":
            suggest = "tacplus_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmtTacacs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmtTacacs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmtTacacs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_servers: Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsAcctServer']] = None,
                 default_role: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 tacplus_servers: Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsTacplusServer']] = None):
        """
        :param _builtins.str default_role: enum: `admin`, `helpdesk`, `none`, `read`
        :param _builtins.str network: Which network the TACACS server resides
        """
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if default_role is not None:
            pulumi.set(__self__, "default_role", default_role)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if tacplus_servers is not None:
            pulumi.set(__self__, "tacplus_servers", tacplus_servers)

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter(name="defaultRole")
    def default_role(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "default_role")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Which network the TACACS server resides
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="tacplusServers")
    def tacplus_servers(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsTacplusServer']]:
        return pulumi.get(self, "tacplus_servers")


@pulumi.output_type
class NetworktemplateSwitchMgmtTacacsAcctServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NetworktemplateSwitchMgmtTacacsTacplusServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NetworktemplateVrfConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworktemplateVrfInstances(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evpnAutoLoopbackSubnet":
            suggest = "evpn_auto_loopback_subnet"
        elif key == "evpnAutoLoopbackSubnet6":
            suggest = "evpn_auto_loopback_subnet6"
        elif key == "extraRoutes":
            suggest = "extra_routes"
        elif key == "extraRoutes6":
            suggest = "extra_routes6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateVrfInstances. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateVrfInstances.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateVrfInstances.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evpn_auto_loopback_subnet: Optional[_builtins.str] = None,
                 evpn_auto_loopback_subnet6: Optional[_builtins.str] = None,
                 extra_routes: Optional[Mapping[str, 'outputs.NetworktemplateVrfInstancesExtraRoutes']] = None,
                 extra_routes6: Optional[Mapping[str, 'outputs.NetworktemplateVrfInstancesExtraRoutes6']] = None,
                 networks: Optional[Sequence[_builtins.str]] = None):
        """
        :param Mapping[str, 'NetworktemplateVrfInstancesExtraRoutesArgs'] extra_routes: Property key is the destination CIDR (e.g. "10.0.0.0/8")
        :param Mapping[str, 'NetworktemplateVrfInstancesExtraRoutes6Args'] extra_routes6: Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        if evpn_auto_loopback_subnet is not None:
            pulumi.set(__self__, "evpn_auto_loopback_subnet", evpn_auto_loopback_subnet)
        if evpn_auto_loopback_subnet6 is not None:
            pulumi.set(__self__, "evpn_auto_loopback_subnet6", evpn_auto_loopback_subnet6)
        if extra_routes is not None:
            pulumi.set(__self__, "extra_routes", extra_routes)
        if extra_routes6 is not None:
            pulumi.set(__self__, "extra_routes6", extra_routes6)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter(name="evpnAutoLoopbackSubnet")
    def evpn_auto_loopback_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "evpn_auto_loopback_subnet")

    @_builtins.property
    @pulumi.getter(name="evpnAutoLoopbackSubnet6")
    def evpn_auto_loopback_subnet6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "evpn_auto_loopback_subnet6")

    @_builtins.property
    @pulumi.getter(name="extraRoutes")
    def extra_routes(self) -> Optional[Mapping[str, 'outputs.NetworktemplateVrfInstancesExtraRoutes']]:
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        return pulumi.get(self, "extra_routes")

    @_builtins.property
    @pulumi.getter(name="extraRoutes6")
    def extra_routes6(self) -> Optional[Mapping[str, 'outputs.NetworktemplateVrfInstancesExtraRoutes6']]:
        """
        Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        return pulumi.get(self, "extra_routes6")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class NetworktemplateVrfInstancesExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        """
        :param _builtins.str via: Next-hop address
        """
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")


@pulumi.output_type
class NetworktemplateVrfInstancesExtraRoutes(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        """
        :param _builtins.str via: Next-hop address
        """
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")


@pulumi.output_type
class RftemplateBand24(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateBand24. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateBand24.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateBand24.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class RftemplateBand5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateBand5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateBand5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateBand5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class RftemplateBand5On24Radio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateBand5On24Radio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateBand5On24Radio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateBand5On24Radio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class RftemplateBand6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"
        elif key == "standardPower":
            suggest = "standard_power"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateBand6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateBand6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateBand6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None,
                 standard_power: Optional[_builtins.bool] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        :param _builtins.bool standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @_builtins.property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[_builtins.bool]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")


@pulumi.output_type
class RftemplateModelSpecific(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "antGain24":
            suggest = "ant_gain24"
        elif key == "antGain5":
            suggest = "ant_gain5"
        elif key == "antGain6":
            suggest = "ant_gain6"
        elif key == "band24Usage":
            suggest = "band24_usage"
        elif key == "band5On24Radio":
            suggest = "band5_on24_radio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateModelSpecific. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateModelSpecific.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateModelSpecific.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ant_gain24: Optional[_builtins.int] = None,
                 ant_gain5: Optional[_builtins.int] = None,
                 ant_gain6: Optional[_builtins.int] = None,
                 band24: Optional['outputs.RftemplateModelSpecificBand24'] = None,
                 band24_usage: Optional[_builtins.str] = None,
                 band5: Optional['outputs.RftemplateModelSpecificBand5'] = None,
                 band5_on24_radio: Optional['outputs.RftemplateModelSpecificBand5On24Radio'] = None,
                 band6: Optional['outputs.RftemplateModelSpecificBand6'] = None):
        """
        :param 'RftemplateModelSpecificBand24Args' band24: Radio Band AP settings
        :param _builtins.str band24_usage: enum: `24`, `5`, `6`, `auto`
        :param 'RftemplateModelSpecificBand5Args' band5: Radio Band AP settings
        :param 'RftemplateModelSpecificBand5On24RadioArgs' band5_on24_radio: Radio Band AP settings
        :param 'RftemplateModelSpecificBand6Args' band6: Radio Band AP settings
        """
        if ant_gain24 is not None:
            pulumi.set(__self__, "ant_gain24", ant_gain24)
        if ant_gain5 is not None:
            pulumi.set(__self__, "ant_gain5", ant_gain5)
        if ant_gain6 is not None:
            pulumi.set(__self__, "ant_gain6", ant_gain6)
        if band24 is not None:
            pulumi.set(__self__, "band24", band24)
        if band24_usage is not None:
            pulumi.set(__self__, "band24_usage", band24_usage)
        if band5 is not None:
            pulumi.set(__self__, "band5", band5)
        if band5_on24_radio is not None:
            pulumi.set(__self__, "band5_on24_radio", band5_on24_radio)
        if band6 is not None:
            pulumi.set(__self__, "band6", band6)

    @_builtins.property
    @pulumi.getter(name="antGain24")
    def ant_gain24(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain24")

    @_builtins.property
    @pulumi.getter(name="antGain5")
    def ant_gain5(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain5")

    @_builtins.property
    @pulumi.getter(name="antGain6")
    def ant_gain6(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain6")

    @_builtins.property
    @pulumi.getter
    def band24(self) -> Optional['outputs.RftemplateModelSpecificBand24']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band24")

    @_builtins.property
    @pulumi.getter(name="band24Usage")
    def band24_usage(self) -> Optional[_builtins.str]:
        """
        enum: `24`, `5`, `6`, `auto`
        """
        return pulumi.get(self, "band24_usage")

    @_builtins.property
    @pulumi.getter
    def band5(self) -> Optional['outputs.RftemplateModelSpecificBand5']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5")

    @_builtins.property
    @pulumi.getter(name="band5On24Radio")
    def band5_on24_radio(self) -> Optional['outputs.RftemplateModelSpecificBand5On24Radio']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5_on24_radio")

    @_builtins.property
    @pulumi.getter
    def band6(self) -> Optional['outputs.RftemplateModelSpecificBand6']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band6")


@pulumi.output_type
class RftemplateModelSpecificBand24(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateModelSpecificBand24. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateModelSpecificBand24.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateModelSpecificBand24.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        tx power of the radio, null or 0 means auto, when power*min=power*max=power=0 to indicate power=0
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class RftemplateModelSpecificBand5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateModelSpecificBand5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateModelSpecificBand5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateModelSpecificBand5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class RftemplateModelSpecificBand5On24Radio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateModelSpecificBand5On24Radio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateModelSpecificBand5On24Radio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateModelSpecificBand5On24Radio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class RftemplateModelSpecificBand6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"
        elif key == "standardPower":
            suggest = "standard_power"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RftemplateModelSpecificBand6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RftemplateModelSpecificBand6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RftemplateModelSpecificBand6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None,
                 standard_power: Optional[_builtins.bool] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        :param _builtins.bool standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Tx power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @_builtins.property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[_builtins.bool]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")


@pulumi.output_type
class ServiceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_range: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_range: Port number, port range, or variable
        :param _builtins.str protocol: `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        Port number, port range, or variable
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ServicepolicyAamw(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aamwprofileId":
            suggest = "aamwprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicepolicyAamw. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicepolicyAamw.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicepolicyAamw.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aamwprofile_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str aamwprofile_id: org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: enum: `docsonly`, `executables`, `standard`
        """
        if aamwprofile_id is not None:
            pulumi.set(__self__, "aamwprofile_id", aamwprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="aamwprofileId")
    def aamwprofile_id(self) -> Optional[_builtins.str]:
        """
        org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "aamwprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `docsonly`, `executables`, `standard`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class ServicepolicyAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avprofileId":
            suggest = "avprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicepolicyAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicepolicyAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicepolicyAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avprofile_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[_builtins.str]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class ServicepolicyAppqoe(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ServicepolicyEwf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "blockMessage":
            suggest = "block_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicepolicyEwf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicepolicyEwf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicepolicyEwf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 block_message: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "block_message")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class ServicepolicyIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "idpprofileId":
            suggest = "idpprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicepolicyIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicepolicyIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicepolicyIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idpprofile_id: Optional[_builtins.str] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param _builtins.str profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[_builtins.str]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class ServicepolicySslProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ciphersCategory":
            suggest = "ciphers_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicepolicySslProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicepolicySslProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicepolicySslProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers_category: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[_builtins.str]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingApiPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noReveal":
            suggest = "no_reveal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingApiPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingApiPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingApiPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_reveal: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool no_reveal: By default, API hides password/secrets when the user doesn't have write access
                 * `true`: API will hide passwords/secrets for all users
                 * `false`: API will hide passwords/secrets for read-only users
        """
        if no_reveal is not None:
            pulumi.set(__self__, "no_reveal", no_reveal)

    @_builtins.property
    @pulumi.getter(name="noReveal")
    def no_reveal(self) -> Optional[_builtins.bool]:
        """
        By default, API hides password/secrets when the user doesn't have write access
          * `true`: API will hide passwords/secrets for all users
          * `false`: API will hide passwords/secrets for read-only users
        """
        return pulumi.get(self, "no_reveal")


@pulumi.output_type
class SettingCelona(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiPrefix":
            suggest = "api_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingCelona. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingCelona.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingCelona.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 api_prefix: _builtins.str):
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_prefix", api_prefix)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> _builtins.str:
        return pulumi.get(self, "api_prefix")


@pulumi.output_type
class SettingCloudshark(dict):
    def __init__(__self__, *,
                 apitoken: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: If using CS Enterprise
        """
        if apitoken is not None:
            pulumi.set(__self__, "apitoken", apitoken)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def apitoken(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apitoken")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        If using CS Enterprise
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SettingCradlepoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpApiId":
            suggest = "cp_api_id"
        elif key == "cpApiKey":
            suggest = "cp_api_key"
        elif key == "ecmApiId":
            suggest = "ecm_api_id"
        elif key == "ecmApiKey":
            suggest = "ecm_api_key"
        elif key == "enableLldp":
            suggest = "enable_lldp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingCradlepoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingCradlepoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingCradlepoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cp_api_id: Optional[_builtins.str] = None,
                 cp_api_key: Optional[_builtins.str] = None,
                 ecm_api_id: Optional[_builtins.str] = None,
                 ecm_api_key: Optional[_builtins.str] = None,
                 enable_lldp: Optional[_builtins.bool] = None):
        if cp_api_id is not None:
            pulumi.set(__self__, "cp_api_id", cp_api_id)
        if cp_api_key is not None:
            pulumi.set(__self__, "cp_api_key", cp_api_key)
        if ecm_api_id is not None:
            pulumi.set(__self__, "ecm_api_id", ecm_api_id)
        if ecm_api_key is not None:
            pulumi.set(__self__, "ecm_api_key", ecm_api_key)
        if enable_lldp is not None:
            pulumi.set(__self__, "enable_lldp", enable_lldp)

    @_builtins.property
    @pulumi.getter(name="cpApiId")
    def cp_api_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cp_api_id")

    @_builtins.property
    @pulumi.getter(name="cpApiKey")
    def cp_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cp_api_key")

    @_builtins.property
    @pulumi.getter(name="ecmApiId")
    def ecm_api_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ecm_api_id")

    @_builtins.property
    @pulumi.getter(name="ecmApiKey")
    def ecm_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ecm_api_key")

    @_builtins.property
    @pulumi.getter(name="enableLldp")
    def enable_lldp(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_lldp")


@pulumi.output_type
class SettingDeviceCert(dict):
    def __init__(__self__, *,
                 cert: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class SettingInstaller(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllDevices":
            suggest = "allow_all_devices"
        elif key == "allowAllSites":
            suggest = "allow_all_sites"
        elif key == "extraSiteIds":
            suggest = "extra_site_ids"
        elif key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingInstaller. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingInstaller.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingInstaller.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_devices: Optional[_builtins.bool] = None,
                 allow_all_sites: Optional[_builtins.bool] = None,
                 extra_site_ids: Optional[Sequence[_builtins.str]] = None,
                 grace_period: Optional[_builtins.int] = None):
        if allow_all_devices is not None:
            pulumi.set(__self__, "allow_all_devices", allow_all_devices)
        if allow_all_sites is not None:
            pulumi.set(__self__, "allow_all_sites", allow_all_sites)
        if extra_site_ids is not None:
            pulumi.set(__self__, "extra_site_ids", extra_site_ids)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @_builtins.property
    @pulumi.getter(name="allowAllDevices")
    def allow_all_devices(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_all_devices")

    @_builtins.property
    @pulumi.getter(name="allowAllSites")
    def allow_all_sites(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_all_sites")

    @_builtins.property
    @pulumi.getter(name="extraSiteIds")
    def extra_site_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_site_ids")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class SettingJcloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orgApitoken":
            suggest = "org_apitoken"
        elif key == "orgApitokenName":
            suggest = "org_apitoken_name"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingJcloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingJcloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingJcloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 org_apitoken: _builtins.str,
                 org_apitoken_name: _builtins.str,
                 org_id: _builtins.str):
        """
        :param _builtins.str org_apitoken: JCloud Org Token
        :param _builtins.str org_apitoken_name: JCloud Org Token Name
        :param _builtins.str org_id: JCloud Org ID
        """
        pulumi.set(__self__, "org_apitoken", org_apitoken)
        pulumi.set(__self__, "org_apitoken_name", org_apitoken_name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="orgApitoken")
    def org_apitoken(self) -> _builtins.str:
        """
        JCloud Org Token
        """
        return pulumi.get(self, "org_apitoken")

    @_builtins.property
    @pulumi.getter(name="orgApitokenName")
    def org_apitoken_name(self) -> _builtins.str:
        """
        JCloud Org Token Name
        """
        return pulumi.get(self, "org_apitoken_name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        JCloud Org ID
        """
        return pulumi.get(self, "org_id")


@pulumi.output_type
class SettingJcloudRa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orgApitoken":
            suggest = "org_apitoken"
        elif key == "orgApitokenName":
            suggest = "org_apitoken_name"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingJcloudRa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingJcloudRa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingJcloudRa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 org_apitoken: Optional[_builtins.str] = None,
                 org_apitoken_name: Optional[_builtins.str] = None,
                 org_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str org_apitoken: JCloud Routing Assurance Org Token
        :param _builtins.str org_apitoken_name: JCloud Routing Assurance Org Token Name
        :param _builtins.str org_id: JCloud Routing Assurance Org ID
        """
        if org_apitoken is not None:
            pulumi.set(__self__, "org_apitoken", org_apitoken)
        if org_apitoken_name is not None:
            pulumi.set(__self__, "org_apitoken_name", org_apitoken_name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="orgApitoken")
    def org_apitoken(self) -> Optional[_builtins.str]:
        """
        JCloud Routing Assurance Org Token
        """
        return pulumi.get(self, "org_apitoken")

    @_builtins.property
    @pulumi.getter(name="orgApitokenName")
    def org_apitoken_name(self) -> Optional[_builtins.str]:
        """
        JCloud Routing Assurance Org Token Name
        """
        return pulumi.get(self, "org_apitoken_name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        """
        JCloud Routing Assurance Org ID
        """
        return pulumi.get(self, "org_id")


@pulumi.output_type
class SettingJuniper(dict):
    def __init__(__self__, *,
                 accounts: Optional[Sequence['outputs.SettingJuniperAccount']] = None):
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)

    @_builtins.property
    @pulumi.getter
    def accounts(self) -> Optional[Sequence['outputs.SettingJuniperAccount']]:
        return pulumi.get(self, "accounts")


@pulumi.output_type
class SettingJuniperAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkedBy":
            suggest = "linked_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingJuniperAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingJuniperAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingJuniperAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linked_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if linked_by is not None:
            pulumi.set(__self__, "linked_by", linked_by)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="linkedBy")
    def linked_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "linked_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SettingJunosShellAccess(dict):
    def __init__(__self__, *,
                 admin: Optional[_builtins.str] = None,
                 helpdesk: Optional[_builtins.str] = None,
                 read: Optional[_builtins.str] = None,
                 write: Optional[_builtins.str] = None):
        """
        :param _builtins.str admin: enum: `admin`, `viewer`, `none`
        :param _builtins.str helpdesk: enum: `admin`, `viewer`, `none`
        :param _builtins.str read: enum: `admin`, `viewer`, `none`
        :param _builtins.str write: enum: `admin`, `viewer`, `none`
        """
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if helpdesk is not None:
            pulumi.set(__self__, "helpdesk", helpdesk)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if write is not None:
            pulumi.set(__self__, "write", write)

    @_builtins.property
    @pulumi.getter
    def admin(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter
    def helpdesk(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "helpdesk")

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "read")

    @_builtins.property
    @pulumi.getter
    def write(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `viewer`, `none`
        """
        return pulumi.get(self, "write")


@pulumi.output_type
class SettingMarvis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoOperations":
            suggest = "auto_operations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingMarvis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingMarvis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingMarvis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_operations: Optional['outputs.SettingMarvisAutoOperations'] = None):
        if auto_operations is not None:
            pulumi.set(__self__, "auto_operations", auto_operations)

    @_builtins.property
    @pulumi.getter(name="autoOperations")
    def auto_operations(self) -> Optional['outputs.SettingMarvisAutoOperations']:
        return pulumi.get(self, "auto_operations")


@pulumi.output_type
class SettingMarvisAutoOperations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bouncePortForAbnormalPoeClient":
            suggest = "bounce_port_for_abnormal_poe_client"
        elif key == "disablePortWhenDdosProtocolViolation":
            suggest = "disable_port_when_ddos_protocol_violation"
        elif key == "disablePortWhenRogueDhcpServerDetected":
            suggest = "disable_port_when_rogue_dhcp_server_detected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingMarvisAutoOperations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingMarvisAutoOperations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingMarvisAutoOperations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounce_port_for_abnormal_poe_client: Optional[_builtins.bool] = None,
                 disable_port_when_ddos_protocol_violation: Optional[_builtins.bool] = None,
                 disable_port_when_rogue_dhcp_server_detected: Optional[_builtins.bool] = None):
        if bounce_port_for_abnormal_poe_client is not None:
            pulumi.set(__self__, "bounce_port_for_abnormal_poe_client", bounce_port_for_abnormal_poe_client)
        if disable_port_when_ddos_protocol_violation is not None:
            pulumi.set(__self__, "disable_port_when_ddos_protocol_violation", disable_port_when_ddos_protocol_violation)
        if disable_port_when_rogue_dhcp_server_detected is not None:
            pulumi.set(__self__, "disable_port_when_rogue_dhcp_server_detected", disable_port_when_rogue_dhcp_server_detected)

    @_builtins.property
    @pulumi.getter(name="bouncePortForAbnormalPoeClient")
    def bounce_port_for_abnormal_poe_client(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "bounce_port_for_abnormal_poe_client")

    @_builtins.property
    @pulumi.getter(name="disablePortWhenDdosProtocolViolation")
    def disable_port_when_ddos_protocol_violation(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_port_when_ddos_protocol_violation")

    @_builtins.property
    @pulumi.getter(name="disablePortWhenRogueDhcpServerDetected")
    def disable_port_when_rogue_dhcp_server_detected(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_port_when_rogue_dhcp_server_detected")


@pulumi.output_type
class SettingMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mxtunnelIds":
            suggest = "mxtunnel_ids"
        elif key == "useMxtunnel":
            suggest = "use_mxtunnel"
        elif key == "useWxtunnel":
            suggest = "use_wxtunnel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mxtunnel_ids: Optional[Sequence[_builtins.str]] = None,
                 use_mxtunnel: Optional[_builtins.bool] = None,
                 use_wxtunnel: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] mxtunnel_ids: List of Mist Tunnels
        :param _builtins.bool use_mxtunnel: Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
        :param _builtins.bool use_wxtunnel: Whether to use wxtunnel for mgmt connectivity
        """
        if mxtunnel_ids is not None:
            pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        if use_mxtunnel is not None:
            pulumi.set(__self__, "use_mxtunnel", use_mxtunnel)
        if use_wxtunnel is not None:
            pulumi.set(__self__, "use_wxtunnel", use_wxtunnel)

    @_builtins.property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Mist Tunnels
        """
        return pulumi.get(self, "mxtunnel_ids")

    @_builtins.property
    @pulumi.getter(name="useMxtunnel")
    def use_mxtunnel(self) -> Optional[_builtins.bool]:
        """
        Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
        """
        return pulumi.get(self, "use_mxtunnel")

    @_builtins.property
    @pulumi.getter(name="useWxtunnel")
    def use_wxtunnel(self) -> Optional[_builtins.bool]:
        """
        Whether to use wxtunnel for mgmt connectivity
        """
        return pulumi.get(self, "use_wxtunnel")


@pulumi.output_type
class SettingMistNac(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultIdpId":
            suggest = "default_idp_id"
        elif key == "disableRsaeAlgorithms":
            suggest = "disable_rsae_algorithms"
        elif key == "eapSslSecurityLevel":
            suggest = "eap_ssl_security_level"
        elif key == "euOnly":
            suggest = "eu_only"
        elif key == "idpMachineCertLookupField":
            suggest = "idp_machine_cert_lookup_field"
        elif key == "idpUserCertLookupField":
            suggest = "idp_user_cert_lookup_field"
        elif key == "serverCert":
            suggest = "server_cert"
        elif key == "useIpVersion":
            suggest = "use_ip_version"
        elif key == "useSslPort":
            suggest = "use_ssl_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingMistNac. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingMistNac.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingMistNac.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cacerts: Optional[Sequence[_builtins.str]] = None,
                 default_idp_id: Optional[_builtins.str] = None,
                 disable_rsae_algorithms: Optional[_builtins.bool] = None,
                 eap_ssl_security_level: Optional[_builtins.int] = None,
                 eu_only: Optional[_builtins.bool] = None,
                 idp_machine_cert_lookup_field: Optional[_builtins.str] = None,
                 idp_user_cert_lookup_field: Optional[_builtins.str] = None,
                 idps: Optional[Sequence['outputs.SettingMistNacIdp']] = None,
                 server_cert: Optional['outputs.SettingMistNacServerCert'] = None,
                 use_ip_version: Optional[_builtins.str] = None,
                 use_ssl_port: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] cacerts: List of PEM-encoded ca certs
        :param _builtins.str default_idp_id: use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
        :param _builtins.bool disable_rsae_algorithms: to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html
        :param _builtins.int eap_ssl_security_level: eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
        :param _builtins.bool eu_only: By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled
        :param _builtins.str idp_machine_cert_lookup_field: allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`
        :param _builtins.str idp_user_cert_lookup_field: allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`
        :param 'SettingMistNacServerCertArgs' server_cert: radius server cert to be presented in EAP TLS
        :param _builtins.str use_ip_version: by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
        :param _builtins.bool use_ssl_port: By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled
        """
        if cacerts is not None:
            pulumi.set(__self__, "cacerts", cacerts)
        if default_idp_id is not None:
            pulumi.set(__self__, "default_idp_id", default_idp_id)
        if disable_rsae_algorithms is not None:
            pulumi.set(__self__, "disable_rsae_algorithms", disable_rsae_algorithms)
        if eap_ssl_security_level is not None:
            pulumi.set(__self__, "eap_ssl_security_level", eap_ssl_security_level)
        if eu_only is not None:
            pulumi.set(__self__, "eu_only", eu_only)
        if idp_machine_cert_lookup_field is not None:
            pulumi.set(__self__, "idp_machine_cert_lookup_field", idp_machine_cert_lookup_field)
        if idp_user_cert_lookup_field is not None:
            pulumi.set(__self__, "idp_user_cert_lookup_field", idp_user_cert_lookup_field)
        if idps is not None:
            pulumi.set(__self__, "idps", idps)
        if server_cert is not None:
            pulumi.set(__self__, "server_cert", server_cert)
        if use_ip_version is not None:
            pulumi.set(__self__, "use_ip_version", use_ip_version)
        if use_ssl_port is not None:
            pulumi.set(__self__, "use_ssl_port", use_ssl_port)

    @_builtins.property
    @pulumi.getter
    def cacerts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of PEM-encoded ca certs
        """
        return pulumi.get(self, "cacerts")

    @_builtins.property
    @pulumi.getter(name="defaultIdpId")
    def default_idp_id(self) -> Optional[_builtins.str]:
        """
        use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
        """
        return pulumi.get(self, "default_idp_id")

    @_builtins.property
    @pulumi.getter(name="disableRsaeAlgorithms")
    def disable_rsae_algorithms(self) -> Optional[_builtins.bool]:
        """
        to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html
        """
        return pulumi.get(self, "disable_rsae_algorithms")

    @_builtins.property
    @pulumi.getter(name="eapSslSecurityLevel")
    def eap_ssl_security_level(self) -> Optional[_builtins.int]:
        """
        eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
        """
        return pulumi.get(self, "eap_ssl_security_level")

    @_builtins.property
    @pulumi.getter(name="euOnly")
    def eu_only(self) -> Optional[_builtins.bool]:
        """
        By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled
        """
        return pulumi.get(self, "eu_only")

    @_builtins.property
    @pulumi.getter(name="idpMachineCertLookupField")
    def idp_machine_cert_lookup_field(self) -> Optional[_builtins.str]:
        """
        allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`
        """
        return pulumi.get(self, "idp_machine_cert_lookup_field")

    @_builtins.property
    @pulumi.getter(name="idpUserCertLookupField")
    def idp_user_cert_lookup_field(self) -> Optional[_builtins.str]:
        """
        allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`
        """
        return pulumi.get(self, "idp_user_cert_lookup_field")

    @_builtins.property
    @pulumi.getter
    def idps(self) -> Optional[Sequence['outputs.SettingMistNacIdp']]:
        return pulumi.get(self, "idps")

    @_builtins.property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> Optional['outputs.SettingMistNacServerCert']:
        """
        radius server cert to be presented in EAP TLS
        """
        return pulumi.get(self, "server_cert")

    @_builtins.property
    @pulumi.getter(name="useIpVersion")
    def use_ip_version(self) -> Optional[_builtins.str]:
        """
        by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
        """
        return pulumi.get(self, "use_ip_version")

    @_builtins.property
    @pulumi.getter(name="useSslPort")
    def use_ssl_port(self) -> Optional[_builtins.bool]:
        """
        By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled
        """
        return pulumi.get(self, "use_ssl_port")


@pulumi.output_type
class SettingMistNacIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userRealms":
            suggest = "user_realms"
        elif key == "excludeRealms":
            suggest = "exclude_realms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingMistNacIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingMistNacIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingMistNacIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 user_realms: Sequence[_builtins.str],
                 exclude_realms: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str id: ID of the `mist_nacidp`
        :param Sequence[_builtins.str] user_realms: Which realm should trigger this IDP. User Realm is extracted from:
                 * Username-AVP (`mist.com` from john@mist.com)
                 * Cert CN
        :param Sequence[_builtins.str] exclude_realms: When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "user_realms", user_realms)
        if exclude_realms is not None:
            pulumi.set(__self__, "exclude_realms", exclude_realms)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the `mist_nacidp`
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="userRealms")
    def user_realms(self) -> Sequence[_builtins.str]:
        """
        Which realm should trigger this IDP. User Realm is extracted from:
          * Username-AVP (`mist.com` from john@mist.com)
          * Cert CN
        """
        return pulumi.get(self, "user_realms")

    @_builtins.property
    @pulumi.getter(name="excludeRealms")
    def exclude_realms(self) -> Optional[Sequence[_builtins.str]]:
        """
        When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org
        """
        return pulumi.get(self, "exclude_realms")


@pulumi.output_type
class SettingMistNacServerCert(dict):
    def __init__(__self__, *,
                 cert: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: private key password (optional)
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        private key password (optional)
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class SettingMxedgeMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configAutoRevert":
            suggest = "config_auto_revert"
        elif key == "fipsEnabled":
            suggest = "fips_enabled"
        elif key == "mistPassword":
            suggest = "mist_password"
        elif key == "oobIpType":
            suggest = "oob_ip_type"
        elif key == "oobIpType6":
            suggest = "oob_ip_type6"
        elif key == "rootPassword":
            suggest = "root_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingMxedgeMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingMxedgeMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingMxedgeMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_auto_revert: Optional[_builtins.bool] = None,
                 fips_enabled: Optional[_builtins.bool] = None,
                 mist_password: Optional[_builtins.str] = None,
                 oob_ip_type: Optional[_builtins.str] = None,
                 oob_ip_type6: Optional[_builtins.str] = None,
                 root_password: Optional[_builtins.str] = None):
        """
        :param _builtins.str oob_ip_type: enum: `dhcp`, `disabled`, `static`
        :param _builtins.str oob_ip_type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if config_auto_revert is not None:
            pulumi.set(__self__, "config_auto_revert", config_auto_revert)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if mist_password is not None:
            pulumi.set(__self__, "mist_password", mist_password)
        if oob_ip_type is not None:
            pulumi.set(__self__, "oob_ip_type", oob_ip_type)
        if oob_ip_type6 is not None:
            pulumi.set(__self__, "oob_ip_type6", oob_ip_type6)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)

    @_builtins.property
    @pulumi.getter(name="configAutoRevert")
    def config_auto_revert(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "config_auto_revert")

    @_builtins.property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fips_enabled")

    @_builtins.property
    @pulumi.getter(name="mistPassword")
    def mist_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mist_password")

    @_builtins.property
    @pulumi.getter(name="oobIpType")
    def oob_ip_type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "oob_ip_type")

    @_builtins.property
    @pulumi.getter(name="oobIpType6")
    def oob_ip_type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "oob_ip_type6")

    @_builtins.property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "root_password")


@pulumi.output_type
class SettingOpticPortConfig(dict):
    def __init__(__self__, *,
                 channelized: Optional[_builtins.bool] = None,
                 speed: Optional[_builtins.str] = None):
        """
        :param _builtins.bool channelized: Enable channelization
        :param _builtins.str speed: Interface speed (e.g. `25g`, `50g`), use the chassis speed by default
        """
        if channelized is not None:
            pulumi.set(__self__, "channelized", channelized)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @_builtins.property
    @pulumi.getter
    def channelized(self) -> Optional[_builtins.bool]:
        """
        Enable channelization
        """
        return pulumi.get(self, "channelized")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        Interface speed (e.g. `25g`, `50g`), use the chassis speed by default
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class SettingPasswordPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiryInDays":
            suggest = "expiry_in_days"
        elif key == "minLength":
            suggest = "min_length"
        elif key == "requiresSpecialChar":
            suggest = "requires_special_char"
        elif key == "requiresTwoFactorAuth":
            suggest = "requires_two_factor_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingPasswordPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingPasswordPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingPasswordPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 expiry_in_days: Optional[_builtins.int] = None,
                 min_length: Optional[_builtins.int] = None,
                 requires_special_char: Optional[_builtins.bool] = None,
                 requires_two_factor_auth: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether the policy is enabled
        :param _builtins.int expiry_in_days: password expiry in days
        :param _builtins.int min_length: Required password length
        :param _builtins.bool requires_special_char: Whether to require special character
        :param _builtins.bool requires_two_factor_auth: Whether to require two-factor auth
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expiry_in_days is not None:
            pulumi.set(__self__, "expiry_in_days", expiry_in_days)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if requires_special_char is not None:
            pulumi.set(__self__, "requires_special_char", requires_special_char)
        if requires_two_factor_auth is not None:
            pulumi.set(__self__, "requires_two_factor_auth", requires_two_factor_auth)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the policy is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="expiryInDays")
    def expiry_in_days(self) -> Optional[_builtins.int]:
        """
        password expiry in days
        """
        return pulumi.get(self, "expiry_in_days")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.int]:
        """
        Required password length
        """
        return pulumi.get(self, "min_length")

    @_builtins.property
    @pulumi.getter(name="requiresSpecialChar")
    def requires_special_char(self) -> Optional[_builtins.bool]:
        """
        Whether to require special character
        """
        return pulumi.get(self, "requires_special_char")

    @_builtins.property
    @pulumi.getter(name="requiresTwoFactorAuth")
    def requires_two_factor_auth(self) -> Optional[_builtins.bool]:
        """
        Whether to require two-factor auth
        """
        return pulumi.get(self, "requires_two_factor_auth")


@pulumi.output_type
class SettingPcap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPktLen":
            suggest = "max_pkt_len"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingPcap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingPcap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingPcap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: Optional[_builtins.str] = None,
                 max_pkt_len: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_pkt_len: Max_len of non-management packets to capture
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if max_pkt_len is not None:
            pulumi.set(__self__, "max_pkt_len", max_pkt_len)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="maxPktLen")
    def max_pkt_len(self) -> Optional[_builtins.int]:
        """
        Max_len of non-management packets to capture
        """
        return pulumi.get(self, "max_pkt_len")


@pulumi.output_type
class SettingSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableLocalSsh":
            suggest = "disable_local_ssh"
        elif key == "fipsZeroizePassword":
            suggest = "fips_zeroize_password"
        elif key == "limitSshAccess":
            suggest = "limit_ssh_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_local_ssh: Optional[_builtins.bool] = None,
                 fips_zeroize_password: Optional[_builtins.str] = None,
                 limit_ssh_access: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disable_local_ssh: Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled
        :param _builtins.str fips_zeroize_password: password required to zeroize devices (FIPS) on site level
        :param _builtins.bool limit_ssh_access: Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
        """
        if disable_local_ssh is not None:
            pulumi.set(__self__, "disable_local_ssh", disable_local_ssh)
        if fips_zeroize_password is not None:
            pulumi.set(__self__, "fips_zeroize_password", fips_zeroize_password)
        if limit_ssh_access is not None:
            pulumi.set(__self__, "limit_ssh_access", limit_ssh_access)

    @_builtins.property
    @pulumi.getter(name="disableLocalSsh")
    def disable_local_ssh(self) -> Optional[_builtins.bool]:
        """
        Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled
        """
        return pulumi.get(self, "disable_local_ssh")

    @_builtins.property
    @pulumi.getter(name="fipsZeroizePassword")
    def fips_zeroize_password(self) -> Optional[_builtins.str]:
        """
        password required to zeroize devices (FIPS) on site level
        """
        return pulumi.get(self, "fips_zeroize_password")

    @_builtins.property
    @pulumi.getter(name="limitSshAccess")
    def limit_ssh_access(self) -> Optional[_builtins.bool]:
        """
        Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
        """
        return pulumi.get(self, "limit_ssh_access")


@pulumi.output_type
class SettingSsr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conductorHosts":
            suggest = "conductor_hosts"
        elif key == "conductorToken":
            suggest = "conductor_token"
        elif key == "disableStats":
            suggest = "disable_stats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSsr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSsr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSsr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conductor_hosts: Optional[Sequence[_builtins.str]] = None,
                 conductor_token: Optional[_builtins.str] = None,
                 disable_stats: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] conductor_hosts: List of Conductor IP Addresses or Hosts to be used by the SSR Devices
        :param _builtins.str conductor_token: Token to be used by the SSR Devices to connect to the Conductor
        :param _builtins.bool disable_stats: Disable stats collection on SSR devices
        """
        if conductor_hosts is not None:
            pulumi.set(__self__, "conductor_hosts", conductor_hosts)
        if conductor_token is not None:
            pulumi.set(__self__, "conductor_token", conductor_token)
        if disable_stats is not None:
            pulumi.set(__self__, "disable_stats", disable_stats)

    @_builtins.property
    @pulumi.getter(name="conductorHosts")
    def conductor_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Conductor IP Addresses or Hosts to be used by the SSR Devices
        """
        return pulumi.get(self, "conductor_hosts")

    @_builtins.property
    @pulumi.getter(name="conductorToken")
    def conductor_token(self) -> Optional[_builtins.str]:
        """
        Token to be used by the SSR Devices to connect to the Conductor
        """
        return pulumi.get(self, "conductor_token")

    @_builtins.property
    @pulumi.getter(name="disableStats")
    def disable_stats(self) -> Optional[_builtins.bool]:
        """
        Disable stats collection on SSR devices
        """
        return pulumi.get(self, "disable_stats")


@pulumi.output_type
class SettingSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoUpgrade":
            suggest = "auto_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_upgrade: Optional['outputs.SettingSwitchAutoUpgrade'] = None):
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional['outputs.SettingSwitchAutoUpgrade']:
        return pulumi.get(self, "auto_upgrade")


@pulumi.output_type
class SettingSwitchAutoUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customVersions":
            suggest = "custom_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSwitchAutoUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSwitchAutoUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSwitchAutoUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_versions: Optional[Mapping[str, _builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 snapshot: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] custom_versions: Custom version to be used. The Property Key is the switch hardware and the property value is the firmware version
        :param _builtins.bool enabled: Enable auto upgrade for the switch
        :param _builtins.bool snapshot: Enable snapshot during the upgrade process
        """
        if custom_versions is not None:
            pulumi.set(__self__, "custom_versions", custom_versions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)

    @_builtins.property
    @pulumi.getter(name="customVersions")
    def custom_versions(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom version to be used. The Property Key is the switch hardware and the property value is the firmware version
        """
        return pulumi.get(self, "custom_versions")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable auto upgrade for the switch
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.bool]:
        """
        Enable snapshot during the upgrade process
        """
        return pulumi.get(self, "snapshot")


@pulumi.output_type
class SettingSwitchMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apAffinityThreshold":
            suggest = "ap_affinity_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSwitchMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSwitchMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSwitchMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int ap_affinity_threshold: If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)

    @_builtins.property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[_builtins.int]:
        """
        If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")


@pulumi.output_type
class SettingSyntheticTest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProbes":
            suggest = "custom_probes"
        elif key == "lanNetworks":
            suggest = "lan_networks"
        elif key == "wanSpeedtest":
            suggest = "wan_speedtest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSyntheticTest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSyntheticTest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSyntheticTest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggressiveness: Optional[_builtins.str] = None,
                 custom_probes: Optional[Mapping[str, 'outputs.SettingSyntheticTestCustomProbes']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 lan_networks: Optional[Sequence['outputs.SettingSyntheticTestLanNetwork']] = None,
                 vlans: Optional[Sequence['outputs.SettingSyntheticTestVlan']] = None,
                 wan_speedtest: Optional['outputs.SettingSyntheticTestWanSpeedtest'] = None):
        """
        :param _builtins.str aggressiveness: enum: `auto`, `high`, `low`
        :param Mapping[str, 'SettingSyntheticTestCustomProbesArgs'] custom_probes: Custom probes to be used for synthetic tests
        :param Sequence['SettingSyntheticTestLanNetworkArgs'] lan_networks: List of networks to be used for synthetic tests
        """
        if aggressiveness is not None:
            pulumi.set(__self__, "aggressiveness", aggressiveness)
        if custom_probes is not None:
            pulumi.set(__self__, "custom_probes", custom_probes)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if lan_networks is not None:
            pulumi.set(__self__, "lan_networks", lan_networks)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)
        if wan_speedtest is not None:
            pulumi.set(__self__, "wan_speedtest", wan_speedtest)

    @_builtins.property
    @pulumi.getter
    def aggressiveness(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `high`, `low`
        """
        return pulumi.get(self, "aggressiveness")

    @_builtins.property
    @pulumi.getter(name="customProbes")
    def custom_probes(self) -> Optional[Mapping[str, 'outputs.SettingSyntheticTestCustomProbes']]:
        """
        Custom probes to be used for synthetic tests
        """
        return pulumi.get(self, "custom_probes")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="lanNetworks")
    def lan_networks(self) -> Optional[Sequence['outputs.SettingSyntheticTestLanNetwork']]:
        """
        List of networks to be used for synthetic tests
        """
        return pulumi.get(self, "lan_networks")

    @_builtins.property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence['outputs.SettingSyntheticTestVlan']]:
        return pulumi.get(self, "vlans")

    @_builtins.property
    @pulumi.getter(name="wanSpeedtest")
    def wan_speedtest(self) -> Optional['outputs.SettingSyntheticTestWanSpeedtest']:
        return pulumi.get(self, "wan_speedtest")


@pulumi.output_type
class SettingSyntheticTestCustomProbes(dict):
    def __init__(__self__, *,
                 aggressiveness: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str aggressiveness: enum: `auto`, `high`, `low`
        :param _builtins.str host: If `type`==`icmp` or `type`==`tcp`, Host to be used for the custom probe
        :param _builtins.int port: If `type`==`tcp`, Port to be used for the custom probe
        :param _builtins.int threshold: In milliseconds
        :param _builtins.str type: enum: `curl`, `icmp`, `tcp`
        :param _builtins.str url: If `type`==`curl`, URL to be used for the custom probe, can be url or IP
        """
        if aggressiveness is not None:
            pulumi.set(__self__, "aggressiveness", aggressiveness)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def aggressiveness(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `high`, `low`
        """
        return pulumi.get(self, "aggressiveness")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        If `type`==`icmp` or `type`==`tcp`, Host to be used for the custom probe
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        If `type`==`tcp`, Port to be used for the custom probe
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        """
        In milliseconds
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `curl`, `icmp`, `tcp`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        If `type`==`curl`, URL to be used for the custom probe, can be url or IP
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SettingSyntheticTestLanNetwork(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 probes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] networks: List of networks to be used for synthetic tests
        :param Sequence[_builtins.str] probes: app name comes from `custom_probes` above or /const/synthetic_test_probes
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of networks to be used for synthetic tests
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def probes(self) -> Optional[Sequence[_builtins.str]]:
        """
        app name comes from `custom_probes` above or /const/synthetic_test_probes
        """
        return pulumi.get(self, "probes")


@pulumi.output_type
class SettingSyntheticTestVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTestUrls":
            suggest = "custom_test_urls"
        elif key == "vlanIds":
            suggest = "vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSyntheticTestVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSyntheticTestVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSyntheticTestVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_test_urls: Optional[Sequence[_builtins.str]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 probes: Optional[Sequence[_builtins.str]] = None,
                 vlan_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool disabled: For some vlans where we don't want this to run
        :param Sequence[_builtins.str] probes: app name comes from `custom_probes` above or /const/synthetic_test_probes
        """
        if custom_test_urls is not None:
            pulumi.set(__self__, "custom_test_urls", custom_test_urls)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @_builtins.property
    @pulumi.getter(name="customTestUrls")
    @_utilities.deprecated("""This attribute is deprecated.""")
    def custom_test_urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "custom_test_urls")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        For some vlans where we don't want this to run
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def probes(self) -> Optional[Sequence[_builtins.str]]:
        """
        app name comes from `custom_probes` above or /const/synthetic_test_probes
        """
        return pulumi.get(self, "probes")

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "vlan_ids")


@pulumi.output_type
class SettingSyntheticTestWanSpeedtest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeOfDay":
            suggest = "time_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSyntheticTestWanSpeedtest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSyntheticTestWanSpeedtest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSyntheticTestWanSpeedtest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 time_of_day: Optional[_builtins.str] = None):
        """
        :param _builtins.str time_of_day: `any` / HH:MM (24-hour format)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_of_day is not None:
            pulumi.set(__self__, "time_of_day", time_of_day)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> Optional[_builtins.str]:
        """
        `any` / HH:MM (24-hour format)
        """
        return pulumi.get(self, "time_of_day")


@pulumi.output_type
class SettingVpnOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asBase":
            suggest = "as_base"
        elif key == "stSubnet":
            suggest = "st_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingVpnOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingVpnOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingVpnOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_base: Optional[_builtins.int] = None,
                 st_subnet: Optional[_builtins.str] = None):
        """
        :param _builtins.str st_subnet: requiring /12 or bigger to support 16 private IPs for 65535 gateways
        """
        if as_base is not None:
            pulumi.set(__self__, "as_base", as_base)
        if st_subnet is not None:
            pulumi.set(__self__, "st_subnet", st_subnet)

    @_builtins.property
    @pulumi.getter(name="asBase")
    def as_base(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "as_base")

    @_builtins.property
    @pulumi.getter(name="stSubnet")
    def st_subnet(self) -> Optional[_builtins.str]:
        """
        requiring /12 or bigger to support 16 private IPs for 65535 gateways
        """
        return pulumi.get(self, "st_subnet")


@pulumi.output_type
class SettingWanPma(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingWiredPma(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingWirelessPma(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SsoRolePrivilege(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteId":
            suggest = "site_id"
        elif key == "sitegroupId":
            suggest = "sitegroup_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoRolePrivilege. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoRolePrivilege.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoRolePrivilege.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: _builtins.str,
                 scope: _builtins.str,
                 site_id: Optional[_builtins.str] = None,
                 sitegroup_id: Optional[_builtins.str] = None,
                 views: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str role: access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        :param _builtins.str scope: enum: `org`, `site`, `sitegroup`
        :param _builtins.str site_id: Required if `scope`==`site`
        :param _builtins.str sitegroup_id: Required if `scope`==`sitegroup`
        :param Sequence[_builtins.str] views: Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
               You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
               Below are the list of supported UI views. Note that this is UI only feature.  
               
                 | UI View | Required Role | Description |
                 | --- | --- | --- |
                 | `reporting` | `read` | full access to all analytics tools |
                 | `marketing` | `read` | can view analytics and location maps |
                 | `super_observer` | `read` | can view all the organization except the subscription page |
                 | `location` | `write` | can view and manage location maps, can view analytics |
                 | `security` | `write` | can view and manage site labels, policies and security |
                 | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
                 | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
                 | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "scope", scope)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if sitegroup_id is not None:
            pulumi.set(__self__, "sitegroup_id", sitegroup_id)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        enum: `org`, `site`, `sitegroup`
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[_builtins.str]:
        """
        Required if `scope`==`site`
        """
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter(name="sitegroupId")
    def sitegroup_id(self) -> Optional[_builtins.str]:
        """
        Required if `scope`==`sitegroup`
        """
        return pulumi.get(self, "sitegroup_id")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Optional[Sequence[_builtins.str]]:
        """
        Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
        You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
        Below are the list of supported UI views. Note that this is UI only feature.  

          | UI View | Required Role | Description |
          | --- | --- | --- |
          | `reporting` | `read` | full access to all analytics tools |
          | `marketing` | `read` | can view analytics and location maps |
          | `super_observer` | `read` | can view all the organization except the subscription page |
          | `location` | `write` | can view and manage location maps, can view analytics |
          | `security` | `write` | can view and manage site labels, policies and security |
          | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
          | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
          | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
        return pulumi.get(self, "views")


@pulumi.output_type
class VpnPathSelection(dict):
    def __init__(__self__, *,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.str strategy: enum: `disabled`, `simple`, `manual`
        """
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        enum: `disabled`, `simple`, `manual`
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class VpnPaths(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdProfile":
            suggest = "bfd_profile"
        elif key == "bfdUseTunnelMode":
            suggest = "bfd_use_tunnel_mode"
        elif key == "peerPaths":
            suggest = "peer_paths"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnPaths. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnPaths.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnPaths.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_profile: Optional[_builtins.str] = None,
                 bfd_use_tunnel_mode: Optional[_builtins.bool] = None,
                 ip: Optional[_builtins.str] = None,
                 peer_paths: Optional[Mapping[str, 'outputs.VpnPathsPeerPaths']] = None,
                 pod: Optional[_builtins.int] = None,
                 traffic_shaping: Optional['outputs.VpnPathsTrafficShaping'] = None):
        """
        :param _builtins.str bfd_profile: enum: `broadband`, `lte`
        :param _builtins.bool bfd_use_tunnel_mode: If `type`==`mesh` and for SSR only, whether to use tunnel mode
        :param _builtins.str ip: If different from the wan port
        :param Mapping[str, 'VpnPathsPeerPathsArgs'] peer_paths: If `type`==`mesh`, Property key is the Peer Interface name
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if peer_paths is not None:
            pulumi.set(__self__, "peer_paths", peer_paths)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @_builtins.property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[_builtins.str]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @_builtins.property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[_builtins.bool]:
        """
        If `type`==`mesh` and for SSR only, whether to use tunnel mode
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        If different from the wan port
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="peerPaths")
    def peer_paths(self) -> Optional[Mapping[str, 'outputs.VpnPathsPeerPaths']]:
        """
        If `type`==`mesh`, Property key is the Peer Interface name
        """
        return pulumi.get(self, "peer_paths")

    @_builtins.property
    @pulumi.getter
    def pod(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "pod")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.VpnPathsTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")


@pulumi.output_type
class VpnPathsPeerPaths(dict):
    def __init__(__self__, *,
                 preference: Optional[_builtins.int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class VpnPathsTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnPathsTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnPathsTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnPathsTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class WlanAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanAirwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "consoleUrl":
            suggest = "console_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAirwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAirwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAirwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None,
                 console_url: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key
        :param _builtins.str console_url: Console URL
        :param _builtins.str password: Password
        :param _builtins.str username: Username
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if console_url is not None:
            pulumi.set(__self__, "console_url", console_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="consoleUrl")
    def console_url(self) -> Optional[_builtins.str]:
        """
        Console URL
        """
        return pulumi.get(self, "console_url")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class WlanAppLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wxtagIds":
            suggest = "wxtag_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAppLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAppLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAppLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apps: Optional[Mapping[str, _builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 wxtag_ids: Optional[Mapping[str, _builtins.int]] = None):
        """
        :param Mapping[str, _builtins.int] apps: Map from app key to bandwidth in kbps. 
               Property key is the app key, defined in Get Application List
        :param Mapping[str, _builtins.int] wxtag_ids: Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Optional[Mapping[str, _builtins.int]]:
        """
        Map from app key to bandwidth in kbps. 
        Property key is the app key, defined in Get Application List
        """
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[Mapping[str, _builtins.int]]:
        """
        Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
        return pulumi.get(self, "wxtag_ids")


@pulumi.output_type
class WlanAppQos(dict):
    def __init__(__self__, *,
                 apps: Optional[Mapping[str, 'outputs.WlanAppQosApps']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 others: Optional[Sequence['outputs.WlanAppQosOther']] = None):
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if others is not None:
            pulumi.set(__self__, "others", others)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Optional[Mapping[str, 'outputs.WlanAppQosApps']]:
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def others(self) -> Optional[Sequence['outputs.WlanAppQosOther']]:
        return pulumi.get(self, "others")


@pulumi.output_type
class WlanAppQosApps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstSubnet":
            suggest = "dst_subnet"
        elif key == "srcSubnet":
            suggest = "src_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAppQosApps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAppQosApps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAppQosApps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dscp: Optional[_builtins.str] = None,
                 dst_subnet: Optional[_builtins.str] = None,
                 src_subnet: Optional[_builtins.str] = None):
        """
        :param _builtins.str dscp: DSCP value range between 0 and 63
        :param _builtins.str dst_subnet: Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        :param _builtins.str src_subnet: Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> Optional[_builtins.str]:
        """
        DSCP value range between 0 and 63
        """
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[_builtins.str]:
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "dst_subnet")

    @_builtins.property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[_builtins.str]:
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "src_subnet")


@pulumi.output_type
class WlanAppQosOther(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstSubnet":
            suggest = "dst_subnet"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "srcSubnet":
            suggest = "src_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAppQosOther. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAppQosOther.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAppQosOther.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dscp: Optional[_builtins.str] = None,
                 dst_subnet: Optional[_builtins.str] = None,
                 port_ranges: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 src_subnet: Optional[_builtins.str] = None):
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dst_subnet")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "src_subnet")


@pulumi.output_type
class WlanAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anticlogThreshold":
            suggest = "anticlog_threshold"
        elif key == "eapReauth":
            suggest = "eap_reauth"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "keyIdx":
            suggest = "key_idx"
        elif key == "multiPskOnly":
            suggest = "multi_psk_only"
        elif key == "privateWlan":
            suggest = "private_wlan"
        elif key == "wepAsSecondaryAuth":
            suggest = "wep_as_secondary_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anticlog_threshold: Optional[_builtins.int] = None,
                 eap_reauth: Optional[_builtins.bool] = None,
                 enable_mac_auth: Optional[_builtins.bool] = None,
                 key_idx: Optional[_builtins.int] = None,
                 keys: Optional[Sequence[_builtins.str]] = None,
                 multi_psk_only: Optional[_builtins.bool] = None,
                 owe: Optional[_builtins.str] = None,
                 pairwises: Optional[Sequence[_builtins.str]] = None,
                 private_wlan: Optional[_builtins.bool] = None,
                 psk: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 wep_as_secondary_auth: Optional[_builtins.bool] = None):
        """
        :param _builtins.int anticlog_threshold: SAE anti-clogging token threshold
        :param _builtins.bool eap_reauth: Whether to trigger EAP reauth when the session ends
        :param _builtins.bool enable_mac_auth: Whether to enable MAC Auth, uses the same auth_servers
        :param _builtins.int key_idx: When `type`==`wep`
        :param Sequence[_builtins.str] keys: When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        :param _builtins.bool multi_psk_only: When `type`==`psk`, whether to only use multi_psk
        :param _builtins.str owe: if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        :param Sequence[_builtins.str] pairwises: When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        :param _builtins.bool private_wlan: When `multi_psk_only`==`true`, whether private wlan is enabled
        :param _builtins.str psk: When `type`==`psk`, 8-64 characters, or 64 hex characters
        :param _builtins.str type: enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        :param _builtins.bool wep_as_secondary_auth: Enable WEP as secondary auth
        """
        if anticlog_threshold is not None:
            pulumi.set(__self__, "anticlog_threshold", anticlog_threshold)
        if eap_reauth is not None:
            pulumi.set(__self__, "eap_reauth", eap_reauth)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if key_idx is not None:
            pulumi.set(__self__, "key_idx", key_idx)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if multi_psk_only is not None:
            pulumi.set(__self__, "multi_psk_only", multi_psk_only)
        if owe is not None:
            pulumi.set(__self__, "owe", owe)
        if pairwises is not None:
            pulumi.set(__self__, "pairwises", pairwises)
        if private_wlan is not None:
            pulumi.set(__self__, "private_wlan", private_wlan)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wep_as_secondary_auth is not None:
            pulumi.set(__self__, "wep_as_secondary_auth", wep_as_secondary_auth)

    @_builtins.property
    @pulumi.getter(name="anticlogThreshold")
    def anticlog_threshold(self) -> Optional[_builtins.int]:
        """
        SAE anti-clogging token threshold
        """
        return pulumi.get(self, "anticlog_threshold")

    @_builtins.property
    @pulumi.getter(name="eapReauth")
    def eap_reauth(self) -> Optional[_builtins.bool]:
        """
        Whether to trigger EAP reauth when the session ends
        """
        return pulumi.get(self, "eap_reauth")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[_builtins.bool]:
        """
        Whether to enable MAC Auth, uses the same auth_servers
        """
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter(name="keyIdx")
    def key_idx(self) -> Optional[_builtins.int]:
        """
        When `type`==`wep`
        """
        return pulumi.get(self, "key_idx")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="multiPskOnly")
    def multi_psk_only(self) -> Optional[_builtins.bool]:
        """
        When `type`==`psk`, whether to only use multi_psk
        """
        return pulumi.get(self, "multi_psk_only")

    @_builtins.property
    @pulumi.getter
    def owe(self) -> Optional[_builtins.str]:
        """
        if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        """
        return pulumi.get(self, "owe")

    @_builtins.property
    @pulumi.getter
    def pairwises(self) -> Optional[Sequence[_builtins.str]]:
        """
        When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        """
        return pulumi.get(self, "pairwises")

    @_builtins.property
    @pulumi.getter(name="privateWlan")
    def private_wlan(self) -> Optional[_builtins.bool]:
        """
        When `multi_psk_only`==`true`, whether private wlan is enabled
        """
        return pulumi.get(self, "private_wlan")

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[_builtins.str]:
        """
        When `type`==`psk`, 8-64 characters, or 64 hex characters
        """
        return pulumi.get(self, "psk")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="wepAsSecondaryAuth")
    def wep_as_secondary_auth(self) -> Optional[_builtins.bool]:
        """
        Enable WEP as secondary auth
        """
        return pulumi.get(self, "wep_as_secondary_auth")


@pulumi.output_type
class WlanAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"
        elif key == "requireMessageAuthenticator":
            suggest = "require_message_authenticator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 require_message_authenticator: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.bool require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[_builtins.bool]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")


@pulumi.output_type
class WlanBonjour(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVlanIds":
            suggest = "additional_vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanBonjour. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanBonjour.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanBonjour.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_vlan_ids: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 services: Optional[Mapping[str, 'outputs.WlanBonjourServices']] = None):
        """
        :param Sequence[_builtins.str] additional_vlan_ids: additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        :param _builtins.bool enabled: Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        :param Mapping[str, 'WlanBonjourServicesArgs'] services: What services are allowed. 
               Property key is the service name
        """
        if additional_vlan_ids is not None:
            pulumi.set(__self__, "additional_vlan_ids", additional_vlan_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter(name="additionalVlanIds")
    def additional_vlan_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        """
        return pulumi.get(self, "additional_vlan_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.WlanBonjourServices']]:
        """
        What services are allowed. 
        Property key is the service name
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class WlanBonjourServices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableLocal":
            suggest = "disable_local"
        elif key == "radiusGroups":
            suggest = "radius_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanBonjourServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanBonjourServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanBonjourServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_local: Optional[_builtins.bool] = None,
                 radius_groups: Optional[Sequence[_builtins.str]] = None,
                 scope: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_local: Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        :param Sequence[_builtins.str] radius_groups: Optional, if the service is further restricted for certain RADIUS groups
        :param _builtins.str scope: how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        if disable_local is not None:
            pulumi.set(__self__, "disable_local", disable_local)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="disableLocal")
    def disable_local(self) -> Optional[_builtins.bool]:
        """
        Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        """
        return pulumi.get(self, "disable_local")

    @_builtins.property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, if the service is further restricted for certain RADIUS groups
        """
        return pulumi.get(self, "radius_groups")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class WlanCiscoCwa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHostnames":
            suggest = "allowed_hostnames"
        elif key == "allowedSubnets":
            suggest = "allowed_subnets"
        elif key == "blockedSubnets":
            suggest = "blocked_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanCiscoCwa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanCiscoCwa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanCiscoCwa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_hostnames: Optional[Sequence[_builtins.str]] = None,
                 allowed_subnets: Optional[Sequence[_builtins.str]] = None,
                 blocked_subnets: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param Sequence[_builtins.str] allowed_subnets: List of CIDRs
        :param Sequence[_builtins.str] blocked_subnets: List of blocked CIDRs
        """
        if allowed_hostnames is not None:
            pulumi.set(__self__, "allowed_hostnames", allowed_hostnames)
        if allowed_subnets is not None:
            pulumi.set(__self__, "allowed_subnets", allowed_subnets)
        if blocked_subnets is not None:
            pulumi.set(__self__, "blocked_subnets", blocked_subnets)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowedHostnames")
    def allowed_hostnames(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "allowed_hostnames")

    @_builtins.property
    @pulumi.getter(name="allowedSubnets")
    def allowed_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "allowed_subnets")

    @_builtins.property
    @pulumi.getter(name="blockedSubnets")
    def blocked_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of blocked CIDRs
        """
        return pulumi.get(self, "blocked_subnets")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanCoaServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableEventTimestampCheck":
            suggest = "disable_event_timestamp_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanCoaServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanCoaServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanCoaServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: _builtins.str,
                 secret: _builtins.str,
                 disable_event_timestamp_check: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_event_timestamp_check: Whether to disable Event-Timestamp Check
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "secret", secret)
        if disable_event_timestamp_check is not None:
            pulumi.set(__self__, "disable_event_timestamp_check", disable_event_timestamp_check)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="disableEventTimestampCheck")
    def disable_event_timestamp_check(self) -> Optional[_builtins.bool]:
        """
        Whether to disable Event-Timestamp Check
        """
        return pulumi.get(self, "disable_event_timestamp_check")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanDnsServerRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "radiusGroups":
            suggest = "radius_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanDnsServerRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanDnsServerRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanDnsServerRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 radius_groups: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] radius_groups: Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
        return pulumi.get(self, "radius_groups")


@pulumi.output_type
class WlanDynamicPsk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPsk":
            suggest = "default_psk"
        elif key == "defaultVlanId":
            suggest = "default_vlan_id"
        elif key == "forceLookup":
            suggest = "force_lookup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanDynamicPsk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanDynamicPsk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanDynamicPsk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_psk: Optional[_builtins.str] = None,
                 default_vlan_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 force_lookup: Optional[_builtins.bool] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_psk: Default PSK to use if cloud WLC is not available, 8-63 characters
        :param _builtins.bool force_lookup: When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        :param _builtins.str source: enum: `cloud_psks`, `radius`
        """
        if default_psk is not None:
            pulumi.set(__self__, "default_psk", default_psk)
        if default_vlan_id is not None:
            pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force_lookup is not None:
            pulumi.set(__self__, "force_lookup", force_lookup)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="defaultPsk")
    def default_psk(self) -> Optional[_builtins.str]:
        """
        Default PSK to use if cloud WLC is not available, 8-63 characters
        """
        return pulumi.get(self, "default_psk")

    @_builtins.property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_vlan_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="forceLookup")
    def force_lookup(self) -> Optional[_builtins.bool]:
        """
        When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        """
        return pulumi.get(self, "force_lookup")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        enum: `cloud_psks`, `radius`
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class WlanDynamicVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultVlanIds":
            suggest = "default_vlan_ids"
        elif key == "localVlanIds":
            suggest = "local_vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanDynamicVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanDynamicVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanDynamicVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_vlan_ids: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 local_vlan_ids: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 vlans: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence[_builtins.str] default_vlan_ids: Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        :param _builtins.bool enabled: Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        :param Sequence[_builtins.str] local_vlan_ids: VLAN_ids to be locally bridged
        :param _builtins.str type: standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        :param Mapping[str, _builtins.str] vlans: Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
                 * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
                 * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        if default_vlan_ids is not None:
            pulumi.set(__self__, "default_vlan_ids", default_vlan_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if local_vlan_ids is not None:
            pulumi.set(__self__, "local_vlan_ids", local_vlan_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @_builtins.property
    @pulumi.getter(name="defaultVlanIds")
    def default_vlan_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        """
        return pulumi.get(self, "default_vlan_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="localVlanIds")
    def local_vlan_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        VLAN_ids to be locally bridged
        """
        return pulumi.get(self, "local_vlan_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlans(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
          * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
          * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class WlanHotspot20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNames":
            suggest = "domain_names"
        elif key == "naiRealms":
            suggest = "nai_realms"
        elif key == "venueName":
            suggest = "venue_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanHotspot20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanHotspot20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanHotspot20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_names: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 nai_realms: Optional[Sequence[_builtins.str]] = None,
                 operators: Optional[Sequence[_builtins.str]] = None,
                 rcois: Optional[Sequence[_builtins.str]] = None,
                 venue_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Whether to enable hotspot 2.0 config
        :param Sequence[_builtins.str] operators: List of operators to support
        :param _builtins.str venue_name: Venue name, default is site name
        """
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if nai_realms is not None:
            pulumi.set(__self__, "nai_realms", nai_realms)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)
        if rcois is not None:
            pulumi.set(__self__, "rcois", rcois)
        if venue_name is not None:
            pulumi.set(__self__, "venue_name", venue_name)

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable hotspot 2.0 config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="naiRealms")
    def nai_realms(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "nai_realms")

    @_builtins.property
    @pulumi.getter
    def operators(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of operators to support
        """
        return pulumi.get(self, "operators")

    @_builtins.property
    @pulumi.getter
    def rcois(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "rcois")

    @_builtins.property
    @pulumi.getter(name="venueName")
    def venue_name(self) -> Optional[_builtins.str]:
        """
        Venue name, default is site name
        """
        return pulumi.get(self, "venue_name")


@pulumi.output_type
class WlanInjectDhcpOption82(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "circuitId":
            suggest = "circuit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanInjectDhcpOption82. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanInjectDhcpOption82.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanInjectDhcpOption82.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 circuit_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str circuit_id: Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
                 * {{AP_MAC}}
                 * {{AP_MAC_DASHED}}
                 * {{AP_MODEL}}
                 * {{AP_NAME}}
                 * {{SITE_NAME}}
                 * {{SSID}}
        :param _builtins.bool enabled: Whether to inject option 82 when forwarding DHCP packets
        """
        if circuit_id is not None:
            pulumi.set(__self__, "circuit_id", circuit_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="circuitId")
    def circuit_id(self) -> Optional[_builtins.str]:
        """
        Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
          * {{AP_MAC}}
          * {{AP_MAC_DASHED}}
          * {{AP_MODEL}}
          * {{AP_NAME}}
          * {{SITE_NAME}}
          * {{SSID}}
        """
        return pulumi.get(self, "circuit_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to inject option 82 when forwarding DHCP packets
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanMistNac(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "fastDot1xTimers":
            suggest = "fast_dot1x_timers"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanMistNac. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanMistNac.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanMistNac.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fast_dot1x_timers: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled.
        :param _builtins.int auth_servers_retries: Radius auth session retries. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "retries" are set to value of `auth_servers_timeout`. "max-requests" is also set when setting `auth_servers_retries` is set to default value to 3.
        :param _builtins.int auth_servers_timeout: Radius auth session timeout. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "quite-period" and "transmit-period" are set to half the value of `auth_servers_timeout`. "supplicant-timeout" is also set when setting `auth_servers_timeout` is set to default value of 10.
        :param _builtins.bool coa_enabled: Allows a RADIUS server to dynamically modify the authorization status of a user session.
        :param _builtins.int coa_port: the communication port used for “Change of Authorization” (CoA) messages
        :param _builtins.bool enabled: When enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed
        :param _builtins.bool fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from `auth_servers_timeout` and `auth_server_retries`.
        :param _builtins.str network: Which network the mist nac server resides in
        :param _builtins.str source_ip: In case there is a static IP for this network, we can specify it using source ip
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled.
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        Radius auth session retries. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "retries" are set to value of `auth_servers_timeout`. "max-requests" is also set when setting `auth_servers_retries` is set to default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        Radius auth session timeout. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "quite-period" and "transmit-period" are set to half the value of `auth_servers_timeout`. "supplicant-timeout" is also set when setting `auth_servers_timeout` is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        """
        Allows a RADIUS server to dynamically modify the authorization status of a user session.
        """
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.int]:
        """
        the communication port used for “Change of Authorization” (CoA) messages
        """
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[_builtins.bool]:
        """
        If set to true, sets default fast-timers with values calculated from `auth_servers_timeout` and `auth_server_retries`.
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Which network the mist nac server resides in
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        In case there is a static IP for this network, we can specify it using source ip
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class WlanPortal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowWlanIdRoam":
            suggest = "allow_wlan_id_roam"
        elif key == "amazonClientId":
            suggest = "amazon_client_id"
        elif key == "amazonClientSecret":
            suggest = "amazon_client_secret"
        elif key == "amazonEmailDomains":
            suggest = "amazon_email_domains"
        elif key == "amazonEnabled":
            suggest = "amazon_enabled"
        elif key == "amazonExpire":
            suggest = "amazon_expire"
        elif key == "azureClientId":
            suggest = "azure_client_id"
        elif key == "azureClientSecret":
            suggest = "azure_client_secret"
        elif key == "azureEnabled":
            suggest = "azure_enabled"
        elif key == "azureExpire":
            suggest = "azure_expire"
        elif key == "azureTenantId":
            suggest = "azure_tenant_id"
        elif key == "broadnetPassword":
            suggest = "broadnet_password"
        elif key == "broadnetSid":
            suggest = "broadnet_sid"
        elif key == "broadnetUserId":
            suggest = "broadnet_user_id"
        elif key == "bypassWhenCloudDown":
            suggest = "bypass_when_cloud_down"
        elif key == "clickatellApiKey":
            suggest = "clickatell_api_key"
        elif key == "crossSite":
            suggest = "cross_site"
        elif key == "emailEnabled":
            suggest = "email_enabled"
        elif key == "externalPortalUrl":
            suggest = "external_portal_url"
        elif key == "facebookClientId":
            suggest = "facebook_client_id"
        elif key == "facebookClientSecret":
            suggest = "facebook_client_secret"
        elif key == "facebookEmailDomains":
            suggest = "facebook_email_domains"
        elif key == "facebookEnabled":
            suggest = "facebook_enabled"
        elif key == "facebookExpire":
            suggest = "facebook_expire"
        elif key == "forwardUrl":
            suggest = "forward_url"
        elif key == "googleClientId":
            suggest = "google_client_id"
        elif key == "googleClientSecret":
            suggest = "google_client_secret"
        elif key == "googleEmailDomains":
            suggest = "google_email_domains"
        elif key == "googleEnabled":
            suggest = "google_enabled"
        elif key == "googleExpire":
            suggest = "google_expire"
        elif key == "gupshupPassword":
            suggest = "gupshup_password"
        elif key == "gupshupUserid":
            suggest = "gupshup_userid"
        elif key == "microsoftClientId":
            suggest = "microsoft_client_id"
        elif key == "microsoftClientSecret":
            suggest = "microsoft_client_secret"
        elif key == "microsoftEmailDomains":
            suggest = "microsoft_email_domains"
        elif key == "microsoftEnabled":
            suggest = "microsoft_enabled"
        elif key == "microsoftExpire":
            suggest = "microsoft_expire"
        elif key == "passphraseEnabled":
            suggest = "passphrase_enabled"
        elif key == "passphraseExpire":
            suggest = "passphrase_expire"
        elif key == "predefinedSponsorsEnabled":
            suggest = "predefined_sponsors_enabled"
        elif key == "predefinedSponsorsHideEmail":
            suggest = "predefined_sponsors_hide_email"
        elif key == "puzzelPassword":
            suggest = "puzzel_password"
        elif key == "puzzelServiceId":
            suggest = "puzzel_service_id"
        elif key == "puzzelUsername":
            suggest = "puzzel_username"
        elif key == "smsEnabled":
            suggest = "sms_enabled"
        elif key == "smsExpire":
            suggest = "sms_expire"
        elif key == "smsMessageFormat":
            suggest = "sms_message_format"
        elif key == "smsProvider":
            suggest = "sms_provider"
        elif key == "smsglobalApiKey":
            suggest = "smsglobal_api_key"
        elif key == "smsglobalApiSecret":
            suggest = "smsglobal_api_secret"
        elif key == "sponsorAutoApprove":
            suggest = "sponsor_auto_approve"
        elif key == "sponsorEmailDomains":
            suggest = "sponsor_email_domains"
        elif key == "sponsorEnabled":
            suggest = "sponsor_enabled"
        elif key == "sponsorExpire":
            suggest = "sponsor_expire"
        elif key == "sponsorLinkValidityDuration":
            suggest = "sponsor_link_validity_duration"
        elif key == "sponsorNotifyAll":
            suggest = "sponsor_notify_all"
        elif key == "sponsorStatusNotify":
            suggest = "sponsor_status_notify"
        elif key == "ssoDefaultRole":
            suggest = "sso_default_role"
        elif key == "ssoForcedRole":
            suggest = "sso_forced_role"
        elif key == "ssoIdpCert":
            suggest = "sso_idp_cert"
        elif key == "ssoIdpSignAlgo":
            suggest = "sso_idp_sign_algo"
        elif key == "ssoIdpSsoUrl":
            suggest = "sso_idp_sso_url"
        elif key == "ssoIssuer":
            suggest = "sso_issuer"
        elif key == "ssoNameidFormat":
            suggest = "sso_nameid_format"
        elif key == "telstraClientId":
            suggest = "telstra_client_id"
        elif key == "telstraClientSecret":
            suggest = "telstra_client_secret"
        elif key == "twilioAuthToken":
            suggest = "twilio_auth_token"
        elif key == "twilioPhoneNumber":
            suggest = "twilio_phone_number"
        elif key == "twilioSid":
            suggest = "twilio_sid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanPortal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanPortal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanPortal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_wlan_id_roam: Optional[_builtins.bool] = None,
                 amazon_client_id: Optional[_builtins.str] = None,
                 amazon_client_secret: Optional[_builtins.str] = None,
                 amazon_email_domains: Optional[Sequence[_builtins.str]] = None,
                 amazon_enabled: Optional[_builtins.bool] = None,
                 amazon_expire: Optional[_builtins.int] = None,
                 auth: Optional[_builtins.str] = None,
                 azure_client_id: Optional[_builtins.str] = None,
                 azure_client_secret: Optional[_builtins.str] = None,
                 azure_enabled: Optional[_builtins.bool] = None,
                 azure_expire: Optional[_builtins.int] = None,
                 azure_tenant_id: Optional[_builtins.str] = None,
                 broadnet_password: Optional[_builtins.str] = None,
                 broadnet_sid: Optional[_builtins.str] = None,
                 broadnet_user_id: Optional[_builtins.str] = None,
                 bypass_when_cloud_down: Optional[_builtins.bool] = None,
                 clickatell_api_key: Optional[_builtins.str] = None,
                 cross_site: Optional[_builtins.bool] = None,
                 email_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 expire: Optional[_builtins.int] = None,
                 external_portal_url: Optional[_builtins.str] = None,
                 facebook_client_id: Optional[_builtins.str] = None,
                 facebook_client_secret: Optional[_builtins.str] = None,
                 facebook_email_domains: Optional[Sequence[_builtins.str]] = None,
                 facebook_enabled: Optional[_builtins.bool] = None,
                 facebook_expire: Optional[_builtins.int] = None,
                 forward: Optional[_builtins.bool] = None,
                 forward_url: Optional[_builtins.str] = None,
                 google_client_id: Optional[_builtins.str] = None,
                 google_client_secret: Optional[_builtins.str] = None,
                 google_email_domains: Optional[Sequence[_builtins.str]] = None,
                 google_enabled: Optional[_builtins.bool] = None,
                 google_expire: Optional[_builtins.int] = None,
                 gupshup_password: Optional[_builtins.str] = None,
                 gupshup_userid: Optional[_builtins.str] = None,
                 microsoft_client_id: Optional[_builtins.str] = None,
                 microsoft_client_secret: Optional[_builtins.str] = None,
                 microsoft_email_domains: Optional[Sequence[_builtins.str]] = None,
                 microsoft_enabled: Optional[_builtins.bool] = None,
                 microsoft_expire: Optional[_builtins.int] = None,
                 passphrase_enabled: Optional[_builtins.bool] = None,
                 passphrase_expire: Optional[_builtins.int] = None,
                 password: Optional[_builtins.str] = None,
                 predefined_sponsors_enabled: Optional[_builtins.bool] = None,
                 predefined_sponsors_hide_email: Optional[_builtins.bool] = None,
                 privacy: Optional[_builtins.bool] = None,
                 puzzel_password: Optional[_builtins.str] = None,
                 puzzel_service_id: Optional[_builtins.str] = None,
                 puzzel_username: Optional[_builtins.str] = None,
                 sms_enabled: Optional[_builtins.bool] = None,
                 sms_expire: Optional[_builtins.int] = None,
                 sms_message_format: Optional[_builtins.str] = None,
                 sms_provider: Optional[_builtins.str] = None,
                 smsglobal_api_key: Optional[_builtins.str] = None,
                 smsglobal_api_secret: Optional[_builtins.str] = None,
                 sponsor_auto_approve: Optional[_builtins.bool] = None,
                 sponsor_email_domains: Optional[Sequence[_builtins.str]] = None,
                 sponsor_enabled: Optional[_builtins.bool] = None,
                 sponsor_expire: Optional[_builtins.int] = None,
                 sponsor_link_validity_duration: Optional[_builtins.str] = None,
                 sponsor_notify_all: Optional[_builtins.bool] = None,
                 sponsor_status_notify: Optional[_builtins.bool] = None,
                 sponsors: Optional[Mapping[str, _builtins.str]] = None,
                 sso_default_role: Optional[_builtins.str] = None,
                 sso_forced_role: Optional[_builtins.str] = None,
                 sso_idp_cert: Optional[_builtins.str] = None,
                 sso_idp_sign_algo: Optional[_builtins.str] = None,
                 sso_idp_sso_url: Optional[_builtins.str] = None,
                 sso_issuer: Optional[_builtins.str] = None,
                 sso_nameid_format: Optional[_builtins.str] = None,
                 telstra_client_id: Optional[_builtins.str] = None,
                 telstra_client_secret: Optional[_builtins.str] = None,
                 twilio_auth_token: Optional[_builtins.str] = None,
                 twilio_phone_number: Optional[_builtins.str] = None,
                 twilio_sid: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_wlan_id_roam: Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        :param _builtins.str amazon_client_id: Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param _builtins.str amazon_client_secret: Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] amazon_email_domains: Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool amazon_enabled: Whether amazon is enabled as a login method
        :param _builtins.int amazon_expire: Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        :param _builtins.str auth: authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        :param _builtins.str azure_client_id: Required if `azure_enabled`==`true`. Azure active directory app client id
        :param _builtins.str azure_client_secret: Required if `azure_enabled`==`true`. Azure active directory app client secret
        :param _builtins.bool azure_enabled: Whether Azure Active Directory is enabled as a login method
        :param _builtins.int azure_expire: Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        :param _builtins.str azure_tenant_id: Required if `azure_enabled`==`true`. Azure active directory tenant id.
        :param _builtins.str broadnet_password: Required if `sms_provider`==`broadnet`
        :param _builtins.str broadnet_sid: Required if `sms_provider`==`broadnet`
        :param _builtins.str broadnet_user_id: Required if `sms_provider`==`broadnet`
        :param _builtins.bool bypass_when_cloud_down: Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        :param _builtins.str clickatell_api_key: Required if `sms_provider`==`clickatell`
        :param _builtins.bool cross_site: Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        :param _builtins.bool email_enabled: Whether email (access code verification) is enabled as a login method
        :param _builtins.bool enabled: Whether guest portal is enabled
        :param _builtins.int expire: How long to remain authorized, in minutes
        :param _builtins.str external_portal_url: Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        :param _builtins.str facebook_client_id: Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param _builtins.str facebook_client_secret: Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] facebook_email_domains: Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool facebook_enabled: Whether facebook is enabled as a login method
        :param _builtins.int facebook_expire: Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        :param _builtins.bool forward: Whether to forward the user to another URL after authorized
        :param _builtins.str forward_url: URL to forward the user to
        :param _builtins.str google_client_id: Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param _builtins.str google_client_secret: Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] google_email_domains: Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool google_enabled: Whether Google is enabled as login method
        :param _builtins.int google_expire: Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        :param _builtins.str gupshup_password: Required if `sms_provider`==`gupshup`
        :param _builtins.str gupshup_userid: Required if `sms_provider`==`gupshup`
        :param _builtins.str microsoft_client_id: Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param _builtins.str microsoft_client_secret: Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] microsoft_email_domains: Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool microsoft_enabled: Whether microsoft 365 is enabled as a login method
        :param _builtins.int microsoft_expire: Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        :param _builtins.bool passphrase_enabled: Whether password is enabled
        :param _builtins.int passphrase_expire: Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        :param _builtins.str password: Required if `passphrase_enabled`==`true`.
        :param _builtins.bool predefined_sponsors_enabled: Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behavior is acc to `sponsor_email_domains`
        :param _builtins.bool predefined_sponsors_hide_email: Whether to hide sponsor’s email from list of sponsors
        :param _builtins.str puzzel_password: Required if `sms_provider`==`puzzel`
        :param _builtins.str puzzel_service_id: Required if `sms_provider`==`puzzel`
        :param _builtins.str puzzel_username: Required if `sms_provider`==`puzzel`
        :param _builtins.bool sms_enabled: Whether sms is enabled as a login method
        :param _builtins.int sms_expire: Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        :param _builtins.str sms_message_format: Optional if `sms_enabled`==`true`. SMS Message format
        :param _builtins.str sms_provider: Optional if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `smsglobal`, `telstra`, `twilio`
        :param _builtins.str smsglobal_api_key: Required if `sms_provider`==`smsglobal`, Client API Key
        :param _builtins.str smsglobal_api_secret: Required if `sms_provider`==`smsglobal`, Client secret
        :param _builtins.bool sponsor_auto_approve: Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        :param Sequence[_builtins.str] sponsor_email_domains: List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        :param _builtins.bool sponsor_enabled: Whether sponsor is enabled
        :param _builtins.int sponsor_expire: Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        :param _builtins.str sponsor_link_validity_duration: Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes. Default is 60 minutes.
        :param _builtins.bool sponsor_notify_all: Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        :param _builtins.bool sponsor_status_notify: Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        :param Mapping[str, _builtins.str] sponsors: object of allowed sponsors email with name. Required if `sponsor_enabled`
                           is `true` and `sponsor_email_domains` is empty.
               
                           Property key is the sponsor email, Property value is the sponsor name
        :param _builtins.str sso_default_role: Optional if `wlan_portal_auth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        :param _builtins.str sso_forced_role: Optional if `wlan_portal_auth`==`sso`
        :param _builtins.str sso_idp_cert: Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        :param _builtins.str sso_idp_sign_algo: Optional if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        :param _builtins.str sso_idp_sso_url: Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        :param _builtins.str sso_issuer: Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        :param _builtins.str sso_nameid_format: Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        :param _builtins.str telstra_client_id: Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        :param _builtins.str telstra_client_secret: Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        :param _builtins.str twilio_auth_token: Required if `sms_provider`==`twilio`, Auth token account with twilio account
        :param _builtins.str twilio_phone_number: Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        :param _builtins.str twilio_sid: Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        if allow_wlan_id_roam is not None:
            pulumi.set(__self__, "allow_wlan_id_roam", allow_wlan_id_roam)
        if amazon_client_id is not None:
            pulumi.set(__self__, "amazon_client_id", amazon_client_id)
        if amazon_client_secret is not None:
            pulumi.set(__self__, "amazon_client_secret", amazon_client_secret)
        if amazon_email_domains is not None:
            pulumi.set(__self__, "amazon_email_domains", amazon_email_domains)
        if amazon_enabled is not None:
            pulumi.set(__self__, "amazon_enabled", amazon_enabled)
        if amazon_expire is not None:
            pulumi.set(__self__, "amazon_expire", amazon_expire)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if azure_client_id is not None:
            pulumi.set(__self__, "azure_client_id", azure_client_id)
        if azure_client_secret is not None:
            pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        if azure_enabled is not None:
            pulumi.set(__self__, "azure_enabled", azure_enabled)
        if azure_expire is not None:
            pulumi.set(__self__, "azure_expire", azure_expire)
        if azure_tenant_id is not None:
            pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        if broadnet_password is not None:
            pulumi.set(__self__, "broadnet_password", broadnet_password)
        if broadnet_sid is not None:
            pulumi.set(__self__, "broadnet_sid", broadnet_sid)
        if broadnet_user_id is not None:
            pulumi.set(__self__, "broadnet_user_id", broadnet_user_id)
        if bypass_when_cloud_down is not None:
            pulumi.set(__self__, "bypass_when_cloud_down", bypass_when_cloud_down)
        if clickatell_api_key is not None:
            pulumi.set(__self__, "clickatell_api_key", clickatell_api_key)
        if cross_site is not None:
            pulumi.set(__self__, "cross_site", cross_site)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if external_portal_url is not None:
            pulumi.set(__self__, "external_portal_url", external_portal_url)
        if facebook_client_id is not None:
            pulumi.set(__self__, "facebook_client_id", facebook_client_id)
        if facebook_client_secret is not None:
            pulumi.set(__self__, "facebook_client_secret", facebook_client_secret)
        if facebook_email_domains is not None:
            pulumi.set(__self__, "facebook_email_domains", facebook_email_domains)
        if facebook_enabled is not None:
            pulumi.set(__self__, "facebook_enabled", facebook_enabled)
        if facebook_expire is not None:
            pulumi.set(__self__, "facebook_expire", facebook_expire)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if forward_url is not None:
            pulumi.set(__self__, "forward_url", forward_url)
        if google_client_id is not None:
            pulumi.set(__self__, "google_client_id", google_client_id)
        if google_client_secret is not None:
            pulumi.set(__self__, "google_client_secret", google_client_secret)
        if google_email_domains is not None:
            pulumi.set(__self__, "google_email_domains", google_email_domains)
        if google_enabled is not None:
            pulumi.set(__self__, "google_enabled", google_enabled)
        if google_expire is not None:
            pulumi.set(__self__, "google_expire", google_expire)
        if gupshup_password is not None:
            pulumi.set(__self__, "gupshup_password", gupshup_password)
        if gupshup_userid is not None:
            pulumi.set(__self__, "gupshup_userid", gupshup_userid)
        if microsoft_client_id is not None:
            pulumi.set(__self__, "microsoft_client_id", microsoft_client_id)
        if microsoft_client_secret is not None:
            pulumi.set(__self__, "microsoft_client_secret", microsoft_client_secret)
        if microsoft_email_domains is not None:
            pulumi.set(__self__, "microsoft_email_domains", microsoft_email_domains)
        if microsoft_enabled is not None:
            pulumi.set(__self__, "microsoft_enabled", microsoft_enabled)
        if microsoft_expire is not None:
            pulumi.set(__self__, "microsoft_expire", microsoft_expire)
        if passphrase_enabled is not None:
            pulumi.set(__self__, "passphrase_enabled", passphrase_enabled)
        if passphrase_expire is not None:
            pulumi.set(__self__, "passphrase_expire", passphrase_expire)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if predefined_sponsors_enabled is not None:
            pulumi.set(__self__, "predefined_sponsors_enabled", predefined_sponsors_enabled)
        if predefined_sponsors_hide_email is not None:
            pulumi.set(__self__, "predefined_sponsors_hide_email", predefined_sponsors_hide_email)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if puzzel_password is not None:
            pulumi.set(__self__, "puzzel_password", puzzel_password)
        if puzzel_service_id is not None:
            pulumi.set(__self__, "puzzel_service_id", puzzel_service_id)
        if puzzel_username is not None:
            pulumi.set(__self__, "puzzel_username", puzzel_username)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if sms_expire is not None:
            pulumi.set(__self__, "sms_expire", sms_expire)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_provider is not None:
            pulumi.set(__self__, "sms_provider", sms_provider)
        if smsglobal_api_key is not None:
            pulumi.set(__self__, "smsglobal_api_key", smsglobal_api_key)
        if smsglobal_api_secret is not None:
            pulumi.set(__self__, "smsglobal_api_secret", smsglobal_api_secret)
        if sponsor_auto_approve is not None:
            pulumi.set(__self__, "sponsor_auto_approve", sponsor_auto_approve)
        if sponsor_email_domains is not None:
            pulumi.set(__self__, "sponsor_email_domains", sponsor_email_domains)
        if sponsor_enabled is not None:
            pulumi.set(__self__, "sponsor_enabled", sponsor_enabled)
        if sponsor_expire is not None:
            pulumi.set(__self__, "sponsor_expire", sponsor_expire)
        if sponsor_link_validity_duration is not None:
            pulumi.set(__self__, "sponsor_link_validity_duration", sponsor_link_validity_duration)
        if sponsor_notify_all is not None:
            pulumi.set(__self__, "sponsor_notify_all", sponsor_notify_all)
        if sponsor_status_notify is not None:
            pulumi.set(__self__, "sponsor_status_notify", sponsor_status_notify)
        if sponsors is not None:
            pulumi.set(__self__, "sponsors", sponsors)
        if sso_default_role is not None:
            pulumi.set(__self__, "sso_default_role", sso_default_role)
        if sso_forced_role is not None:
            pulumi.set(__self__, "sso_forced_role", sso_forced_role)
        if sso_idp_cert is not None:
            pulumi.set(__self__, "sso_idp_cert", sso_idp_cert)
        if sso_idp_sign_algo is not None:
            pulumi.set(__self__, "sso_idp_sign_algo", sso_idp_sign_algo)
        if sso_idp_sso_url is not None:
            pulumi.set(__self__, "sso_idp_sso_url", sso_idp_sso_url)
        if sso_issuer is not None:
            pulumi.set(__self__, "sso_issuer", sso_issuer)
        if sso_nameid_format is not None:
            pulumi.set(__self__, "sso_nameid_format", sso_nameid_format)
        if telstra_client_id is not None:
            pulumi.set(__self__, "telstra_client_id", telstra_client_id)
        if telstra_client_secret is not None:
            pulumi.set(__self__, "telstra_client_secret", telstra_client_secret)
        if twilio_auth_token is not None:
            pulumi.set(__self__, "twilio_auth_token", twilio_auth_token)
        if twilio_phone_number is not None:
            pulumi.set(__self__, "twilio_phone_number", twilio_phone_number)
        if twilio_sid is not None:
            pulumi.set(__self__, "twilio_sid", twilio_sid)

    @_builtins.property
    @pulumi.getter(name="allowWlanIdRoam")
    def allow_wlan_id_roam(self) -> Optional[_builtins.bool]:
        """
        Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "allow_wlan_id_roam")

    @_builtins.property
    @pulumi.getter(name="amazonClientId")
    def amazon_client_id(self) -> Optional[_builtins.str]:
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "amazon_client_id")

    @_builtins.property
    @pulumi.getter(name="amazonClientSecret")
    def amazon_client_secret(self) -> Optional[_builtins.str]:
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "amazon_client_secret")

    @_builtins.property
    @pulumi.getter(name="amazonEmailDomains")
    def amazon_email_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "amazon_email_domains")

    @_builtins.property
    @pulumi.getter(name="amazonEnabled")
    def amazon_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether amazon is enabled as a login method
        """
        return pulumi.get(self, "amazon_enabled")

    @_builtins.property
    @pulumi.getter(name="amazonExpire")
    def amazon_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "amazon_expire")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[_builtins.str]:
        """
        authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> Optional[_builtins.str]:
        """
        Required if `azure_enabled`==`true`. Azure active directory app client id
        """
        return pulumi.get(self, "azure_client_id")

    @_builtins.property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> Optional[_builtins.str]:
        """
        Required if `azure_enabled`==`true`. Azure active directory app client secret
        """
        return pulumi.get(self, "azure_client_secret")

    @_builtins.property
    @pulumi.getter(name="azureEnabled")
    def azure_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether Azure Active Directory is enabled as a login method
        """
        return pulumi.get(self, "azure_enabled")

    @_builtins.property
    @pulumi.getter(name="azureExpire")
    def azure_expire(self) -> Optional[_builtins.int]:
        """
        Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "azure_expire")

    @_builtins.property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> Optional[_builtins.str]:
        """
        Required if `azure_enabled`==`true`. Azure active directory tenant id.
        """
        return pulumi.get(self, "azure_tenant_id")

    @_builtins.property
    @pulumi.getter(name="broadnetPassword")
    def broadnet_password(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_password")

    @_builtins.property
    @pulumi.getter(name="broadnetSid")
    def broadnet_sid(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_sid")

    @_builtins.property
    @pulumi.getter(name="broadnetUserId")
    def broadnet_user_id(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_user_id")

    @_builtins.property
    @pulumi.getter(name="bypassWhenCloudDown")
    def bypass_when_cloud_down(self) -> Optional[_builtins.bool]:
        """
        Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        """
        return pulumi.get(self, "bypass_when_cloud_down")

    @_builtins.property
    @pulumi.getter(name="clickatellApiKey")
    def clickatell_api_key(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`clickatell`
        """
        return pulumi.get(self, "clickatell_api_key")

    @_builtins.property
    @pulumi.getter(name="crossSite")
    def cross_site(self) -> Optional[_builtins.bool]:
        """
        Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "cross_site")

    @_builtins.property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether email (access code verification) is enabled as a login method
        """
        return pulumi.get(self, "email_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether guest portal is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def expire(self) -> Optional[_builtins.int]:
        """
        How long to remain authorized, in minutes
        """
        return pulumi.get(self, "expire")

    @_builtins.property
    @pulumi.getter(name="externalPortalUrl")
    def external_portal_url(self) -> Optional[_builtins.str]:
        """
        Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        """
        return pulumi.get(self, "external_portal_url")

    @_builtins.property
    @pulumi.getter(name="facebookClientId")
    def facebook_client_id(self) -> Optional[_builtins.str]:
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "facebook_client_id")

    @_builtins.property
    @pulumi.getter(name="facebookClientSecret")
    def facebook_client_secret(self) -> Optional[_builtins.str]:
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "facebook_client_secret")

    @_builtins.property
    @pulumi.getter(name="facebookEmailDomains")
    def facebook_email_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "facebook_email_domains")

    @_builtins.property
    @pulumi.getter(name="facebookEnabled")
    def facebook_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether facebook is enabled as a login method
        """
        return pulumi.get(self, "facebook_enabled")

    @_builtins.property
    @pulumi.getter(name="facebookExpire")
    def facebook_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "facebook_expire")

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[_builtins.bool]:
        """
        Whether to forward the user to another URL after authorized
        """
        return pulumi.get(self, "forward")

    @_builtins.property
    @pulumi.getter(name="forwardUrl")
    def forward_url(self) -> Optional[_builtins.str]:
        """
        URL to forward the user to
        """
        return pulumi.get(self, "forward_url")

    @_builtins.property
    @pulumi.getter(name="googleClientId")
    def google_client_id(self) -> Optional[_builtins.str]:
        """
        Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "google_client_id")

    @_builtins.property
    @pulumi.getter(name="googleClientSecret")
    def google_client_secret(self) -> Optional[_builtins.str]:
        """
        Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "google_client_secret")

    @_builtins.property
    @pulumi.getter(name="googleEmailDomains")
    def google_email_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "google_email_domains")

    @_builtins.property
    @pulumi.getter(name="googleEnabled")
    def google_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether Google is enabled as login method
        """
        return pulumi.get(self, "google_enabled")

    @_builtins.property
    @pulumi.getter(name="googleExpire")
    def google_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "google_expire")

    @_builtins.property
    @pulumi.getter(name="gupshupPassword")
    def gupshup_password(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_password")

    @_builtins.property
    @pulumi.getter(name="gupshupUserid")
    def gupshup_userid(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_userid")

    @_builtins.property
    @pulumi.getter(name="microsoftClientId")
    def microsoft_client_id(self) -> Optional[_builtins.str]:
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "microsoft_client_id")

    @_builtins.property
    @pulumi.getter(name="microsoftClientSecret")
    def microsoft_client_secret(self) -> Optional[_builtins.str]:
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "microsoft_client_secret")

    @_builtins.property
    @pulumi.getter(name="microsoftEmailDomains")
    def microsoft_email_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "microsoft_email_domains")

    @_builtins.property
    @pulumi.getter(name="microsoftEnabled")
    def microsoft_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether microsoft 365 is enabled as a login method
        """
        return pulumi.get(self, "microsoft_enabled")

    @_builtins.property
    @pulumi.getter(name="microsoftExpire")
    def microsoft_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "microsoft_expire")

    @_builtins.property
    @pulumi.getter(name="passphraseEnabled")
    def passphrase_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether password is enabled
        """
        return pulumi.get(self, "passphrase_enabled")

    @_builtins.property
    @pulumi.getter(name="passphraseExpire")
    def passphrase_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        """
        return pulumi.get(self, "passphrase_expire")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Required if `passphrase_enabled`==`true`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="predefinedSponsorsEnabled")
    def predefined_sponsors_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behavior is acc to `sponsor_email_domains`
        """
        return pulumi.get(self, "predefined_sponsors_enabled")

    @_builtins.property
    @pulumi.getter(name="predefinedSponsorsHideEmail")
    def predefined_sponsors_hide_email(self) -> Optional[_builtins.bool]:
        """
        Whether to hide sponsor’s email from list of sponsors
        """
        return pulumi.get(self, "predefined_sponsors_hide_email")

    @_builtins.property
    @pulumi.getter
    def privacy(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "privacy")

    @_builtins.property
    @pulumi.getter(name="puzzelPassword")
    def puzzel_password(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_password")

    @_builtins.property
    @pulumi.getter(name="puzzelServiceId")
    def puzzel_service_id(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_service_id")

    @_builtins.property
    @pulumi.getter(name="puzzelUsername")
    def puzzel_username(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_username")

    @_builtins.property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether sms is enabled as a login method
        """
        return pulumi.get(self, "sms_enabled")

    @_builtins.property
    @pulumi.getter(name="smsExpire")
    def sms_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sms_expire")

    @_builtins.property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[_builtins.str]:
        """
        Optional if `sms_enabled`==`true`. SMS Message format
        """
        return pulumi.get(self, "sms_message_format")

    @_builtins.property
    @pulumi.getter(name="smsProvider")
    def sms_provider(self) -> Optional[_builtins.str]:
        """
        Optional if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `smsglobal`, `telstra`, `twilio`
        """
        return pulumi.get(self, "sms_provider")

    @_builtins.property
    @pulumi.getter(name="smsglobalApiKey")
    def smsglobal_api_key(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`smsglobal`, Client API Key
        """
        return pulumi.get(self, "smsglobal_api_key")

    @_builtins.property
    @pulumi.getter(name="smsglobalApiSecret")
    def smsglobal_api_secret(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`smsglobal`, Client secret
        """
        return pulumi.get(self, "smsglobal_api_secret")

    @_builtins.property
    @pulumi.getter(name="sponsorAutoApprove")
    def sponsor_auto_approve(self) -> Optional[_builtins.bool]:
        """
        Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        """
        return pulumi.get(self, "sponsor_auto_approve")

    @_builtins.property
    @pulumi.getter(name="sponsorEmailDomains")
    def sponsor_email_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        """
        return pulumi.get(self, "sponsor_email_domains")

    @_builtins.property
    @pulumi.getter(name="sponsorEnabled")
    def sponsor_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether sponsor is enabled
        """
        return pulumi.get(self, "sponsor_enabled")

    @_builtins.property
    @pulumi.getter(name="sponsorExpire")
    def sponsor_expire(self) -> Optional[_builtins.int]:
        """
        Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sponsor_expire")

    @_builtins.property
    @pulumi.getter(name="sponsorLinkValidityDuration")
    def sponsor_link_validity_duration(self) -> Optional[_builtins.str]:
        """
        Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes. Default is 60 minutes.
        """
        return pulumi.get(self, "sponsor_link_validity_duration")

    @_builtins.property
    @pulumi.getter(name="sponsorNotifyAll")
    def sponsor_notify_all(self) -> Optional[_builtins.bool]:
        """
        Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        """
        return pulumi.get(self, "sponsor_notify_all")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusNotify")
    def sponsor_status_notify(self) -> Optional[_builtins.bool]:
        """
        Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        """
        return pulumi.get(self, "sponsor_status_notify")

    @_builtins.property
    @pulumi.getter
    def sponsors(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        object of allowed sponsors email with name. Required if `sponsor_enabled`
                    is `true` and `sponsor_email_domains` is empty.

                    Property key is the sponsor email, Property value is the sponsor name
        """
        return pulumi.get(self, "sponsors")

    @_builtins.property
    @pulumi.getter(name="ssoDefaultRole")
    def sso_default_role(self) -> Optional[_builtins.str]:
        """
        Optional if `wlan_portal_auth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        """
        return pulumi.get(self, "sso_default_role")

    @_builtins.property
    @pulumi.getter(name="ssoForcedRole")
    def sso_forced_role(self) -> Optional[_builtins.str]:
        """
        Optional if `wlan_portal_auth`==`sso`
        """
        return pulumi.get(self, "sso_forced_role")

    @_builtins.property
    @pulumi.getter(name="ssoIdpCert")
    def sso_idp_cert(self) -> Optional[_builtins.str]:
        """
        Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        """
        return pulumi.get(self, "sso_idp_cert")

    @_builtins.property
    @pulumi.getter(name="ssoIdpSignAlgo")
    def sso_idp_sign_algo(self) -> Optional[_builtins.str]:
        """
        Optional if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        """
        return pulumi.get(self, "sso_idp_sign_algo")

    @_builtins.property
    @pulumi.getter(name="ssoIdpSsoUrl")
    def sso_idp_sso_url(self) -> Optional[_builtins.str]:
        """
        Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        """
        return pulumi.get(self, "sso_idp_sso_url")

    @_builtins.property
    @pulumi.getter(name="ssoIssuer")
    def sso_issuer(self) -> Optional[_builtins.str]:
        """
        Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        """
        return pulumi.get(self, "sso_issuer")

    @_builtins.property
    @pulumi.getter(name="ssoNameidFormat")
    def sso_nameid_format(self) -> Optional[_builtins.str]:
        """
        Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        """
        return pulumi.get(self, "sso_nameid_format")

    @_builtins.property
    @pulumi.getter(name="telstraClientId")
    def telstra_client_id(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        """
        return pulumi.get(self, "telstra_client_id")

    @_builtins.property
    @pulumi.getter(name="telstraClientSecret")
    def telstra_client_secret(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        """
        return pulumi.get(self, "telstra_client_secret")

    @_builtins.property
    @pulumi.getter(name="twilioAuthToken")
    def twilio_auth_token(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`twilio`, Auth token account with twilio account
        """
        return pulumi.get(self, "twilio_auth_token")

    @_builtins.property
    @pulumi.getter(name="twilioPhoneNumber")
    def twilio_phone_number(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        """
        return pulumi.get(self, "twilio_phone_number")

    @_builtins.property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> Optional[_builtins.str]:
        """
        Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        return pulumi.get(self, "twilio_sid")


@pulumi.output_type
class WlanPortalTemplatePortalTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessCodeAlternateEmail":
            suggest = "access_code_alternate_email"
        elif key == "authButtonAmazon":
            suggest = "auth_button_amazon"
        elif key == "authButtonAzure":
            suggest = "auth_button_azure"
        elif key == "authButtonEmail":
            suggest = "auth_button_email"
        elif key == "authButtonFacebook":
            suggest = "auth_button_facebook"
        elif key == "authButtonGoogle":
            suggest = "auth_button_google"
        elif key == "authButtonMicrosoft":
            suggest = "auth_button_microsoft"
        elif key == "authButtonPassphrase":
            suggest = "auth_button_passphrase"
        elif key == "authButtonSms":
            suggest = "auth_button_sms"
        elif key == "authButtonSponsor":
            suggest = "auth_button_sponsor"
        elif key == "authLabel":
            suggest = "auth_label"
        elif key == "backLink":
            suggest = "back_link"
        elif key == "colorDark":
            suggest = "color_dark"
        elif key == "colorLight":
            suggest = "color_light"
        elif key == "companyError":
            suggest = "company_error"
        elif key == "companyLabel":
            suggest = "company_label"
        elif key == "emailAccessDomainError":
            suggest = "email_access_domain_error"
        elif key == "emailCancel":
            suggest = "email_cancel"
        elif key == "emailCodeCancel":
            suggest = "email_code_cancel"
        elif key == "emailCodeError":
            suggest = "email_code_error"
        elif key == "emailCodeFieldLabel":
            suggest = "email_code_field_label"
        elif key == "emailCodeMessage":
            suggest = "email_code_message"
        elif key == "emailCodeSubmit":
            suggest = "email_code_submit"
        elif key == "emailCodeTitle":
            suggest = "email_code_title"
        elif key == "emailError":
            suggest = "email_error"
        elif key == "emailFieldLabel":
            suggest = "email_field_label"
        elif key == "emailLabel":
            suggest = "email_label"
        elif key == "emailMessage":
            suggest = "email_message"
        elif key == "emailSubmit":
            suggest = "email_submit"
        elif key == "emailTitle":
            suggest = "email_title"
        elif key == "marketingPolicyLink":
            suggest = "marketing_policy_link"
        elif key == "marketingPolicyOptIn":
            suggest = "marketing_policy_opt_in"
        elif key == "marketingPolicyOptInLabel":
            suggest = "marketing_policy_opt_in_label"
        elif key == "marketingPolicyOptInText":
            suggest = "marketing_policy_opt_in_text"
        elif key == "multiAuth":
            suggest = "multi_auth"
        elif key == "nameError":
            suggest = "name_error"
        elif key == "nameLabel":
            suggest = "name_label"
        elif key == "optOutDefault":
            suggest = "opt_out_default"
        elif key == "optoutLabel":
            suggest = "optout_label"
        elif key == "pageTitle":
            suggest = "page_title"
        elif key == "passphraseCancel":
            suggest = "passphrase_cancel"
        elif key == "passphraseError":
            suggest = "passphrase_error"
        elif key == "passphraseLabel":
            suggest = "passphrase_label"
        elif key == "passphraseMessage":
            suggest = "passphrase_message"
        elif key == "passphraseSubmit":
            suggest = "passphrase_submit"
        elif key == "passphraseTitle":
            suggest = "passphrase_title"
        elif key == "poweredBy":
            suggest = "powered_by"
        elif key == "privacyPolicyAcceptLabel":
            suggest = "privacy_policy_accept_label"
        elif key == "privacyPolicyError":
            suggest = "privacy_policy_error"
        elif key == "privacyPolicyLink":
            suggest = "privacy_policy_link"
        elif key == "privacyPolicyText":
            suggest = "privacy_policy_text"
        elif key == "requiredFieldLabel":
            suggest = "required_field_label"
        elif key == "responsiveLayout":
            suggest = "responsive_layout"
        elif key == "signInLabel":
            suggest = "sign_in_label"
        elif key == "smsCarrierDefault":
            suggest = "sms_carrier_default"
        elif key == "smsCarrierError":
            suggest = "sms_carrier_error"
        elif key == "smsCarrierFieldLabel":
            suggest = "sms_carrier_field_label"
        elif key == "smsCodeCancel":
            suggest = "sms_code_cancel"
        elif key == "smsCodeError":
            suggest = "sms_code_error"
        elif key == "smsCodeFieldLabel":
            suggest = "sms_code_field_label"
        elif key == "smsCodeMessage":
            suggest = "sms_code_message"
        elif key == "smsCodeSubmit":
            suggest = "sms_code_submit"
        elif key == "smsCodeTitle":
            suggest = "sms_code_title"
        elif key == "smsCountryFieldLabel":
            suggest = "sms_country_field_label"
        elif key == "smsCountryFormat":
            suggest = "sms_country_format"
        elif key == "smsHaveAccessCode":
            suggest = "sms_have_access_code"
        elif key == "smsIsTwilio":
            suggest = "sms_is_twilio"
        elif key == "smsMessageFormat":
            suggest = "sms_message_format"
        elif key == "smsNumberCancel":
            suggest = "sms_number_cancel"
        elif key == "smsNumberError":
            suggest = "sms_number_error"
        elif key == "smsNumberFieldLabel":
            suggest = "sms_number_field_label"
        elif key == "smsNumberFormat":
            suggest = "sms_number_format"
        elif key == "smsNumberMessage":
            suggest = "sms_number_message"
        elif key == "smsNumberSubmit":
            suggest = "sms_number_submit"
        elif key == "smsNumberTitle":
            suggest = "sms_number_title"
        elif key == "smsUsernameFormat":
            suggest = "sms_username_format"
        elif key == "smsValidityDuration":
            suggest = "sms_validity_duration"
        elif key == "sponsorBackLink":
            suggest = "sponsor_back_link"
        elif key == "sponsorCancel":
            suggest = "sponsor_cancel"
        elif key == "sponsorEmail":
            suggest = "sponsor_email"
        elif key == "sponsorEmailError":
            suggest = "sponsor_email_error"
        elif key == "sponsorEmailTemplate":
            suggest = "sponsor_email_template"
        elif key == "sponsorInfoApproved":
            suggest = "sponsor_info_approved"
        elif key == "sponsorInfoDenied":
            suggest = "sponsor_info_denied"
        elif key == "sponsorInfoPending":
            suggest = "sponsor_info_pending"
        elif key == "sponsorName":
            suggest = "sponsor_name"
        elif key == "sponsorNameError":
            suggest = "sponsor_name_error"
        elif key == "sponsorNotePending":
            suggest = "sponsor_note_pending"
        elif key == "sponsorRequestAccess":
            suggest = "sponsor_request_access"
        elif key == "sponsorStatusApproved":
            suggest = "sponsor_status_approved"
        elif key == "sponsorStatusDenied":
            suggest = "sponsor_status_denied"
        elif key == "sponsorStatusPending":
            suggest = "sponsor_status_pending"
        elif key == "sponsorSubmit":
            suggest = "sponsor_submit"
        elif key == "sponsorsError":
            suggest = "sponsors_error"
        elif key == "sponsorsFieldLabel":
            suggest = "sponsors_field_label"
        elif key == "tosAcceptLabel":
            suggest = "tos_accept_label"
        elif key == "tosError":
            suggest = "tos_error"
        elif key == "tosLink":
            suggest = "tos_link"
        elif key == "tosText":
            suggest = "tos_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanPortalTemplatePortalTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanPortalTemplatePortalTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanPortalTemplatePortalTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_code_alternate_email: Optional[_builtins.str] = None,
                 alignment: Optional[_builtins.str] = None,
                 auth_button_amazon: Optional[_builtins.str] = None,
                 auth_button_azure: Optional[_builtins.str] = None,
                 auth_button_email: Optional[_builtins.str] = None,
                 auth_button_facebook: Optional[_builtins.str] = None,
                 auth_button_google: Optional[_builtins.str] = None,
                 auth_button_microsoft: Optional[_builtins.str] = None,
                 auth_button_passphrase: Optional[_builtins.str] = None,
                 auth_button_sms: Optional[_builtins.str] = None,
                 auth_button_sponsor: Optional[_builtins.str] = None,
                 auth_label: Optional[_builtins.str] = None,
                 back_link: Optional[_builtins.str] = None,
                 color: Optional[_builtins.str] = None,
                 color_dark: Optional[_builtins.str] = None,
                 color_light: Optional[_builtins.str] = None,
                 company: Optional[_builtins.bool] = None,
                 company_error: Optional[_builtins.str] = None,
                 company_label: Optional[_builtins.str] = None,
                 email: Optional[_builtins.bool] = None,
                 email_access_domain_error: Optional[_builtins.str] = None,
                 email_cancel: Optional[_builtins.str] = None,
                 email_code_cancel: Optional[_builtins.str] = None,
                 email_code_error: Optional[_builtins.str] = None,
                 email_code_field_label: Optional[_builtins.str] = None,
                 email_code_message: Optional[_builtins.str] = None,
                 email_code_submit: Optional[_builtins.str] = None,
                 email_code_title: Optional[_builtins.str] = None,
                 email_error: Optional[_builtins.str] = None,
                 email_field_label: Optional[_builtins.str] = None,
                 email_label: Optional[_builtins.str] = None,
                 email_message: Optional[_builtins.str] = None,
                 email_submit: Optional[_builtins.str] = None,
                 email_title: Optional[_builtins.str] = None,
                 field1: Optional[_builtins.bool] = None,
                 field1error: Optional[_builtins.str] = None,
                 field1label: Optional[_builtins.str] = None,
                 field1required: Optional[_builtins.bool] = None,
                 field2: Optional[_builtins.bool] = None,
                 field2error: Optional[_builtins.str] = None,
                 field2label: Optional[_builtins.str] = None,
                 field2required: Optional[_builtins.bool] = None,
                 field3: Optional[_builtins.bool] = None,
                 field3error: Optional[_builtins.str] = None,
                 field3label: Optional[_builtins.str] = None,
                 field3required: Optional[_builtins.bool] = None,
                 field4: Optional[_builtins.bool] = None,
                 field4error: Optional[_builtins.str] = None,
                 field4label: Optional[_builtins.str] = None,
                 field4required: Optional[_builtins.bool] = None,
                 locales: Optional[Mapping[str, 'outputs.WlanPortalTemplatePortalTemplateLocales']] = None,
                 logo: Optional[_builtins.str] = None,
                 marketing_policy_link: Optional[_builtins.str] = None,
                 marketing_policy_opt_in: Optional[_builtins.bool] = None,
                 marketing_policy_opt_in_label: Optional[_builtins.str] = None,
                 marketing_policy_opt_in_text: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 multi_auth: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.bool] = None,
                 name_error: Optional[_builtins.str] = None,
                 name_label: Optional[_builtins.str] = None,
                 opt_out_default: Optional[_builtins.bool] = None,
                 optout: Optional[_builtins.bool] = None,
                 optout_label: Optional[_builtins.str] = None,
                 page_title: Optional[_builtins.str] = None,
                 passphrase_cancel: Optional[_builtins.str] = None,
                 passphrase_error: Optional[_builtins.str] = None,
                 passphrase_label: Optional[_builtins.str] = None,
                 passphrase_message: Optional[_builtins.str] = None,
                 passphrase_submit: Optional[_builtins.str] = None,
                 passphrase_title: Optional[_builtins.str] = None,
                 powered_by: Optional[_builtins.bool] = None,
                 privacy: Optional[_builtins.bool] = None,
                 privacy_policy_accept_label: Optional[_builtins.str] = None,
                 privacy_policy_error: Optional[_builtins.str] = None,
                 privacy_policy_link: Optional[_builtins.str] = None,
                 privacy_policy_text: Optional[_builtins.str] = None,
                 required_field_label: Optional[_builtins.str] = None,
                 responsive_layout: Optional[_builtins.bool] = None,
                 sign_in_label: Optional[_builtins.str] = None,
                 sms_carrier_default: Optional[_builtins.str] = None,
                 sms_carrier_error: Optional[_builtins.str] = None,
                 sms_carrier_field_label: Optional[_builtins.str] = None,
                 sms_code_cancel: Optional[_builtins.str] = None,
                 sms_code_error: Optional[_builtins.str] = None,
                 sms_code_field_label: Optional[_builtins.str] = None,
                 sms_code_message: Optional[_builtins.str] = None,
                 sms_code_submit: Optional[_builtins.str] = None,
                 sms_code_title: Optional[_builtins.str] = None,
                 sms_country_field_label: Optional[_builtins.str] = None,
                 sms_country_format: Optional[_builtins.str] = None,
                 sms_have_access_code: Optional[_builtins.str] = None,
                 sms_is_twilio: Optional[_builtins.bool] = None,
                 sms_message_format: Optional[_builtins.str] = None,
                 sms_number_cancel: Optional[_builtins.str] = None,
                 sms_number_error: Optional[_builtins.str] = None,
                 sms_number_field_label: Optional[_builtins.str] = None,
                 sms_number_format: Optional[_builtins.str] = None,
                 sms_number_message: Optional[_builtins.str] = None,
                 sms_number_submit: Optional[_builtins.str] = None,
                 sms_number_title: Optional[_builtins.str] = None,
                 sms_username_format: Optional[_builtins.str] = None,
                 sms_validity_duration: Optional[_builtins.int] = None,
                 sponsor_back_link: Optional[_builtins.str] = None,
                 sponsor_cancel: Optional[_builtins.str] = None,
                 sponsor_email: Optional[_builtins.str] = None,
                 sponsor_email_error: Optional[_builtins.str] = None,
                 sponsor_email_template: Optional[_builtins.str] = None,
                 sponsor_info_approved: Optional[_builtins.str] = None,
                 sponsor_info_denied: Optional[_builtins.str] = None,
                 sponsor_info_pending: Optional[_builtins.str] = None,
                 sponsor_name: Optional[_builtins.str] = None,
                 sponsor_name_error: Optional[_builtins.str] = None,
                 sponsor_note_pending: Optional[_builtins.str] = None,
                 sponsor_request_access: Optional[_builtins.str] = None,
                 sponsor_status_approved: Optional[_builtins.str] = None,
                 sponsor_status_denied: Optional[_builtins.str] = None,
                 sponsor_status_pending: Optional[_builtins.str] = None,
                 sponsor_submit: Optional[_builtins.str] = None,
                 sponsors_error: Optional[_builtins.str] = None,
                 sponsors_field_label: Optional[_builtins.str] = None,
                 tos: Optional[_builtins.bool] = None,
                 tos_accept_label: Optional[_builtins.str] = None,
                 tos_error: Optional[_builtins.str] = None,
                 tos_link: Optional[_builtins.str] = None,
                 tos_text: Optional[_builtins.str] = None):
        """
        :param _builtins.str alignment: defines alignment on portal. enum: `center`, `left`, `right`
        :param _builtins.str auth_button_amazon: Label for Amazon auth button
        :param _builtins.str auth_button_azure: Label for Azure auth button
        :param _builtins.str auth_button_email: Label for Email auth button
        :param _builtins.str auth_button_facebook: Label for Facebook auth button
        :param _builtins.str auth_button_google: Label for Google auth button
        :param _builtins.str auth_button_microsoft: Label for Microsoft auth button
        :param _builtins.str auth_button_passphrase: Label for passphrase auth button
        :param _builtins.str auth_button_sms: Label for SMS auth button
        :param _builtins.str auth_button_sponsor: Label for Sponsor auth button
        :param _builtins.str back_link: Label of the link to go back to /logon
        :param _builtins.str color: Portal main color
        :param _builtins.bool company: Whether company field is required
        :param _builtins.str company_error: Error message when company not provided
        :param _builtins.str company_label: Label of company field
        :param _builtins.bool email: Whether email field is required
        :param _builtins.str email_access_domain_error: Error message when a user has valid social login but doesn't match specified email domains.
        :param _builtins.str email_cancel: Label for cancel confirmation code submission using email auth
        :param _builtins.str email_error: Error message when email not provided
        :param _builtins.str email_label: Label of email field
        :param _builtins.str email_submit: Label for confirmation code submit button using email auth
        :param _builtins.str email_title: Title for the Email registration
        :param _builtins.bool field1: Whether to ask field1
        :param _builtins.str field1error: Error message when field1 not provided
        :param _builtins.str field1label: Label of field1
        :param _builtins.bool field1required: Whether field1 is required field
        :param _builtins.bool field2: Whether to ask field2
        :param _builtins.str field2error: Error message when field2 not provided
        :param _builtins.str field2label: Label of field2
        :param _builtins.bool field2required: Whether field2 is required field
        :param _builtins.bool field3: Whether to ask field3
        :param _builtins.str field3error: Error message when field3 not provided
        :param _builtins.str field3label: Label of field3
        :param _builtins.bool field3required: Whether field3 is required field
        :param _builtins.bool field4: Whether to ask field4
        :param _builtins.str field4error: Error message when field4 not provided
        :param _builtins.str field4label: Label of field4
        :param _builtins.bool field4required: Whether field4 is required field
        :param Mapping[str, 'WlanPortalTemplatePortalTemplateLocalesArgs'] locales: Can be used to localize the portal based on the User Agent. Allowed property key values are:
                 `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
                 `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
                 `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
                 `zh-Hans`, `zh-Hant`
        :param _builtins.str logo: path to the background image file. File must be a `png` image less than 100kB and image dimension must be less 500px x 200px (width x height).
        :param _builtins.str marketing_policy_link: label of the link to go to /marketing_policy
        :param _builtins.bool marketing_policy_opt_in: Whether marketing policy optin is enabled
        :param _builtins.str marketing_policy_opt_in_label: label for marketing optin
        :param _builtins.str marketing_policy_opt_in_text: marketing policy text
        :param _builtins.bool name: Whether name field is required
        :param _builtins.str name_error: Error message when name not provided
        :param _builtins.str name_label: Label of name field
        :param _builtins.bool opt_out_default: Default value for the `Do not store` checkbox
        :param _builtins.bool optout: Whether to display Do Not Store My Personal Information
        :param _builtins.str optout_label: Label for Do Not Store My Personal Information
        :param _builtins.str passphrase_cancel: Label for the Passphrase cancel button
        :param _builtins.str passphrase_error: Error message when invalid passphrase is provided
        :param _builtins.str passphrase_label: Passphrase
        :param _builtins.str passphrase_submit: Label for the Passphrase submit button
        :param _builtins.str passphrase_title: Title for passphrase details page
        :param _builtins.bool powered_by: Whether to show \\"Powered by Mist\\"
        :param _builtins.bool privacy: Whether to require the Privacy Term acceptance
        :param _builtins.str privacy_policy_accept_label: Prefix of the label of the link to go to Privacy Policy
        :param _builtins.str privacy_policy_error: Error message when Privacy Policy not accepted
        :param _builtins.str privacy_policy_link: Label of the link to go to Privacy Policy
        :param _builtins.str privacy_policy_text: Text of the Privacy Policy
        :param _builtins.str required_field_label: Label to denote required field
        :param _builtins.str sign_in_label: Label of the button to signin
        :param _builtins.str sms_carrier_field_label: Label for mobile carrier drop-down list
        :param _builtins.str sms_code_cancel: Label for cancel confirmation code submission
        :param _builtins.str sms_code_error: Error message when confirmation code is invalid
        :param _builtins.str sms_code_submit: Label for confirmation code submit button
        :param _builtins.str sms_have_access_code: Label for checkbox to specify that the user has access code
        :param _builtins.str sms_message_format: Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        :param _builtins.str sms_number_cancel: Label for canceling mobile details for SMS auth
        :param _builtins.str sms_number_field_label: Label for field to provide mobile number
        :param _builtins.str sms_number_submit: Label for submit button for code generation
        :param _builtins.str sms_number_title: Title for phone number details
        :param _builtins.int sms_validity_duration: How long confirmation code should be considered valid (in minutes)
        :param _builtins.str sponsor_email: Label for Sponsor Email
        :param _builtins.str sponsor_email_template: HTML template to replace/override default sponsor email template 
               Sponsor Email Template supports following template variables:
                 * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
                 * `deny_url`: Renders URL to reject the request
                 * `guest_email`: Renders Email ID of the guest
                 * `guest_name`: Renders Name of the guest
                 * `field1`: Renders value of the Custom Field 1
                 * `field2`: Renders value of the Custom Field 2
                 * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
                 * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        :param _builtins.str sponsor_name: Label for Sponsor Name
        :param _builtins.str sponsor_request_access: Submit button label request Wifi Access and notify sponsor about guest request
        :param _builtins.str sponsor_status_approved: Text to display if sponsor approves request
        :param _builtins.str sponsor_status_denied: Text to display when sponsor denies request
        :param _builtins.str sponsor_status_pending: Text to display if request is still pending
        :param _builtins.str sponsor_submit: Submit button label to notify sponsor about guest request
        :param _builtins.str tos_accept_label: Prefix of the label of the link to go to tos
        :param _builtins.str tos_error: Error message when tos not accepted
        :param _builtins.str tos_link: Label of the link to go to tos
        :param _builtins.str tos_text: Text of the Terms of Service
        """
        if access_code_alternate_email is not None:
            pulumi.set(__self__, "access_code_alternate_email", access_code_alternate_email)
        if alignment is not None:
            pulumi.set(__self__, "alignment", alignment)
        if auth_button_amazon is not None:
            pulumi.set(__self__, "auth_button_amazon", auth_button_amazon)
        if auth_button_azure is not None:
            pulumi.set(__self__, "auth_button_azure", auth_button_azure)
        if auth_button_email is not None:
            pulumi.set(__self__, "auth_button_email", auth_button_email)
        if auth_button_facebook is not None:
            pulumi.set(__self__, "auth_button_facebook", auth_button_facebook)
        if auth_button_google is not None:
            pulumi.set(__self__, "auth_button_google", auth_button_google)
        if auth_button_microsoft is not None:
            pulumi.set(__self__, "auth_button_microsoft", auth_button_microsoft)
        if auth_button_passphrase is not None:
            pulumi.set(__self__, "auth_button_passphrase", auth_button_passphrase)
        if auth_button_sms is not None:
            pulumi.set(__self__, "auth_button_sms", auth_button_sms)
        if auth_button_sponsor is not None:
            pulumi.set(__self__, "auth_button_sponsor", auth_button_sponsor)
        if auth_label is not None:
            pulumi.set(__self__, "auth_label", auth_label)
        if back_link is not None:
            pulumi.set(__self__, "back_link", back_link)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_dark is not None:
            pulumi.set(__self__, "color_dark", color_dark)
        if color_light is not None:
            pulumi.set(__self__, "color_light", color_light)
        if company is not None:
            pulumi.set(__self__, "company", company)
        if company_error is not None:
            pulumi.set(__self__, "company_error", company_error)
        if company_label is not None:
            pulumi.set(__self__, "company_label", company_label)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_access_domain_error is not None:
            pulumi.set(__self__, "email_access_domain_error", email_access_domain_error)
        if email_cancel is not None:
            pulumi.set(__self__, "email_cancel", email_cancel)
        if email_code_cancel is not None:
            pulumi.set(__self__, "email_code_cancel", email_code_cancel)
        if email_code_error is not None:
            pulumi.set(__self__, "email_code_error", email_code_error)
        if email_code_field_label is not None:
            pulumi.set(__self__, "email_code_field_label", email_code_field_label)
        if email_code_message is not None:
            pulumi.set(__self__, "email_code_message", email_code_message)
        if email_code_submit is not None:
            pulumi.set(__self__, "email_code_submit", email_code_submit)
        if email_code_title is not None:
            pulumi.set(__self__, "email_code_title", email_code_title)
        if email_error is not None:
            pulumi.set(__self__, "email_error", email_error)
        if email_field_label is not None:
            pulumi.set(__self__, "email_field_label", email_field_label)
        if email_label is not None:
            pulumi.set(__self__, "email_label", email_label)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_submit is not None:
            pulumi.set(__self__, "email_submit", email_submit)
        if email_title is not None:
            pulumi.set(__self__, "email_title", email_title)
        if field1 is not None:
            pulumi.set(__self__, "field1", field1)
        if field1error is not None:
            pulumi.set(__self__, "field1error", field1error)
        if field1label is not None:
            pulumi.set(__self__, "field1label", field1label)
        if field1required is not None:
            pulumi.set(__self__, "field1required", field1required)
        if field2 is not None:
            pulumi.set(__self__, "field2", field2)
        if field2error is not None:
            pulumi.set(__self__, "field2error", field2error)
        if field2label is not None:
            pulumi.set(__self__, "field2label", field2label)
        if field2required is not None:
            pulumi.set(__self__, "field2required", field2required)
        if field3 is not None:
            pulumi.set(__self__, "field3", field3)
        if field3error is not None:
            pulumi.set(__self__, "field3error", field3error)
        if field3label is not None:
            pulumi.set(__self__, "field3label", field3label)
        if field3required is not None:
            pulumi.set(__self__, "field3required", field3required)
        if field4 is not None:
            pulumi.set(__self__, "field4", field4)
        if field4error is not None:
            pulumi.set(__self__, "field4error", field4error)
        if field4label is not None:
            pulumi.set(__self__, "field4label", field4label)
        if field4required is not None:
            pulumi.set(__self__, "field4required", field4required)
        if locales is not None:
            pulumi.set(__self__, "locales", locales)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if marketing_policy_link is not None:
            pulumi.set(__self__, "marketing_policy_link", marketing_policy_link)
        if marketing_policy_opt_in is not None:
            pulumi.set(__self__, "marketing_policy_opt_in", marketing_policy_opt_in)
        if marketing_policy_opt_in_label is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_label", marketing_policy_opt_in_label)
        if marketing_policy_opt_in_text is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_text", marketing_policy_opt_in_text)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if multi_auth is not None:
            pulumi.set(__self__, "multi_auth", multi_auth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_error is not None:
            pulumi.set(__self__, "name_error", name_error)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if opt_out_default is not None:
            pulumi.set(__self__, "opt_out_default", opt_out_default)
        if optout is not None:
            pulumi.set(__self__, "optout", optout)
        if optout_label is not None:
            pulumi.set(__self__, "optout_label", optout_label)
        if page_title is not None:
            pulumi.set(__self__, "page_title", page_title)
        if passphrase_cancel is not None:
            pulumi.set(__self__, "passphrase_cancel", passphrase_cancel)
        if passphrase_error is not None:
            pulumi.set(__self__, "passphrase_error", passphrase_error)
        if passphrase_label is not None:
            pulumi.set(__self__, "passphrase_label", passphrase_label)
        if passphrase_message is not None:
            pulumi.set(__self__, "passphrase_message", passphrase_message)
        if passphrase_submit is not None:
            pulumi.set(__self__, "passphrase_submit", passphrase_submit)
        if passphrase_title is not None:
            pulumi.set(__self__, "passphrase_title", passphrase_title)
        if powered_by is not None:
            pulumi.set(__self__, "powered_by", powered_by)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if privacy_policy_accept_label is not None:
            pulumi.set(__self__, "privacy_policy_accept_label", privacy_policy_accept_label)
        if privacy_policy_error is not None:
            pulumi.set(__self__, "privacy_policy_error", privacy_policy_error)
        if privacy_policy_link is not None:
            pulumi.set(__self__, "privacy_policy_link", privacy_policy_link)
        if privacy_policy_text is not None:
            pulumi.set(__self__, "privacy_policy_text", privacy_policy_text)
        if required_field_label is not None:
            pulumi.set(__self__, "required_field_label", required_field_label)
        if responsive_layout is not None:
            pulumi.set(__self__, "responsive_layout", responsive_layout)
        if sign_in_label is not None:
            pulumi.set(__self__, "sign_in_label", sign_in_label)
        if sms_carrier_default is not None:
            pulumi.set(__self__, "sms_carrier_default", sms_carrier_default)
        if sms_carrier_error is not None:
            pulumi.set(__self__, "sms_carrier_error", sms_carrier_error)
        if sms_carrier_field_label is not None:
            pulumi.set(__self__, "sms_carrier_field_label", sms_carrier_field_label)
        if sms_code_cancel is not None:
            pulumi.set(__self__, "sms_code_cancel", sms_code_cancel)
        if sms_code_error is not None:
            pulumi.set(__self__, "sms_code_error", sms_code_error)
        if sms_code_field_label is not None:
            pulumi.set(__self__, "sms_code_field_label", sms_code_field_label)
        if sms_code_message is not None:
            pulumi.set(__self__, "sms_code_message", sms_code_message)
        if sms_code_submit is not None:
            pulumi.set(__self__, "sms_code_submit", sms_code_submit)
        if sms_code_title is not None:
            pulumi.set(__self__, "sms_code_title", sms_code_title)
        if sms_country_field_label is not None:
            pulumi.set(__self__, "sms_country_field_label", sms_country_field_label)
        if sms_country_format is not None:
            pulumi.set(__self__, "sms_country_format", sms_country_format)
        if sms_have_access_code is not None:
            pulumi.set(__self__, "sms_have_access_code", sms_have_access_code)
        if sms_is_twilio is not None:
            pulumi.set(__self__, "sms_is_twilio", sms_is_twilio)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_number_cancel is not None:
            pulumi.set(__self__, "sms_number_cancel", sms_number_cancel)
        if sms_number_error is not None:
            pulumi.set(__self__, "sms_number_error", sms_number_error)
        if sms_number_field_label is not None:
            pulumi.set(__self__, "sms_number_field_label", sms_number_field_label)
        if sms_number_format is not None:
            pulumi.set(__self__, "sms_number_format", sms_number_format)
        if sms_number_message is not None:
            pulumi.set(__self__, "sms_number_message", sms_number_message)
        if sms_number_submit is not None:
            pulumi.set(__self__, "sms_number_submit", sms_number_submit)
        if sms_number_title is not None:
            pulumi.set(__self__, "sms_number_title", sms_number_title)
        if sms_username_format is not None:
            pulumi.set(__self__, "sms_username_format", sms_username_format)
        if sms_validity_duration is not None:
            pulumi.set(__self__, "sms_validity_duration", sms_validity_duration)
        if sponsor_back_link is not None:
            pulumi.set(__self__, "sponsor_back_link", sponsor_back_link)
        if sponsor_cancel is not None:
            pulumi.set(__self__, "sponsor_cancel", sponsor_cancel)
        if sponsor_email is not None:
            pulumi.set(__self__, "sponsor_email", sponsor_email)
        if sponsor_email_error is not None:
            pulumi.set(__self__, "sponsor_email_error", sponsor_email_error)
        if sponsor_email_template is not None:
            pulumi.set(__self__, "sponsor_email_template", sponsor_email_template)
        if sponsor_info_approved is not None:
            pulumi.set(__self__, "sponsor_info_approved", sponsor_info_approved)
        if sponsor_info_denied is not None:
            pulumi.set(__self__, "sponsor_info_denied", sponsor_info_denied)
        if sponsor_info_pending is not None:
            pulumi.set(__self__, "sponsor_info_pending", sponsor_info_pending)
        if sponsor_name is not None:
            pulumi.set(__self__, "sponsor_name", sponsor_name)
        if sponsor_name_error is not None:
            pulumi.set(__self__, "sponsor_name_error", sponsor_name_error)
        if sponsor_note_pending is not None:
            pulumi.set(__self__, "sponsor_note_pending", sponsor_note_pending)
        if sponsor_request_access is not None:
            pulumi.set(__self__, "sponsor_request_access", sponsor_request_access)
        if sponsor_status_approved is not None:
            pulumi.set(__self__, "sponsor_status_approved", sponsor_status_approved)
        if sponsor_status_denied is not None:
            pulumi.set(__self__, "sponsor_status_denied", sponsor_status_denied)
        if sponsor_status_pending is not None:
            pulumi.set(__self__, "sponsor_status_pending", sponsor_status_pending)
        if sponsor_submit is not None:
            pulumi.set(__self__, "sponsor_submit", sponsor_submit)
        if sponsors_error is not None:
            pulumi.set(__self__, "sponsors_error", sponsors_error)
        if sponsors_field_label is not None:
            pulumi.set(__self__, "sponsors_field_label", sponsors_field_label)
        if tos is not None:
            pulumi.set(__self__, "tos", tos)
        if tos_accept_label is not None:
            pulumi.set(__self__, "tos_accept_label", tos_accept_label)
        if tos_error is not None:
            pulumi.set(__self__, "tos_error", tos_error)
        if tos_link is not None:
            pulumi.set(__self__, "tos_link", tos_link)
        if tos_text is not None:
            pulumi.set(__self__, "tos_text", tos_text)

    @_builtins.property
    @pulumi.getter(name="accessCodeAlternateEmail")
    def access_code_alternate_email(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_code_alternate_email")

    @_builtins.property
    @pulumi.getter
    def alignment(self) -> Optional[_builtins.str]:
        """
        defines alignment on portal. enum: `center`, `left`, `right`
        """
        return pulumi.get(self, "alignment")

    @_builtins.property
    @pulumi.getter(name="authButtonAmazon")
    def auth_button_amazon(self) -> Optional[_builtins.str]:
        """
        Label for Amazon auth button
        """
        return pulumi.get(self, "auth_button_amazon")

    @_builtins.property
    @pulumi.getter(name="authButtonAzure")
    def auth_button_azure(self) -> Optional[_builtins.str]:
        """
        Label for Azure auth button
        """
        return pulumi.get(self, "auth_button_azure")

    @_builtins.property
    @pulumi.getter(name="authButtonEmail")
    def auth_button_email(self) -> Optional[_builtins.str]:
        """
        Label for Email auth button
        """
        return pulumi.get(self, "auth_button_email")

    @_builtins.property
    @pulumi.getter(name="authButtonFacebook")
    def auth_button_facebook(self) -> Optional[_builtins.str]:
        """
        Label for Facebook auth button
        """
        return pulumi.get(self, "auth_button_facebook")

    @_builtins.property
    @pulumi.getter(name="authButtonGoogle")
    def auth_button_google(self) -> Optional[_builtins.str]:
        """
        Label for Google auth button
        """
        return pulumi.get(self, "auth_button_google")

    @_builtins.property
    @pulumi.getter(name="authButtonMicrosoft")
    def auth_button_microsoft(self) -> Optional[_builtins.str]:
        """
        Label for Microsoft auth button
        """
        return pulumi.get(self, "auth_button_microsoft")

    @_builtins.property
    @pulumi.getter(name="authButtonPassphrase")
    def auth_button_passphrase(self) -> Optional[_builtins.str]:
        """
        Label for passphrase auth button
        """
        return pulumi.get(self, "auth_button_passphrase")

    @_builtins.property
    @pulumi.getter(name="authButtonSms")
    def auth_button_sms(self) -> Optional[_builtins.str]:
        """
        Label for SMS auth button
        """
        return pulumi.get(self, "auth_button_sms")

    @_builtins.property
    @pulumi.getter(name="authButtonSponsor")
    def auth_button_sponsor(self) -> Optional[_builtins.str]:
        """
        Label for Sponsor auth button
        """
        return pulumi.get(self, "auth_button_sponsor")

    @_builtins.property
    @pulumi.getter(name="authLabel")
    def auth_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auth_label")

    @_builtins.property
    @pulumi.getter(name="backLink")
    def back_link(self) -> Optional[_builtins.str]:
        """
        Label of the link to go back to /logon
        """
        return pulumi.get(self, "back_link")

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        Portal main color
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="colorDark")
    def color_dark(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "color_dark")

    @_builtins.property
    @pulumi.getter(name="colorLight")
    def color_light(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "color_light")

    @_builtins.property
    @pulumi.getter
    def company(self) -> Optional[_builtins.bool]:
        """
        Whether company field is required
        """
        return pulumi.get(self, "company")

    @_builtins.property
    @pulumi.getter(name="companyError")
    def company_error(self) -> Optional[_builtins.str]:
        """
        Error message when company not provided
        """
        return pulumi.get(self, "company_error")

    @_builtins.property
    @pulumi.getter(name="companyLabel")
    def company_label(self) -> Optional[_builtins.str]:
        """
        Label of company field
        """
        return pulumi.get(self, "company_label")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.bool]:
        """
        Whether email field is required
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="emailAccessDomainError")
    def email_access_domain_error(self) -> Optional[_builtins.str]:
        """
        Error message when a user has valid social login but doesn't match specified email domains.
        """
        return pulumi.get(self, "email_access_domain_error")

    @_builtins.property
    @pulumi.getter(name="emailCancel")
    def email_cancel(self) -> Optional[_builtins.str]:
        """
        Label for cancel confirmation code submission using email auth
        """
        return pulumi.get(self, "email_cancel")

    @_builtins.property
    @pulumi.getter(name="emailCodeCancel")
    def email_code_cancel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_cancel")

    @_builtins.property
    @pulumi.getter(name="emailCodeError")
    def email_code_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_error")

    @_builtins.property
    @pulumi.getter(name="emailCodeFieldLabel")
    def email_code_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_field_label")

    @_builtins.property
    @pulumi.getter(name="emailCodeMessage")
    def email_code_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_message")

    @_builtins.property
    @pulumi.getter(name="emailCodeSubmit")
    def email_code_submit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_submit")

    @_builtins.property
    @pulumi.getter(name="emailCodeTitle")
    def email_code_title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_title")

    @_builtins.property
    @pulumi.getter(name="emailError")
    def email_error(self) -> Optional[_builtins.str]:
        """
        Error message when email not provided
        """
        return pulumi.get(self, "email_error")

    @_builtins.property
    @pulumi.getter(name="emailFieldLabel")
    def email_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_field_label")

    @_builtins.property
    @pulumi.getter(name="emailLabel")
    def email_label(self) -> Optional[_builtins.str]:
        """
        Label of email field
        """
        return pulumi.get(self, "email_label")

    @_builtins.property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_message")

    @_builtins.property
    @pulumi.getter(name="emailSubmit")
    def email_submit(self) -> Optional[_builtins.str]:
        """
        Label for confirmation code submit button using email auth
        """
        return pulumi.get(self, "email_submit")

    @_builtins.property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> Optional[_builtins.str]:
        """
        Title for the Email registration
        """
        return pulumi.get(self, "email_title")

    @_builtins.property
    @pulumi.getter
    def field1(self) -> Optional[_builtins.bool]:
        """
        Whether to ask field1
        """
        return pulumi.get(self, "field1")

    @_builtins.property
    @pulumi.getter
    def field1error(self) -> Optional[_builtins.str]:
        """
        Error message when field1 not provided
        """
        return pulumi.get(self, "field1error")

    @_builtins.property
    @pulumi.getter
    def field1label(self) -> Optional[_builtins.str]:
        """
        Label of field1
        """
        return pulumi.get(self, "field1label")

    @_builtins.property
    @pulumi.getter
    def field1required(self) -> Optional[_builtins.bool]:
        """
        Whether field1 is required field
        """
        return pulumi.get(self, "field1required")

    @_builtins.property
    @pulumi.getter
    def field2(self) -> Optional[_builtins.bool]:
        """
        Whether to ask field2
        """
        return pulumi.get(self, "field2")

    @_builtins.property
    @pulumi.getter
    def field2error(self) -> Optional[_builtins.str]:
        """
        Error message when field2 not provided
        """
        return pulumi.get(self, "field2error")

    @_builtins.property
    @pulumi.getter
    def field2label(self) -> Optional[_builtins.str]:
        """
        Label of field2
        """
        return pulumi.get(self, "field2label")

    @_builtins.property
    @pulumi.getter
    def field2required(self) -> Optional[_builtins.bool]:
        """
        Whether field2 is required field
        """
        return pulumi.get(self, "field2required")

    @_builtins.property
    @pulumi.getter
    def field3(self) -> Optional[_builtins.bool]:
        """
        Whether to ask field3
        """
        return pulumi.get(self, "field3")

    @_builtins.property
    @pulumi.getter
    def field3error(self) -> Optional[_builtins.str]:
        """
        Error message when field3 not provided
        """
        return pulumi.get(self, "field3error")

    @_builtins.property
    @pulumi.getter
    def field3label(self) -> Optional[_builtins.str]:
        """
        Label of field3
        """
        return pulumi.get(self, "field3label")

    @_builtins.property
    @pulumi.getter
    def field3required(self) -> Optional[_builtins.bool]:
        """
        Whether field3 is required field
        """
        return pulumi.get(self, "field3required")

    @_builtins.property
    @pulumi.getter
    def field4(self) -> Optional[_builtins.bool]:
        """
        Whether to ask field4
        """
        return pulumi.get(self, "field4")

    @_builtins.property
    @pulumi.getter
    def field4error(self) -> Optional[_builtins.str]:
        """
        Error message when field4 not provided
        """
        return pulumi.get(self, "field4error")

    @_builtins.property
    @pulumi.getter
    def field4label(self) -> Optional[_builtins.str]:
        """
        Label of field4
        """
        return pulumi.get(self, "field4label")

    @_builtins.property
    @pulumi.getter
    def field4required(self) -> Optional[_builtins.bool]:
        """
        Whether field4 is required field
        """
        return pulumi.get(self, "field4required")

    @_builtins.property
    @pulumi.getter
    def locales(self) -> Optional[Mapping[str, 'outputs.WlanPortalTemplatePortalTemplateLocales']]:
        """
        Can be used to localize the portal based on the User Agent. Allowed property key values are:
          `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
          `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
          `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
          `zh-Hans`, `zh-Hant`
        """
        return pulumi.get(self, "locales")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        path to the background image file. File must be a `png` image less than 100kB and image dimension must be less 500px x 200px (width x height).
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyLink")
    def marketing_policy_link(self) -> Optional[_builtins.str]:
        """
        label of the link to go to /marketing_policy
        """
        return pulumi.get(self, "marketing_policy_link")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyOptIn")
    def marketing_policy_opt_in(self) -> Optional[_builtins.bool]:
        """
        Whether marketing policy optin is enabled
        """
        return pulumi.get(self, "marketing_policy_opt_in")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyOptInLabel")
    def marketing_policy_opt_in_label(self) -> Optional[_builtins.str]:
        """
        label for marketing optin
        """
        return pulumi.get(self, "marketing_policy_opt_in_label")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyOptInText")
    def marketing_policy_opt_in_text(self) -> Optional[_builtins.str]:
        """
        marketing policy text
        """
        return pulumi.get(self, "marketing_policy_opt_in_text")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="multiAuth")
    def multi_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "multi_auth")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.bool]:
        """
        Whether name field is required
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameError")
    def name_error(self) -> Optional[_builtins.str]:
        """
        Error message when name not provided
        """
        return pulumi.get(self, "name_error")

    @_builtins.property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[_builtins.str]:
        """
        Label of name field
        """
        return pulumi.get(self, "name_label")

    @_builtins.property
    @pulumi.getter(name="optOutDefault")
    def opt_out_default(self) -> Optional[_builtins.bool]:
        """
        Default value for the `Do not store` checkbox
        """
        return pulumi.get(self, "opt_out_default")

    @_builtins.property
    @pulumi.getter
    def optout(self) -> Optional[_builtins.bool]:
        """
        Whether to display Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout")

    @_builtins.property
    @pulumi.getter(name="optoutLabel")
    def optout_label(self) -> Optional[_builtins.str]:
        """
        Label for Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout_label")

    @_builtins.property
    @pulumi.getter(name="pageTitle")
    def page_title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "page_title")

    @_builtins.property
    @pulumi.getter(name="passphraseCancel")
    def passphrase_cancel(self) -> Optional[_builtins.str]:
        """
        Label for the Passphrase cancel button
        """
        return pulumi.get(self, "passphrase_cancel")

    @_builtins.property
    @pulumi.getter(name="passphraseError")
    def passphrase_error(self) -> Optional[_builtins.str]:
        """
        Error message when invalid passphrase is provided
        """
        return pulumi.get(self, "passphrase_error")

    @_builtins.property
    @pulumi.getter(name="passphraseLabel")
    def passphrase_label(self) -> Optional[_builtins.str]:
        """
        Passphrase
        """
        return pulumi.get(self, "passphrase_label")

    @_builtins.property
    @pulumi.getter(name="passphraseMessage")
    def passphrase_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "passphrase_message")

    @_builtins.property
    @pulumi.getter(name="passphraseSubmit")
    def passphrase_submit(self) -> Optional[_builtins.str]:
        """
        Label for the Passphrase submit button
        """
        return pulumi.get(self, "passphrase_submit")

    @_builtins.property
    @pulumi.getter(name="passphraseTitle")
    def passphrase_title(self) -> Optional[_builtins.str]:
        """
        Title for passphrase details page
        """
        return pulumi.get(self, "passphrase_title")

    @_builtins.property
    @pulumi.getter(name="poweredBy")
    def powered_by(self) -> Optional[_builtins.bool]:
        """
        Whether to show \\"Powered by Mist\\"
        """
        return pulumi.get(self, "powered_by")

    @_builtins.property
    @pulumi.getter
    def privacy(self) -> Optional[_builtins.bool]:
        """
        Whether to require the Privacy Term acceptance
        """
        return pulumi.get(self, "privacy")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyAcceptLabel")
    def privacy_policy_accept_label(self) -> Optional[_builtins.str]:
        """
        Prefix of the label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_accept_label")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyError")
    def privacy_policy_error(self) -> Optional[_builtins.str]:
        """
        Error message when Privacy Policy not accepted
        """
        return pulumi.get(self, "privacy_policy_error")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyLink")
    def privacy_policy_link(self) -> Optional[_builtins.str]:
        """
        Label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_link")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyText")
    def privacy_policy_text(self) -> Optional[_builtins.str]:
        """
        Text of the Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_text")

    @_builtins.property
    @pulumi.getter(name="requiredFieldLabel")
    def required_field_label(self) -> Optional[_builtins.str]:
        """
        Label to denote required field
        """
        return pulumi.get(self, "required_field_label")

    @_builtins.property
    @pulumi.getter(name="responsiveLayout")
    def responsive_layout(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "responsive_layout")

    @_builtins.property
    @pulumi.getter(name="signInLabel")
    def sign_in_label(self) -> Optional[_builtins.str]:
        """
        Label of the button to signin
        """
        return pulumi.get(self, "sign_in_label")

    @_builtins.property
    @pulumi.getter(name="smsCarrierDefault")
    def sms_carrier_default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_carrier_default")

    @_builtins.property
    @pulumi.getter(name="smsCarrierError")
    def sms_carrier_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_carrier_error")

    @_builtins.property
    @pulumi.getter(name="smsCarrierFieldLabel")
    def sms_carrier_field_label(self) -> Optional[_builtins.str]:
        """
        Label for mobile carrier drop-down list
        """
        return pulumi.get(self, "sms_carrier_field_label")

    @_builtins.property
    @pulumi.getter(name="smsCodeCancel")
    def sms_code_cancel(self) -> Optional[_builtins.str]:
        """
        Label for cancel confirmation code submission
        """
        return pulumi.get(self, "sms_code_cancel")

    @_builtins.property
    @pulumi.getter(name="smsCodeError")
    def sms_code_error(self) -> Optional[_builtins.str]:
        """
        Error message when confirmation code is invalid
        """
        return pulumi.get(self, "sms_code_error")

    @_builtins.property
    @pulumi.getter(name="smsCodeFieldLabel")
    def sms_code_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_code_field_label")

    @_builtins.property
    @pulumi.getter(name="smsCodeMessage")
    def sms_code_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_code_message")

    @_builtins.property
    @pulumi.getter(name="smsCodeSubmit")
    def sms_code_submit(self) -> Optional[_builtins.str]:
        """
        Label for confirmation code submit button
        """
        return pulumi.get(self, "sms_code_submit")

    @_builtins.property
    @pulumi.getter(name="smsCodeTitle")
    def sms_code_title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_code_title")

    @_builtins.property
    @pulumi.getter(name="smsCountryFieldLabel")
    def sms_country_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_country_field_label")

    @_builtins.property
    @pulumi.getter(name="smsCountryFormat")
    def sms_country_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_country_format")

    @_builtins.property
    @pulumi.getter(name="smsHaveAccessCode")
    def sms_have_access_code(self) -> Optional[_builtins.str]:
        """
        Label for checkbox to specify that the user has access code
        """
        return pulumi.get(self, "sms_have_access_code")

    @_builtins.property
    @pulumi.getter(name="smsIsTwilio")
    def sms_is_twilio(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "sms_is_twilio")

    @_builtins.property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[_builtins.str]:
        """
        Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        """
        return pulumi.get(self, "sms_message_format")

    @_builtins.property
    @pulumi.getter(name="smsNumberCancel")
    def sms_number_cancel(self) -> Optional[_builtins.str]:
        """
        Label for canceling mobile details for SMS auth
        """
        return pulumi.get(self, "sms_number_cancel")

    @_builtins.property
    @pulumi.getter(name="smsNumberError")
    def sms_number_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_number_error")

    @_builtins.property
    @pulumi.getter(name="smsNumberFieldLabel")
    def sms_number_field_label(self) -> Optional[_builtins.str]:
        """
        Label for field to provide mobile number
        """
        return pulumi.get(self, "sms_number_field_label")

    @_builtins.property
    @pulumi.getter(name="smsNumberFormat")
    def sms_number_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_number_format")

    @_builtins.property
    @pulumi.getter(name="smsNumberMessage")
    def sms_number_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_number_message")

    @_builtins.property
    @pulumi.getter(name="smsNumberSubmit")
    def sms_number_submit(self) -> Optional[_builtins.str]:
        """
        Label for submit button for code generation
        """
        return pulumi.get(self, "sms_number_submit")

    @_builtins.property
    @pulumi.getter(name="smsNumberTitle")
    def sms_number_title(self) -> Optional[_builtins.str]:
        """
        Title for phone number details
        """
        return pulumi.get(self, "sms_number_title")

    @_builtins.property
    @pulumi.getter(name="smsUsernameFormat")
    def sms_username_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_username_format")

    @_builtins.property
    @pulumi.getter(name="smsValidityDuration")
    def sms_validity_duration(self) -> Optional[_builtins.int]:
        """
        How long confirmation code should be considered valid (in minutes)
        """
        return pulumi.get(self, "sms_validity_duration")

    @_builtins.property
    @pulumi.getter(name="sponsorBackLink")
    def sponsor_back_link(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_back_link")

    @_builtins.property
    @pulumi.getter(name="sponsorCancel")
    def sponsor_cancel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_cancel")

    @_builtins.property
    @pulumi.getter(name="sponsorEmail")
    def sponsor_email(self) -> Optional[_builtins.str]:
        """
        Label for Sponsor Email
        """
        return pulumi.get(self, "sponsor_email")

    @_builtins.property
    @pulumi.getter(name="sponsorEmailError")
    def sponsor_email_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_email_error")

    @_builtins.property
    @pulumi.getter(name="sponsorEmailTemplate")
    def sponsor_email_template(self) -> Optional[_builtins.str]:
        """
        HTML template to replace/override default sponsor email template 
        Sponsor Email Template supports following template variables:
          * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
          * `deny_url`: Renders URL to reject the request
          * `guest_email`: Renders Email ID of the guest
          * `guest_name`: Renders Name of the guest
          * `field1`: Renders value of the Custom Field 1
          * `field2`: Renders value of the Custom Field 2
          * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
          * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        """
        return pulumi.get(self, "sponsor_email_template")

    @_builtins.property
    @pulumi.getter(name="sponsorInfoApproved")
    def sponsor_info_approved(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_info_approved")

    @_builtins.property
    @pulumi.getter(name="sponsorInfoDenied")
    def sponsor_info_denied(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_info_denied")

    @_builtins.property
    @pulumi.getter(name="sponsorInfoPending")
    def sponsor_info_pending(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_info_pending")

    @_builtins.property
    @pulumi.getter(name="sponsorName")
    def sponsor_name(self) -> Optional[_builtins.str]:
        """
        Label for Sponsor Name
        """
        return pulumi.get(self, "sponsor_name")

    @_builtins.property
    @pulumi.getter(name="sponsorNameError")
    def sponsor_name_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_name_error")

    @_builtins.property
    @pulumi.getter(name="sponsorNotePending")
    def sponsor_note_pending(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_note_pending")

    @_builtins.property
    @pulumi.getter(name="sponsorRequestAccess")
    def sponsor_request_access(self) -> Optional[_builtins.str]:
        """
        Submit button label request Wifi Access and notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_request_access")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusApproved")
    def sponsor_status_approved(self) -> Optional[_builtins.str]:
        """
        Text to display if sponsor approves request
        """
        return pulumi.get(self, "sponsor_status_approved")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusDenied")
    def sponsor_status_denied(self) -> Optional[_builtins.str]:
        """
        Text to display when sponsor denies request
        """
        return pulumi.get(self, "sponsor_status_denied")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusPending")
    def sponsor_status_pending(self) -> Optional[_builtins.str]:
        """
        Text to display if request is still pending
        """
        return pulumi.get(self, "sponsor_status_pending")

    @_builtins.property
    @pulumi.getter(name="sponsorSubmit")
    def sponsor_submit(self) -> Optional[_builtins.str]:
        """
        Submit button label to notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_submit")

    @_builtins.property
    @pulumi.getter(name="sponsorsError")
    def sponsors_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsors_error")

    @_builtins.property
    @pulumi.getter(name="sponsorsFieldLabel")
    def sponsors_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsors_field_label")

    @_builtins.property
    @pulumi.getter
    def tos(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "tos")

    @_builtins.property
    @pulumi.getter(name="tosAcceptLabel")
    def tos_accept_label(self) -> Optional[_builtins.str]:
        """
        Prefix of the label of the link to go to tos
        """
        return pulumi.get(self, "tos_accept_label")

    @_builtins.property
    @pulumi.getter(name="tosError")
    def tos_error(self) -> Optional[_builtins.str]:
        """
        Error message when tos not accepted
        """
        return pulumi.get(self, "tos_error")

    @_builtins.property
    @pulumi.getter(name="tosLink")
    def tos_link(self) -> Optional[_builtins.str]:
        """
        Label of the link to go to tos
        """
        return pulumi.get(self, "tos_link")

    @_builtins.property
    @pulumi.getter(name="tosText")
    def tos_text(self) -> Optional[_builtins.str]:
        """
        Text of the Terms of Service
        """
        return pulumi.get(self, "tos_text")


@pulumi.output_type
class WlanPortalTemplatePortalTemplateLocales(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authButtonAmazon":
            suggest = "auth_button_amazon"
        elif key == "authButtonAzure":
            suggest = "auth_button_azure"
        elif key == "authButtonEmail":
            suggest = "auth_button_email"
        elif key == "authButtonFacebook":
            suggest = "auth_button_facebook"
        elif key == "authButtonGoogle":
            suggest = "auth_button_google"
        elif key == "authButtonMicrosoft":
            suggest = "auth_button_microsoft"
        elif key == "authButtonPassphrase":
            suggest = "auth_button_passphrase"
        elif key == "authButtonSms":
            suggest = "auth_button_sms"
        elif key == "authButtonSponsor":
            suggest = "auth_button_sponsor"
        elif key == "authLabel":
            suggest = "auth_label"
        elif key == "backLink":
            suggest = "back_link"
        elif key == "companyError":
            suggest = "company_error"
        elif key == "companyLabel":
            suggest = "company_label"
        elif key == "emailAccessDomainError":
            suggest = "email_access_domain_error"
        elif key == "emailCancel":
            suggest = "email_cancel"
        elif key == "emailCodeCancel":
            suggest = "email_code_cancel"
        elif key == "emailCodeError":
            suggest = "email_code_error"
        elif key == "emailCodeFieldLabel":
            suggest = "email_code_field_label"
        elif key == "emailCodeMessage":
            suggest = "email_code_message"
        elif key == "emailCodeSubmit":
            suggest = "email_code_submit"
        elif key == "emailCodeTitle":
            suggest = "email_code_title"
        elif key == "emailError":
            suggest = "email_error"
        elif key == "emailFieldLabel":
            suggest = "email_field_label"
        elif key == "emailLabel":
            suggest = "email_label"
        elif key == "emailMessage":
            suggest = "email_message"
        elif key == "emailSubmit":
            suggest = "email_submit"
        elif key == "emailTitle":
            suggest = "email_title"
        elif key == "marketingPolicyLink":
            suggest = "marketing_policy_link"
        elif key == "marketingPolicyOptIn":
            suggest = "marketing_policy_opt_in"
        elif key == "marketingPolicyOptInLabel":
            suggest = "marketing_policy_opt_in_label"
        elif key == "marketingPolicyOptInText":
            suggest = "marketing_policy_opt_in_text"
        elif key == "nameError":
            suggest = "name_error"
        elif key == "nameLabel":
            suggest = "name_label"
        elif key == "optoutLabel":
            suggest = "optout_label"
        elif key == "pageTitle":
            suggest = "page_title"
        elif key == "passphraseCancel":
            suggest = "passphrase_cancel"
        elif key == "passphraseError":
            suggest = "passphrase_error"
        elif key == "passphraseLabel":
            suggest = "passphrase_label"
        elif key == "passphraseMessage":
            suggest = "passphrase_message"
        elif key == "passphraseSubmit":
            suggest = "passphrase_submit"
        elif key == "passphraseTitle":
            suggest = "passphrase_title"
        elif key == "privacyPolicyAcceptLabel":
            suggest = "privacy_policy_accept_label"
        elif key == "privacyPolicyError":
            suggest = "privacy_policy_error"
        elif key == "privacyPolicyLink":
            suggest = "privacy_policy_link"
        elif key == "privacyPolicyText":
            suggest = "privacy_policy_text"
        elif key == "requiredFieldLabel":
            suggest = "required_field_label"
        elif key == "signInLabel":
            suggest = "sign_in_label"
        elif key == "smsCarrierDefault":
            suggest = "sms_carrier_default"
        elif key == "smsCarrierError":
            suggest = "sms_carrier_error"
        elif key == "smsCarrierFieldLabel":
            suggest = "sms_carrier_field_label"
        elif key == "smsCodeCancel":
            suggest = "sms_code_cancel"
        elif key == "smsCodeError":
            suggest = "sms_code_error"
        elif key == "smsCodeFieldLabel":
            suggest = "sms_code_field_label"
        elif key == "smsCodeMessage":
            suggest = "sms_code_message"
        elif key == "smsCodeSubmit":
            suggest = "sms_code_submit"
        elif key == "smsCodeTitle":
            suggest = "sms_code_title"
        elif key == "smsCountryFieldLabel":
            suggest = "sms_country_field_label"
        elif key == "smsCountryFormat":
            suggest = "sms_country_format"
        elif key == "smsHaveAccessCode":
            suggest = "sms_have_access_code"
        elif key == "smsMessageFormat":
            suggest = "sms_message_format"
        elif key == "smsNumberCancel":
            suggest = "sms_number_cancel"
        elif key == "smsNumberError":
            suggest = "sms_number_error"
        elif key == "smsNumberFieldLabel":
            suggest = "sms_number_field_label"
        elif key == "smsNumberFormat":
            suggest = "sms_number_format"
        elif key == "smsNumberMessage":
            suggest = "sms_number_message"
        elif key == "smsNumberSubmit":
            suggest = "sms_number_submit"
        elif key == "smsNumberTitle":
            suggest = "sms_number_title"
        elif key == "smsUsernameFormat":
            suggest = "sms_username_format"
        elif key == "sponsorBackLink":
            suggest = "sponsor_back_link"
        elif key == "sponsorCancel":
            suggest = "sponsor_cancel"
        elif key == "sponsorEmail":
            suggest = "sponsor_email"
        elif key == "sponsorEmailError":
            suggest = "sponsor_email_error"
        elif key == "sponsorInfoApproved":
            suggest = "sponsor_info_approved"
        elif key == "sponsorInfoDenied":
            suggest = "sponsor_info_denied"
        elif key == "sponsorInfoPending":
            suggest = "sponsor_info_pending"
        elif key == "sponsorName":
            suggest = "sponsor_name"
        elif key == "sponsorNameError":
            suggest = "sponsor_name_error"
        elif key == "sponsorNotePending":
            suggest = "sponsor_note_pending"
        elif key == "sponsorRequestAccess":
            suggest = "sponsor_request_access"
        elif key == "sponsorStatusApproved":
            suggest = "sponsor_status_approved"
        elif key == "sponsorStatusDenied":
            suggest = "sponsor_status_denied"
        elif key == "sponsorStatusPending":
            suggest = "sponsor_status_pending"
        elif key == "sponsorSubmit":
            suggest = "sponsor_submit"
        elif key == "sponsorsError":
            suggest = "sponsors_error"
        elif key == "sponsorsFieldLabel":
            suggest = "sponsors_field_label"
        elif key == "tosAcceptLabel":
            suggest = "tos_accept_label"
        elif key == "tosError":
            suggest = "tos_error"
        elif key == "tosLink":
            suggest = "tos_link"
        elif key == "tosText":
            suggest = "tos_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanPortalTemplatePortalTemplateLocales. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanPortalTemplatePortalTemplateLocales.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanPortalTemplatePortalTemplateLocales.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_button_amazon: Optional[_builtins.str] = None,
                 auth_button_azure: Optional[_builtins.str] = None,
                 auth_button_email: Optional[_builtins.str] = None,
                 auth_button_facebook: Optional[_builtins.str] = None,
                 auth_button_google: Optional[_builtins.str] = None,
                 auth_button_microsoft: Optional[_builtins.str] = None,
                 auth_button_passphrase: Optional[_builtins.str] = None,
                 auth_button_sms: Optional[_builtins.str] = None,
                 auth_button_sponsor: Optional[_builtins.str] = None,
                 auth_label: Optional[_builtins.str] = None,
                 back_link: Optional[_builtins.str] = None,
                 company_error: Optional[_builtins.str] = None,
                 company_label: Optional[_builtins.str] = None,
                 email_access_domain_error: Optional[_builtins.str] = None,
                 email_cancel: Optional[_builtins.str] = None,
                 email_code_cancel: Optional[_builtins.str] = None,
                 email_code_error: Optional[_builtins.str] = None,
                 email_code_field_label: Optional[_builtins.str] = None,
                 email_code_message: Optional[_builtins.str] = None,
                 email_code_submit: Optional[_builtins.str] = None,
                 email_code_title: Optional[_builtins.str] = None,
                 email_error: Optional[_builtins.str] = None,
                 email_field_label: Optional[_builtins.str] = None,
                 email_label: Optional[_builtins.str] = None,
                 email_message: Optional[_builtins.str] = None,
                 email_submit: Optional[_builtins.str] = None,
                 email_title: Optional[_builtins.str] = None,
                 field1error: Optional[_builtins.str] = None,
                 field1label: Optional[_builtins.str] = None,
                 field2error: Optional[_builtins.str] = None,
                 field2label: Optional[_builtins.str] = None,
                 field3error: Optional[_builtins.str] = None,
                 field3label: Optional[_builtins.str] = None,
                 field4error: Optional[_builtins.str] = None,
                 field4label: Optional[_builtins.str] = None,
                 marketing_policy_link: Optional[_builtins.str] = None,
                 marketing_policy_opt_in: Optional[_builtins.bool] = None,
                 marketing_policy_opt_in_label: Optional[_builtins.str] = None,
                 marketing_policy_opt_in_text: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 name_error: Optional[_builtins.str] = None,
                 name_label: Optional[_builtins.str] = None,
                 optout_label: Optional[_builtins.str] = None,
                 page_title: Optional[_builtins.str] = None,
                 passphrase_cancel: Optional[_builtins.str] = None,
                 passphrase_error: Optional[_builtins.str] = None,
                 passphrase_label: Optional[_builtins.str] = None,
                 passphrase_message: Optional[_builtins.str] = None,
                 passphrase_submit: Optional[_builtins.str] = None,
                 passphrase_title: Optional[_builtins.str] = None,
                 privacy_policy_accept_label: Optional[_builtins.str] = None,
                 privacy_policy_error: Optional[_builtins.str] = None,
                 privacy_policy_link: Optional[_builtins.str] = None,
                 privacy_policy_text: Optional[_builtins.str] = None,
                 required_field_label: Optional[_builtins.str] = None,
                 sign_in_label: Optional[_builtins.str] = None,
                 sms_carrier_default: Optional[_builtins.str] = None,
                 sms_carrier_error: Optional[_builtins.str] = None,
                 sms_carrier_field_label: Optional[_builtins.str] = None,
                 sms_code_cancel: Optional[_builtins.str] = None,
                 sms_code_error: Optional[_builtins.str] = None,
                 sms_code_field_label: Optional[_builtins.str] = None,
                 sms_code_message: Optional[_builtins.str] = None,
                 sms_code_submit: Optional[_builtins.str] = None,
                 sms_code_title: Optional[_builtins.str] = None,
                 sms_country_field_label: Optional[_builtins.str] = None,
                 sms_country_format: Optional[_builtins.str] = None,
                 sms_have_access_code: Optional[_builtins.str] = None,
                 sms_message_format: Optional[_builtins.str] = None,
                 sms_number_cancel: Optional[_builtins.str] = None,
                 sms_number_error: Optional[_builtins.str] = None,
                 sms_number_field_label: Optional[_builtins.str] = None,
                 sms_number_format: Optional[_builtins.str] = None,
                 sms_number_message: Optional[_builtins.str] = None,
                 sms_number_submit: Optional[_builtins.str] = None,
                 sms_number_title: Optional[_builtins.str] = None,
                 sms_username_format: Optional[_builtins.str] = None,
                 sponsor_back_link: Optional[_builtins.str] = None,
                 sponsor_cancel: Optional[_builtins.str] = None,
                 sponsor_email: Optional[_builtins.str] = None,
                 sponsor_email_error: Optional[_builtins.str] = None,
                 sponsor_info_approved: Optional[_builtins.str] = None,
                 sponsor_info_denied: Optional[_builtins.str] = None,
                 sponsor_info_pending: Optional[_builtins.str] = None,
                 sponsor_name: Optional[_builtins.str] = None,
                 sponsor_name_error: Optional[_builtins.str] = None,
                 sponsor_note_pending: Optional[_builtins.str] = None,
                 sponsor_request_access: Optional[_builtins.str] = None,
                 sponsor_status_approved: Optional[_builtins.str] = None,
                 sponsor_status_denied: Optional[_builtins.str] = None,
                 sponsor_status_pending: Optional[_builtins.str] = None,
                 sponsor_submit: Optional[_builtins.str] = None,
                 sponsors_error: Optional[_builtins.str] = None,
                 sponsors_field_label: Optional[_builtins.str] = None,
                 tos_accept_label: Optional[_builtins.str] = None,
                 tos_error: Optional[_builtins.str] = None,
                 tos_link: Optional[_builtins.str] = None,
                 tos_text: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_button_amazon: Label for Amazon auth button
        :param _builtins.str auth_button_azure: Label for Azure auth button
        :param _builtins.str auth_button_email: Label for Email auth button
        :param _builtins.str auth_button_facebook: Label for Facebook auth button
        :param _builtins.str auth_button_google: Label for Google auth button
        :param _builtins.str auth_button_microsoft: Label for Microsoft auth button
        :param _builtins.str auth_button_passphrase: Label for passphrase auth button
        :param _builtins.str auth_button_sms: Label for SMS auth button
        :param _builtins.str auth_button_sponsor: Label for Sponsor auth button
        :param _builtins.str back_link: Label of the link to go back to /logon
        :param _builtins.str company_error: Error message when company not provided
        :param _builtins.str company_label: Label of company field
        :param _builtins.str email_access_domain_error: Error message when a user has valid social login but doesn't match specified email domains.
        :param _builtins.str email_cancel: Label for cancel confirmation code submission using email auth
        :param _builtins.str email_error: Error message when email not provided
        :param _builtins.str email_label: Label of email field
        :param _builtins.str email_submit: Label for confirmation code submit button using email auth
        :param _builtins.str email_title: Title for the Email registration
        :param _builtins.str field1error: Error message when field1 not provided
        :param _builtins.str field1label: Label of field1
        :param _builtins.str field2error: Error message when field2 not provided
        :param _builtins.str field2label: Label of field2
        :param _builtins.str field3error: Error message when field3 not provided
        :param _builtins.str field3label: Label of field3
        :param _builtins.str field4error: Error message when field4 not provided
        :param _builtins.str field4label: Label of field4
        :param _builtins.str marketing_policy_link: label of the link to go to /marketing_policy
        :param _builtins.bool marketing_policy_opt_in: Whether marketing policy optin is enabled
        :param _builtins.str marketing_policy_opt_in_label: label for marketing optin
        :param _builtins.str marketing_policy_opt_in_text: marketing policy text
        :param _builtins.str name_error: Error message when name not provided
        :param _builtins.str name_label: Label of name field
        :param _builtins.str optout_label: Label for Do Not Store My Personal Information
        :param _builtins.str passphrase_cancel: Label for the Passphrase cancel button
        :param _builtins.str passphrase_error: Error message when invalid passphrase is provided
        :param _builtins.str passphrase_label: Passphrase
        :param _builtins.str passphrase_submit: Label for the Passphrase submit button
        :param _builtins.str passphrase_title: Title for passphrase details page
        :param _builtins.str privacy_policy_accept_label: Prefix of the label of the link to go to Privacy Policy
        :param _builtins.str privacy_policy_error: Error message when Privacy Policy not accepted
        :param _builtins.str privacy_policy_link: Label of the link to go to Privacy Policy
        :param _builtins.str privacy_policy_text: Text of the Privacy Policy
        :param _builtins.str required_field_label: Label to denote required field
        :param _builtins.str sign_in_label: Label of the button to signin
        :param _builtins.str sms_carrier_field_label: Label for mobile carrier drop-down list
        :param _builtins.str sms_code_cancel: Label for cancel confirmation code submission
        :param _builtins.str sms_code_error: Error message when confirmation code is invalid
        :param _builtins.str sms_code_submit: Label for confirmation code submit button
        :param _builtins.str sms_have_access_code: Label for checkbox to specify that the user has access code
        :param _builtins.str sms_message_format: Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        :param _builtins.str sms_number_cancel: Label for canceling mobile details for SMS auth
        :param _builtins.str sms_number_field_label: Label for field to provide mobile number
        :param _builtins.str sms_number_submit: Label for submit button for code generation
        :param _builtins.str sms_number_title: Title for phone number details
        :param _builtins.str sponsor_email: Label for Sponsor Email
        :param _builtins.str sponsor_name: Label for Sponsor Name
        :param _builtins.str sponsor_request_access: Submit button label request Wifi Access and notify sponsor about guest request
        :param _builtins.str sponsor_status_approved: Text to display if sponsor approves request
        :param _builtins.str sponsor_status_denied: Text to display when sponsor denies request
        :param _builtins.str sponsor_status_pending: Text to display if request is still pending
        :param _builtins.str sponsor_submit: Submit button label to notify sponsor about guest request
        :param _builtins.str tos_accept_label: Prefix of the label of the link to go to tos
        :param _builtins.str tos_error: Error message when tos not accepted
        :param _builtins.str tos_link: Label of the link to go to tos
        :param _builtins.str tos_text: Text of the Terms of Service
        """
        if auth_button_amazon is not None:
            pulumi.set(__self__, "auth_button_amazon", auth_button_amazon)
        if auth_button_azure is not None:
            pulumi.set(__self__, "auth_button_azure", auth_button_azure)
        if auth_button_email is not None:
            pulumi.set(__self__, "auth_button_email", auth_button_email)
        if auth_button_facebook is not None:
            pulumi.set(__self__, "auth_button_facebook", auth_button_facebook)
        if auth_button_google is not None:
            pulumi.set(__self__, "auth_button_google", auth_button_google)
        if auth_button_microsoft is not None:
            pulumi.set(__self__, "auth_button_microsoft", auth_button_microsoft)
        if auth_button_passphrase is not None:
            pulumi.set(__self__, "auth_button_passphrase", auth_button_passphrase)
        if auth_button_sms is not None:
            pulumi.set(__self__, "auth_button_sms", auth_button_sms)
        if auth_button_sponsor is not None:
            pulumi.set(__self__, "auth_button_sponsor", auth_button_sponsor)
        if auth_label is not None:
            pulumi.set(__self__, "auth_label", auth_label)
        if back_link is not None:
            pulumi.set(__self__, "back_link", back_link)
        if company_error is not None:
            pulumi.set(__self__, "company_error", company_error)
        if company_label is not None:
            pulumi.set(__self__, "company_label", company_label)
        if email_access_domain_error is not None:
            pulumi.set(__self__, "email_access_domain_error", email_access_domain_error)
        if email_cancel is not None:
            pulumi.set(__self__, "email_cancel", email_cancel)
        if email_code_cancel is not None:
            pulumi.set(__self__, "email_code_cancel", email_code_cancel)
        if email_code_error is not None:
            pulumi.set(__self__, "email_code_error", email_code_error)
        if email_code_field_label is not None:
            pulumi.set(__self__, "email_code_field_label", email_code_field_label)
        if email_code_message is not None:
            pulumi.set(__self__, "email_code_message", email_code_message)
        if email_code_submit is not None:
            pulumi.set(__self__, "email_code_submit", email_code_submit)
        if email_code_title is not None:
            pulumi.set(__self__, "email_code_title", email_code_title)
        if email_error is not None:
            pulumi.set(__self__, "email_error", email_error)
        if email_field_label is not None:
            pulumi.set(__self__, "email_field_label", email_field_label)
        if email_label is not None:
            pulumi.set(__self__, "email_label", email_label)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_submit is not None:
            pulumi.set(__self__, "email_submit", email_submit)
        if email_title is not None:
            pulumi.set(__self__, "email_title", email_title)
        if field1error is not None:
            pulumi.set(__self__, "field1error", field1error)
        if field1label is not None:
            pulumi.set(__self__, "field1label", field1label)
        if field2error is not None:
            pulumi.set(__self__, "field2error", field2error)
        if field2label is not None:
            pulumi.set(__self__, "field2label", field2label)
        if field3error is not None:
            pulumi.set(__self__, "field3error", field3error)
        if field3label is not None:
            pulumi.set(__self__, "field3label", field3label)
        if field4error is not None:
            pulumi.set(__self__, "field4error", field4error)
        if field4label is not None:
            pulumi.set(__self__, "field4label", field4label)
        if marketing_policy_link is not None:
            pulumi.set(__self__, "marketing_policy_link", marketing_policy_link)
        if marketing_policy_opt_in is not None:
            pulumi.set(__self__, "marketing_policy_opt_in", marketing_policy_opt_in)
        if marketing_policy_opt_in_label is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_label", marketing_policy_opt_in_label)
        if marketing_policy_opt_in_text is not None:
            pulumi.set(__self__, "marketing_policy_opt_in_text", marketing_policy_opt_in_text)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name_error is not None:
            pulumi.set(__self__, "name_error", name_error)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if optout_label is not None:
            pulumi.set(__self__, "optout_label", optout_label)
        if page_title is not None:
            pulumi.set(__self__, "page_title", page_title)
        if passphrase_cancel is not None:
            pulumi.set(__self__, "passphrase_cancel", passphrase_cancel)
        if passphrase_error is not None:
            pulumi.set(__self__, "passphrase_error", passphrase_error)
        if passphrase_label is not None:
            pulumi.set(__self__, "passphrase_label", passphrase_label)
        if passphrase_message is not None:
            pulumi.set(__self__, "passphrase_message", passphrase_message)
        if passphrase_submit is not None:
            pulumi.set(__self__, "passphrase_submit", passphrase_submit)
        if passphrase_title is not None:
            pulumi.set(__self__, "passphrase_title", passphrase_title)
        if privacy_policy_accept_label is not None:
            pulumi.set(__self__, "privacy_policy_accept_label", privacy_policy_accept_label)
        if privacy_policy_error is not None:
            pulumi.set(__self__, "privacy_policy_error", privacy_policy_error)
        if privacy_policy_link is not None:
            pulumi.set(__self__, "privacy_policy_link", privacy_policy_link)
        if privacy_policy_text is not None:
            pulumi.set(__self__, "privacy_policy_text", privacy_policy_text)
        if required_field_label is not None:
            pulumi.set(__self__, "required_field_label", required_field_label)
        if sign_in_label is not None:
            pulumi.set(__self__, "sign_in_label", sign_in_label)
        if sms_carrier_default is not None:
            pulumi.set(__self__, "sms_carrier_default", sms_carrier_default)
        if sms_carrier_error is not None:
            pulumi.set(__self__, "sms_carrier_error", sms_carrier_error)
        if sms_carrier_field_label is not None:
            pulumi.set(__self__, "sms_carrier_field_label", sms_carrier_field_label)
        if sms_code_cancel is not None:
            pulumi.set(__self__, "sms_code_cancel", sms_code_cancel)
        if sms_code_error is not None:
            pulumi.set(__self__, "sms_code_error", sms_code_error)
        if sms_code_field_label is not None:
            pulumi.set(__self__, "sms_code_field_label", sms_code_field_label)
        if sms_code_message is not None:
            pulumi.set(__self__, "sms_code_message", sms_code_message)
        if sms_code_submit is not None:
            pulumi.set(__self__, "sms_code_submit", sms_code_submit)
        if sms_code_title is not None:
            pulumi.set(__self__, "sms_code_title", sms_code_title)
        if sms_country_field_label is not None:
            pulumi.set(__self__, "sms_country_field_label", sms_country_field_label)
        if sms_country_format is not None:
            pulumi.set(__self__, "sms_country_format", sms_country_format)
        if sms_have_access_code is not None:
            pulumi.set(__self__, "sms_have_access_code", sms_have_access_code)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_number_cancel is not None:
            pulumi.set(__self__, "sms_number_cancel", sms_number_cancel)
        if sms_number_error is not None:
            pulumi.set(__self__, "sms_number_error", sms_number_error)
        if sms_number_field_label is not None:
            pulumi.set(__self__, "sms_number_field_label", sms_number_field_label)
        if sms_number_format is not None:
            pulumi.set(__self__, "sms_number_format", sms_number_format)
        if sms_number_message is not None:
            pulumi.set(__self__, "sms_number_message", sms_number_message)
        if sms_number_submit is not None:
            pulumi.set(__self__, "sms_number_submit", sms_number_submit)
        if sms_number_title is not None:
            pulumi.set(__self__, "sms_number_title", sms_number_title)
        if sms_username_format is not None:
            pulumi.set(__self__, "sms_username_format", sms_username_format)
        if sponsor_back_link is not None:
            pulumi.set(__self__, "sponsor_back_link", sponsor_back_link)
        if sponsor_cancel is not None:
            pulumi.set(__self__, "sponsor_cancel", sponsor_cancel)
        if sponsor_email is not None:
            pulumi.set(__self__, "sponsor_email", sponsor_email)
        if sponsor_email_error is not None:
            pulumi.set(__self__, "sponsor_email_error", sponsor_email_error)
        if sponsor_info_approved is not None:
            pulumi.set(__self__, "sponsor_info_approved", sponsor_info_approved)
        if sponsor_info_denied is not None:
            pulumi.set(__self__, "sponsor_info_denied", sponsor_info_denied)
        if sponsor_info_pending is not None:
            pulumi.set(__self__, "sponsor_info_pending", sponsor_info_pending)
        if sponsor_name is not None:
            pulumi.set(__self__, "sponsor_name", sponsor_name)
        if sponsor_name_error is not None:
            pulumi.set(__self__, "sponsor_name_error", sponsor_name_error)
        if sponsor_note_pending is not None:
            pulumi.set(__self__, "sponsor_note_pending", sponsor_note_pending)
        if sponsor_request_access is not None:
            pulumi.set(__self__, "sponsor_request_access", sponsor_request_access)
        if sponsor_status_approved is not None:
            pulumi.set(__self__, "sponsor_status_approved", sponsor_status_approved)
        if sponsor_status_denied is not None:
            pulumi.set(__self__, "sponsor_status_denied", sponsor_status_denied)
        if sponsor_status_pending is not None:
            pulumi.set(__self__, "sponsor_status_pending", sponsor_status_pending)
        if sponsor_submit is not None:
            pulumi.set(__self__, "sponsor_submit", sponsor_submit)
        if sponsors_error is not None:
            pulumi.set(__self__, "sponsors_error", sponsors_error)
        if sponsors_field_label is not None:
            pulumi.set(__self__, "sponsors_field_label", sponsors_field_label)
        if tos_accept_label is not None:
            pulumi.set(__self__, "tos_accept_label", tos_accept_label)
        if tos_error is not None:
            pulumi.set(__self__, "tos_error", tos_error)
        if tos_link is not None:
            pulumi.set(__self__, "tos_link", tos_link)
        if tos_text is not None:
            pulumi.set(__self__, "tos_text", tos_text)

    @_builtins.property
    @pulumi.getter(name="authButtonAmazon")
    def auth_button_amazon(self) -> Optional[_builtins.str]:
        """
        Label for Amazon auth button
        """
        return pulumi.get(self, "auth_button_amazon")

    @_builtins.property
    @pulumi.getter(name="authButtonAzure")
    def auth_button_azure(self) -> Optional[_builtins.str]:
        """
        Label for Azure auth button
        """
        return pulumi.get(self, "auth_button_azure")

    @_builtins.property
    @pulumi.getter(name="authButtonEmail")
    def auth_button_email(self) -> Optional[_builtins.str]:
        """
        Label for Email auth button
        """
        return pulumi.get(self, "auth_button_email")

    @_builtins.property
    @pulumi.getter(name="authButtonFacebook")
    def auth_button_facebook(self) -> Optional[_builtins.str]:
        """
        Label for Facebook auth button
        """
        return pulumi.get(self, "auth_button_facebook")

    @_builtins.property
    @pulumi.getter(name="authButtonGoogle")
    def auth_button_google(self) -> Optional[_builtins.str]:
        """
        Label for Google auth button
        """
        return pulumi.get(self, "auth_button_google")

    @_builtins.property
    @pulumi.getter(name="authButtonMicrosoft")
    def auth_button_microsoft(self) -> Optional[_builtins.str]:
        """
        Label for Microsoft auth button
        """
        return pulumi.get(self, "auth_button_microsoft")

    @_builtins.property
    @pulumi.getter(name="authButtonPassphrase")
    def auth_button_passphrase(self) -> Optional[_builtins.str]:
        """
        Label for passphrase auth button
        """
        return pulumi.get(self, "auth_button_passphrase")

    @_builtins.property
    @pulumi.getter(name="authButtonSms")
    def auth_button_sms(self) -> Optional[_builtins.str]:
        """
        Label for SMS auth button
        """
        return pulumi.get(self, "auth_button_sms")

    @_builtins.property
    @pulumi.getter(name="authButtonSponsor")
    def auth_button_sponsor(self) -> Optional[_builtins.str]:
        """
        Label for Sponsor auth button
        """
        return pulumi.get(self, "auth_button_sponsor")

    @_builtins.property
    @pulumi.getter(name="authLabel")
    def auth_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auth_label")

    @_builtins.property
    @pulumi.getter(name="backLink")
    def back_link(self) -> Optional[_builtins.str]:
        """
        Label of the link to go back to /logon
        """
        return pulumi.get(self, "back_link")

    @_builtins.property
    @pulumi.getter(name="companyError")
    def company_error(self) -> Optional[_builtins.str]:
        """
        Error message when company not provided
        """
        return pulumi.get(self, "company_error")

    @_builtins.property
    @pulumi.getter(name="companyLabel")
    def company_label(self) -> Optional[_builtins.str]:
        """
        Label of company field
        """
        return pulumi.get(self, "company_label")

    @_builtins.property
    @pulumi.getter(name="emailAccessDomainError")
    def email_access_domain_error(self) -> Optional[_builtins.str]:
        """
        Error message when a user has valid social login but doesn't match specified email domains.
        """
        return pulumi.get(self, "email_access_domain_error")

    @_builtins.property
    @pulumi.getter(name="emailCancel")
    def email_cancel(self) -> Optional[_builtins.str]:
        """
        Label for cancel confirmation code submission using email auth
        """
        return pulumi.get(self, "email_cancel")

    @_builtins.property
    @pulumi.getter(name="emailCodeCancel")
    def email_code_cancel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_cancel")

    @_builtins.property
    @pulumi.getter(name="emailCodeError")
    def email_code_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_error")

    @_builtins.property
    @pulumi.getter(name="emailCodeFieldLabel")
    def email_code_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_field_label")

    @_builtins.property
    @pulumi.getter(name="emailCodeMessage")
    def email_code_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_message")

    @_builtins.property
    @pulumi.getter(name="emailCodeSubmit")
    def email_code_submit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_submit")

    @_builtins.property
    @pulumi.getter(name="emailCodeTitle")
    def email_code_title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_code_title")

    @_builtins.property
    @pulumi.getter(name="emailError")
    def email_error(self) -> Optional[_builtins.str]:
        """
        Error message when email not provided
        """
        return pulumi.get(self, "email_error")

    @_builtins.property
    @pulumi.getter(name="emailFieldLabel")
    def email_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_field_label")

    @_builtins.property
    @pulumi.getter(name="emailLabel")
    def email_label(self) -> Optional[_builtins.str]:
        """
        Label of email field
        """
        return pulumi.get(self, "email_label")

    @_builtins.property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email_message")

    @_builtins.property
    @pulumi.getter(name="emailSubmit")
    def email_submit(self) -> Optional[_builtins.str]:
        """
        Label for confirmation code submit button using email auth
        """
        return pulumi.get(self, "email_submit")

    @_builtins.property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> Optional[_builtins.str]:
        """
        Title for the Email registration
        """
        return pulumi.get(self, "email_title")

    @_builtins.property
    @pulumi.getter
    def field1error(self) -> Optional[_builtins.str]:
        """
        Error message when field1 not provided
        """
        return pulumi.get(self, "field1error")

    @_builtins.property
    @pulumi.getter
    def field1label(self) -> Optional[_builtins.str]:
        """
        Label of field1
        """
        return pulumi.get(self, "field1label")

    @_builtins.property
    @pulumi.getter
    def field2error(self) -> Optional[_builtins.str]:
        """
        Error message when field2 not provided
        """
        return pulumi.get(self, "field2error")

    @_builtins.property
    @pulumi.getter
    def field2label(self) -> Optional[_builtins.str]:
        """
        Label of field2
        """
        return pulumi.get(self, "field2label")

    @_builtins.property
    @pulumi.getter
    def field3error(self) -> Optional[_builtins.str]:
        """
        Error message when field3 not provided
        """
        return pulumi.get(self, "field3error")

    @_builtins.property
    @pulumi.getter
    def field3label(self) -> Optional[_builtins.str]:
        """
        Label of field3
        """
        return pulumi.get(self, "field3label")

    @_builtins.property
    @pulumi.getter
    def field4error(self) -> Optional[_builtins.str]:
        """
        Error message when field4 not provided
        """
        return pulumi.get(self, "field4error")

    @_builtins.property
    @pulumi.getter
    def field4label(self) -> Optional[_builtins.str]:
        """
        Label of field4
        """
        return pulumi.get(self, "field4label")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyLink")
    def marketing_policy_link(self) -> Optional[_builtins.str]:
        """
        label of the link to go to /marketing_policy
        """
        return pulumi.get(self, "marketing_policy_link")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyOptIn")
    def marketing_policy_opt_in(self) -> Optional[_builtins.bool]:
        """
        Whether marketing policy optin is enabled
        """
        return pulumi.get(self, "marketing_policy_opt_in")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyOptInLabel")
    def marketing_policy_opt_in_label(self) -> Optional[_builtins.str]:
        """
        label for marketing optin
        """
        return pulumi.get(self, "marketing_policy_opt_in_label")

    @_builtins.property
    @pulumi.getter(name="marketingPolicyOptInText")
    def marketing_policy_opt_in_text(self) -> Optional[_builtins.str]:
        """
        marketing policy text
        """
        return pulumi.get(self, "marketing_policy_opt_in_text")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="nameError")
    def name_error(self) -> Optional[_builtins.str]:
        """
        Error message when name not provided
        """
        return pulumi.get(self, "name_error")

    @_builtins.property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[_builtins.str]:
        """
        Label of name field
        """
        return pulumi.get(self, "name_label")

    @_builtins.property
    @pulumi.getter(name="optoutLabel")
    def optout_label(self) -> Optional[_builtins.str]:
        """
        Label for Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout_label")

    @_builtins.property
    @pulumi.getter(name="pageTitle")
    def page_title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "page_title")

    @_builtins.property
    @pulumi.getter(name="passphraseCancel")
    def passphrase_cancel(self) -> Optional[_builtins.str]:
        """
        Label for the Passphrase cancel button
        """
        return pulumi.get(self, "passphrase_cancel")

    @_builtins.property
    @pulumi.getter(name="passphraseError")
    def passphrase_error(self) -> Optional[_builtins.str]:
        """
        Error message when invalid passphrase is provided
        """
        return pulumi.get(self, "passphrase_error")

    @_builtins.property
    @pulumi.getter(name="passphraseLabel")
    def passphrase_label(self) -> Optional[_builtins.str]:
        """
        Passphrase
        """
        return pulumi.get(self, "passphrase_label")

    @_builtins.property
    @pulumi.getter(name="passphraseMessage")
    def passphrase_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "passphrase_message")

    @_builtins.property
    @pulumi.getter(name="passphraseSubmit")
    def passphrase_submit(self) -> Optional[_builtins.str]:
        """
        Label for the Passphrase submit button
        """
        return pulumi.get(self, "passphrase_submit")

    @_builtins.property
    @pulumi.getter(name="passphraseTitle")
    def passphrase_title(self) -> Optional[_builtins.str]:
        """
        Title for passphrase details page
        """
        return pulumi.get(self, "passphrase_title")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyAcceptLabel")
    def privacy_policy_accept_label(self) -> Optional[_builtins.str]:
        """
        Prefix of the label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_accept_label")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyError")
    def privacy_policy_error(self) -> Optional[_builtins.str]:
        """
        Error message when Privacy Policy not accepted
        """
        return pulumi.get(self, "privacy_policy_error")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyLink")
    def privacy_policy_link(self) -> Optional[_builtins.str]:
        """
        Label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_link")

    @_builtins.property
    @pulumi.getter(name="privacyPolicyText")
    def privacy_policy_text(self) -> Optional[_builtins.str]:
        """
        Text of the Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_text")

    @_builtins.property
    @pulumi.getter(name="requiredFieldLabel")
    def required_field_label(self) -> Optional[_builtins.str]:
        """
        Label to denote required field
        """
        return pulumi.get(self, "required_field_label")

    @_builtins.property
    @pulumi.getter(name="signInLabel")
    def sign_in_label(self) -> Optional[_builtins.str]:
        """
        Label of the button to signin
        """
        return pulumi.get(self, "sign_in_label")

    @_builtins.property
    @pulumi.getter(name="smsCarrierDefault")
    def sms_carrier_default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_carrier_default")

    @_builtins.property
    @pulumi.getter(name="smsCarrierError")
    def sms_carrier_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_carrier_error")

    @_builtins.property
    @pulumi.getter(name="smsCarrierFieldLabel")
    def sms_carrier_field_label(self) -> Optional[_builtins.str]:
        """
        Label for mobile carrier drop-down list
        """
        return pulumi.get(self, "sms_carrier_field_label")

    @_builtins.property
    @pulumi.getter(name="smsCodeCancel")
    def sms_code_cancel(self) -> Optional[_builtins.str]:
        """
        Label for cancel confirmation code submission
        """
        return pulumi.get(self, "sms_code_cancel")

    @_builtins.property
    @pulumi.getter(name="smsCodeError")
    def sms_code_error(self) -> Optional[_builtins.str]:
        """
        Error message when confirmation code is invalid
        """
        return pulumi.get(self, "sms_code_error")

    @_builtins.property
    @pulumi.getter(name="smsCodeFieldLabel")
    def sms_code_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_code_field_label")

    @_builtins.property
    @pulumi.getter(name="smsCodeMessage")
    def sms_code_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_code_message")

    @_builtins.property
    @pulumi.getter(name="smsCodeSubmit")
    def sms_code_submit(self) -> Optional[_builtins.str]:
        """
        Label for confirmation code submit button
        """
        return pulumi.get(self, "sms_code_submit")

    @_builtins.property
    @pulumi.getter(name="smsCodeTitle")
    def sms_code_title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_code_title")

    @_builtins.property
    @pulumi.getter(name="smsCountryFieldLabel")
    def sms_country_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_country_field_label")

    @_builtins.property
    @pulumi.getter(name="smsCountryFormat")
    def sms_country_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_country_format")

    @_builtins.property
    @pulumi.getter(name="smsHaveAccessCode")
    def sms_have_access_code(self) -> Optional[_builtins.str]:
        """
        Label for checkbox to specify that the user has access code
        """
        return pulumi.get(self, "sms_have_access_code")

    @_builtins.property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[_builtins.str]:
        """
        Format of access code sms message. {{code}} and {{duration}} are placeholders and should be retained as is.
        """
        return pulumi.get(self, "sms_message_format")

    @_builtins.property
    @pulumi.getter(name="smsNumberCancel")
    def sms_number_cancel(self) -> Optional[_builtins.str]:
        """
        Label for canceling mobile details for SMS auth
        """
        return pulumi.get(self, "sms_number_cancel")

    @_builtins.property
    @pulumi.getter(name="smsNumberError")
    def sms_number_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_number_error")

    @_builtins.property
    @pulumi.getter(name="smsNumberFieldLabel")
    def sms_number_field_label(self) -> Optional[_builtins.str]:
        """
        Label for field to provide mobile number
        """
        return pulumi.get(self, "sms_number_field_label")

    @_builtins.property
    @pulumi.getter(name="smsNumberFormat")
    def sms_number_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_number_format")

    @_builtins.property
    @pulumi.getter(name="smsNumberMessage")
    def sms_number_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_number_message")

    @_builtins.property
    @pulumi.getter(name="smsNumberSubmit")
    def sms_number_submit(self) -> Optional[_builtins.str]:
        """
        Label for submit button for code generation
        """
        return pulumi.get(self, "sms_number_submit")

    @_builtins.property
    @pulumi.getter(name="smsNumberTitle")
    def sms_number_title(self) -> Optional[_builtins.str]:
        """
        Title for phone number details
        """
        return pulumi.get(self, "sms_number_title")

    @_builtins.property
    @pulumi.getter(name="smsUsernameFormat")
    def sms_username_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sms_username_format")

    @_builtins.property
    @pulumi.getter(name="sponsorBackLink")
    def sponsor_back_link(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_back_link")

    @_builtins.property
    @pulumi.getter(name="sponsorCancel")
    def sponsor_cancel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_cancel")

    @_builtins.property
    @pulumi.getter(name="sponsorEmail")
    def sponsor_email(self) -> Optional[_builtins.str]:
        """
        Label for Sponsor Email
        """
        return pulumi.get(self, "sponsor_email")

    @_builtins.property
    @pulumi.getter(name="sponsorEmailError")
    def sponsor_email_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_email_error")

    @_builtins.property
    @pulumi.getter(name="sponsorInfoApproved")
    def sponsor_info_approved(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_info_approved")

    @_builtins.property
    @pulumi.getter(name="sponsorInfoDenied")
    def sponsor_info_denied(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_info_denied")

    @_builtins.property
    @pulumi.getter(name="sponsorInfoPending")
    def sponsor_info_pending(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_info_pending")

    @_builtins.property
    @pulumi.getter(name="sponsorName")
    def sponsor_name(self) -> Optional[_builtins.str]:
        """
        Label for Sponsor Name
        """
        return pulumi.get(self, "sponsor_name")

    @_builtins.property
    @pulumi.getter(name="sponsorNameError")
    def sponsor_name_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_name_error")

    @_builtins.property
    @pulumi.getter(name="sponsorNotePending")
    def sponsor_note_pending(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsor_note_pending")

    @_builtins.property
    @pulumi.getter(name="sponsorRequestAccess")
    def sponsor_request_access(self) -> Optional[_builtins.str]:
        """
        Submit button label request Wifi Access and notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_request_access")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusApproved")
    def sponsor_status_approved(self) -> Optional[_builtins.str]:
        """
        Text to display if sponsor approves request
        """
        return pulumi.get(self, "sponsor_status_approved")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusDenied")
    def sponsor_status_denied(self) -> Optional[_builtins.str]:
        """
        Text to display when sponsor denies request
        """
        return pulumi.get(self, "sponsor_status_denied")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusPending")
    def sponsor_status_pending(self) -> Optional[_builtins.str]:
        """
        Text to display if request is still pending
        """
        return pulumi.get(self, "sponsor_status_pending")

    @_builtins.property
    @pulumi.getter(name="sponsorSubmit")
    def sponsor_submit(self) -> Optional[_builtins.str]:
        """
        Submit button label to notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_submit")

    @_builtins.property
    @pulumi.getter(name="sponsorsError")
    def sponsors_error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsors_error")

    @_builtins.property
    @pulumi.getter(name="sponsorsFieldLabel")
    def sponsors_field_label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sponsors_field_label")

    @_builtins.property
    @pulumi.getter(name="tosAcceptLabel")
    def tos_accept_label(self) -> Optional[_builtins.str]:
        """
        Prefix of the label of the link to go to tos
        """
        return pulumi.get(self, "tos_accept_label")

    @_builtins.property
    @pulumi.getter(name="tosError")
    def tos_error(self) -> Optional[_builtins.str]:
        """
        Error message when tos not accepted
        """
        return pulumi.get(self, "tos_error")

    @_builtins.property
    @pulumi.getter(name="tosLink")
    def tos_link(self) -> Optional[_builtins.str]:
        """
        Label of the link to go to tos
        """
        return pulumi.get(self, "tos_link")

    @_builtins.property
    @pulumi.getter(name="tosText")
    def tos_text(self) -> Optional[_builtins.str]:
        """
        Text of the Terms of Service
        """
        return pulumi.get(self, "tos_text")


@pulumi.output_type
class WlanQos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanQos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanQos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanQos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_: Optional[_builtins.str] = None,
                 overwrite: Optional[_builtins.bool] = None):
        """
        :param _builtins.str class_: enum: `background`, `best_effort`, `video`, `voice`
        :param _builtins.bool overwrite: Whether to overwrite QoS
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[_builtins.str]:
        """
        enum: `background`, `best_effort`, `video`, `voice`
        """
        return pulumi.get(self, "class_")

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> Optional[_builtins.bool]:
        """
        Whether to overwrite QoS
        """
        return pulumi.get(self, "overwrite")


@pulumi.output_type
class WlanRadsec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "mxclusterIds":
            suggest = "mxcluster_ids"
        elif key == "proxyHosts":
            suggest = "proxy_hosts"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "useMxedge":
            suggest = "use_mxedge"
        elif key == "useSiteMxedge":
            suggest = "use_site_mxedge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanRadsec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanRadsec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanRadsec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coa_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idle_timeout: Optional[_builtins.str] = None,
                 mxcluster_ids: Optional[Sequence[_builtins.str]] = None,
                 proxy_hosts: Optional[Sequence[_builtins.str]] = None,
                 server_name: Optional[_builtins.str] = None,
                 servers: Optional[Sequence['outputs.WlanRadsecServer']] = None,
                 use_mxedge: Optional[_builtins.bool] = None,
                 use_site_mxedge: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        :param Sequence[_builtins.str] proxy_hosts: Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        :param _builtins.str server_name: Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param Sequence['WlanRadsecServerArgs'] servers: List of RadSec Servers. Only if not Mist Edge.
        :param _builtins.bool use_mxedge: use mxedge(s) as RadSec Proxy
        :param _builtins.bool use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if mxcluster_ids is not None:
            pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        if proxy_hosts is not None:
            pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if use_mxedge is not None:
            pulumi.set(__self__, "use_mxedge", use_mxedge)
        if use_site_mxedge is not None:
            pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @_builtins.property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        """
        return pulumi.get(self, "proxy_hosts")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.WlanRadsecServer']]:
        """
        List of RadSec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> Optional[_builtins.bool]:
        """
        use mxedge(s) as RadSec Proxy
        """
        return pulumi.get(self, "use_mxedge")

    @_builtins.property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> Optional[_builtins.bool]:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")


@pulumi.output_type
class WlanRadsecServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanRateset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minRssi":
            suggest = "min_rssi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanRateset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanRateset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanRateset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eht: Optional[_builtins.str] = None,
                 he: Optional[_builtins.str] = None,
                 ht: Optional[_builtins.str] = None,
                 legacies: Optional[Sequence[_builtins.str]] = None,
                 min_rssi: Optional[_builtins.int] = None,
                 template: Optional[_builtins.str] = None,
                 vht: Optional[_builtins.str] = None):
        """
        :param _builtins.str eht: If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        :param _builtins.str he: If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        :param _builtins.str ht: If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        :param Sequence[_builtins.str] legacies: if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
        :param _builtins.int min_rssi: Minimum RSSI for client to connect, 0 means not enforcing
        :param _builtins.str template: Data Rates template to apply. enum: 
                 * `no-legacy`: no 11b
                 * `compatible`: all, like before, default setting that Broadcom/Atheros used
                 * `legacy-only`: disable 802.11n and 802.11ac
                 * `high-density`: no 11b, no low rates
                 * `custom`: user defined
        :param _builtins.str vht: If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
        if eht is not None:
            pulumi.set(__self__, "eht", eht)
        if he is not None:
            pulumi.set(__self__, "he", he)
        if ht is not None:
            pulumi.set(__self__, "ht", ht)
        if legacies is not None:
            pulumi.set(__self__, "legacies", legacies)
        if min_rssi is not None:
            pulumi.set(__self__, "min_rssi", min_rssi)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if vht is not None:
            pulumi.set(__self__, "vht", vht)

    @_builtins.property
    @pulumi.getter
    def eht(self) -> Optional[_builtins.str]:
        """
        If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        """
        return pulumi.get(self, "eht")

    @_builtins.property
    @pulumi.getter
    def he(self) -> Optional[_builtins.str]:
        """
        If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        """
        return pulumi.get(self, "he")

    @_builtins.property
    @pulumi.getter
    def ht(self) -> Optional[_builtins.str]:
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        """
        return pulumi.get(self, "ht")

    @_builtins.property
    @pulumi.getter
    def legacies(self) -> Optional[Sequence[_builtins.str]]:
        """
        if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
        """
        return pulumi.get(self, "legacies")

    @_builtins.property
    @pulumi.getter(name="minRssi")
    def min_rssi(self) -> Optional[_builtins.int]:
        """
        Minimum RSSI for client to connect, 0 means not enforcing
        """
        return pulumi.get(self, "min_rssi")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        Data Rates template to apply. enum: 
          * `no-legacy`: no 11b
          * `compatible`: all, like before, default setting that Broadcom/Atheros used
          * `legacy-only`: disable 802.11n and 802.11ac
          * `high-density`: no 11b, no low rates
          * `custom`: user defined
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter
    def vht(self) -> Optional[_builtins.str]:
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
        return pulumi.get(self, "vht")


@pulumi.output_type
class WlanSchedule(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 hours: Optional['outputs.WlanScheduleHours'] = None):
        """
        :param 'WlanScheduleHoursArgs' hours: Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional['outputs.WlanScheduleHours']:
        """
        Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
        return pulumi.get(self, "hours")


@pulumi.output_type
class WlanScheduleHours(dict):
    def __init__(__self__, *,
                 fri: Optional[_builtins.str] = None,
                 mon: Optional[_builtins.str] = None,
                 sat: Optional[_builtins.str] = None,
                 sun: Optional[_builtins.str] = None,
                 thu: Optional[_builtins.str] = None,
                 tue: Optional[_builtins.str] = None,
                 wed: Optional[_builtins.str] = None):
        """
        :param _builtins.str fri: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str mon: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str sat: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str sun: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str thu: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str tue: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str wed: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @_builtins.property
    @pulumi.getter
    def fri(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "fri")

    @_builtins.property
    @pulumi.getter
    def mon(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "mon")

    @_builtins.property
    @pulumi.getter
    def sat(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "sat")

    @_builtins.property
    @pulumi.getter
    def sun(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "sun")

    @_builtins.property
    @pulumi.getter
    def thu(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "thu")

    @_builtins.property
    @pulumi.getter
    def tue(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "tue")

    @_builtins.property
    @pulumi.getter
    def wed(self) -> Optional[_builtins.str]:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "wed")


@pulumi.output_type
class WlantemplateApplies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orgId":
            suggest = "org_id"
        elif key == "siteIds":
            suggest = "site_ids"
        elif key == "sitegroupIds":
            suggest = "sitegroup_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlantemplateApplies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlantemplateApplies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlantemplateApplies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 org_id: Optional[_builtins.str] = None,
                 site_ids: Optional[Sequence[_builtins.str]] = None,
                 sitegroup_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] site_ids: List of site ids
        :param Sequence[_builtins.str] sitegroup_ids: List of sitegroup ids
        """
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of site ids
        """
        return pulumi.get(self, "site_ids")

    @_builtins.property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of sitegroup ids
        """
        return pulumi.get(self, "sitegroup_ids")


@pulumi.output_type
class WlantemplateExceptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteIds":
            suggest = "site_ids"
        elif key == "sitegroupIds":
            suggest = "sitegroup_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlantemplateExceptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlantemplateExceptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlantemplateExceptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_ids: Optional[Sequence[_builtins.str]] = None,
                 sitegroup_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] site_ids: List of site ids
        :param Sequence[_builtins.str] sitegroup_ids: List of sitegroup ids
        """
        if site_ids is not None:
            pulumi.set(__self__, "site_ids", site_ids)
        if sitegroup_ids is not None:
            pulumi.set(__self__, "sitegroup_ids", sitegroup_ids)

    @_builtins.property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of site ids
        """
        return pulumi.get(self, "site_ids")

    @_builtins.property
    @pulumi.getter(name="sitegroupIds")
    def sitegroup_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of sitegroup ids
        """
        return pulumi.get(self, "sitegroup_ids")


@pulumi.output_type
class WxtagSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WxtagSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WxtagSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WxtagSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_range: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 subnets: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str port_range: Matched destination port, "0" means any
        :param _builtins.str protocol: tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        :param Sequence[_builtins.str] subnets: Matched destination subnets and/or IP Addresses
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        Matched destination port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        Matched destination subnets and/or IP Addresses
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetAlarmtemplatesOrgAlarmtemplateResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 delivery: 'outputs.GetAlarmtemplatesOrgAlarmtemplateDeliveryResult',
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 rules: Mapping[str, 'outputs.GetAlarmtemplatesOrgAlarmtemplateRulesResult']):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param 'GetAlarmtemplatesOrgAlarmtemplateDeliveryArgs' delivery: Delivery object to configure the alarm delivery
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str name: Some string to name the alarm template
        :param Mapping[str, 'GetAlarmtemplatesOrgAlarmtemplateRulesArgs'] rules: Alarm Rules object to configure the individual alarm keys/types. Property key is the alarm name.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "delivery", delivery)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def delivery(self) -> 'outputs.GetAlarmtemplatesOrgAlarmtemplateDeliveryResult':
        """
        Delivery object to configure the alarm delivery
        """
        return pulumi.get(self, "delivery")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Some string to name the alarm template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Mapping[str, 'outputs.GetAlarmtemplatesOrgAlarmtemplateRulesResult']:
        """
        Alarm Rules object to configure the individual alarm keys/types. Property key is the alarm name.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetAlarmtemplatesOrgAlarmtemplateDeliveryResult(dict):
    def __init__(__self__, *,
                 additional_emails: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 to_org_admins: _builtins.bool,
                 to_site_admins: _builtins.bool):
        """
        :param Sequence[_builtins.str] additional_emails: List of additional email string to deliver the alarms via emails
        :param _builtins.bool enabled: Whether to enable the alarm delivery via emails or not
        :param _builtins.bool to_org_admins: Whether to deliver the alarms via emails to Org admins or not
        :param _builtins.bool to_site_admins: Whether to deliver the alarms via emails to Site admins or not
        """
        pulumi.set(__self__, "additional_emails", additional_emails)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "to_org_admins", to_org_admins)
        pulumi.set(__self__, "to_site_admins", to_site_admins)

    @_builtins.property
    @pulumi.getter(name="additionalEmails")
    def additional_emails(self) -> Sequence[_builtins.str]:
        """
        List of additional email string to deliver the alarms via emails
        """
        return pulumi.get(self, "additional_emails")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the alarm delivery via emails or not
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="toOrgAdmins")
    def to_org_admins(self) -> _builtins.bool:
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        return pulumi.get(self, "to_org_admins")

    @_builtins.property
    @pulumi.getter(name="toSiteAdmins")
    def to_site_admins(self) -> _builtins.bool:
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
        return pulumi.get(self, "to_site_admins")


@pulumi.output_type
class GetAlarmtemplatesOrgAlarmtemplateRulesResult(dict):
    def __init__(__self__, *,
                 delivery: 'outputs.GetAlarmtemplatesOrgAlarmtemplateRulesDeliveryResult',
                 enabled: _builtins.bool):
        """
        :param 'GetAlarmtemplatesOrgAlarmtemplateRulesDeliveryArgs' delivery: Delivery object to configure the alarm delivery
        """
        pulumi.set(__self__, "delivery", delivery)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def delivery(self) -> 'outputs.GetAlarmtemplatesOrgAlarmtemplateRulesDeliveryResult':
        """
        Delivery object to configure the alarm delivery
        """
        return pulumi.get(self, "delivery")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetAlarmtemplatesOrgAlarmtemplateRulesDeliveryResult(dict):
    def __init__(__self__, *,
                 additional_emails: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 to_org_admins: _builtins.bool,
                 to_site_admins: _builtins.bool):
        """
        :param Sequence[_builtins.str] additional_emails: List of additional email string to deliver the alarms via emails
        :param _builtins.bool enabled: Whether to enable the alarm delivery via emails or not
        :param _builtins.bool to_org_admins: Whether to deliver the alarms via emails to Org admins or not
        :param _builtins.bool to_site_admins: Whether to deliver the alarms via emails to Site admins or not
        """
        pulumi.set(__self__, "additional_emails", additional_emails)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "to_org_admins", to_org_admins)
        pulumi.set(__self__, "to_site_admins", to_site_admins)

    @_builtins.property
    @pulumi.getter(name="additionalEmails")
    def additional_emails(self) -> Sequence[_builtins.str]:
        """
        List of additional email string to deliver the alarms via emails
        """
        return pulumi.get(self, "additional_emails")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the alarm delivery via emails or not
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="toOrgAdmins")
    def to_org_admins(self) -> _builtins.bool:
        """
        Whether to deliver the alarms via emails to Org admins or not
        """
        return pulumi.get(self, "to_org_admins")

    @_builtins.property
    @pulumi.getter(name="toSiteAdmins")
    def to_site_admins(self) -> _builtins.bool:
        """
        Whether to deliver the alarms via emails to Site admins or not
        """
        return pulumi.get(self, "to_site_admins")


@pulumi.output_type
class GetAvprofilesOrgAvprofileResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 fallback_action: _builtins.str,
                 id: _builtins.str,
                 max_filesize: _builtins.int,
                 mime_whitelists: Sequence[_builtins.str],
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 protocols: Sequence[_builtins.str],
                 url_whitelists: Sequence[_builtins.str]):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str fallback_action: enum: `block`, `permit`
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.int max_filesize: In KB
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param Sequence[_builtins.str] protocols: List of protocols to monitor. enum: `ftp`, `http`, `imap`, `pop3`, `smtp`
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "fallback_action", fallback_action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_filesize", max_filesize)
        pulumi.set(__self__, "mime_whitelists", mime_whitelists)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "protocols", protocols)
        pulumi.set(__self__, "url_whitelists", url_whitelists)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> _builtins.str:
        """
        enum: `block`, `permit`
        """
        return pulumi.get(self, "fallback_action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maxFilesize")
    def max_filesize(self) -> _builtins.int:
        """
        In KB
        """
        return pulumi.get(self, "max_filesize")

    @_builtins.property
    @pulumi.getter(name="mimeWhitelists")
    def mime_whitelists(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "mime_whitelists")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Sequence[_builtins.str]:
        """
        List of protocols to monitor. enum: `ftp`, `http`, `imap`, `pop3`, `smtp`
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="urlWhitelists")
    def url_whitelists(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "url_whitelists")


@pulumi.output_type
class GetDeviceprofilesApDeviceprofileResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str):
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetDeviceprofilesGatewayDeviceprofileResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str):
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetEvpnTopologiesOrgEvpnTopologyResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 evpn_options: 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsResult',
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 pod_names: Mapping[str, _builtins.str]):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param 'GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsArgs' evpn_options: EVPN Options
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param Mapping[str, _builtins.str] pod_names: Property key is the pod number
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "evpn_options", evpn_options)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "pod_names", pod_names)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="evpnOptions")
    def evpn_options(self) -> 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsResult':
        """
        EVPN Options
        """
        return pulumi.get(self, "evpn_options")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="podNames")
    def pod_names(self) -> Mapping[str, _builtins.str]:
        """
        Property key is the pod number
        """
        return pulumi.get(self, "pod_names")


@pulumi.output_type
class GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsResult(dict):
    def __init__(__self__, *,
                 auto_loopback_subnet: _builtins.str,
                 auto_loopback_subnet6: _builtins.str,
                 auto_router_id_subnet: _builtins.str,
                 auto_router_id_subnet6: _builtins.str,
                 core_as_border: _builtins.bool,
                 overlay: 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsOverlayResult',
                 per_vlan_vga_v4_mac: _builtins.bool,
                 per_vlan_vga_v6_mac: _builtins.bool,
                 routed_at: _builtins.str,
                 underlay: 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsUnderlayResult',
                 vs_instances: Mapping[str, 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsVsInstancesResult']):
        """
        :param _builtins.str auto_loopback_subnet: Optional, for dhcp*relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server*id-overrides
        :param _builtins.str auto_loopback_subnet6: Optional, for dhcp*relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server*id-overrides
        :param _builtins.str auto_router_id_subnet: Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        :param _builtins.str auto_router_id_subnet6: Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        :param _builtins.bool core_as_border: Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        :param _builtins.bool per_vlan_vga_v4_mac: Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4*mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan*id/256, YY=vlan_id%256)
        :param _builtins.bool per_vlan_vga_v6_mac: Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6*mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan*id/256, YY=vlan_id%256)
        :param _builtins.str routed_at: optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        :param Mapping[str, 'GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsVsInstancesArgs'] vs_instances: Optional, for EX9200 only to segregate virtual-switches
        """
        pulumi.set(__self__, "auto_loopback_subnet", auto_loopback_subnet)
        pulumi.set(__self__, "auto_loopback_subnet6", auto_loopback_subnet6)
        pulumi.set(__self__, "auto_router_id_subnet", auto_router_id_subnet)
        pulumi.set(__self__, "auto_router_id_subnet6", auto_router_id_subnet6)
        pulumi.set(__self__, "core_as_border", core_as_border)
        pulumi.set(__self__, "overlay", overlay)
        pulumi.set(__self__, "per_vlan_vga_v4_mac", per_vlan_vga_v4_mac)
        pulumi.set(__self__, "per_vlan_vga_v6_mac", per_vlan_vga_v6_mac)
        pulumi.set(__self__, "routed_at", routed_at)
        pulumi.set(__self__, "underlay", underlay)
        pulumi.set(__self__, "vs_instances", vs_instances)

    @_builtins.property
    @pulumi.getter(name="autoLoopbackSubnet")
    def auto_loopback_subnet(self) -> _builtins.str:
        """
        Optional, for dhcp*relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server*id-overrides
        """
        return pulumi.get(self, "auto_loopback_subnet")

    @_builtins.property
    @pulumi.getter(name="autoLoopbackSubnet6")
    def auto_loopback_subnet6(self) -> _builtins.str:
        """
        Optional, for dhcp*relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server*id-overrides
        """
        return pulumi.get(self, "auto_loopback_subnet6")

    @_builtins.property
    @pulumi.getter(name="autoRouterIdSubnet")
    def auto_router_id_subnet(self) -> _builtins.str:
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        return pulumi.get(self, "auto_router_id_subnet")

    @_builtins.property
    @pulumi.getter(name="autoRouterIdSubnet6")
    def auto_router_id_subnet6(self) -> _builtins.str:
        """
        Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored
        """
        return pulumi.get(self, "auto_router_id_subnet6")

    @_builtins.property
    @pulumi.getter(name="coreAsBorder")
    def core_as_border(self) -> _builtins.bool:
        """
        Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well
        """
        return pulumi.get(self, "core_as_border")

    @_builtins.property
    @pulumi.getter
    def overlay(self) -> 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsOverlayResult':
        return pulumi.get(self, "overlay")

    @_builtins.property
    @pulumi.getter(name="perVlanVgaV4Mac")
    def per_vlan_vga_v4_mac(self) -> _builtins.bool:
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4*mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan*id/256, YY=vlan_id%256)
        """
        return pulumi.get(self, "per_vlan_vga_v4_mac")

    @_builtins.property
    @pulumi.getter(name="perVlanVgaV6Mac")
    def per_vlan_vga_v6_mac(self) -> _builtins.bool:
        """
        Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6*mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan*id/256, YY=vlan_id%256)
        """
        return pulumi.get(self, "per_vlan_vga_v6_mac")

    @_builtins.property
    @pulumi.getter(name="routedAt")
    def routed_at(self) -> _builtins.str:
        """
        optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
        """
        return pulumi.get(self, "routed_at")

    @_builtins.property
    @pulumi.getter
    def underlay(self) -> 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsUnderlayResult':
        return pulumi.get(self, "underlay")

    @_builtins.property
    @pulumi.getter(name="vsInstances")
    def vs_instances(self) -> Mapping[str, 'outputs.GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsVsInstancesResult']:
        """
        Optional, for EX9200 only to segregate virtual-switches
        """
        return pulumi.get(self, "vs_instances")


@pulumi.output_type
class GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsOverlayResult(dict):
    def __init__(__self__, *,
                 as_: _builtins.int):
        """
        :param _builtins.int as_: Overlay BGP Local AS Number
        """
        pulumi.set(__self__, "as_", as_)

    @_builtins.property
    @pulumi.getter(name="as")
    def as_(self) -> _builtins.int:
        """
        Overlay BGP Local AS Number
        """
        return pulumi.get(self, "as_")


@pulumi.output_type
class GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsUnderlayResult(dict):
    def __init__(__self__, *,
                 as_base: _builtins.int,
                 routed_id_prefix: _builtins.str,
                 subnet: _builtins.str,
                 use_ipv6: _builtins.bool):
        """
        :param _builtins.int as_base: Underlay BGP Base AS Number
        :param _builtins.str subnet: Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        :param _builtins.bool use_ipv6: If v6 is desired for underlay
        """
        pulumi.set(__self__, "as_base", as_base)
        pulumi.set(__self__, "routed_id_prefix", routed_id_prefix)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "use_ipv6", use_ipv6)

    @_builtins.property
    @pulumi.getter(name="asBase")
    def as_base(self) -> _builtins.int:
        """
        Underlay BGP Base AS Number
        """
        return pulumi.get(self, "as_base")

    @_builtins.property
    @pulumi.getter(name="routedIdPrefix")
    def routed_id_prefix(self) -> _builtins.str:
        return pulumi.get(self, "routed_id_prefix")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="useIpv6")
    def use_ipv6(self) -> _builtins.bool:
        """
        If v6 is desired for underlay
        """
        return pulumi.get(self, "use_ipv6")


@pulumi.output_type
class GetEvpnTopologiesOrgEvpnTopologyEvpnOptionsVsInstancesResult(dict):
    def __init__(__self__, *,
                 networks: Sequence[_builtins.str]):
        pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class GetGatewaytemplatesOrgGatewaytemplateResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str):
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetIdpprofilesOrgIdpprofileResult(dict):
    def __init__(__self__, *,
                 base_profile: _builtins.str,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 overwrites: Sequence['outputs.GetIdpprofilesOrgIdpprofileOverwriteResult']):
        """
        :param _builtins.str base_profile: enum: `critical`, `standard`, `strict`
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        """
        pulumi.set(__self__, "base_profile", base_profile)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "overwrites", overwrites)

    @_builtins.property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> _builtins.str:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Sequence['outputs.GetIdpprofilesOrgIdpprofileOverwriteResult']:
        return pulumi.get(self, "overwrites")


@pulumi.output_type
class GetIdpprofilesOrgIdpprofileOverwriteResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 matching: 'outputs.GetIdpprofilesOrgIdpprofileOverwriteMatchingResult',
                 name: _builtins.str):
        """
        :param _builtins.str action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "matching", matching)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> 'outputs.GetIdpprofilesOrgIdpprofileOverwriteMatchingResult':
        return pulumi.get(self, "matching")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetIdpprofilesOrgIdpprofileOverwriteMatchingResult(dict):
    def __init__(__self__, *,
                 attack_names: Sequence[_builtins.str],
                 dst_subnets: Sequence[_builtins.str],
                 severities: Sequence[_builtins.str]):
        pulumi.set(__self__, "attack_names", attack_names)
        pulumi.set(__self__, "dst_subnets", dst_subnets)
        pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "attack_names")

    @_builtins.property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dst_subnets")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "severities")


@pulumi.output_type
class GetInventoryOrgInventoryResult(dict):
    def __init__(__self__, *,
                 adopted: _builtins.bool,
                 claim_code: _builtins.str,
                 connected: _builtins.bool,
                 deviceprofile_id: _builtins.str,
                 hostname: _builtins.str,
                 hw_rev: _builtins.str,
                 id: _builtins.str,
                 jsi: _builtins.bool,
                 mac: _builtins.str,
                 model: _builtins.str,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 serial: _builtins.str,
                 site_id: _builtins.str,
                 sku: _builtins.str,
                 type: _builtins.str,
                 vc_mac: _builtins.str):
        """
        :param _builtins.bool adopted: Only if `type`==`switch` or `type`==`gateway`, whether the switch/gateway is adopted
        :param _builtins.str claim_code: Device claim code
        :param _builtins.bool connected: Whether the device is connected
        :param _builtins.str deviceprofile_id: Deviceprofile id if assigned, null if not assigned
        :param _builtins.str hostname: Hostname reported by the device
        :param _builtins.str hw_rev: Device hardware revision number
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.str mac: Device MAC address
        :param _builtins.str model: Device model
        :param _builtins.str name: Device name if configured
        :param _builtins.str serial: Device serial
        :param _builtins.str site_id: Site ID where the device is assigned to
        :param _builtins.str sku: Device stock keeping unit
        :param _builtins.str type: enum: `ap`, `gateway`, `switch`
        :param _builtins.str vc_mac: If `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
        pulumi.set(__self__, "adopted", adopted)
        pulumi.set(__self__, "claim_code", claim_code)
        pulumi.set(__self__, "connected", connected)
        pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "hw_rev", hw_rev)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "jsi", jsi)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vc_mac", vc_mac)

    @_builtins.property
    @pulumi.getter
    def adopted(self) -> _builtins.bool:
        """
        Only if `type`==`switch` or `type`==`gateway`, whether the switch/gateway is adopted
        """
        return pulumi.get(self, "adopted")

    @_builtins.property
    @pulumi.getter(name="claimCode")
    def claim_code(self) -> _builtins.str:
        """
        Device claim code
        """
        return pulumi.get(self, "claim_code")

    @_builtins.property
    @pulumi.getter
    def connected(self) -> _builtins.bool:
        """
        Whether the device is connected
        """
        return pulumi.get(self, "connected")

    @_builtins.property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> _builtins.str:
        """
        Deviceprofile id if assigned, null if not assigned
        """
        return pulumi.get(self, "deviceprofile_id")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname reported by the device
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="hwRev")
    def hw_rev(self) -> _builtins.str:
        """
        Device hardware revision number
        """
        return pulumi.get(self, "hw_rev")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def jsi(self) -> _builtins.bool:
        return pulumi.get(self, "jsi")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Device MAC address
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Device model
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Device name if configured
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Device serial
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        """
        Site ID where the device is assigned to
        """
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> _builtins.str:
        """
        Device stock keeping unit
        """
        return pulumi.get(self, "sku")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `ap`, `gateway`, `switch`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vcMac")
    def vc_mac(self) -> _builtins.str:
        """
        If `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Cluster, MAC Address of the Cluster
        """
        return pulumi.get(self, "vc_mac")


@pulumi.output_type
class GetNacEndpointsOrgUsermacResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 labels: Sequence[_builtins.str],
                 mac: _builtins.str,
                 name: _builtins.str,
                 notes: _builtins.str,
                 radius_group: _builtins.str,
                 vlan: _builtins.str):
        """
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.str mac: Only non-local-admin MAC is accepted
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "radius_group", radius_group)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Only non-local-admin MAC is accepted
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> _builtins.str:
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> _builtins.str:
        return pulumi.get(self, "radius_group")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.str:
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetNacrulesOrgNacruleResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 enabled: _builtins.bool,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 order: _builtins.int,
                 org_id: _builtins.str):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.bool enabled: Enabled or not
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.int order: Order of the rule, lower value implies higher priority
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enabled or not
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        """
        Order of the rule, lower value implies higher priority
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetNactagsOrgNactagResult(dict):
    def __init__(__self__, *,
                 allow_usermac_override: _builtins.bool,
                 created_time: _builtins.float,
                 egress_vlan_names: Sequence[_builtins.str],
                 gbp_tag: _builtins.str,
                 id: _builtins.str,
                 match: _builtins.str,
                 match_all: _builtins.bool,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 radius_attrs: Sequence[_builtins.str],
                 radius_group: _builtins.str,
                 radius_vendor_attrs: Sequence[_builtins.str],
                 session_timeout: _builtins.int,
                 type: _builtins.str,
                 username_attr: _builtins.str,
                 values: Sequence[_builtins.str],
                 vlan: _builtins.str):
        """
        :param _builtins.bool allow_usermac_override: Can be set to true to allow the override by usermac result
        :param _builtins.float created_time: When the object has been created, in epoch
        :param Sequence[_builtins.str] egress_vlan_names: If `type`==`egress_vlan_names`, list of egress vlans to return
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.str match: if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`, `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
        :param _builtins.bool match_all: This field is applicable only when `type`==`match`
                 * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
                 * `true`: means all values should be matched (i.e., match-all behavior)
               
               
               Currently it makes sense to set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param Sequence[_builtins.str] radius_attrs: If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". 
               It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
               Note that it is allowed to have more than one radius_attrs in the result of a given rule.
        :param _builtins.str radius_group: If `type`==`radius_group`
        :param Sequence[_builtins.str] radius_vendor_attrs: If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field "radius_vendor_attrs". 
               It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
               Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        :param _builtins.int session_timeout: If `type`==`session_timeout, in seconds
        :param _builtins.str type: enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`, `username_attr`, `vlan`
        :param _builtins.str username_attr: enum: `automatic`, `cn`, `dns`, `email`, `upn`
        :param Sequence[_builtins.str] values: If `type`==`match`
        :param _builtins.str vlan: If `type`==`vlan`
        """
        pulumi.set(__self__, "allow_usermac_override", allow_usermac_override)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "egress_vlan_names", egress_vlan_names)
        pulumi.set(__self__, "gbp_tag", gbp_tag)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "match_all", match_all)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "radius_attrs", radius_attrs)
        pulumi.set(__self__, "radius_group", radius_group)
        pulumi.set(__self__, "radius_vendor_attrs", radius_vendor_attrs)
        pulumi.set(__self__, "session_timeout", session_timeout)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "username_attr", username_attr)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "vlan", vlan)

    @_builtins.property
    @pulumi.getter(name="allowUsermacOverride")
    def allow_usermac_override(self) -> _builtins.bool:
        """
        Can be set to true to allow the override by usermac result
        """
        return pulumi.get(self, "allow_usermac_override")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="egressVlanNames")
    def egress_vlan_names(self) -> Sequence[_builtins.str]:
        """
        If `type`==`egress_vlan_names`, list of egress vlans to return
        """
        return pulumi.get(self, "egress_vlan_names")

    @_builtins.property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> _builtins.str:
        return pulumi.get(self, "gbp_tag")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`, `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="matchAll")
    def match_all(self) -> _builtins.bool:
        """
        This field is applicable only when `type`==`match`
          * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
          * `true`: means all values should be matched (i.e., match-all behavior)


        Currently it makes sense to set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`
        """
        return pulumi.get(self, "match_all")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="radiusAttrs")
    def radius_attrs(self) -> Sequence[_builtins.str]:
        """
        If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". 
        It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
        Note that it is allowed to have more than one radius_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_attrs")

    @_builtins.property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> _builtins.str:
        """
        If `type`==`radius_group`
        """
        return pulumi.get(self, "radius_group")

    @_builtins.property
    @pulumi.getter(name="radiusVendorAttrs")
    def radius_vendor_attrs(self) -> Sequence[_builtins.str]:
        """
        If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field "radius_vendor_attrs". 
        It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
        Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
        """
        return pulumi.get(self, "radius_vendor_attrs")

    @_builtins.property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> _builtins.int:
        """
        If `type`==`session_timeout, in seconds
        """
        return pulumi.get(self, "session_timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`, `username_attr`, `vlan`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="usernameAttr")
    def username_attr(self) -> _builtins.str:
        """
        enum: `automatic`, `cn`, `dns`, `email`, `upn`
        """
        return pulumi.get(self, "username_attr")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        If `type`==`match`
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.str:
        """
        If `type`==`vlan`
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetNetworksOrgNetworkResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 disallow_mist_services: _builtins.bool,
                 gateway: _builtins.str,
                 gateway6: _builtins.str,
                 id: _builtins.str,
                 internal_access: 'outputs.GetNetworksOrgNetworkInternalAccessResult',
                 internet_access: 'outputs.GetNetworksOrgNetworkInternetAccessResult',
                 isolation: _builtins.bool,
                 modified_time: _builtins.float,
                 multicast: 'outputs.GetNetworksOrgNetworkMulticastResult',
                 name: _builtins.str,
                 org_id: _builtins.str,
                 routed_for_networks: Sequence[_builtins.str],
                 subnet: _builtins.str,
                 subnet6: _builtins.str,
                 tenants: Mapping[str, 'outputs.GetNetworksOrgNetworkTenantsResult'],
                 vlan_id: _builtins.str,
                 vpn_access: Mapping[str, 'outputs.GetNetworksOrgNetworkVpnAccessResult']):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.bool disallow_mist_services: Whether to disallow Mist Devices in the network
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param 'GetNetworksOrgNetworkInternetAccessArgs' internet_access: Whether this network has direct internet access
        :param _builtins.bool isolation: Whether to allow clients in the network to talk to each other
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param 'GetNetworksOrgNetworkMulticastArgs' multicast: Whether to enable multicast support (only PIM-sparse mode is supported)
        :param Sequence[_builtins.str] routed_for_networks: For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param Mapping[str, 'GetNetworksOrgNetworkTenantsArgs'] tenants: Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        :param Mapping[str, 'GetNetworksOrgNetworkVpnAccessArgs'] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "gateway6", gateway6)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internal_access", internal_access)
        pulumi.set(__self__, "internet_access", internet_access)
        pulumi.set(__self__, "isolation", isolation)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "multicast", multicast)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "subnet6", subnet6)
        pulumi.set(__self__, "tenants", tenants)
        pulumi.set(__self__, "vlan_id", vlan_id)
        pulumi.set(__self__, "vpn_access", vpn_access)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> _builtins.bool:
        """
        Whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> _builtins.str:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> 'outputs.GetNetworksOrgNetworkInternalAccessResult':
        return pulumi.get(self, "internal_access")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> 'outputs.GetNetworksOrgNetworkInternetAccessResult':
        """
        Whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> _builtins.bool:
        """
        Whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> 'outputs.GetNetworksOrgNetworkMulticastResult':
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Sequence[_builtins.str]:
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def subnet6(self) -> _builtins.str:
        return pulumi.get(self, "subnet6")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkTenantsResult']:
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "tenants")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkVpnAccessResult']:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")


@pulumi.output_type
class GetNetworksOrgNetworkInternalAccessResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetNetworksOrgNetworkInternetAccessResult(dict):
    def __init__(__self__, *,
                 create_simple_service_policy: _builtins.bool,
                 destination_nat: Mapping[str, 'outputs.GetNetworksOrgNetworkInternetAccessDestinationNatResult'],
                 enabled: _builtins.bool,
                 restricted: _builtins.bool,
                 static_nat: Mapping[str, 'outputs.GetNetworksOrgNetworkInternetAccessStaticNatResult']):
        """
        :param Mapping[str, 'GetNetworksOrgNetworkInternetAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.bool restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param Mapping[str, 'GetNetworksOrgNetworkInternetAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        pulumi.set(__self__, "destination_nat", destination_nat)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "restricted", restricted)
        pulumi.set(__self__, "static_nat", static_nat)

    @_builtins.property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> _builtins.bool:
        return pulumi.get(self, "create_simple_service_policy")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkInternetAccessDestinationNatResult']:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def restricted(self) -> _builtins.bool:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkInternetAccessStaticNatResult']:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")


@pulumi.output_type
class GetNetworksOrgNetworkInternetAccessDestinationNatResult(dict):
    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.str,
                 wan_name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> _builtins.str:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GetNetworksOrgNetworkInternetAccessStaticNatResult(dict):
    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 wan_name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> _builtins.str:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GetNetworksOrgNetworkMulticastResult(dict):
    def __init__(__self__, *,
                 disable_igmp: _builtins.bool,
                 enabled: _builtins.bool,
                 groups: Mapping[str, 'outputs.GetNetworksOrgNetworkMulticastGroupsResult']):
        """
        :param _builtins.bool disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param Mapping[str, 'GetNetworksOrgNetworkMulticastGroupsArgs'] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        pulumi.set(__self__, "disable_igmp", disable_igmp)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> _builtins.bool:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkMulticastGroupsResult']:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class GetNetworksOrgNetworkMulticastGroupsResult(dict):
    def __init__(__self__, *,
                 rp_ip: _builtins.str):
        """
        :param _builtins.str rp_ip: RP (rendezvous point) IP Address
        """
        pulumi.set(__self__, "rp_ip", rp_ip)

    @_builtins.property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> _builtins.str:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")


@pulumi.output_type
class GetNetworksOrgNetworkTenantsResult(dict):
    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "addresses")


@pulumi.output_type
class GetNetworksOrgNetworkVpnAccessResult(dict):
    def __init__(__self__, *,
                 advertised_subnet: _builtins.str,
                 allow_ping: _builtins.bool,
                 destination_nat: Mapping[str, 'outputs.GetNetworksOrgNetworkVpnAccessDestinationNatResult'],
                 nat_pool: _builtins.str,
                 no_readvertise_to_lan_bgp: _builtins.bool,
                 no_readvertise_to_lan_ospf: _builtins.bool,
                 no_readvertise_to_overlay: _builtins.bool,
                 other_vrfs: Sequence[_builtins.str],
                 routed: _builtins.bool,
                 source_nat: 'outputs.GetNetworksOrgNetworkVpnAccessSourceNatResult',
                 static_nat: Mapping[str, 'outputs.GetNetworksOrgNetworkVpnAccessStaticNatResult'],
                 summarized_subnet: _builtins.str,
                 summarized_subnet_to_lan_bgp: _builtins.str,
                 summarized_subnet_to_lan_ospf: _builtins.str):
        """
        :param _builtins.str advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param _builtins.bool allow_ping: Whether to allow ping from vpn into this routed network
        :param Mapping[str, 'GetNetworksOrgNetworkVpnAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.str nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param _builtins.bool no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.bool no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param _builtins.bool no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param Sequence[_builtins.str] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param _builtins.bool routed: Whether this network is routable
        :param 'GetNetworksOrgNetworkVpnAccessSourceNatArgs' source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param Mapping[str, 'GetNetworksOrgNetworkVpnAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param _builtins.str summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.str summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        pulumi.set(__self__, "allow_ping", allow_ping)
        pulumi.set(__self__, "destination_nat", destination_nat)
        pulumi.set(__self__, "nat_pool", nat_pool)
        pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        pulumi.set(__self__, "other_vrfs", other_vrfs)
        pulumi.set(__self__, "routed", routed)
        pulumi.set(__self__, "source_nat", source_nat)
        pulumi.set(__self__, "static_nat", static_nat)
        pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @_builtins.property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> _builtins.str:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @_builtins.property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> _builtins.bool:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkVpnAccessDestinationNatResult']:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> _builtins.str:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> _builtins.bool:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> _builtins.bool:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> _builtins.bool:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Sequence[_builtins.str]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @_builtins.property
    @pulumi.getter
    def routed(self) -> _builtins.bool:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @_builtins.property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> 'outputs.GetNetworksOrgNetworkVpnAccessSourceNatResult':
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Mapping[str, 'outputs.GetNetworksOrgNetworkVpnAccessStaticNatResult']:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> _builtins.str:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> _builtins.str:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> _builtins.str:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")


@pulumi.output_type
class GetNetworksOrgNetworkVpnAccessDestinationNatResult(dict):
    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.str):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetNetworksOrgNetworkVpnAccessSourceNatResult(dict):
    def __init__(__self__, *,
                 external_ip: _builtins.str):
        pulumi.set(__self__, "external_ip", external_ip)

    @_builtins.property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> _builtins.str:
        return pulumi.get(self, "external_ip")


@pulumi.output_type
class GetNetworksOrgNetworkVpnAccessStaticNatResult(dict):
    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNetworktemplatesOrgNetworktemplateResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetPsksOrgPskResult(dict):
    def __init__(__self__, *,
                 admin_sso_id: _builtins.str,
                 created_time: _builtins.float,
                 email: _builtins.str,
                 expire_time: _builtins.int,
                 expiry_notification_time: _builtins.int,
                 id: _builtins.str,
                 mac: _builtins.str,
                 macs: Sequence[_builtins.str],
                 max_usage: _builtins.int,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 note: _builtins.str,
                 notify_expiry: _builtins.bool,
                 notify_on_create_or_edit: _builtins.bool,
                 old_passphrase: _builtins.str,
                 org_id: _builtins.str,
                 passphrase: _builtins.str,
                 role: _builtins.str,
                 ssid: _builtins.str,
                 usage: _builtins.str,
                 vlan_id: _builtins.str):
        """
        :param _builtins.str admin_sso_id: sso id for psk created from psk portal
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str email: email to send psk expiring notifications to
        :param _builtins.int expire_time: Expire time for this PSK key (epoch time in seconds). Default `null` (as no expiration)
        :param _builtins.int expiry_notification_time: Number of days before psk is expired. Used as to when to start sending reminder notification when the psk is about to expire
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.str mac: If `usage`==`single`, the mac that this PSK ties to, empty if `auto-binding`
        :param Sequence[_builtins.str] macs: If `usage`==`macs`, this list contains N number of client mac addresses or mac patterns(1122*) or both. This list is capped at 5000
        :param _builtins.int max_usage: For Org PSK Only. Max concurrent users for this PSK key. Default is 0 (unlimited)
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.bool notify_expiry: If set to true, reminder notification will be sent when psk is about to expire
        :param _builtins.bool notify_on_create_or_edit: If set to true, notification will be sent when psk is created or edited
        :param _builtins.str old_passphrase: previous passphrase of the PSK if it has been rotated
        :param _builtins.str passphrase: passphrase of the PSK (8-63 character or 64 in hex)
        :param _builtins.str ssid: SSID this PSK should be applicable to
        :param _builtins.str usage: enum: `macs`, `multi`, `single`
        """
        pulumi.set(__self__, "admin_sso_id", admin_sso_id)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "expiry_notification_time", expiry_notification_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "macs", macs)
        pulumi.set(__self__, "max_usage", max_usage)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "note", note)
        pulumi.set(__self__, "notify_expiry", notify_expiry)
        pulumi.set(__self__, "notify_on_create_or_edit", notify_on_create_or_edit)
        pulumi.set(__self__, "old_passphrase", old_passphrase)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "ssid", ssid)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="adminSsoId")
    def admin_sso_id(self) -> _builtins.str:
        """
        sso id for psk created from psk portal
        """
        return pulumi.get(self, "admin_sso_id")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        email to send psk expiring notifications to
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> _builtins.int:
        """
        Expire time for this PSK key (epoch time in seconds). Default `null` (as no expiration)
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="expiryNotificationTime")
    def expiry_notification_time(self) -> _builtins.int:
        """
        Number of days before psk is expired. Used as to when to start sending reminder notification when the psk is about to expire
        """
        return pulumi.get(self, "expiry_notification_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        If `usage`==`single`, the mac that this PSK ties to, empty if `auto-binding`
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def macs(self) -> Sequence[_builtins.str]:
        """
        If `usage`==`macs`, this list contains N number of client mac addresses or mac patterns(1122*) or both. This list is capped at 5000
        """
        return pulumi.get(self, "macs")

    @_builtins.property
    @pulumi.getter(name="maxUsage")
    def max_usage(self) -> _builtins.int:
        """
        For Org PSK Only. Max concurrent users for this PSK key. Default is 0 (unlimited)
        """
        return pulumi.get(self, "max_usage")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def note(self) -> _builtins.str:
        return pulumi.get(self, "note")

    @_builtins.property
    @pulumi.getter(name="notifyExpiry")
    def notify_expiry(self) -> _builtins.bool:
        """
        If set to true, reminder notification will be sent when psk is about to expire
        """
        return pulumi.get(self, "notify_expiry")

    @_builtins.property
    @pulumi.getter(name="notifyOnCreateOrEdit")
    def notify_on_create_or_edit(self) -> _builtins.bool:
        """
        If set to true, notification will be sent when psk is created or edited
        """
        return pulumi.get(self, "notify_on_create_or_edit")

    @_builtins.property
    @pulumi.getter(name="oldPassphrase")
    def old_passphrase(self) -> _builtins.str:
        """
        previous passphrase of the PSK if it has been rotated
        """
        return pulumi.get(self, "old_passphrase")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        """
        passphrase of the PSK (8-63 character or 64 in hex)
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> _builtins.str:
        """
        SSID this PSK should be applicable to
        """
        return pulumi.get(self, "ssid")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        enum: `macs`, `multi`, `single`
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetRftemplatesOrgRftemplateResult(dict):
    def __init__(__self__, *,
                 country_code: _builtins.str,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str):
        """
        :param _builtins.str country_code: Optional, country code to use. If specified, this gets applied to all sites using the RF Template
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str name: The name of the RF template
        """
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        """
        Optional, country code to use. If specified, this gets applied to all sites using the RF Template
        """
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the RF template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicyResult(dict):
    def __init__(__self__, *,
                 aamw: 'outputs.GetServicepoliciesOrgServicepolicyAamwResult',
                 action: _builtins.str,
                 antivirus: 'outputs.GetServicepoliciesOrgServicepolicyAntivirusResult',
                 appqoe: 'outputs.GetServicepoliciesOrgServicepolicyAppqoeResult',
                 created_time: _builtins.float,
                 ewfs: Sequence['outputs.GetServicepoliciesOrgServicepolicyEwfResult'],
                 id: _builtins.str,
                 idp: 'outputs.GetServicepoliciesOrgServicepolicyIdpResult',
                 local_routing: _builtins.bool,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 path_preference: _builtins.str,
                 services: Sequence[_builtins.str],
                 ssl_proxy: 'outputs.GetServicepoliciesOrgServicepolicySslProxyResult',
                 tenants: Sequence[_builtins.str]):
        """
        :param 'GetServicepoliciesOrgServicepolicyAamwArgs' aamw: For SRX Only
        :param _builtins.str action: enum: `allow`, `deny`
        :param 'GetServicepoliciesOrgServicepolicyAntivirusArgs' antivirus: For SRX-only
        :param 'GetServicepoliciesOrgServicepolicyAppqoeArgs' appqoe: For SRX Only
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.bool local_routing: access within the same VRF
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str path_preference: By default, we derive all paths available and use them, optionally, you can customize by using `path_preference`
        :param 'GetServicepoliciesOrgServicepolicySslProxyArgs' ssl_proxy: For SRX-only
        """
        pulumi.set(__self__, "aamw", aamw)
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "antivirus", antivirus)
        pulumi.set(__self__, "appqoe", appqoe)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "ewfs", ewfs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "idp", idp)
        pulumi.set(__self__, "local_routing", local_routing)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "path_preference", path_preference)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "ssl_proxy", ssl_proxy)
        pulumi.set(__self__, "tenants", tenants)

    @_builtins.property
    @pulumi.getter
    def aamw(self) -> 'outputs.GetServicepoliciesOrgServicepolicyAamwResult':
        """
        For SRX Only
        """
        return pulumi.get(self, "aamw")

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> 'outputs.GetServicepoliciesOrgServicepolicyAntivirusResult':
        """
        For SRX-only
        """
        return pulumi.get(self, "antivirus")

    @_builtins.property
    @pulumi.getter
    def appqoe(self) -> 'outputs.GetServicepoliciesOrgServicepolicyAppqoeResult':
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def ewfs(self) -> Sequence['outputs.GetServicepoliciesOrgServicepolicyEwfResult']:
        return pulumi.get(self, "ewfs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def idp(self) -> 'outputs.GetServicepoliciesOrgServicepolicyIdpResult':
        return pulumi.get(self, "idp")

    @_builtins.property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> _builtins.bool:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> _builtins.str:
        """
        By default, we derive all paths available and use them, optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sslProxy")
    def ssl_proxy(self) -> 'outputs.GetServicepoliciesOrgServicepolicySslProxyResult':
        """
        For SRX-only
        """
        return pulumi.get(self, "ssl_proxy")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tenants")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicyAamwResult(dict):
    def __init__(__self__, *,
                 aamwprofile_id: _builtins.str,
                 enabled: _builtins.bool,
                 profile: _builtins.str):
        """
        :param _builtins.str aamwprofile_id: org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: enum: `docsonly`, `executables`, `standard`
        """
        pulumi.set(__self__, "aamwprofile_id", aamwprofile_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="aamwprofileId")
    def aamwprofile_id(self) -> _builtins.str:
        """
        org-level Advanced Advance Anti Malware Profile (SkyAtp) Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "aamwprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> _builtins.str:
        """
        enum: `docsonly`, `executables`, `standard`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicyAntivirusResult(dict):
    def __init__(__self__, *,
                 avprofile_id: _builtins.str,
                 enabled: _builtins.bool,
                 profile: _builtins.str):
        """
        :param _builtins.str avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: Default / noftp / httponly / or keys from av_profiles
        """
        pulumi.set(__self__, "avprofile_id", avprofile_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> _builtins.str:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> _builtins.str:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicyAppqoeResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicyEwfResult(dict):
    def __init__(__self__, *,
                 alert_only: _builtins.bool,
                 block_message: _builtins.str,
                 enabled: _builtins.bool,
                 profile: _builtins.str):
        """
        :param _builtins.str profile: enum: `critical`, `standard`, `strict`
        """
        pulumi.set(__self__, "alert_only", alert_only)
        pulumi.set(__self__, "block_message", block_message)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> _builtins.bool:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> _builtins.str:
        return pulumi.get(self, "block_message")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> _builtins.str:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicyIdpResult(dict):
    def __init__(__self__, *,
                 alert_only: _builtins.bool,
                 enabled: _builtins.bool,
                 idpprofile_id: _builtins.str,
                 profile: _builtins.str):
        """
        :param _builtins.str idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param _builtins.str profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        pulumi.set(__self__, "alert_only", alert_only)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> _builtins.bool:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> _builtins.str:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> _builtins.str:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GetServicepoliciesOrgServicepolicySslProxyResult(dict):
    def __init__(__self__, *,
                 ciphers_category: _builtins.str,
                 enabled: _builtins.bool):
        """
        :param _builtins.str ciphers_category: enum: `medium`, `strong`, `weak`
        """
        pulumi.set(__self__, "ciphers_category", ciphers_category)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> _builtins.str:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetServicesOrgServiceResult(dict):
    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 app_categories: Sequence[_builtins.str],
                 app_subcategories: Sequence[_builtins.str],
                 apps: Sequence[_builtins.str],
                 client_limit_down: _builtins.int,
                 client_limit_up: _builtins.int,
                 created_time: _builtins.float,
                 description: _builtins.str,
                 dscp: _builtins.str,
                 failover_policy: _builtins.str,
                 hostnames: Sequence[_builtins.str],
                 id: _builtins.str,
                 max_jitter: _builtins.str,
                 max_latency: _builtins.str,
                 max_loss: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 service_limit_down: _builtins.int,
                 service_limit_up: _builtins.int,
                 sle_enabled: _builtins.bool,
                 specs: Sequence['outputs.GetServicesOrgServiceSpecResult'],
                 ssr_relaxed_tcp_state_enforcement: _builtins.bool,
                 traffic_class: _builtins.str,
                 traffic_type: _builtins.str,
                 type: _builtins.str,
                 urls: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] addresses: If `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        :param Sequence[_builtins.str] app_categories: When `type`==`app_categories`, list of application categories are available through List App Category Definitions
        :param Sequence[_builtins.str] app_subcategories: When `type`==`app_categories`, list of application categories are available through List App Sub Category Definitions
        :param Sequence[_builtins.str] apps: When `type`==`apps`, list of applications are available through:
                 * List Applications
                 * List Gateway Applications
                 * /insight/top_app_by-bytes?wired=true
        :param _builtins.int client_limit_down: 0 means unlimited
        :param _builtins.int client_limit_up: 0 means unlimited
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str failover_policy: enum: `non_revertable`, `none`, `revertable`
        :param Sequence[_builtins.str] hostnames: If `type`==`custom`, web filtering
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.int service_limit_down: 0 means unlimited
        :param _builtins.int service_limit_up: 0 means unlimited
        :param _builtins.bool sle_enabled: Whether to enable measure SLE
        :param Sequence['GetServicesOrgServiceSpecArgs'] specs: When `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        :param _builtins.str traffic_class: when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        :param _builtins.str traffic_type: values from List Traffic Types
        :param _builtins.str type: enum: `app_categories`, `apps`, `custom`, `urls`
        :param Sequence[_builtins.str] urls: When `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "app_categories", app_categories)
        pulumi.set(__self__, "app_subcategories", app_subcategories)
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "client_limit_down", client_limit_down)
        pulumi.set(__self__, "client_limit_up", client_limit_up)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dscp", dscp)
        pulumi.set(__self__, "failover_policy", failover_policy)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "max_jitter", max_jitter)
        pulumi.set(__self__, "max_latency", max_latency)
        pulumi.set(__self__, "max_loss", max_loss)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "service_limit_down", service_limit_down)
        pulumi.set(__self__, "service_limit_up", service_limit_up)
        pulumi.set(__self__, "sle_enabled", sle_enabled)
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "ssr_relaxed_tcp_state_enforcement", ssr_relaxed_tcp_state_enforcement)
        pulumi.set(__self__, "traffic_class", traffic_class)
        pulumi.set(__self__, "traffic_type", traffic_type)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        If `type`==`custom`, ip subnets (e.g. 10.0.0.0/8)
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="appCategories")
    def app_categories(self) -> Sequence[_builtins.str]:
        """
        When `type`==`app_categories`, list of application categories are available through List App Category Definitions
        """
        return pulumi.get(self, "app_categories")

    @_builtins.property
    @pulumi.getter(name="appSubcategories")
    def app_subcategories(self) -> Sequence[_builtins.str]:
        """
        When `type`==`app_categories`, list of application categories are available through List App Sub Category Definitions
        """
        return pulumi.get(self, "app_subcategories")

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Sequence[_builtins.str]:
        """
        When `type`==`apps`, list of applications are available through:
          * List Applications
          * List Gateway Applications
          * /insight/top_app_by-bytes?wired=true
        """
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> _builtins.int:
        """
        0 means unlimited
        """
        return pulumi.get(self, "client_limit_down")

    @_builtins.property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> _builtins.int:
        """
        0 means unlimited
        """
        return pulumi.get(self, "client_limit_up")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> _builtins.str:
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="failoverPolicy")
    def failover_policy(self) -> _builtins.str:
        """
        enum: `non_revertable`, `none`, `revertable`
        """
        return pulumi.get(self, "failover_policy")

    @_builtins.property
    @pulumi.getter
    def hostnames(self) -> Sequence[_builtins.str]:
        """
        If `type`==`custom`, web filtering
        """
        return pulumi.get(self, "hostnames")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> _builtins.str:
        return pulumi.get(self, "max_jitter")

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> _builtins.str:
        return pulumi.get(self, "max_latency")

    @_builtins.property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> _builtins.str:
        return pulumi.get(self, "max_loss")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="serviceLimitDown")
    def service_limit_down(self) -> _builtins.int:
        """
        0 means unlimited
        """
        return pulumi.get(self, "service_limit_down")

    @_builtins.property
    @pulumi.getter(name="serviceLimitUp")
    def service_limit_up(self) -> _builtins.int:
        """
        0 means unlimited
        """
        return pulumi.get(self, "service_limit_up")

    @_builtins.property
    @pulumi.getter(name="sleEnabled")
    def sle_enabled(self) -> _builtins.bool:
        """
        Whether to enable measure SLE
        """
        return pulumi.get(self, "sle_enabled")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetServicesOrgServiceSpecResult']:
        """
        When `type`==`custom`, optional, if it doesn't exist, http and https is assumed
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter(name="ssrRelaxedTcpStateEnforcement")
    def ssr_relaxed_tcp_state_enforcement(self) -> _builtins.bool:
        return pulumi.get(self, "ssr_relaxed_tcp_state_enforcement")

    @_builtins.property
    @pulumi.getter(name="trafficClass")
    def traffic_class(self) -> _builtins.str:
        """
        when `traffic_type`==`custom`. enum: `best_effort`, `high`, `low`, `medium`
        """
        return pulumi.get(self, "traffic_class")

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> _builtins.str:
        """
        values from List Traffic Types
        """
        return pulumi.get(self, "traffic_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `app_categories`, `apps`, `custom`, `urls`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence[_builtins.str]:
        """
        When `type`==`urls`, no need for spec as URL can encode the ports being used
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetServicesOrgServiceSpecResult(dict):
    def __init__(__self__, *,
                 port_range: _builtins.str,
                 protocol: _builtins.str):
        """
        :param _builtins.str port_range: Port number, port range, or variable
        :param _builtins.str protocol: `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> _builtins.str:
        """
        Port number, port range, or variable
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetSitegroupsOrgSitegroupResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 site_ids: Sequence[_builtins.str]):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "site_ids", site_ids)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="siteIds")
    def site_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "site_ids")


@pulumi.output_type
class GetSsoRolesOrgSsoRoleResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 privileges: Sequence['outputs.GetSsoRolesOrgSsoRolePrivilegeResult']):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "privileges", privileges)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def privileges(self) -> Sequence['outputs.GetSsoRolesOrgSsoRolePrivilegeResult']:
        return pulumi.get(self, "privileges")


@pulumi.output_type
class GetSsoRolesOrgSsoRolePrivilegeResult(dict):
    def __init__(__self__, *,
                 role: _builtins.str,
                 scope: _builtins.str,
                 site_id: _builtins.str,
                 sitegroup_id: _builtins.str,
                 views: Sequence[_builtins.str]):
        """
        :param _builtins.str role: access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        :param _builtins.str scope: enum: `org`, `site`, `sitegroup`
        :param _builtins.str site_id: If `scope`==`site`
        :param _builtins.str sitegroup_id: If `scope`==`sitegroup`
        :param Sequence[_builtins.str] views: Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
               You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
               Below are the list of supported UI views. Note that this is UI only feature.  
               
                 | UI View | Required Role | Description |
                 | --- | --- | --- |
                 | `reporting` | `read` | full access to all analytics tools |
                 | `marketing` | `read` | can view analytics and location maps |
                 | `super_observer` | `read` | can view all the organization except the subscription page |
                 | `location` | `write` | can view and manage location maps, can view analytics |
                 | `security` | `write` | can view and manage site labels, policies and security |
                 | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
                 | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
                 | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "sitegroup_id", sitegroup_id)
        pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        enum: `org`, `site`, `sitegroup`
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        """
        If `scope`==`site`
        """
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter(name="sitegroupId")
    def sitegroup_id(self) -> _builtins.str:
        """
        If `scope`==`sitegroup`
        """
        return pulumi.get(self, "sitegroup_id")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Sequence[_builtins.str]:
        """
        Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  
        You can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  
        Below are the list of supported UI views. Note that this is UI only feature.  

          | UI View | Required Role | Description |
          | --- | --- | --- |
          | `reporting` | `read` | full access to all analytics tools |
          | `marketing` | `read` | can view analytics and location maps |
          | `super_observer` | `read` | can view all the organization except the subscription page |
          | `location` | `write` | can view and manage location maps, can view analytics |
          | `security` | `write` | can view and manage site labels, policies and security |
          | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |
          | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |
          | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |
        """
        return pulumi.get(self, "views")


@pulumi.output_type
class GetVpnsOrgVpnResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 path_selection: 'outputs.GetVpnsOrgVpnPathSelectionResult',
                 paths: Mapping[str, 'outputs.GetVpnsOrgVpnPathsResult'],
                 type: _builtins.str):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param 'GetVpnsOrgVpnPathSelectionArgs' path_selection: Only if `type`==`hub_spoke`
        :param Mapping[str, 'GetVpnsOrgVpnPathsArgs'] paths: For `type`==`hub_spoke`, Property key is the VPN name. For `type`==`mesh`, Property key is the Interface name
        :param _builtins.str type: enum: `hub_spoke`, `mesh`
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "path_selection", path_selection)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="pathSelection")
    def path_selection(self) -> 'outputs.GetVpnsOrgVpnPathSelectionResult':
        """
        Only if `type`==`hub_spoke`
        """
        return pulumi.get(self, "path_selection")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Mapping[str, 'outputs.GetVpnsOrgVpnPathsResult']:
        """
        For `type`==`hub_spoke`, Property key is the VPN name. For `type`==`mesh`, Property key is the Interface name
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `hub_spoke`, `mesh`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVpnsOrgVpnPathSelectionResult(dict):
    def __init__(__self__, *,
                 strategy: _builtins.str):
        """
        :param _builtins.str strategy: enum: `disabled`, `simple`, `manual`
        """
        pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> _builtins.str:
        """
        enum: `disabled`, `simple`, `manual`
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetVpnsOrgVpnPathsResult(dict):
    def __init__(__self__, *,
                 bfd_profile: _builtins.str,
                 bfd_use_tunnel_mode: _builtins.bool,
                 ip: _builtins.str,
                 peer_paths: Mapping[str, 'outputs.GetVpnsOrgVpnPathsPeerPathsResult'],
                 pod: _builtins.int,
                 traffic_shaping: 'outputs.GetVpnsOrgVpnPathsTrafficShapingResult'):
        """
        :param _builtins.str bfd_profile: enum: `broadband`, `lte`
        :param _builtins.bool bfd_use_tunnel_mode: If `type`==`mesh` and for SSR only, whether toi use tunnel mode
        :param _builtins.str ip: If different from the wan port
        :param Mapping[str, 'GetVpnsOrgVpnPathsPeerPathsArgs'] peer_paths: If `type`==`mesh`, Property key is the Peer Interface name
        """
        pulumi.set(__self__, "bfd_profile", bfd_profile)
        pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "peer_paths", peer_paths)
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @_builtins.property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> _builtins.str:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @_builtins.property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> _builtins.bool:
        """
        If `type`==`mesh` and for SSR only, whether toi use tunnel mode
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        If different from the wan port
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="peerPaths")
    def peer_paths(self) -> Mapping[str, 'outputs.GetVpnsOrgVpnPathsPeerPathsResult']:
        """
        If `type`==`mesh`, Property key is the Peer Interface name
        """
        return pulumi.get(self, "peer_paths")

    @_builtins.property
    @pulumi.getter
    def pod(self) -> _builtins.int:
        return pulumi.get(self, "pod")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> 'outputs.GetVpnsOrgVpnPathsTrafficShapingResult':
        return pulumi.get(self, "traffic_shaping")


@pulumi.output_type
class GetVpnsOrgVpnPathsPeerPathsResult(dict):
    def __init__(__self__, *,
                 preference: _builtins.int):
        pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> _builtins.int:
        return pulumi.get(self, "preference")


@pulumi.output_type
class GetVpnsOrgVpnPathsTrafficShapingResult(dict):
    def __init__(__self__, *,
                 class_percentages: Sequence[_builtins.int],
                 enabled: _builtins.bool,
                 max_tx_kbps: _builtins.int):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        pulumi.set(__self__, "class_percentages", class_percentages)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Sequence[_builtins.int]:
        """
        percentages for different class of traffic: high / medium / low / best-effort adding up to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> _builtins.int:
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class GetWebhooksOrgWebhookResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 enabled: _builtins.bool,
                 headers: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 oauth2_client_id: _builtins.str,
                 oauth2_client_secret: _builtins.str,
                 oauth2_grant_type: _builtins.str,
                 oauth2_password: _builtins.str,
                 oauth2_scopes: Sequence[_builtins.str],
                 oauth2_token_url: _builtins.str,
                 oauth2_username: _builtins.str,
                 org_id: _builtins.str,
                 secret: _builtins.str,
                 single_event_per_message: _builtins.bool,
                 splunk_token: _builtins.str,
                 topics: Sequence[_builtins.str],
                 type: _builtins.str,
                 url: _builtins.str,
                 verify_cert: _builtins.bool):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.bool enabled: Whether webhook is enabled
        :param Mapping[str, _builtins.str] headers: If `type`=`http-post`, additional custom HTTP headers to add. The headers name and value must be string, total bytes of headers name and value must be less than 1000
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str name: Name of the webhook
        :param _builtins.str oauth2_client_id: Required when `oauth2_grant_type`==`client_credentials`
        :param _builtins.str oauth2_client_secret: Required when `oauth2_grant_type`==`client_credentials`
        :param _builtins.str oauth2_grant_type: required when `type`==`oauth2`. enum: `client_credentials`, `password`
        :param _builtins.str oauth2_password: Required when `oauth2_grant_type`==`password`
        :param Sequence[_builtins.str] oauth2_scopes: Required when `type`==`oauth2`, if provided, will be used in the token request
        :param _builtins.str oauth2_token_url: Required when `type`==`oauth2`
        :param _builtins.str oauth2_username: Required when `oauth2_grant_type`==`password`
        :param _builtins.str secret: Only if `type`=`http-post`
        :param _builtins.bool single_event_per_message: Some solutions may not be able to parse multiple events from a single message (e.g. IBM Qradar, DSM). When set to `true`, only a single event will be sent per message. this feature is only available on certain topics (see List Webhook Topics)
        :param _builtins.str splunk_token: Required if `type`=`splunk`. If splunk_token is not defined for a type Splunk webhook, it will not send, regardless if the webhook receiver is configured to accept it.
        :param Sequence[_builtins.str] topics: List of supported webhook topics available with the API Call List Webhook Topics
        :param _builtins.str type: enum: `aws-sns`, `google-pubsub`, `http-post`, `oauth2`, `splunk`
        :param _builtins.bool verify_cert: When url uses HTTPS, whether to verify the certificate
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        pulumi.set(__self__, "oauth2_grant_type", oauth2_grant_type)
        pulumi.set(__self__, "oauth2_password", oauth2_password)
        pulumi.set(__self__, "oauth2_scopes", oauth2_scopes)
        pulumi.set(__self__, "oauth2_token_url", oauth2_token_url)
        pulumi.set(__self__, "oauth2_username", oauth2_username)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "single_event_per_message", single_event_per_message)
        pulumi.set(__self__, "splunk_token", splunk_token)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "verify_cert", verify_cert)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether webhook is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Mapping[str, _builtins.str]:
        """
        If `type`=`http-post`, additional custom HTTP headers to add. The headers name and value must be string, total bytes of headers name and value must be less than 1000
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the webhook
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> _builtins.str:
        """
        Required when `oauth2_grant_type`==`client_credentials`
        """
        return pulumi.get(self, "oauth2_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> _builtins.str:
        """
        Required when `oauth2_grant_type`==`client_credentials`
        """
        return pulumi.get(self, "oauth2_client_secret")

    @_builtins.property
    @pulumi.getter(name="oauth2GrantType")
    def oauth2_grant_type(self) -> _builtins.str:
        """
        required when `type`==`oauth2`. enum: `client_credentials`, `password`
        """
        return pulumi.get(self, "oauth2_grant_type")

    @_builtins.property
    @pulumi.getter(name="oauth2Password")
    def oauth2_password(self) -> _builtins.str:
        """
        Required when `oauth2_grant_type`==`password`
        """
        return pulumi.get(self, "oauth2_password")

    @_builtins.property
    @pulumi.getter(name="oauth2Scopes")
    def oauth2_scopes(self) -> Sequence[_builtins.str]:
        """
        Required when `type`==`oauth2`, if provided, will be used in the token request
        """
        return pulumi.get(self, "oauth2_scopes")

    @_builtins.property
    @pulumi.getter(name="oauth2TokenUrl")
    def oauth2_token_url(self) -> _builtins.str:
        """
        Required when `type`==`oauth2`
        """
        return pulumi.get(self, "oauth2_token_url")

    @_builtins.property
    @pulumi.getter(name="oauth2Username")
    def oauth2_username(self) -> _builtins.str:
        """
        Required when `oauth2_grant_type`==`password`
        """
        return pulumi.get(self, "oauth2_username")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Only if `type`=`http-post`
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="singleEventPerMessage")
    def single_event_per_message(self) -> _builtins.bool:
        """
        Some solutions may not be able to parse multiple events from a single message (e.g. IBM Qradar, DSM). When set to `true`, only a single event will be sent per message. this feature is only available on certain topics (see List Webhook Topics)
        """
        return pulumi.get(self, "single_event_per_message")

    @_builtins.property
    @pulumi.getter(name="splunkToken")
    def splunk_token(self) -> _builtins.str:
        """
        Required if `type`=`splunk`. If splunk_token is not defined for a type Splunk webhook, it will not send, regardless if the webhook receiver is configured to accept it.
        """
        return pulumi.get(self, "splunk_token")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence[_builtins.str]:
        """
        List of supported webhook topics available with the API Call List Webhook Topics
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `aws-sns`, `google-pubsub`, `http-post`, `oauth2`, `splunk`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> _builtins.bool:
        """
        When url uses HTTPS, whether to verify the certificate
        """
        return pulumi.get(self, "verify_cert")


@pulumi.output_type
class GetWlansOrgWlanResult(dict):
    def __init__(__self__, *,
                 acct_immediate_update: _builtins.bool,
                 acct_interim_interval: _builtins.int,
                 acct_servers: Sequence['outputs.GetWlansOrgWlanAcctServerResult'],
                 airwatch: 'outputs.GetWlansOrgWlanAirwatchResult',
                 allow_ipv6_ndp: _builtins.bool,
                 allow_mdns: _builtins.bool,
                 allow_ssdp: _builtins.bool,
                 ap_ids: Sequence[_builtins.str],
                 app_limit: 'outputs.GetWlansOrgWlanAppLimitResult',
                 app_qos: 'outputs.GetWlansOrgWlanAppQosResult',
                 apply_to: _builtins.str,
                 arp_filter: _builtins.bool,
                 auth: 'outputs.GetWlansOrgWlanAuthResult',
                 auth_server_selection: _builtins.str,
                 auth_servers: Sequence['outputs.GetWlansOrgWlanAuthServerResult'],
                 auth_servers_nas_id: _builtins.str,
                 auth_servers_nas_ip: _builtins.str,
                 auth_servers_retries: _builtins.int,
                 auth_servers_timeout: _builtins.int,
                 band_steer: _builtins.bool,
                 band_steer_force_band5: _builtins.bool,
                 bands: Sequence[_builtins.str],
                 block_blacklist_clients: _builtins.bool,
                 bonjour: 'outputs.GetWlansOrgWlanBonjourResult',
                 cisco_cwa: 'outputs.GetWlansOrgWlanCiscoCwaResult',
                 client_limit_down: _builtins.str,
                 client_limit_down_enabled: _builtins.bool,
                 client_limit_up: _builtins.str,
                 client_limit_up_enabled: _builtins.bool,
                 coa_servers: Sequence['outputs.GetWlansOrgWlanCoaServerResult'],
                 created_time: _builtins.float,
                 disable11ax: _builtins.bool,
                 disable11be: _builtins.bool,
                 disable_ht_vht_rates: _builtins.bool,
                 disable_uapsd: _builtins.bool,
                 disable_v1_roam_notify: _builtins.bool,
                 disable_v2_roam_notify: _builtins.bool,
                 disable_when_gateway_unreachable: _builtins.bool,
                 disable_when_mxtunnel_down: _builtins.bool,
                 disable_wmm: _builtins.bool,
                 dns_server_rewrite: 'outputs.GetWlansOrgWlanDnsServerRewriteResult',
                 dtim: _builtins.int,
                 dynamic_psk: 'outputs.GetWlansOrgWlanDynamicPskResult',
                 dynamic_vlan: 'outputs.GetWlansOrgWlanDynamicVlanResult',
                 enable_local_keycaching: _builtins.bool,
                 enable_wireless_bridging: _builtins.bool,
                 enable_wireless_bridging_dhcp_tracking: _builtins.bool,
                 enabled: _builtins.bool,
                 fast_dot1x_timers: _builtins.bool,
                 hide_ssid: _builtins.bool,
                 hostname_ie: _builtins.bool,
                 hotspot20: 'outputs.GetWlansOrgWlanHotspot20Result',
                 id: _builtins.str,
                 inject_dhcp_option82: 'outputs.GetWlansOrgWlanInjectDhcpOption82Result',
                 interface: _builtins.str,
                 isolation: _builtins.bool,
                 l2_isolation: _builtins.bool,
                 legacy_overds: _builtins.bool,
                 limit_bcast: _builtins.bool,
                 limit_probe_response: _builtins.bool,
                 max_idletime: _builtins.int,
                 max_num_clients: _builtins.int,
                 mist_nac: 'outputs.GetWlansOrgWlanMistNacResult',
                 modified_time: _builtins.float,
                 msp_id: _builtins.str,
                 mxtunnel_ids: Sequence[_builtins.str],
                 mxtunnel_names: Sequence[_builtins.str],
                 no_static_dns: _builtins.bool,
                 no_static_ip: _builtins.bool,
                 org_id: _builtins.str,
                 portal: 'outputs.GetWlansOrgWlanPortalResult',
                 portal_allowed_hostnames: Sequence[_builtins.str],
                 portal_allowed_subnets: Sequence[_builtins.str],
                 portal_api_secret: _builtins.str,
                 portal_denied_hostnames: Sequence[_builtins.str],
                 portal_image: _builtins.str,
                 portal_sso_url: _builtins.str,
                 qos: 'outputs.GetWlansOrgWlanQosResult',
                 radsec: 'outputs.GetWlansOrgWlanRadsecResult',
                 rateset: Mapping[str, 'outputs.GetWlansOrgWlanRatesetResult'],
                 reconnect_clients_when_roaming_mxcluster: _builtins.bool,
                 roam_mode: _builtins.str,
                 schedule: 'outputs.GetWlansOrgWlanScheduleResult',
                 sle_excluded: _builtins.bool,
                 ssid: _builtins.str,
                 template_id: _builtins.str,
                 use_eapol_v1: _builtins.bool,
                 vlan_enabled: _builtins.bool,
                 vlan_id: _builtins.str,
                 vlan_ids: Sequence[_builtins.str],
                 vlan_pooling: _builtins.bool,
                 wlan_limit_down: _builtins.str,
                 wlan_limit_down_enabled: _builtins.bool,
                 wlan_limit_up: _builtins.str,
                 wlan_limit_up_enabled: _builtins.bool,
                 wxtag_ids: Sequence[_builtins.str],
                 wxtunnel_id: _builtins.str,
                 wxtunnel_remote_id: _builtins.str):
        """
        :param _builtins.bool acct_immediate_update: Enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param Sequence['GetWlansOrgWlanAcctServerArgs'] acct_servers: List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param 'GetWlansOrgWlanAirwatchArgs' airwatch: Airwatch wlan settings
        :param _builtins.bool allow_ipv6_ndp: Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param _builtins.bool allow_mdns: Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param _builtins.bool allow_ssdp: Only applicable when `limit_bcast`==`true`, which allows SSDP
        :param Sequence[_builtins.str] ap_ids: List of device ids
        :param 'GetWlansOrgWlanAppLimitArgs' app_limit: Bandwidth limiting for apps (applies to up/down)
        :param 'GetWlansOrgWlanAppQosArgs' app_qos: APp qos wlan settings
        :param _builtins.str apply_to: enum: `aps`, `site`, `wxtags`
        :param _builtins.bool arp_filter: Whether to enable smart arp filter
        :param 'GetWlansOrgWlanAuthArgs' auth: Authentication wlan settings
        :param _builtins.str auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param Sequence['GetWlansOrgWlanAuthServerArgs'] auth_servers: List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
        :param _builtins.str auth_servers_nas_id: Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param _builtins.str auth_servers_nas_ip: Optional, NAS-IP-ADDRESS to use
        :param _builtins.int auth_servers_retries: Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.
        :param _builtins.int auth_servers_timeout: Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.
        :param _builtins.bool band_steer: Whether to enable band_steering, this works only when band==both
        :param _builtins.bool band_steer_force_band5: Force dual_band capable client to connect to 5G
        :param Sequence[_builtins.str] bands: List of radios that the wlan should apply to.
        :param _builtins.bool block_blacklist_clients: Whether to block the clients in the blacklist (up to first 256 macs)
        :param 'GetWlansOrgWlanBonjourArgs' bonjour: Bonjour gateway wlan settings
        :param 'GetWlansOrgWlanCiscoCwaArgs' cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param _builtins.bool client_limit_down_enabled: If downlink limiting per-client is enabled
        :param _builtins.bool client_limit_up_enabled: If uplink limiting per-client is enabled
        :param Sequence['GetWlansOrgWlanCoaServerArgs'] coa_servers: List of COA (change of authorization) servers, optional
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.bool disable11ax: Some old WLAN drivers may not be compatible
        :param _builtins.bool disable11be: To disable Wi-Fi 7 EHT IEs
        :param _builtins.bool disable_ht_vht_rates: To disable ht or vht rates
        :param _builtins.bool disable_uapsd: Whether to disable U-APSD
        :param _builtins.bool disable_v1_roam_notify: Disable sending v2 roam notification messages
        :param _builtins.bool disable_v2_roam_notify: Disable sending v2 roam notification messages
        :param _builtins.bool disable_when_gateway_unreachable: When any of the following is true, this WLAN will be disabled
                  * cannot get IP
                  * cannot obtain default gateway
                  * cannot reach default gateway
        :param _builtins.bool disable_wmm: Whether to disable WMM
        :param 'GetWlansOrgWlanDnsServerRewriteArgs' dns_server_rewrite: For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param 'GetWlansOrgWlanDynamicPskArgs' dynamic_psk: For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
                 * PSK will come from RADIUS server
                 * AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed)
                 * AP sends BSSID:SSID as Caller-Station-ID
                 * `auth_servers` is required
                 * PSK will come from cloud WLC if source is cloud_psks
                 * default_psk will be used if cloud WLC is not available
                 * `multi_psk_only` and `psk` is ignored
                 * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
        :param 'GetWlansOrgWlanDynamicVlanArgs' dynamic_vlan: For 802.1x
        :param _builtins.bool enable_local_keycaching: Enable AP-AP keycaching via multicast
        :param _builtins.bool enable_wireless_bridging: By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        :param _builtins.bool enable_wireless_bridging_dhcp_tracking: If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless
        :param _builtins.bool enabled: If this wlan is enabled
        :param _builtins.bool fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
        :param _builtins.bool hide_ssid: Whether to hide SSID in beacon
        :param _builtins.bool hostname_ie: Include hostname inside IE in AP beacons / probe responses
        :param 'GetWlansOrgWlanHotspot20Args' hotspot20: Hostspot 2.0 wlan settings
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.str interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param _builtins.bool isolation: Whether to stop clients to talk to each other
        :param _builtins.bool l2_isolation: If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param _builtins.bool legacy_overds: Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
        :param _builtins.bool limit_bcast: Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param _builtins.bool limit_probe_response: Limit probe response base on some heuristic rules
        :param _builtins.int max_idletime: Max idle time in seconds
        :param _builtins.int max_num_clients: Maximum number of client connected to the SSID. `0` means unlimited
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param Sequence[_builtins.str] mxtunnel_ids: When `interface`=`mxtunnel`, id of the Mist Tunnel
        :param Sequence[_builtins.str] mxtunnel_names: When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param _builtins.bool no_static_dns: Whether to only allow client to use DNS that we’ve learned from DHCP response
        :param _builtins.bool no_static_ip: Whether to only allow client that we’ve learned from DHCP exchange to talk
        :param 'GetWlansOrgWlanPortalArgs' portal: Portal wlan settings
        :param Sequence[_builtins.str] portal_allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param Sequence[_builtins.str] portal_allowed_subnets: List of CIDRs
        :param _builtins.str portal_api_secret: APi secret (auto-generated) that can be used to sign guest authorization requests
        :param Sequence[_builtins.str] portal_denied_hostnames: List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param _builtins.str portal_image: Url of portal background image
        :param 'GetWlansOrgWlanRadsecArgs' radsec: RadSec settings
        :param Mapping[str, 'GetWlansOrgWlanRatesetArgs'] rateset: Property key is the RF band. enum: `24`, `5`, `6`
        :param _builtins.bool reconnect_clients_when_roaming_mxcluster: When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        :param _builtins.str roam_mode: enum: `11r`, `OKC`, `NONE`
        :param 'GetWlansOrgWlanScheduleArgs' schedule: WLAN operating schedule, default is disabled
        :param _builtins.bool sle_excluded: Whether to exclude this WLAN from SLE metrics
        :param _builtins.str ssid: Name of the SSID
        :param _builtins.bool use_eapol_v1: If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param _builtins.bool vlan_enabled: If vlan tagging is enabled
        :param Sequence[_builtins.str] vlan_ids: if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        :param _builtins.bool vlan_pooling: Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        :param _builtins.bool wlan_limit_down_enabled: If downlink limiting for whole wlan is enabled
        :param _builtins.bool wlan_limit_up_enabled: If uplink limiting for whole wlan is enabled
        :param Sequence[_builtins.str] wxtag_ids: List of wxtag_ids
        :param _builtins.str wxtunnel_id: When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param _builtins.str wxtunnel_remote_id: When `interface`=`wxtunnel`, remote tunnel identifier
        """
        pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        pulumi.set(__self__, "acct_servers", acct_servers)
        pulumi.set(__self__, "airwatch", airwatch)
        pulumi.set(__self__, "allow_ipv6_ndp", allow_ipv6_ndp)
        pulumi.set(__self__, "allow_mdns", allow_mdns)
        pulumi.set(__self__, "allow_ssdp", allow_ssdp)
        pulumi.set(__self__, "ap_ids", ap_ids)
        pulumi.set(__self__, "app_limit", app_limit)
        pulumi.set(__self__, "app_qos", app_qos)
        pulumi.set(__self__, "apply_to", apply_to)
        pulumi.set(__self__, "arp_filter", arp_filter)
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        pulumi.set(__self__, "auth_servers", auth_servers)
        pulumi.set(__self__, "auth_servers_nas_id", auth_servers_nas_id)
        pulumi.set(__self__, "auth_servers_nas_ip", auth_servers_nas_ip)
        pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        pulumi.set(__self__, "band_steer", band_steer)
        pulumi.set(__self__, "band_steer_force_band5", band_steer_force_band5)
        pulumi.set(__self__, "bands", bands)
        pulumi.set(__self__, "block_blacklist_clients", block_blacklist_clients)
        pulumi.set(__self__, "bonjour", bonjour)
        pulumi.set(__self__, "cisco_cwa", cisco_cwa)
        pulumi.set(__self__, "client_limit_down", client_limit_down)
        pulumi.set(__self__, "client_limit_down_enabled", client_limit_down_enabled)
        pulumi.set(__self__, "client_limit_up", client_limit_up)
        pulumi.set(__self__, "client_limit_up_enabled", client_limit_up_enabled)
        pulumi.set(__self__, "coa_servers", coa_servers)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "disable11ax", disable11ax)
        pulumi.set(__self__, "disable11be", disable11be)
        pulumi.set(__self__, "disable_ht_vht_rates", disable_ht_vht_rates)
        pulumi.set(__self__, "disable_uapsd", disable_uapsd)
        pulumi.set(__self__, "disable_v1_roam_notify", disable_v1_roam_notify)
        pulumi.set(__self__, "disable_v2_roam_notify", disable_v2_roam_notify)
        pulumi.set(__self__, "disable_when_gateway_unreachable", disable_when_gateway_unreachable)
        pulumi.set(__self__, "disable_when_mxtunnel_down", disable_when_mxtunnel_down)
        pulumi.set(__self__, "disable_wmm", disable_wmm)
        pulumi.set(__self__, "dns_server_rewrite", dns_server_rewrite)
        pulumi.set(__self__, "dtim", dtim)
        pulumi.set(__self__, "dynamic_psk", dynamic_psk)
        pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        pulumi.set(__self__, "enable_local_keycaching", enable_local_keycaching)
        pulumi.set(__self__, "enable_wireless_bridging", enable_wireless_bridging)
        pulumi.set(__self__, "enable_wireless_bridging_dhcp_tracking", enable_wireless_bridging_dhcp_tracking)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        pulumi.set(__self__, "hide_ssid", hide_ssid)
        pulumi.set(__self__, "hostname_ie", hostname_ie)
        pulumi.set(__self__, "hotspot20", hotspot20)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inject_dhcp_option82", inject_dhcp_option82)
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "isolation", isolation)
        pulumi.set(__self__, "l2_isolation", l2_isolation)
        pulumi.set(__self__, "legacy_overds", legacy_overds)
        pulumi.set(__self__, "limit_bcast", limit_bcast)
        pulumi.set(__self__, "limit_probe_response", limit_probe_response)
        pulumi.set(__self__, "max_idletime", max_idletime)
        pulumi.set(__self__, "max_num_clients", max_num_clients)
        pulumi.set(__self__, "mist_nac", mist_nac)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "msp_id", msp_id)
        pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        pulumi.set(__self__, "mxtunnel_names", mxtunnel_names)
        pulumi.set(__self__, "no_static_dns", no_static_dns)
        pulumi.set(__self__, "no_static_ip", no_static_ip)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "portal", portal)
        pulumi.set(__self__, "portal_allowed_hostnames", portal_allowed_hostnames)
        pulumi.set(__self__, "portal_allowed_subnets", portal_allowed_subnets)
        pulumi.set(__self__, "portal_api_secret", portal_api_secret)
        pulumi.set(__self__, "portal_denied_hostnames", portal_denied_hostnames)
        pulumi.set(__self__, "portal_image", portal_image)
        pulumi.set(__self__, "portal_sso_url", portal_sso_url)
        pulumi.set(__self__, "qos", qos)
        pulumi.set(__self__, "radsec", radsec)
        pulumi.set(__self__, "rateset", rateset)
        pulumi.set(__self__, "reconnect_clients_when_roaming_mxcluster", reconnect_clients_when_roaming_mxcluster)
        pulumi.set(__self__, "roam_mode", roam_mode)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "sle_excluded", sle_excluded)
        pulumi.set(__self__, "ssid", ssid)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "use_eapol_v1", use_eapol_v1)
        pulumi.set(__self__, "vlan_enabled", vlan_enabled)
        pulumi.set(__self__, "vlan_id", vlan_id)
        pulumi.set(__self__, "vlan_ids", vlan_ids)
        pulumi.set(__self__, "vlan_pooling", vlan_pooling)
        pulumi.set(__self__, "wlan_limit_down", wlan_limit_down)
        pulumi.set(__self__, "wlan_limit_down_enabled", wlan_limit_down_enabled)
        pulumi.set(__self__, "wlan_limit_up", wlan_limit_up)
        pulumi.set(__self__, "wlan_limit_up_enabled", wlan_limit_up_enabled)
        pulumi.set(__self__, "wxtag_ids", wxtag_ids)
        pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @_builtins.property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> _builtins.bool:
        """
        Enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> _builtins.int:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Sequence['outputs.GetWlansOrgWlanAcctServerResult']:
        """
        List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter
    def airwatch(self) -> 'outputs.GetWlansOrgWlanAirwatchResult':
        """
        Airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @_builtins.property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> _builtins.bool:
        """
        Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @_builtins.property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> _builtins.bool:
        """
        Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @_builtins.property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> _builtins.bool:
        """
        Only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @_builtins.property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> Sequence[_builtins.str]:
        """
        List of device ids
        """
        return pulumi.get(self, "ap_ids")

    @_builtins.property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> 'outputs.GetWlansOrgWlanAppLimitResult':
        """
        Bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @_builtins.property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> 'outputs.GetWlansOrgWlanAppQosResult':
        """
        APp qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @_builtins.property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> _builtins.str:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @_builtins.property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> _builtins.bool:
        """
        Whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> 'outputs.GetWlansOrgWlanAuthResult':
        """
        Authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> _builtins.str:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @_builtins.property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Sequence['outputs.GetWlansOrgWlanAuthServerResult']:
        """
        List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @_builtins.property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> _builtins.str:
        """
        Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @_builtins.property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> _builtins.str:
        """
        Optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> _builtins.int:
        """
        Radius auth session retries. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> _builtins.int:
        """
        Radius auth session timeout. Following fast timers are set if "fast_dot1x_timers" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> _builtins.bool:
        """
        Whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @_builtins.property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> _builtins.bool:
        """
        Force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Sequence[_builtins.str]:
        """
        List of radios that the wlan should apply to.
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> _builtins.bool:
        """
        Whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @_builtins.property
    @pulumi.getter
    def bonjour(self) -> 'outputs.GetWlansOrgWlanBonjourResult':
        """
        Bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @_builtins.property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> 'outputs.GetWlansOrgWlanCiscoCwaResult':
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @_builtins.property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> _builtins.str:
        return pulumi.get(self, "client_limit_down")

    @_builtins.property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> _builtins.bool:
        """
        If downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @_builtins.property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> _builtins.str:
        return pulumi.get(self, "client_limit_up")

    @_builtins.property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> _builtins.bool:
        """
        If uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @_builtins.property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> Sequence['outputs.GetWlansOrgWlanCoaServerResult']:
        """
        List of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def disable11ax(self) -> _builtins.bool:
        """
        Some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @_builtins.property
    @pulumi.getter
    def disable11be(self) -> _builtins.bool:
        """
        To disable Wi-Fi 7 EHT IEs
        """
        return pulumi.get(self, "disable11be")

    @_builtins.property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> _builtins.bool:
        """
        To disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @_builtins.property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> _builtins.bool:
        """
        Whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @_builtins.property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> _builtins.bool:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @_builtins.property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> _builtins.bool:
        """
        Disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @_builtins.property
    @pulumi.getter(name="disableWhenGatewayUnreachable")
    def disable_when_gateway_unreachable(self) -> _builtins.bool:
        """
        When any of the following is true, this WLAN will be disabled
           * cannot get IP
           * cannot obtain default gateway
           * cannot reach default gateway
        """
        return pulumi.get(self, "disable_when_gateway_unreachable")

    @_builtins.property
    @pulumi.getter(name="disableWhenMxtunnelDown")
    def disable_when_mxtunnel_down(self) -> _builtins.bool:
        return pulumi.get(self, "disable_when_mxtunnel_down")

    @_builtins.property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> _builtins.bool:
        """
        Whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @_builtins.property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> 'outputs.GetWlansOrgWlanDnsServerRewriteResult':
        """
        For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @_builtins.property
    @pulumi.getter
    def dtim(self) -> _builtins.int:
        return pulumi.get(self, "dtim")

    @_builtins.property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> 'outputs.GetWlansOrgWlanDynamicPskResult':
        """
        For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
          * PSK will come from RADIUS server
          * AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed)
          * AP sends BSSID:SSID as Caller-Station-ID
          * `auth_servers` is required
          * PSK will come from cloud WLC if source is cloud_psks
          * default_psk will be used if cloud WLC is not available
          * `multi_psk_only` and `psk` is ignored
          * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @_builtins.property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> 'outputs.GetWlansOrgWlanDynamicVlanResult':
        """
        For 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @_builtins.property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> _builtins.bool:
        """
        Enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @_builtins.property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> _builtins.bool:
        """
        By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @_builtins.property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> _builtins.bool:
        """
        If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> _builtins.bool:
        """
        If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @_builtins.property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> _builtins.bool:
        """
        Whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @_builtins.property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> _builtins.bool:
        """
        Include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @_builtins.property
    @pulumi.getter
    def hotspot20(self) -> 'outputs.GetWlansOrgWlanHotspot20Result':
        """
        Hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> 'outputs.GetWlansOrgWlanInjectDhcpOption82Result':
        return pulumi.get(self, "inject_dhcp_option82")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> _builtins.str:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> _builtins.bool:
        """
        Whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> _builtins.bool:
        """
        If isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @_builtins.property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> _builtins.bool:
        """
        Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @_builtins.property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> _builtins.bool:
        """
        Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @_builtins.property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> _builtins.bool:
        """
        Limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @_builtins.property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> _builtins.int:
        """
        Max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @_builtins.property
    @pulumi.getter(name="maxNumClients")
    def max_num_clients(self) -> _builtins.int:
        """
        Maximum number of client connected to the SSID. `0` means unlimited
        """
        return pulumi.get(self, "max_num_clients")

    @_builtins.property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> 'outputs.GetWlansOrgWlanMistNacResult':
        return pulumi.get(self, "mist_nac")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter(name="mspId")
    def msp_id(self) -> _builtins.str:
        return pulumi.get(self, "msp_id")

    @_builtins.property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Sequence[_builtins.str]:
        """
        When `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @_builtins.property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> Sequence[_builtins.str]:
        """
        When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @_builtins.property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> _builtins.bool:
        """
        Whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @_builtins.property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> _builtins.bool:
        """
        Whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def portal(self) -> 'outputs.GetWlansOrgWlanPortalResult':
        """
        Portal wlan settings
        """
        return pulumi.get(self, "portal")

    @_builtins.property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> Sequence[_builtins.str]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @_builtins.property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> Sequence[_builtins.str]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @_builtins.property
    @pulumi.getter(name="portalApiSecret")
    def portal_api_secret(self) -> _builtins.str:
        """
        APi secret (auto-generated) that can be used to sign guest authorization requests
        """
        return pulumi.get(self, "portal_api_secret")

    @_builtins.property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> Sequence[_builtins.str]:
        """
        List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @_builtins.property
    @pulumi.getter(name="portalImage")
    def portal_image(self) -> _builtins.str:
        """
        Url of portal background image
        """
        return pulumi.get(self, "portal_image")

    @_builtins.property
    @pulumi.getter(name="portalSsoUrl")
    def portal_sso_url(self) -> _builtins.str:
        return pulumi.get(self, "portal_sso_url")

    @_builtins.property
    @pulumi.getter
    def qos(self) -> 'outputs.GetWlansOrgWlanQosResult':
        return pulumi.get(self, "qos")

    @_builtins.property
    @pulumi.getter
    def radsec(self) -> 'outputs.GetWlansOrgWlanRadsecResult':
        """
        RadSec settings
        """
        return pulumi.get(self, "radsec")

    @_builtins.property
    @pulumi.getter
    def rateset(self) -> Mapping[str, 'outputs.GetWlansOrgWlanRatesetResult']:
        """
        Property key is the RF band. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "rateset")

    @_builtins.property
    @pulumi.getter(name="reconnectClientsWhenRoamingMxcluster")
    def reconnect_clients_when_roaming_mxcluster(self) -> _builtins.bool:
        """
        When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        """
        return pulumi.get(self, "reconnect_clients_when_roaming_mxcluster")

    @_builtins.property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> _builtins.str:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.GetWlansOrgWlanScheduleResult':
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> _builtins.bool:
        """
        Whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> _builtins.str:
        """
        Name of the SSID
        """
        return pulumi.get(self, "ssid")

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> _builtins.bool:
        """
        If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @_builtins.property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> _builtins.bool:
        """
        If vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Sequence[_builtins.str]:
        """
        if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
        """
        return pulumi.get(self, "vlan_ids")

    @_builtins.property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> _builtins.bool:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @_builtins.property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> _builtins.str:
        return pulumi.get(self, "wlan_limit_down")

    @_builtins.property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> _builtins.bool:
        """
        If downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @_builtins.property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> _builtins.str:
        return pulumi.get(self, "wlan_limit_up")

    @_builtins.property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> _builtins.bool:
        """
        If uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @_builtins.property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Sequence[_builtins.str]:
        """
        List of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @_builtins.property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> _builtins.str:
        """
        When `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @_builtins.property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> _builtins.str:
        """
        When `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")


@pulumi.output_type
class GetWlansOrgWlanAcctServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 keywrap_enabled: _builtins.bool,
                 keywrap_format: _builtins.str,
                 keywrap_kek: _builtins.str,
                 keywrap_mack: _builtins.str,
                 port: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.str secret: Secret of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        pulumi.set(__self__, "keywrap_format", keywrap_format)
        pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> _builtins.str:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> _builtins.str:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> _builtins.str:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetWlansOrgWlanAirwatchResult(dict):
    def __init__(__self__, *,
                 api_key: _builtins.str,
                 console_url: _builtins.str,
                 enabled: _builtins.bool,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str api_key: API Key
        :param _builtins.str console_url: Console URL
        :param _builtins.str password: Password
        :param _builtins.str username: Username
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "console_url", console_url)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="consoleUrl")
    def console_url(self) -> _builtins.str:
        """
        Console URL
        """
        return pulumi.get(self, "console_url")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetWlansOrgWlanAppLimitResult(dict):
    def __init__(__self__, *,
                 apps: Mapping[str, _builtins.int],
                 enabled: _builtins.bool,
                 wxtag_ids: Mapping[str, _builtins.int]):
        """
        :param Mapping[str, _builtins.int] apps: Map from app key to bandwidth in kbps. 
               Property key is the app key, defined in Get Application List
        :param Mapping[str, _builtins.int] wxtag_ids: Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "wxtag_ids", wxtag_ids)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Mapping[str, _builtins.int]:
        """
        Map from app key to bandwidth in kbps. 
        Property key is the app key, defined in Get Application List
        """
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Mapping[str, _builtins.int]:
        """
        Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`
        """
        return pulumi.get(self, "wxtag_ids")


@pulumi.output_type
class GetWlansOrgWlanAppQosResult(dict):
    def __init__(__self__, *,
                 apps: Mapping[str, 'outputs.GetWlansOrgWlanAppQosAppsResult'],
                 enabled: _builtins.bool,
                 others: Sequence['outputs.GetWlansOrgWlanAppQosOtherResult']):
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "others", others)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Mapping[str, 'outputs.GetWlansOrgWlanAppQosAppsResult']:
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def others(self) -> Sequence['outputs.GetWlansOrgWlanAppQosOtherResult']:
        return pulumi.get(self, "others")


@pulumi.output_type
class GetWlansOrgWlanAppQosAppsResult(dict):
    def __init__(__self__, *,
                 dscp: _builtins.str,
                 dst_subnet: _builtins.str,
                 src_subnet: _builtins.str):
        """
        :param _builtins.str dst_subnet: Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        :param _builtins.str src_subnet: Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        pulumi.set(__self__, "dscp", dscp)
        pulumi.set(__self__, "dst_subnet", dst_subnet)
        pulumi.set(__self__, "src_subnet", src_subnet)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> _builtins.str:
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> _builtins.str:
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "dst_subnet")

    @_builtins.property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> _builtins.str:
        """
        Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "src_subnet")


@pulumi.output_type
class GetWlansOrgWlanAppQosOtherResult(dict):
    def __init__(__self__, *,
                 dscp: _builtins.str,
                 dst_subnet: _builtins.str,
                 port_ranges: _builtins.str,
                 protocol: _builtins.str,
                 src_subnet: _builtins.str):
        pulumi.set(__self__, "dscp", dscp)
        pulumi.set(__self__, "dst_subnet", dst_subnet)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "src_subnet", src_subnet)

    @_builtins.property
    @pulumi.getter
    def dscp(self) -> _builtins.str:
        return pulumi.get(self, "dscp")

    @_builtins.property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> _builtins.str:
        return pulumi.get(self, "dst_subnet")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> _builtins.str:
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> _builtins.str:
        return pulumi.get(self, "src_subnet")


@pulumi.output_type
class GetWlansOrgWlanAuthResult(dict):
    def __init__(__self__, *,
                 anticlog_threshold: _builtins.int,
                 eap_reauth: _builtins.bool,
                 enable_mac_auth: _builtins.bool,
                 key_idx: _builtins.int,
                 keys: Sequence[_builtins.str],
                 multi_psk_only: _builtins.bool,
                 owe: _builtins.str,
                 pairwises: Sequence[_builtins.str],
                 private_wlan: _builtins.bool,
                 psk: _builtins.str,
                 type: _builtins.str,
                 wep_as_secondary_auth: _builtins.bool):
        """
        :param _builtins.int anticlog_threshold: SAE anti-clogging token threshold
        :param _builtins.bool eap_reauth: Whether to trigger EAP reauth when the session ends
        :param _builtins.bool enable_mac_auth: Whether to enable MAC Auth, uses the same auth_servers
        :param _builtins.int key_idx: When `type`==`wep`
        :param Sequence[_builtins.str] keys: When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        :param _builtins.bool multi_psk_only: When `type`==`psk`, whether to only use multi_psk
        :param _builtins.str owe: if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        :param Sequence[_builtins.str] pairwises: When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        :param _builtins.bool private_wlan: When `multi_psk_only`==`true`, whether private wlan is enabled
        :param _builtins.str psk: When `type`==`psk`, 8-64 characters, or 64 hex characters
        :param _builtins.str type: enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        :param _builtins.bool wep_as_secondary_auth: Enable WEP as secondary auth
        """
        pulumi.set(__self__, "anticlog_threshold", anticlog_threshold)
        pulumi.set(__self__, "eap_reauth", eap_reauth)
        pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        pulumi.set(__self__, "key_idx", key_idx)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "multi_psk_only", multi_psk_only)
        pulumi.set(__self__, "owe", owe)
        pulumi.set(__self__, "pairwises", pairwises)
        pulumi.set(__self__, "private_wlan", private_wlan)
        pulumi.set(__self__, "psk", psk)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "wep_as_secondary_auth", wep_as_secondary_auth)

    @_builtins.property
    @pulumi.getter(name="anticlogThreshold")
    def anticlog_threshold(self) -> _builtins.int:
        """
        SAE anti-clogging token threshold
        """
        return pulumi.get(self, "anticlog_threshold")

    @_builtins.property
    @pulumi.getter(name="eapReauth")
    def eap_reauth(self) -> _builtins.bool:
        """
        Whether to trigger EAP reauth when the session ends
        """
        return pulumi.get(self, "eap_reauth")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> _builtins.bool:
        """
        Whether to enable MAC Auth, uses the same auth_servers
        """
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter(name="keyIdx")
    def key_idx(self) -> _builtins.int:
        """
        When `type`==`wep`
        """
        return pulumi.get(self, "key_idx")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        """
        When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="multiPskOnly")
    def multi_psk_only(self) -> _builtins.bool:
        """
        When `type`==`psk`, whether to only use multi_psk
        """
        return pulumi.get(self, "multi_psk_only")

    @_builtins.property
    @pulumi.getter
    def owe(self) -> _builtins.str:
        """
        if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        """
        return pulumi.get(self, "owe")

    @_builtins.property
    @pulumi.getter
    def pairwises(self) -> Sequence[_builtins.str]:
        """
        When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        """
        return pulumi.get(self, "pairwises")

    @_builtins.property
    @pulumi.getter(name="privateWlan")
    def private_wlan(self) -> _builtins.bool:
        """
        When `multi_psk_only`==`true`, whether private wlan is enabled
        """
        return pulumi.get(self, "private_wlan")

    @_builtins.property
    @pulumi.getter
    def psk(self) -> _builtins.str:
        """
        When `type`==`psk`, 8-64 characters, or 64 hex characters
        """
        return pulumi.get(self, "psk")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="wepAsSecondaryAuth")
    def wep_as_secondary_auth(self) -> _builtins.bool:
        """
        Enable WEP as secondary auth
        """
        return pulumi.get(self, "wep_as_secondary_auth")


@pulumi.output_type
class GetWlansOrgWlanAuthServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 keywrap_enabled: _builtins.bool,
                 keywrap_format: _builtins.str,
                 keywrap_kek: _builtins.str,
                 keywrap_mack: _builtins.str,
                 port: _builtins.str,
                 require_message_authenticator: _builtins.bool,
                 secret: _builtins.str):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.bool require_message_authenticator: Whether to require Message-Authenticator in requests
        :param _builtins.str secret: Secret of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        pulumi.set(__self__, "keywrap_format", keywrap_format)
        pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> _builtins.str:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> _builtins.str:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> _builtins.str:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> _builtins.bool:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetWlansOrgWlanBonjourResult(dict):
    def __init__(__self__, *,
                 additional_vlan_ids: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 services: Mapping[str, 'outputs.GetWlansOrgWlanBonjourServicesResult']):
        """
        :param Sequence[_builtins.str] additional_vlan_ids: additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        :param _builtins.bool enabled: Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        :param Mapping[str, 'GetWlansOrgWlanBonjourServicesArgs'] services: What services are allowed. 
               Property key is the service name
        """
        pulumi.set(__self__, "additional_vlan_ids", additional_vlan_ids)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter(name="additionalVlanIds")
    def additional_vlan_ids(self) -> Sequence[_builtins.str]:
        """
        additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        """
        return pulumi.get(self, "additional_vlan_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.GetWlansOrgWlanBonjourServicesResult']:
        """
        What services are allowed. 
        Property key is the service name
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class GetWlansOrgWlanBonjourServicesResult(dict):
    def __init__(__self__, *,
                 disable_local: _builtins.bool,
                 radius_groups: Sequence[_builtins.str],
                 scope: _builtins.str):
        """
        :param _builtins.bool disable_local: Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        :param Sequence[_builtins.str] radius_groups: Optional, if the service is further restricted for certain RADIUS groups
        :param _builtins.str scope: how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        pulumi.set(__self__, "disable_local", disable_local)
        pulumi.set(__self__, "radius_groups", radius_groups)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="disableLocal")
    def disable_local(self) -> _builtins.bool:
        """
        Whether to prevent wireless clients to discover bonjour devices on the same WLAN
        """
        return pulumi.get(self, "disable_local")

    @_builtins.property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Sequence[_builtins.str]:
        """
        Optional, if the service is further restricted for certain RADIUS groups
        """
        return pulumi.get(self, "radius_groups")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetWlansOrgWlanCiscoCwaResult(dict):
    def __init__(__self__, *,
                 allowed_hostnames: Sequence[_builtins.str],
                 allowed_subnets: Sequence[_builtins.str],
                 blocked_subnets: Sequence[_builtins.str],
                 enabled: _builtins.bool):
        """
        :param Sequence[_builtins.str] allowed_hostnames: List of hostnames without http(s):// (matched by substring)
        :param Sequence[_builtins.str] allowed_subnets: List of CIDRs
        :param Sequence[_builtins.str] blocked_subnets: List of blocked CIDRs
        """
        pulumi.set(__self__, "allowed_hostnames", allowed_hostnames)
        pulumi.set(__self__, "allowed_subnets", allowed_subnets)
        pulumi.set(__self__, "blocked_subnets", blocked_subnets)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowedHostnames")
    def allowed_hostnames(self) -> Sequence[_builtins.str]:
        """
        List of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "allowed_hostnames")

    @_builtins.property
    @pulumi.getter(name="allowedSubnets")
    def allowed_subnets(self) -> Sequence[_builtins.str]:
        """
        List of CIDRs
        """
        return pulumi.get(self, "allowed_subnets")

    @_builtins.property
    @pulumi.getter(name="blockedSubnets")
    def blocked_subnets(self) -> Sequence[_builtins.str]:
        """
        List of blocked CIDRs
        """
        return pulumi.get(self, "blocked_subnets")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWlansOrgWlanCoaServerResult(dict):
    def __init__(__self__, *,
                 disable_event_timestamp_check: _builtins.bool,
                 enabled: _builtins.bool,
                 ip: _builtins.str,
                 port: _builtins.str,
                 secret: _builtins.str):
        """
        :param _builtins.bool disable_event_timestamp_check: Whether to disable Event-Timestamp Check
        """
        pulumi.set(__self__, "disable_event_timestamp_check", disable_event_timestamp_check)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="disableEventTimestampCheck")
    def disable_event_timestamp_check(self) -> _builtins.bool:
        """
        Whether to disable Event-Timestamp Check
        """
        return pulumi.get(self, "disable_event_timestamp_check")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetWlansOrgWlanDnsServerRewriteResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 radius_groups: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] radius_groups: Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "radius_groups", radius_groups)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Mapping[str, _builtins.str]:
        """
        Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server
        """
        return pulumi.get(self, "radius_groups")


@pulumi.output_type
class GetWlansOrgWlanDynamicPskResult(dict):
    def __init__(__self__, *,
                 default_psk: _builtins.str,
                 default_vlan_id: _builtins.str,
                 enabled: _builtins.bool,
                 force_lookup: _builtins.bool,
                 source: _builtins.str):
        """
        :param _builtins.str default_psk: Default PSK to use if cloud WLC is not available, 8-63 characters
        :param _builtins.bool force_lookup: When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        :param _builtins.str source: enum: `cloud_psks`, `radius`
        """
        pulumi.set(__self__, "default_psk", default_psk)
        pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "force_lookup", force_lookup)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="defaultPsk")
    def default_psk(self) -> _builtins.str:
        """
        Default PSK to use if cloud WLC is not available, 8-63 characters
        """
        return pulumi.get(self, "default_psk")

    @_builtins.property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "default_vlan_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="forceLookup")
    def force_lookup(self) -> _builtins.bool:
        """
        When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto
        """
        return pulumi.get(self, "force_lookup")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        enum: `cloud_psks`, `radius`
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetWlansOrgWlanDynamicVlanResult(dict):
    def __init__(__self__, *,
                 default_vlan_ids: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 local_vlan_ids: Sequence[_builtins.str],
                 type: _builtins.str,
                 vlans: Mapping[str, _builtins.str]):
        """
        :param Sequence[_builtins.str] default_vlan_ids: Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        :param _builtins.bool enabled: Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        :param Sequence[_builtins.str] local_vlan_ids: VLAN_ids to be locally bridged
        :param _builtins.str type: standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        :param Mapping[str, _builtins.str] vlans: Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
                 * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
                 * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        pulumi.set(__self__, "default_vlan_ids", default_vlan_ids)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "local_vlan_ids", local_vlan_ids)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vlans", vlans)

    @_builtins.property
    @pulumi.getter(name="defaultVlanIds")
    def default_vlan_ids(self) -> Sequence[_builtins.str]:
        """
        Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        """
        return pulumi.get(self, "default_vlan_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="localVlanIds")
    def local_vlan_ids(self) -> Sequence[_builtins.str]:
        """
        VLAN_ids to be locally bridged
        """
        return pulumi.get(self, "local_vlan_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlans(self) -> Mapping[str, _builtins.str]:
        """
        Map between vlan_id (as string) to airespace interface names (comma-separated) or null for standard mapping
          * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
          * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class GetWlansOrgWlanHotspot20Result(dict):
    def __init__(__self__, *,
                 domain_names: Sequence[_builtins.str],
                 enabled: _builtins.bool,
                 nai_realms: Sequence[_builtins.str],
                 operators: Sequence[_builtins.str],
                 rcois: Sequence[_builtins.str],
                 venue_name: _builtins.str):
        """
        :param _builtins.bool enabled: Whether to enable hotspot 2.0 config
        :param Sequence[_builtins.str] operators: List of operators to support
        :param _builtins.str venue_name: Venue name, default is site name
        """
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "nai_realms", nai_realms)
        pulumi.set(__self__, "operators", operators)
        pulumi.set(__self__, "rcois", rcois)
        pulumi.set(__self__, "venue_name", venue_name)

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable hotspot 2.0 config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="naiRealms")
    def nai_realms(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "nai_realms")

    @_builtins.property
    @pulumi.getter
    def operators(self) -> Sequence[_builtins.str]:
        """
        List of operators to support
        """
        return pulumi.get(self, "operators")

    @_builtins.property
    @pulumi.getter
    def rcois(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "rcois")

    @_builtins.property
    @pulumi.getter(name="venueName")
    def venue_name(self) -> _builtins.str:
        """
        Venue name, default is site name
        """
        return pulumi.get(self, "venue_name")


@pulumi.output_type
class GetWlansOrgWlanInjectDhcpOption82Result(dict):
    def __init__(__self__, *,
                 circuit_id: _builtins.str,
                 enabled: _builtins.bool):
        """
        :param _builtins.str circuit_id: Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
                 * {{AP_MAC}}
                 * {{AP_MAC_DASHED}}
                 * {{AP_MODEL}}
                 * {{AP_NAME}}
                 * {{SITE_NAME}}
                 * {{SSID}}
        :param _builtins.bool enabled: Whether to inject option 82 when forwarding DHCP packets
        """
        pulumi.set(__self__, "circuit_id", circuit_id)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="circuitId")
    def circuit_id(self) -> _builtins.str:
        """
        Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
          * {{AP_MAC}}
          * {{AP_MAC_DASHED}}
          * {{AP_MODEL}}
          * {{AP_NAME}}
          * {{SITE_NAME}}
          * {{SSID}}
        """
        return pulumi.get(self, "circuit_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to inject option 82 when forwarding DHCP packets
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWlansOrgWlanMistNacResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: When enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        When enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetWlansOrgWlanPortalResult(dict):
    def __init__(__self__, *,
                 allow_wlan_id_roam: _builtins.bool,
                 amazon_client_id: _builtins.str,
                 amazon_client_secret: _builtins.str,
                 amazon_email_domains: Sequence[_builtins.str],
                 amazon_enabled: _builtins.bool,
                 amazon_expire: _builtins.int,
                 auth: _builtins.str,
                 azure_client_id: _builtins.str,
                 azure_client_secret: _builtins.str,
                 azure_enabled: _builtins.bool,
                 azure_expire: _builtins.int,
                 azure_tenant_id: _builtins.str,
                 broadnet_password: _builtins.str,
                 broadnet_sid: _builtins.str,
                 broadnet_user_id: _builtins.str,
                 bypass_when_cloud_down: _builtins.bool,
                 clickatell_api_key: _builtins.str,
                 cross_site: _builtins.bool,
                 email_enabled: _builtins.bool,
                 enabled: _builtins.bool,
                 expire: _builtins.int,
                 external_portal_url: _builtins.str,
                 facebook_client_id: _builtins.str,
                 facebook_client_secret: _builtins.str,
                 facebook_email_domains: Sequence[_builtins.str],
                 facebook_enabled: _builtins.bool,
                 facebook_expire: _builtins.int,
                 forward: _builtins.bool,
                 forward_url: _builtins.str,
                 google_client_id: _builtins.str,
                 google_client_secret: _builtins.str,
                 google_email_domains: Sequence[_builtins.str],
                 google_enabled: _builtins.bool,
                 google_expire: _builtins.int,
                 gupshup_password: _builtins.str,
                 gupshup_userid: _builtins.str,
                 microsoft_client_id: _builtins.str,
                 microsoft_client_secret: _builtins.str,
                 microsoft_email_domains: Sequence[_builtins.str],
                 microsoft_enabled: _builtins.bool,
                 microsoft_expire: _builtins.int,
                 passphrase_enabled: _builtins.bool,
                 passphrase_expire: _builtins.int,
                 password: _builtins.str,
                 predefined_sponsors_enabled: _builtins.bool,
                 predefined_sponsors_hide_email: _builtins.bool,
                 privacy: _builtins.bool,
                 puzzel_password: _builtins.str,
                 puzzel_service_id: _builtins.str,
                 puzzel_username: _builtins.str,
                 sms_enabled: _builtins.bool,
                 sms_expire: _builtins.int,
                 sms_message_format: _builtins.str,
                 sms_provider: _builtins.str,
                 sponsor_auto_approve: _builtins.bool,
                 sponsor_email_domains: Sequence[_builtins.str],
                 sponsor_enabled: _builtins.bool,
                 sponsor_expire: _builtins.int,
                 sponsor_link_validity_duration: _builtins.str,
                 sponsor_notify_all: _builtins.bool,
                 sponsor_status_notify: _builtins.bool,
                 sponsors: Mapping[str, _builtins.str],
                 sso_default_role: _builtins.str,
                 sso_forced_role: _builtins.str,
                 sso_idp_cert: _builtins.str,
                 sso_idp_sign_algo: _builtins.str,
                 sso_idp_sso_url: _builtins.str,
                 sso_issuer: _builtins.str,
                 sso_nameid_format: _builtins.str,
                 telstra_client_id: _builtins.str,
                 telstra_client_secret: _builtins.str,
                 twilio_auth_token: _builtins.str,
                 twilio_phone_number: _builtins.str,
                 twilio_sid: _builtins.str):
        """
        :param _builtins.bool allow_wlan_id_roam: Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        :param _builtins.str amazon_client_id: Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param _builtins.str amazon_client_secret: Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] amazon_email_domains: Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool amazon_enabled: Whether amazon is enabled as a login method
        :param _builtins.int amazon_expire: Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        :param _builtins.str auth: authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        :param _builtins.str azure_client_id: Required if `azure_enabled`==`true`. Azure active directory app client id
        :param _builtins.str azure_client_secret: Required if `azure_enabled`==`true`. Azure active directory app client secret
        :param _builtins.bool azure_enabled: Whether Azure Active Directory is enabled as a login method
        :param _builtins.int azure_expire: Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        :param _builtins.str azure_tenant_id: Required if `azure_enabled`==`true`. Azure active directory tenant id.
        :param _builtins.str broadnet_password: Required if `sms_provider`==`broadnet`
        :param _builtins.str broadnet_sid: Required if `sms_provider`==`broadnet`
        :param _builtins.str broadnet_user_id: Required if `sms_provider`==`broadnet`
        :param _builtins.bool bypass_when_cloud_down: Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        :param _builtins.str clickatell_api_key: Required if `sms_provider`==`clickatell`
        :param _builtins.bool cross_site: Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        :param _builtins.bool email_enabled: Whether email (access code verification) is enabled as a login method
        :param _builtins.bool enabled: Whether guest portal is enabled
        :param _builtins.int expire: How long to remain authorized, in minutes
        :param _builtins.str external_portal_url: Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        :param _builtins.str facebook_client_id: Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param _builtins.str facebook_client_secret: Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] facebook_email_domains: Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool facebook_enabled: Whether facebook is enabled as a login method
        :param _builtins.int facebook_expire: Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        :param _builtins.bool forward: Whether to forward the user to another URL after authorized
        :param _builtins.str forward_url: URL to forward the user to
        :param _builtins.str google_client_id: Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param _builtins.str google_client_secret: Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] google_email_domains: Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool google_enabled: Whether Google is enabled as login method
        :param _builtins.int google_expire: Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        :param _builtins.str gupshup_password: Required if `sms_provider`==`gupshup`
        :param _builtins.str gupshup_userid: Required if `sms_provider`==`gupshup`
        :param _builtins.str microsoft_client_id: Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param _builtins.str microsoft_client_secret: Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        :param Sequence[_builtins.str] microsoft_email_domains: Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param _builtins.bool microsoft_enabled: Whether microsoft 365 is enabled as a login method
        :param _builtins.int microsoft_expire: Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        :param _builtins.bool passphrase_enabled: Whether password is enabled
        :param _builtins.int passphrase_expire: Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        :param _builtins.str password: Required if `passphrase_enabled`==`true`.
        :param _builtins.bool predefined_sponsors_enabled: Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        :param _builtins.bool predefined_sponsors_hide_email: Whether to hide sponsor’s email from list of sponsors
        :param _builtins.str puzzel_password: Required if `sms_provider`==`puzzel`
        :param _builtins.str puzzel_service_id: Required if `sms_provider`==`puzzel`
        :param _builtins.str puzzel_username: Required if `sms_provider`==`puzzel`
        :param _builtins.bool sms_enabled: Whether sms is enabled as a login method
        :param _builtins.int sms_expire: Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        :param _builtins.str sms_message_format: Optional if `sms_enabled`==`true`. SMS Message format
        :param _builtins.str sms_provider: Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        :param _builtins.bool sponsor_auto_approve: Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        :param Sequence[_builtins.str] sponsor_email_domains: List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        :param _builtins.bool sponsor_enabled: Whether sponsor is enabled
        :param _builtins.int sponsor_expire: Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        :param _builtins.bool sponsor_notify_all: Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        :param _builtins.bool sponsor_status_notify: Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        :param Mapping[str, _builtins.str] sponsors: object of allowed sponsors email with name. Required if `sponsor_enabled`
                           is `true` and `sponsor_email_domains` is empty.
               
                           Property key is the sponsor email, Property value is the sponsor name
        :param _builtins.str sso_default_role: Optional if `wlan_portal_auth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        :param _builtins.str sso_forced_role: Optional if `wlan_portal_auth`==`sso`
        :param _builtins.str sso_idp_cert: Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        :param _builtins.str sso_idp_sign_algo: Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        :param _builtins.str sso_idp_sso_url: Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        :param _builtins.str sso_issuer: Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        :param _builtins.str sso_nameid_format: Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        :param _builtins.str telstra_client_id: Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        :param _builtins.str telstra_client_secret: Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        :param _builtins.str twilio_auth_token: Required if `sms_provider`==`twilio`, Auth token account with twilio account
        :param _builtins.str twilio_phone_number: Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        :param _builtins.str twilio_sid: Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        pulumi.set(__self__, "allow_wlan_id_roam", allow_wlan_id_roam)
        pulumi.set(__self__, "amazon_client_id", amazon_client_id)
        pulumi.set(__self__, "amazon_client_secret", amazon_client_secret)
        pulumi.set(__self__, "amazon_email_domains", amazon_email_domains)
        pulumi.set(__self__, "amazon_enabled", amazon_enabled)
        pulumi.set(__self__, "amazon_expire", amazon_expire)
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "azure_client_id", azure_client_id)
        pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        pulumi.set(__self__, "azure_enabled", azure_enabled)
        pulumi.set(__self__, "azure_expire", azure_expire)
        pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        pulumi.set(__self__, "broadnet_password", broadnet_password)
        pulumi.set(__self__, "broadnet_sid", broadnet_sid)
        pulumi.set(__self__, "broadnet_user_id", broadnet_user_id)
        pulumi.set(__self__, "bypass_when_cloud_down", bypass_when_cloud_down)
        pulumi.set(__self__, "clickatell_api_key", clickatell_api_key)
        pulumi.set(__self__, "cross_site", cross_site)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expire", expire)
        pulumi.set(__self__, "external_portal_url", external_portal_url)
        pulumi.set(__self__, "facebook_client_id", facebook_client_id)
        pulumi.set(__self__, "facebook_client_secret", facebook_client_secret)
        pulumi.set(__self__, "facebook_email_domains", facebook_email_domains)
        pulumi.set(__self__, "facebook_enabled", facebook_enabled)
        pulumi.set(__self__, "facebook_expire", facebook_expire)
        pulumi.set(__self__, "forward", forward)
        pulumi.set(__self__, "forward_url", forward_url)
        pulumi.set(__self__, "google_client_id", google_client_id)
        pulumi.set(__self__, "google_client_secret", google_client_secret)
        pulumi.set(__self__, "google_email_domains", google_email_domains)
        pulumi.set(__self__, "google_enabled", google_enabled)
        pulumi.set(__self__, "google_expire", google_expire)
        pulumi.set(__self__, "gupshup_password", gupshup_password)
        pulumi.set(__self__, "gupshup_userid", gupshup_userid)
        pulumi.set(__self__, "microsoft_client_id", microsoft_client_id)
        pulumi.set(__self__, "microsoft_client_secret", microsoft_client_secret)
        pulumi.set(__self__, "microsoft_email_domains", microsoft_email_domains)
        pulumi.set(__self__, "microsoft_enabled", microsoft_enabled)
        pulumi.set(__self__, "microsoft_expire", microsoft_expire)
        pulumi.set(__self__, "passphrase_enabled", passphrase_enabled)
        pulumi.set(__self__, "passphrase_expire", passphrase_expire)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "predefined_sponsors_enabled", predefined_sponsors_enabled)
        pulumi.set(__self__, "predefined_sponsors_hide_email", predefined_sponsors_hide_email)
        pulumi.set(__self__, "privacy", privacy)
        pulumi.set(__self__, "puzzel_password", puzzel_password)
        pulumi.set(__self__, "puzzel_service_id", puzzel_service_id)
        pulumi.set(__self__, "puzzel_username", puzzel_username)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "sms_expire", sms_expire)
        pulumi.set(__self__, "sms_message_format", sms_message_format)
        pulumi.set(__self__, "sms_provider", sms_provider)
        pulumi.set(__self__, "sponsor_auto_approve", sponsor_auto_approve)
        pulumi.set(__self__, "sponsor_email_domains", sponsor_email_domains)
        pulumi.set(__self__, "sponsor_enabled", sponsor_enabled)
        pulumi.set(__self__, "sponsor_expire", sponsor_expire)
        pulumi.set(__self__, "sponsor_link_validity_duration", sponsor_link_validity_duration)
        pulumi.set(__self__, "sponsor_notify_all", sponsor_notify_all)
        pulumi.set(__self__, "sponsor_status_notify", sponsor_status_notify)
        pulumi.set(__self__, "sponsors", sponsors)
        pulumi.set(__self__, "sso_default_role", sso_default_role)
        pulumi.set(__self__, "sso_forced_role", sso_forced_role)
        pulumi.set(__self__, "sso_idp_cert", sso_idp_cert)
        pulumi.set(__self__, "sso_idp_sign_algo", sso_idp_sign_algo)
        pulumi.set(__self__, "sso_idp_sso_url", sso_idp_sso_url)
        pulumi.set(__self__, "sso_issuer", sso_issuer)
        pulumi.set(__self__, "sso_nameid_format", sso_nameid_format)
        pulumi.set(__self__, "telstra_client_id", telstra_client_id)
        pulumi.set(__self__, "telstra_client_secret", telstra_client_secret)
        pulumi.set(__self__, "twilio_auth_token", twilio_auth_token)
        pulumi.set(__self__, "twilio_phone_number", twilio_phone_number)
        pulumi.set(__self__, "twilio_sid", twilio_sid)

    @_builtins.property
    @pulumi.getter(name="allowWlanIdRoam")
    def allow_wlan_id_roam(self) -> _builtins.bool:
        """
        Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "allow_wlan_id_roam")

    @_builtins.property
    @pulumi.getter(name="amazonClientId")
    def amazon_client_id(self) -> _builtins.str:
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "amazon_client_id")

    @_builtins.property
    @pulumi.getter(name="amazonClientSecret")
    def amazon_client_secret(self) -> _builtins.str:
        """
        Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "amazon_client_secret")

    @_builtins.property
    @pulumi.getter(name="amazonEmailDomains")
    def amazon_email_domains(self) -> Sequence[_builtins.str]:
        """
        Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "amazon_email_domains")

    @_builtins.property
    @pulumi.getter(name="amazonEnabled")
    def amazon_enabled(self) -> _builtins.bool:
        """
        Whether amazon is enabled as a login method
        """
        return pulumi.get(self, "amazon_enabled")

    @_builtins.property
    @pulumi.getter(name="amazonExpire")
    def amazon_expire(self) -> _builtins.int:
        """
        Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "amazon_expire")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> _builtins.str:
        """
        authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sms`, `sponsor`, `sso`
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> _builtins.str:
        """
        Required if `azure_enabled`==`true`. Azure active directory app client id
        """
        return pulumi.get(self, "azure_client_id")

    @_builtins.property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> _builtins.str:
        """
        Required if `azure_enabled`==`true`. Azure active directory app client secret
        """
        return pulumi.get(self, "azure_client_secret")

    @_builtins.property
    @pulumi.getter(name="azureEnabled")
    def azure_enabled(self) -> _builtins.bool:
        """
        Whether Azure Active Directory is enabled as a login method
        """
        return pulumi.get(self, "azure_enabled")

    @_builtins.property
    @pulumi.getter(name="azureExpire")
    def azure_expire(self) -> _builtins.int:
        """
        Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "azure_expire")

    @_builtins.property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> _builtins.str:
        """
        Required if `azure_enabled`==`true`. Azure active directory tenant id.
        """
        return pulumi.get(self, "azure_tenant_id")

    @_builtins.property
    @pulumi.getter(name="broadnetPassword")
    def broadnet_password(self) -> _builtins.str:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_password")

    @_builtins.property
    @pulumi.getter(name="broadnetSid")
    def broadnet_sid(self) -> _builtins.str:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_sid")

    @_builtins.property
    @pulumi.getter(name="broadnetUserId")
    def broadnet_user_id(self) -> _builtins.str:
        """
        Required if `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_user_id")

    @_builtins.property
    @pulumi.getter(name="bypassWhenCloudDown")
    def bypass_when_cloud_down(self) -> _builtins.bool:
        """
        Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        """
        return pulumi.get(self, "bypass_when_cloud_down")

    @_builtins.property
    @pulumi.getter(name="clickatellApiKey")
    def clickatell_api_key(self) -> _builtins.str:
        """
        Required if `sms_provider`==`clickatell`
        """
        return pulumi.get(self, "clickatell_api_key")

    @_builtins.property
    @pulumi.getter(name="crossSite")
    def cross_site(self) -> _builtins.bool:
        """
        Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "cross_site")

    @_builtins.property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> _builtins.bool:
        """
        Whether email (access code verification) is enabled as a login method
        """
        return pulumi.get(self, "email_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether guest portal is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def expire(self) -> _builtins.int:
        """
        How long to remain authorized, in minutes
        """
        return pulumi.get(self, "expire")

    @_builtins.property
    @pulumi.getter(name="externalPortalUrl")
    def external_portal_url(self) -> _builtins.str:
        """
        Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        """
        return pulumi.get(self, "external_portal_url")

    @_builtins.property
    @pulumi.getter(name="facebookClientId")
    def facebook_client_id(self) -> _builtins.str:
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "facebook_client_id")

    @_builtins.property
    @pulumi.getter(name="facebookClientSecret")
    def facebook_client_secret(self) -> _builtins.str:
        """
        Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "facebook_client_secret")

    @_builtins.property
    @pulumi.getter(name="facebookEmailDomains")
    def facebook_email_domains(self) -> Sequence[_builtins.str]:
        """
        Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "facebook_email_domains")

    @_builtins.property
    @pulumi.getter(name="facebookEnabled")
    def facebook_enabled(self) -> _builtins.bool:
        """
        Whether facebook is enabled as a login method
        """
        return pulumi.get(self, "facebook_enabled")

    @_builtins.property
    @pulumi.getter(name="facebookExpire")
    def facebook_expire(self) -> _builtins.int:
        """
        Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "facebook_expire")

    @_builtins.property
    @pulumi.getter
    def forward(self) -> _builtins.bool:
        """
        Whether to forward the user to another URL after authorized
        """
        return pulumi.get(self, "forward")

    @_builtins.property
    @pulumi.getter(name="forwardUrl")
    def forward_url(self) -> _builtins.str:
        """
        URL to forward the user to
        """
        return pulumi.get(self, "forward_url")

    @_builtins.property
    @pulumi.getter(name="googleClientId")
    def google_client_id(self) -> _builtins.str:
        """
        Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "google_client_id")

    @_builtins.property
    @pulumi.getter(name="googleClientSecret")
    def google_client_secret(self) -> _builtins.str:
        """
        Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "google_client_secret")

    @_builtins.property
    @pulumi.getter(name="googleEmailDomains")
    def google_email_domains(self) -> Sequence[_builtins.str]:
        """
        Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "google_email_domains")

    @_builtins.property
    @pulumi.getter(name="googleEnabled")
    def google_enabled(self) -> _builtins.bool:
        """
        Whether Google is enabled as login method
        """
        return pulumi.get(self, "google_enabled")

    @_builtins.property
    @pulumi.getter(name="googleExpire")
    def google_expire(self) -> _builtins.int:
        """
        Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "google_expire")

    @_builtins.property
    @pulumi.getter(name="gupshupPassword")
    def gupshup_password(self) -> _builtins.str:
        """
        Required if `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_password")

    @_builtins.property
    @pulumi.getter(name="gupshupUserid")
    def gupshup_userid(self) -> _builtins.str:
        """
        Required if `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_userid")

    @_builtins.property
    @pulumi.getter(name="microsoftClientId")
    def microsoft_client_id(self) -> _builtins.str:
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "microsoft_client_id")

    @_builtins.property
    @pulumi.getter(name="microsoftClientSecret")
    def microsoft_client_secret(self) -> _builtins.str:
        """
        Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a corresponding value. Else leave blank.
        """
        return pulumi.get(self, "microsoft_client_secret")

    @_builtins.property
    @pulumi.getter(name="microsoftEmailDomains")
    def microsoft_email_domains(self) -> Sequence[_builtins.str]:
        """
        Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "microsoft_email_domains")

    @_builtins.property
    @pulumi.getter(name="microsoftEnabled")
    def microsoft_enabled(self) -> _builtins.bool:
        """
        Whether microsoft 365 is enabled as a login method
        """
        return pulumi.get(self, "microsoft_enabled")

    @_builtins.property
    @pulumi.getter(name="microsoftExpire")
    def microsoft_expire(self) -> _builtins.int:
        """
        Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "microsoft_expire")

    @_builtins.property
    @pulumi.getter(name="passphraseEnabled")
    def passphrase_enabled(self) -> _builtins.bool:
        """
        Whether password is enabled
        """
        return pulumi.get(self, "passphrase_enabled")

    @_builtins.property
    @pulumi.getter(name="passphraseExpire")
    def passphrase_expire(self) -> _builtins.int:
        """
        Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        """
        return pulumi.get(self, "passphrase_expire")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Required if `passphrase_enabled`==`true`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="predefinedSponsorsEnabled")
    def predefined_sponsors_enabled(self) -> _builtins.bool:
        """
        Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        """
        return pulumi.get(self, "predefined_sponsors_enabled")

    @_builtins.property
    @pulumi.getter(name="predefinedSponsorsHideEmail")
    def predefined_sponsors_hide_email(self) -> _builtins.bool:
        """
        Whether to hide sponsor’s email from list of sponsors
        """
        return pulumi.get(self, "predefined_sponsors_hide_email")

    @_builtins.property
    @pulumi.getter
    def privacy(self) -> _builtins.bool:
        return pulumi.get(self, "privacy")

    @_builtins.property
    @pulumi.getter(name="puzzelPassword")
    def puzzel_password(self) -> _builtins.str:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_password")

    @_builtins.property
    @pulumi.getter(name="puzzelServiceId")
    def puzzel_service_id(self) -> _builtins.str:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_service_id")

    @_builtins.property
    @pulumi.getter(name="puzzelUsername")
    def puzzel_username(self) -> _builtins.str:
        """
        Required if `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_username")

    @_builtins.property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> _builtins.bool:
        """
        Whether sms is enabled as a login method
        """
        return pulumi.get(self, "sms_enabled")

    @_builtins.property
    @pulumi.getter(name="smsExpire")
    def sms_expire(self) -> _builtins.int:
        """
        Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sms_expire")

    @_builtins.property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> _builtins.str:
        """
        Optional if `sms_enabled`==`true`. SMS Message format
        """
        return pulumi.get(self, "sms_message_format")

    @_builtins.property
    @pulumi.getter(name="smsProvider")
    def sms_provider(self) -> _builtins.str:
        """
        Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        """
        return pulumi.get(self, "sms_provider")

    @_builtins.property
    @pulumi.getter(name="sponsorAutoApprove")
    def sponsor_auto_approve(self) -> _builtins.bool:
        """
        Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        """
        return pulumi.get(self, "sponsor_auto_approve")

    @_builtins.property
    @pulumi.getter(name="sponsorEmailDomains")
    def sponsor_email_domains(self) -> Sequence[_builtins.str]:
        """
        List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        """
        return pulumi.get(self, "sponsor_email_domains")

    @_builtins.property
    @pulumi.getter(name="sponsorEnabled")
    def sponsor_enabled(self) -> _builtins.bool:
        """
        Whether sponsor is enabled
        """
        return pulumi.get(self, "sponsor_enabled")

    @_builtins.property
    @pulumi.getter(name="sponsorExpire")
    def sponsor_expire(self) -> _builtins.int:
        """
        Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sponsor_expire")

    @_builtins.property
    @pulumi.getter(name="sponsorLinkValidityDuration")
    def sponsor_link_validity_duration(self) -> _builtins.str:
        return pulumi.get(self, "sponsor_link_validity_duration")

    @_builtins.property
    @pulumi.getter(name="sponsorNotifyAll")
    def sponsor_notify_all(self) -> _builtins.bool:
        """
        Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        """
        return pulumi.get(self, "sponsor_notify_all")

    @_builtins.property
    @pulumi.getter(name="sponsorStatusNotify")
    def sponsor_status_notify(self) -> _builtins.bool:
        """
        Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)
        """
        return pulumi.get(self, "sponsor_status_notify")

    @_builtins.property
    @pulumi.getter
    def sponsors(self) -> Mapping[str, _builtins.str]:
        """
        object of allowed sponsors email with name. Required if `sponsor_enabled`
                    is `true` and `sponsor_email_domains` is empty.

                    Property key is the sponsor email, Property value is the sponsor name
        """
        return pulumi.get(self, "sponsors")

    @_builtins.property
    @pulumi.getter(name="ssoDefaultRole")
    def sso_default_role(self) -> _builtins.str:
        """
        Optional if `wlan_portal_auth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        """
        return pulumi.get(self, "sso_default_role")

    @_builtins.property
    @pulumi.getter(name="ssoForcedRole")
    def sso_forced_role(self) -> _builtins.str:
        """
        Optional if `wlan_portal_auth`==`sso`
        """
        return pulumi.get(self, "sso_forced_role")

    @_builtins.property
    @pulumi.getter(name="ssoIdpCert")
    def sso_idp_cert(self) -> _builtins.str:
        """
        Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)
        """
        return pulumi.get(self, "sso_idp_cert")

    @_builtins.property
    @pulumi.getter(name="ssoIdpSignAlgo")
    def sso_idp_sign_algo(self) -> _builtins.str:
        """
        Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
        """
        return pulumi.get(self, "sso_idp_sign_algo")

    @_builtins.property
    @pulumi.getter(name="ssoIdpSsoUrl")
    def sso_idp_sso_url(self) -> _builtins.str:
        """
        Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL
        """
        return pulumi.get(self, "sso_idp_sso_url")

    @_builtins.property
    @pulumi.getter(name="ssoIssuer")
    def sso_issuer(self) -> _builtins.str:
        """
        Required if `wlan_portal_auth`==`sso`, IDP issuer URL
        """
        return pulumi.get(self, "sso_issuer")

    @_builtins.property
    @pulumi.getter(name="ssoNameidFormat")
    def sso_nameid_format(self) -> _builtins.str:
        """
        Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`
        """
        return pulumi.get(self, "sso_nameid_format")

    @_builtins.property
    @pulumi.getter(name="telstraClientId")
    def telstra_client_id(self) -> _builtins.str:
        """
        Required if `sms_provider`==`telstra`, Client ID provided by Telstra
        """
        return pulumi.get(self, "telstra_client_id")

    @_builtins.property
    @pulumi.getter(name="telstraClientSecret")
    def telstra_client_secret(self) -> _builtins.str:
        """
        Required if `sms_provider`==`telstra`, Client secret provided by Telstra
        """
        return pulumi.get(self, "telstra_client_secret")

    @_builtins.property
    @pulumi.getter(name="twilioAuthToken")
    def twilio_auth_token(self) -> _builtins.str:
        """
        Required if `sms_provider`==`twilio`, Auth token account with twilio account
        """
        return pulumi.get(self, "twilio_auth_token")

    @_builtins.property
    @pulumi.getter(name="twilioPhoneNumber")
    def twilio_phone_number(self) -> _builtins.str:
        """
        Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        """
        return pulumi.get(self, "twilio_phone_number")

    @_builtins.property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> _builtins.str:
        """
        Required if `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        return pulumi.get(self, "twilio_sid")


@pulumi.output_type
class GetWlansOrgWlanQosResult(dict):
    def __init__(__self__, *,
                 class_: _builtins.str,
                 overwrite: _builtins.bool):
        """
        :param _builtins.str class_: enum: `background`, `best_effort`, `video`, `voice`
        :param _builtins.bool overwrite: Whether to overwrite QoS
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "overwrite", overwrite)

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> _builtins.str:
        """
        enum: `background`, `best_effort`, `video`, `voice`
        """
        return pulumi.get(self, "class_")

    @_builtins.property
    @pulumi.getter
    def overwrite(self) -> _builtins.bool:
        """
        Whether to overwrite QoS
        """
        return pulumi.get(self, "overwrite")


@pulumi.output_type
class GetWlansOrgWlanRadsecResult(dict):
    def __init__(__self__, *,
                 coa_enabled: _builtins.bool,
                 enabled: _builtins.bool,
                 idle_timeout: _builtins.str,
                 mxcluster_ids: Sequence[_builtins.str],
                 proxy_hosts: Sequence[_builtins.str],
                 server_name: _builtins.str,
                 servers: Sequence['outputs.GetWlansOrgWlanRadsecServerResult'],
                 use_mxedge: _builtins.bool,
                 use_site_mxedge: _builtins.bool):
        """
        :param Sequence[_builtins.str] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        :param Sequence[_builtins.str] proxy_hosts: Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        :param _builtins.str server_name: Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param Sequence['GetWlansOrgWlanRadsecServerArgs'] servers: List of RadSec Servers. Only if not Mist Edge.
        :param _builtins.bool use_mxedge: use mxedge(s) as RadSec Proxy
        :param _builtins.bool use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        pulumi.set(__self__, "coa_enabled", coa_enabled)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        pulumi.set(__self__, "server_name", server_name)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "use_mxedge", use_mxedge)
        pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.str:
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Sequence[_builtins.str]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @_builtins.property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Sequence[_builtins.str]:
        """
        Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        """
        return pulumi.get(self, "proxy_hosts")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> _builtins.str:
        """
        Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetWlansOrgWlanRadsecServerResult']:
        """
        List of RadSec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> _builtins.bool:
        """
        use mxedge(s) as RadSec Proxy
        """
        return pulumi.get(self, "use_mxedge")

    @_builtins.property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> _builtins.bool:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")


@pulumi.output_type
class GetWlansOrgWlanRadsecServerResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetWlansOrgWlanRatesetResult(dict):
    def __init__(__self__, *,
                 eht: _builtins.str,
                 he: _builtins.str,
                 ht: _builtins.str,
                 legacies: Sequence[_builtins.str],
                 min_rssi: _builtins.int,
                 template: _builtins.str,
                 vht: _builtins.str):
        """
        :param _builtins.str eht: If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        :param _builtins.str he: If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        :param _builtins.str ht: If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        :param Sequence[_builtins.str] legacies: If `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values
        :param _builtins.int min_rssi: Minimum RSSI for client to connect, 0 means not enforcing
        :param _builtins.str template: Data Rates template to apply. enum: 
                 * `no-legacy`: no 11b
                 * `compatible`: all, like before, default setting that Broadcom/Atheros used
                 * `legacy-only`: disable 802.11n and 802.11ac
                 * `high-density`: no 11b, no low rates
                 * `custom`: user defined
        :param _builtins.str vht: If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
        pulumi.set(__self__, "eht", eht)
        pulumi.set(__self__, "he", he)
        pulumi.set(__self__, "ht", ht)
        pulumi.set(__self__, "legacies", legacies)
        pulumi.set(__self__, "min_rssi", min_rssi)
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "vht", vht)

    @_builtins.property
    @pulumi.getter
    def eht(self) -> _builtins.str:
        """
        If `template`==`custom`. EHT MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit)
        """
        return pulumi.get(self, "eht")

    @_builtins.property
    @pulumi.getter
    def he(self) -> _builtins.str:
        """
        If `template`==`custom`. HE MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit
        """
        return pulumi.get(self, "he")

    @_builtins.property
    @pulumi.getter
    def ht(self) -> _builtins.str:
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
        """
        return pulumi.get(self, "ht")

    @_builtins.property
    @pulumi.getter
    def legacies(self) -> Sequence[_builtins.str]:
        """
        If `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values
        """
        return pulumi.get(self, "legacies")

    @_builtins.property
    @pulumi.getter(name="minRssi")
    def min_rssi(self) -> _builtins.int:
        """
        Minimum RSSI for client to connect, 0 means not enforcing
        """
        return pulumi.get(self, "min_rssi")

    @_builtins.property
    @pulumi.getter
    def template(self) -> _builtins.str:
        """
        Data Rates template to apply. enum: 
          * `no-legacy`: no 11b
          * `compatible`: all, like before, default setting that Broadcom/Atheros used
          * `legacy-only`: disable 802.11n and 802.11ac
          * `high-density`: no 11b, no low rates
          * `custom`: user defined
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter
    def vht(self) -> _builtins.str:
        """
        If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
        """
        return pulumi.get(self, "vht")


@pulumi.output_type
class GetWlansOrgWlanScheduleResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 hours: 'outputs.GetWlansOrgWlanScheduleHoursResult'):
        """
        :param 'GetWlansOrgWlanScheduleHoursArgs' hours: Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "hours", hours)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def hours(self) -> 'outputs.GetWlansOrgWlanScheduleHoursResult':
        """
        Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)
        """
        return pulumi.get(self, "hours")


@pulumi.output_type
class GetWlansOrgWlanScheduleHoursResult(dict):
    def __init__(__self__, *,
                 fri: _builtins.str,
                 mon: _builtins.str,
                 sat: _builtins.str,
                 sun: _builtins.str,
                 thu: _builtins.str,
                 tue: _builtins.str,
                 wed: _builtins.str):
        """
        :param _builtins.str fri: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str mon: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str sat: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str sun: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str thu: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str tue: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        :param _builtins.str wed: Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        pulumi.set(__self__, "fri", fri)
        pulumi.set(__self__, "mon", mon)
        pulumi.set(__self__, "sat", sat)
        pulumi.set(__self__, "sun", sun)
        pulumi.set(__self__, "thu", thu)
        pulumi.set(__self__, "tue", tue)
        pulumi.set(__self__, "wed", wed)

    @_builtins.property
    @pulumi.getter
    def fri(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "fri")

    @_builtins.property
    @pulumi.getter
    def mon(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "mon")

    @_builtins.property
    @pulumi.getter
    def sat(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "sat")

    @_builtins.property
    @pulumi.getter
    def sun(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "sun")

    @_builtins.property
    @pulumi.getter
    def thu(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "thu")

    @_builtins.property
    @pulumi.getter
    def tue(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "tue")

    @_builtins.property
    @pulumi.getter
    def wed(self) -> _builtins.str:
        """
        Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.
        """
        return pulumi.get(self, "wed")


@pulumi.output_type
class GetWlantemplatesOrgWlantemplateResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 org_id: _builtins.str):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")


@pulumi.output_type
class GetWxtagsOrgWxtagResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.float,
                 id: _builtins.str,
                 last_ips: Sequence[_builtins.str],
                 mac: _builtins.str,
                 match: _builtins.str,
                 modified_time: _builtins.float,
                 name: _builtins.str,
                 op: _builtins.str,
                 org_id: _builtins.str,
                 resource_mac: _builtins.str,
                 services: Sequence[_builtins.str],
                 site_id: _builtins.str,
                 specs: Sequence['outputs.GetWxtagsOrgWxtagSpecResult'],
                 subnet: _builtins.str,
                 type: _builtins.str,
                 values: Sequence[_builtins.str],
                 vlan_id: _builtins.str):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param _builtins.str mac: If `type`==`client`, Client MAC Address
        :param _builtins.str match: required if `type`==`match`. enum: `ap_id`, `app`, `asset_mac`, `client_mac`, `hostname`, `ip_range_subnet`, `port`, `psk_name`, `psk_role`, `radius_attr`, `radius_class`, `radius_group`, `radius_username`, `sdkclient_uuid`, `wlan_id`
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str name: The name
        :param _builtins.str op: required if `type`==`match`, type of tag (inclusive/exclusive). enum: `in`, `not_in`
        :param Sequence['GetWxtagsOrgWxtagSpecArgs'] specs: If `type`==`spec`
        :param _builtins.str type: enum: `client`, `match`, `resource`, `spec`, `subnet`, `vlan`
        :param Sequence[_builtins.str] values: Required if `type`==`match` and
                 * `match`==`ap_id`: list of AP IDs
                 * `match`==`app`: list of Application Names
                 * `match`==`asset_mac`: list of Asset MAC Addresses
                 * `match`==`client_mac`: list of Client MAC Addresses
                 * `match`==`hostname`: list of Resources Hostnames
                 * `match`==`ip_range_subnet`: list of IP Addresses and/or CIDRs
                 * `match`==`psk_name`: list of PSK Names
                 * `match`==`psk_role`: list of PSK Roles
                 * `match`==`port`: list of Ports or Port Ranges
                 * `match`==`radius_attr`: list of RADIUS Attributes. The values are [ "6=1", "26=10.2.3.4" ], this support other RADIUS attributes where we know the type
                 * `match`==`radius_class`: list of RADIUS Classes. This matches the ATTR-Class(25)
                 * `match`==`radius_group`: list of RADIUS Groups. This is a smart tag that matches RADIUS-Filter-ID, Airespace-ACL-Name (VendorID=14179, VendorType=6) / Aruba-User-Role (VendorID=14823, VendorType=1)
                 * `match`==`radius_username`: list of RADIUS Usernames. This matches the ATTR-User-Name(1)
                 * `match`==`sdkclient_uuid`: list of SDK UUIDs
                 * `match`==`wlan_id`: list of WLAN IDs
               
               **Notes**:
               Variables are not allowed
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_ips", last_ips)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "resource_mac", resource_mac)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastIps")
    def last_ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "last_ips")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        If `type`==`client`, Client MAC Address
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        required if `type`==`match`. enum: `ap_id`, `app`, `asset_mac`, `client_mac`, `hostname`, `ip_range_subnet`, `port`, `psk_name`, `psk_role`, `radius_attr`, `radius_class`, `radius_group`, `radius_username`, `sdkclient_uuid`, `wlan_id`
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        required if `type`==`match`, type of tag (inclusive/exclusive). enum: `in`, `not_in`
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="resourceMac")
    def resource_mac(self) -> _builtins.str:
        return pulumi.get(self, "resource_mac")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetWxtagsOrgWxtagSpecResult']:
        """
        If `type`==`spec`
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `client`, `match`, `resource`, `spec`, `subnet`, `vlan`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Required if `type`==`match` and
          * `match`==`ap_id`: list of AP IDs
          * `match`==`app`: list of Application Names
          * `match`==`asset_mac`: list of Asset MAC Addresses
          * `match`==`client_mac`: list of Client MAC Addresses
          * `match`==`hostname`: list of Resources Hostnames
          * `match`==`ip_range_subnet`: list of IP Addresses and/or CIDRs
          * `match`==`psk_name`: list of PSK Names
          * `match`==`psk_role`: list of PSK Roles
          * `match`==`port`: list of Ports or Port Ranges
          * `match`==`radius_attr`: list of RADIUS Attributes. The values are [ "6=1", "26=10.2.3.4" ], this support other RADIUS attributes where we know the type
          * `match`==`radius_class`: list of RADIUS Classes. This matches the ATTR-Class(25)
          * `match`==`radius_group`: list of RADIUS Groups. This is a smart tag that matches RADIUS-Filter-ID, Airespace-ACL-Name (VendorID=14179, VendorType=6) / Aruba-User-Role (VendorID=14823, VendorType=1)
          * `match`==`radius_username`: list of RADIUS Usernames. This matches the ATTR-User-Name(1)
          * `match`==`sdkclient_uuid`: list of SDK UUIDs
          * `match`==`wlan_id`: list of WLAN IDs

        **Notes**:
        Variables are not allowed
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetWxtagsOrgWxtagSpecResult(dict):
    def __init__(__self__, *,
                 port_range: _builtins.str,
                 protocol: _builtins.str,
                 subnets: Sequence[_builtins.str]):
        """
        :param _builtins.str port_range: Matched destination port, "0" means any
        :param _builtins.str protocol: tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        :param Sequence[_builtins.str] subnets: Matched destination subnets and/or IP Addresses
        """
        pulumi.set(__self__, "port_range", port_range)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> _builtins.str:
        """
        Matched destination port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        """
        Matched destination subnets and/or IP Addresses
        """
        return pulumi.get(self, "subnets")


