# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['WlanArgs', 'Wlan']

@pulumi.input_type
class WlanArgs:
    def __init__(__self__, *,
                 site_id: pulumi.Input[str],
                 ssid: pulumi.Input[str],
                 acct_immediate_update: Optional[pulumi.Input[bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]] = None,
                 airwatch: Optional[pulumi.Input['WlanAirwatchArgs']] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[bool]] = None,
                 allow_mdns: Optional[pulumi.Input[bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_limit: Optional[pulumi.Input['WlanAppLimitArgs']] = None,
                 app_qos: Optional[pulumi.Input['WlanAppQosArgs']] = None,
                 apply_to: Optional[pulumi.Input[str]] = None,
                 arp_filter: Optional[pulumi.Input[bool]] = None,
                 auth: Optional[pulumi.Input['WlanAuthArgs']] = None,
                 auth_server_selection: Optional[pulumi.Input[str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[int]] = None,
                 band_steer: Optional[pulumi.Input[bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[bool]] = None,
                 bonjour: Optional[pulumi.Input['WlanBonjourArgs']] = None,
                 cisco_cwa: Optional[pulumi.Input['WlanCiscoCwaArgs']] = None,
                 client_limit_down: Optional[pulumi.Input[int]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 client_limit_up: Optional[pulumi.Input[int]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]] = None,
                 disable11ax: Optional[pulumi.Input[bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_wmm: Optional[pulumi.Input[bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input['WlanDnsServerRewriteArgs']] = None,
                 dtim: Optional[pulumi.Input[int]] = None,
                 dynamic_psk: Optional[pulumi.Input['WlanDynamicPskArgs']] = None,
                 dynamic_vlan: Optional[pulumi.Input['WlanDynamicVlanArgs']] = None,
                 enable_local_keycaching: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[bool]] = None,
                 hide_ssid: Optional[pulumi.Input[bool]] = None,
                 hostname_ie: Optional[pulumi.Input[bool]] = None,
                 hotspot20: Optional[pulumi.Input['WlanHotspot20Args']] = None,
                 inject_dhcp_option82: Optional[pulumi.Input['WlanInjectDhcpOption82Args']] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 isolation: Optional[pulumi.Input[bool]] = None,
                 l2_isolation: Optional[pulumi.Input[bool]] = None,
                 legacy_overds: Optional[pulumi.Input[bool]] = None,
                 limit_bcast: Optional[pulumi.Input[bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[bool]] = None,
                 max_idletime: Optional[pulumi.Input[int]] = None,
                 mist_nac: Optional[pulumi.Input['WlanMistNacArgs']] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[bool]] = None,
                 no_static_ip: Optional[pulumi.Input[bool]] = None,
                 portal: Optional[pulumi.Input['WlanPortalArgs']] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 qos: Optional[pulumi.Input['WlanQosArgs']] = None,
                 radsec: Optional[pulumi.Input['WlanRadsecArgs']] = None,
                 roam_mode: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input['WlanScheduleArgs']] = None,
                 sle_excluded: Optional[pulumi.Input[bool]] = None,
                 use_eapol_v1: Optional[pulumi.Input[bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[int]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[int]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a Wlan resource.
        :param pulumi.Input[str] ssid: the name of the SSID
        :param pulumi.Input[bool] acct_immediate_update: enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[int] acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]] acct_servers: list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input['WlanAirwatchArgs'] airwatch: airwatch wlan settings
        :param pulumi.Input[bool] allow_ipv6_ndp: only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[bool] allow_mdns: only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[bool] allow_ssdp: only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ap_ids: list of device ids
        :param pulumi.Input['WlanAppLimitArgs'] app_limit: bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input['WlanAppQosArgs'] app_qos: app qos wlan settings
        :param pulumi.Input[str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[bool] arp_filter: whether to enable smart arp filter
        :param pulumi.Input['WlanAuthArgs'] auth: authentication wlan settings
        :param pulumi.Input[str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]] auth_servers: list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[str] auth_servers_nas_id: optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[str] auth_servers_nas_ip: optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[int] auth_servers_retries: radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
               set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
               default value to 3.
        :param pulumi.Input[int] auth_servers_timeout: radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
               ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
               is also set when setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[bool] band_steer: whether to enable band_steering, this works only when band==both
        :param pulumi.Input[bool] band_steer_force_band5: force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[bool] block_blacklist_clients: whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input['WlanBonjourArgs'] bonjour: bonjour gateway wlan settings
        :param pulumi.Input['WlanCiscoCwaArgs'] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[int] client_limit_down: kbps
        :param pulumi.Input[bool] client_limit_down_enabled: if downlink limiting per-client is enabled
        :param pulumi.Input[int] client_limit_up: kbps
        :param pulumi.Input[bool] client_limit_up_enabled: if uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]] coa_servers: list of COA (change of authorization) servers, optional
        :param pulumi.Input[bool] disable11ax: some old WLAN drivers may not be compatible
        :param pulumi.Input[bool] disable_ht_vht_rates: to disable ht or vht rates
        :param pulumi.Input[bool] disable_uapsd: whether to disable U-APSD
        :param pulumi.Input[bool] disable_v1_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_v2_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_wmm: whether to disable WMM
        :param pulumi.Input['WlanDnsServerRewriteArgs'] dns_server_rewrite: for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input['WlanDynamicPskArgs'] dynamic_psk: for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input['WlanDynamicVlanArgs'] dynamic_vlan: for 802.1x
        :param pulumi.Input[bool] enable_local_keycaching: enable AP-AP keycaching via multicast
        :param pulumi.Input[bool] enable_wireless_bridging: by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        :param pulumi.Input[bool] enable_wireless_bridging_dhcp_tracking: if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[bool] enabled: if this wlan is enabled
        :param pulumi.Input[bool] fast_dot1x_timers: if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[bool] hide_ssid: whether to hide SSID in beacon
        :param pulumi.Input[bool] hostname_ie: include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input['WlanHotspot20Args'] hotspot20: hostspot 2.0 wlan settings
        :param pulumi.Input[str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[bool] isolation: whether to stop clients to talk to each other
        :param pulumi.Input[bool] l2_isolation: if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[bool] legacy_overds: legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[bool] limit_bcast: whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[bool] limit_probe_response: limit probe response base on some heuristic rules
        :param pulumi.Input[int] max_idletime: max idle time in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_ids: when `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_names: when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[bool] no_static_dns: whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[bool] no_static_ip: whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input['WlanPortalArgs'] portal: portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_hostnames: list of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_subnets: list of CIDRs
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_denied_hostnames: list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input['WlanRadsecArgs'] radsec: Radsec settings
        :param pulumi.Input[str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input['WlanScheduleArgs'] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[bool] sle_excluded: whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[bool] use_eapol_v1: if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[bool] vlan_enabled: if vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlan_ids: vlan_ids to use when there’s no match from RA
        :param pulumi.Input[bool] vlan_pooling: vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        :param pulumi.Input[int] wlan_limit_down: kbps
        :param pulumi.Input[bool] wlan_limit_down_enabled: if downlink limiting for whole wlan is enabled
        :param pulumi.Input[int] wlan_limit_up: kbps
        :param pulumi.Input[bool] wlan_limit_up_enabled: if uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wxtag_ids: list of wxtag_ids
        :param pulumi.Input[str] wxtunnel_id: when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[str] wxtunnel_remote_id: when `interface`=`wxtunnel`, remote tunnel identifier
        """
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "ssid", ssid)
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if airwatch is not None:
            pulumi.set(__self__, "airwatch", airwatch)
        if allow_ipv6_ndp is not None:
            pulumi.set(__self__, "allow_ipv6_ndp", allow_ipv6_ndp)
        if allow_mdns is not None:
            pulumi.set(__self__, "allow_mdns", allow_mdns)
        if allow_ssdp is not None:
            pulumi.set(__self__, "allow_ssdp", allow_ssdp)
        if ap_ids is not None:
            pulumi.set(__self__, "ap_ids", ap_ids)
        if app_limit is not None:
            pulumi.set(__self__, "app_limit", app_limit)
        if app_qos is not None:
            pulumi.set(__self__, "app_qos", app_qos)
        if apply_to is not None:
            pulumi.set(__self__, "apply_to", apply_to)
        if arp_filter is not None:
            pulumi.set(__self__, "arp_filter", arp_filter)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_nas_id is not None:
            pulumi.set(__self__, "auth_servers_nas_id", auth_servers_nas_id)
        if auth_servers_nas_ip is not None:
            pulumi.set(__self__, "auth_servers_nas_ip", auth_servers_nas_ip)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if band_steer is not None:
            pulumi.set(__self__, "band_steer", band_steer)
        if band_steer_force_band5 is not None:
            pulumi.set(__self__, "band_steer_force_band5", band_steer_force_band5)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if block_blacklist_clients is not None:
            pulumi.set(__self__, "block_blacklist_clients", block_blacklist_clients)
        if bonjour is not None:
            pulumi.set(__self__, "bonjour", bonjour)
        if cisco_cwa is not None:
            pulumi.set(__self__, "cisco_cwa", cisco_cwa)
        if client_limit_down is not None:
            pulumi.set(__self__, "client_limit_down", client_limit_down)
        if client_limit_down_enabled is not None:
            pulumi.set(__self__, "client_limit_down_enabled", client_limit_down_enabled)
        if client_limit_up is not None:
            pulumi.set(__self__, "client_limit_up", client_limit_up)
        if client_limit_up_enabled is not None:
            pulumi.set(__self__, "client_limit_up_enabled", client_limit_up_enabled)
        if coa_servers is not None:
            pulumi.set(__self__, "coa_servers", coa_servers)
        if disable11ax is not None:
            pulumi.set(__self__, "disable11ax", disable11ax)
        if disable_ht_vht_rates is not None:
            pulumi.set(__self__, "disable_ht_vht_rates", disable_ht_vht_rates)
        if disable_uapsd is not None:
            pulumi.set(__self__, "disable_uapsd", disable_uapsd)
        if disable_v1_roam_notify is not None:
            pulumi.set(__self__, "disable_v1_roam_notify", disable_v1_roam_notify)
        if disable_v2_roam_notify is not None:
            pulumi.set(__self__, "disable_v2_roam_notify", disable_v2_roam_notify)
        if disable_wmm is not None:
            pulumi.set(__self__, "disable_wmm", disable_wmm)
        if dns_server_rewrite is not None:
            pulumi.set(__self__, "dns_server_rewrite", dns_server_rewrite)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if dynamic_psk is not None:
            pulumi.set(__self__, "dynamic_psk", dynamic_psk)
        if dynamic_vlan is not None:
            pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        if enable_local_keycaching is not None:
            pulumi.set(__self__, "enable_local_keycaching", enable_local_keycaching)
        if enable_wireless_bridging is not None:
            pulumi.set(__self__, "enable_wireless_bridging", enable_wireless_bridging)
        if enable_wireless_bridging_dhcp_tracking is not None:
            pulumi.set(__self__, "enable_wireless_bridging_dhcp_tracking", enable_wireless_bridging_dhcp_tracking)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if hide_ssid is not None:
            pulumi.set(__self__, "hide_ssid", hide_ssid)
        if hostname_ie is not None:
            pulumi.set(__self__, "hostname_ie", hostname_ie)
        if hotspot20 is not None:
            pulumi.set(__self__, "hotspot20", hotspot20)
        if inject_dhcp_option82 is not None:
            pulumi.set(__self__, "inject_dhcp_option82", inject_dhcp_option82)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if l2_isolation is not None:
            pulumi.set(__self__, "l2_isolation", l2_isolation)
        if legacy_overds is not None:
            pulumi.set(__self__, "legacy_overds", legacy_overds)
        if limit_bcast is not None:
            pulumi.set(__self__, "limit_bcast", limit_bcast)
        if limit_probe_response is not None:
            pulumi.set(__self__, "limit_probe_response", limit_probe_response)
        if max_idletime is not None:
            pulumi.set(__self__, "max_idletime", max_idletime)
        if mist_nac is not None:
            pulumi.set(__self__, "mist_nac", mist_nac)
        if mxtunnel_ids is not None:
            pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        if mxtunnel_names is not None:
            pulumi.set(__self__, "mxtunnel_names", mxtunnel_names)
        if no_static_dns is not None:
            pulumi.set(__self__, "no_static_dns", no_static_dns)
        if no_static_ip is not None:
            pulumi.set(__self__, "no_static_ip", no_static_ip)
        if portal is not None:
            pulumi.set(__self__, "portal", portal)
        if portal_allowed_hostnames is not None:
            pulumi.set(__self__, "portal_allowed_hostnames", portal_allowed_hostnames)
        if portal_allowed_subnets is not None:
            pulumi.set(__self__, "portal_allowed_subnets", portal_allowed_subnets)
        if portal_denied_hostnames is not None:
            pulumi.set(__self__, "portal_denied_hostnames", portal_denied_hostnames)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if radsec is not None:
            pulumi.set(__self__, "radsec", radsec)
        if roam_mode is not None:
            pulumi.set(__self__, "roam_mode", roam_mode)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if sle_excluded is not None:
            pulumi.set(__self__, "sle_excluded", sle_excluded)
        if use_eapol_v1 is not None:
            pulumi.set(__self__, "use_eapol_v1", use_eapol_v1)
        if vlan_enabled is not None:
            pulumi.set(__self__, "vlan_enabled", vlan_enabled)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)
        if vlan_pooling is not None:
            pulumi.set(__self__, "vlan_pooling", vlan_pooling)
        if wlan_limit_down is not None:
            pulumi.set(__self__, "wlan_limit_down", wlan_limit_down)
        if wlan_limit_down_enabled is not None:
            pulumi.set(__self__, "wlan_limit_down_enabled", wlan_limit_down_enabled)
        if wlan_limit_up is not None:
            pulumi.set(__self__, "wlan_limit_up", wlan_limit_up)
        if wlan_limit_up_enabled is not None:
            pulumi.set(__self__, "wlan_limit_up_enabled", wlan_limit_up_enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)
        if wxtunnel_id is not None:
            pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        if wxtunnel_remote_id is not None:
            pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter
    def ssid(self) -> pulumi.Input[str]:
        """
        the name of the SSID
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssid", value)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[pulumi.Input[bool]]:
        """
        enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @acct_immediate_update.setter
    def acct_immediate_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "acct_immediate_update", value)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[int]]:
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]:
        """
        list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter
    def airwatch(self) -> Optional[pulumi.Input['WlanAirwatchArgs']]:
        """
        airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @airwatch.setter
    def airwatch(self, value: Optional[pulumi.Input['WlanAirwatchArgs']]):
        pulumi.set(self, "airwatch", value)

    @property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> Optional[pulumi.Input[bool]]:
        """
        only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @allow_ipv6_ndp.setter
    def allow_ipv6_ndp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ipv6_ndp", value)

    @property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> Optional[pulumi.Input[bool]]:
        """
        only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @allow_mdns.setter
    def allow_mdns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_mdns", value)

    @property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> Optional[pulumi.Input[bool]]:
        """
        only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @allow_ssdp.setter
    def allow_ssdp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ssdp", value)

    @property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of device ids
        """
        return pulumi.get(self, "ap_ids")

    @ap_ids.setter
    def ap_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ap_ids", value)

    @property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> Optional[pulumi.Input['WlanAppLimitArgs']]:
        """
        bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @app_limit.setter
    def app_limit(self, value: Optional[pulumi.Input['WlanAppLimitArgs']]):
        pulumi.set(self, "app_limit", value)

    @property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> Optional[pulumi.Input['WlanAppQosArgs']]:
        """
        app qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @app_qos.setter
    def app_qos(self, value: Optional[pulumi.Input['WlanAppQosArgs']]):
        pulumi.set(self, "app_qos", value)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @apply_to.setter
    def apply_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_to", value)

    @property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @arp_filter.setter
    def arp_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "arp_filter", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['WlanAuthArgs']]:
        """
        authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['WlanAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[pulumi.Input[str]]:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @auth_server_selection.setter
    def auth_server_selection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_server_selection", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]:
        """
        list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> Optional[pulumi.Input[str]]:
        """
        optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @auth_servers_nas_id.setter
    def auth_servers_nas_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_servers_nas_id", value)

    @property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> Optional[pulumi.Input[str]]:
        """
        optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @auth_servers_nas_ip.setter
    def auth_servers_nas_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_servers_nas_ip", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
        set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
        default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
        ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
        is also set when setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @band_steer.setter
    def band_steer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "band_steer", value)

    @property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> Optional[pulumi.Input[bool]]:
        """
        force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @band_steer_force_band5.setter
    def band_steer_force_band5(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "band_steer_force_band5", value)

    @property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "bands", value)

    @property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @block_blacklist_clients.setter
    def block_blacklist_clients(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_blacklist_clients", value)

    @property
    @pulumi.getter
    def bonjour(self) -> Optional[pulumi.Input['WlanBonjourArgs']]:
        """
        bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @bonjour.setter
    def bonjour(self, value: Optional[pulumi.Input['WlanBonjourArgs']]):
        pulumi.set(self, "bonjour", value)

    @property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> Optional[pulumi.Input['WlanCiscoCwaArgs']]:
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @cisco_cwa.setter
    def cisco_cwa(self, value: Optional[pulumi.Input['WlanCiscoCwaArgs']]):
        pulumi.set(self, "cisco_cwa", value)

    @property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "client_limit_down")

    @client_limit_down.setter
    def client_limit_down(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_limit_down", value)

    @property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @client_limit_down_enabled.setter
    def client_limit_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_limit_down_enabled", value)

    @property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "client_limit_up")

    @client_limit_up.setter
    def client_limit_up(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_limit_up", value)

    @property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @client_limit_up_enabled.setter
    def client_limit_up_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_limit_up_enabled", value)

    @property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]:
        """
        list of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @coa_servers.setter
    def coa_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]):
        pulumi.set(self, "coa_servers", value)

    @property
    @pulumi.getter
    def disable11ax(self) -> Optional[pulumi.Input[bool]]:
        """
        some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @disable11ax.setter
    def disable11ax(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable11ax", value)

    @property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> Optional[pulumi.Input[bool]]:
        """
        to disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @disable_ht_vht_rates.setter
    def disable_ht_vht_rates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_ht_vht_rates", value)

    @property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @disable_uapsd.setter
    def disable_uapsd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_uapsd", value)

    @property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> Optional[pulumi.Input[bool]]:
        """
        disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @disable_v1_roam_notify.setter
    def disable_v1_roam_notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_v1_roam_notify", value)

    @property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> Optional[pulumi.Input[bool]]:
        """
        disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @disable_v2_roam_notify.setter
    def disable_v2_roam_notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_v2_roam_notify", value)

    @property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @disable_wmm.setter
    def disable_wmm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_wmm", value)

    @property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> Optional[pulumi.Input['WlanDnsServerRewriteArgs']]:
        """
        for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @dns_server_rewrite.setter
    def dns_server_rewrite(self, value: Optional[pulumi.Input['WlanDnsServerRewriteArgs']]):
        pulumi.set(self, "dns_server_rewrite", value)

    @property
    @pulumi.getter
    def dtim(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dtim")

    @dtim.setter
    def dtim(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dtim", value)

    @property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> Optional[pulumi.Input['WlanDynamicPskArgs']]:
        """
        for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @dynamic_psk.setter
    def dynamic_psk(self, value: Optional[pulumi.Input['WlanDynamicPskArgs']]):
        pulumi.set(self, "dynamic_psk", value)

    @property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> Optional[pulumi.Input['WlanDynamicVlanArgs']]:
        """
        for 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @dynamic_vlan.setter
    def dynamic_vlan(self, value: Optional[pulumi.Input['WlanDynamicVlanArgs']]):
        pulumi.set(self, "dynamic_vlan", value)

    @property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> Optional[pulumi.Input[bool]]:
        """
        enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @enable_local_keycaching.setter
    def enable_local_keycaching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_keycaching", value)

    @property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @enable_wireless_bridging.setter
    def enable_wireless_bridging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_wireless_bridging", value)

    @property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> Optional[pulumi.Input[bool]]:
        """
        if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @enable_wireless_bridging_dhcp_tracking.setter
    def enable_wireless_bridging_dhcp_tracking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_wireless_bridging_dhcp_tracking", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[pulumi.Input[bool]]:
        """
        if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @fast_dot1x_timers.setter
    def fast_dot1x_timers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fast_dot1x_timers", value)

    @property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @hide_ssid.setter
    def hide_ssid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_ssid", value)

    @property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> Optional[pulumi.Input[bool]]:
        """
        include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @hostname_ie.setter
    def hostname_ie(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hostname_ie", value)

    @property
    @pulumi.getter
    def hotspot20(self) -> Optional[pulumi.Input['WlanHotspot20Args']]:
        """
        hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @hotspot20.setter
    def hotspot20(self, value: Optional[pulumi.Input['WlanHotspot20Args']]):
        pulumi.set(self, "hotspot20", value)

    @property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> Optional[pulumi.Input['WlanInjectDhcpOption82Args']]:
        return pulumi.get(self, "inject_dhcp_option82")

    @inject_dhcp_option82.setter
    def inject_dhcp_option82(self, value: Optional[pulumi.Input['WlanInjectDhcpOption82Args']]):
        pulumi.set(self, "inject_dhcp_option82", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @l2_isolation.setter
    def l2_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "l2_isolation", value)

    @property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> Optional[pulumi.Input[bool]]:
        """
        legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @legacy_overds.setter
    def legacy_overds(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "legacy_overds", value)

    @property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @limit_bcast.setter
    def limit_bcast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_bcast", value)

    @property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> Optional[pulumi.Input[bool]]:
        """
        limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @limit_probe_response.setter
    def limit_probe_response(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_probe_response", value)

    @property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> Optional[pulumi.Input[int]]:
        """
        max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @max_idletime.setter
    def max_idletime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_idletime", value)

    @property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> Optional[pulumi.Input['WlanMistNacArgs']]:
        return pulumi.get(self, "mist_nac")

    @mist_nac.setter
    def mist_nac(self, value: Optional[pulumi.Input['WlanMistNacArgs']]):
        pulumi.set(self, "mist_nac", value)

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @mxtunnel_ids.setter
    def mxtunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mxtunnel_ids", value)

    @property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @mxtunnel_names.setter
    def mxtunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mxtunnel_names", value)

    @property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @no_static_dns.setter
    def no_static_dns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_static_dns", value)

    @property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @no_static_ip.setter
    def no_static_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_static_ip", value)

    @property
    @pulumi.getter
    def portal(self) -> Optional[pulumi.Input['WlanPortalArgs']]:
        """
        portal wlan settings
        """
        return pulumi.get(self, "portal")

    @portal.setter
    def portal(self, value: Optional[pulumi.Input['WlanPortalArgs']]):
        pulumi.set(self, "portal", value)

    @property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @portal_allowed_hostnames.setter
    def portal_allowed_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "portal_allowed_hostnames", value)

    @property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @portal_allowed_subnets.setter
    def portal_allowed_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "portal_allowed_subnets", value)

    @property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @portal_denied_hostnames.setter
    def portal_denied_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "portal_denied_hostnames", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input['WlanQosArgs']]:
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input['WlanQosArgs']]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter
    def radsec(self) -> Optional[pulumi.Input['WlanRadsecArgs']]:
        """
        Radsec settings
        """
        return pulumi.get(self, "radsec")

    @radsec.setter
    def radsec(self, value: Optional[pulumi.Input['WlanRadsecArgs']]):
        pulumi.set(self, "radsec", value)

    @property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @roam_mode.setter
    def roam_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roam_mode", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['WlanScheduleArgs']]:
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['WlanScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @sle_excluded.setter
    def sle_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sle_excluded", value)

    @property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> Optional[pulumi.Input[bool]]:
        """
        if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @use_eapol_v1.setter
    def use_eapol_v1(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_eapol_v1", value)

    @property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @vlan_enabled.setter
    def vlan_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vlan_enabled", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vlan_ids to use when there’s no match from RA
        """
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlan_ids", value)

    @property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> Optional[pulumi.Input[bool]]:
        """
        vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @vlan_pooling.setter
    def vlan_pooling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vlan_pooling", value)

    @property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "wlan_limit_down")

    @wlan_limit_down.setter
    def wlan_limit_down(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wlan_limit_down", value)

    @property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @wlan_limit_down_enabled.setter
    def wlan_limit_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wlan_limit_down_enabled", value)

    @property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "wlan_limit_up")

    @wlan_limit_up.setter
    def wlan_limit_up(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wlan_limit_up", value)

    @property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @wlan_limit_up_enabled.setter
    def wlan_limit_up_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wlan_limit_up_enabled", value)

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @wxtag_ids.setter
    def wxtag_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wxtag_ids", value)

    @property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @wxtunnel_id.setter
    def wxtunnel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wxtunnel_id", value)

    @property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")

    @wxtunnel_remote_id.setter
    def wxtunnel_remote_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wxtunnel_remote_id", value)


@pulumi.input_type
class _WlanState:
    def __init__(__self__, *,
                 acct_immediate_update: Optional[pulumi.Input[bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]] = None,
                 airwatch: Optional[pulumi.Input['WlanAirwatchArgs']] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[bool]] = None,
                 allow_mdns: Optional[pulumi.Input[bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_limit: Optional[pulumi.Input['WlanAppLimitArgs']] = None,
                 app_qos: Optional[pulumi.Input['WlanAppQosArgs']] = None,
                 apply_to: Optional[pulumi.Input[str]] = None,
                 arp_filter: Optional[pulumi.Input[bool]] = None,
                 auth: Optional[pulumi.Input['WlanAuthArgs']] = None,
                 auth_server_selection: Optional[pulumi.Input[str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[int]] = None,
                 band_steer: Optional[pulumi.Input[bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[bool]] = None,
                 bonjour: Optional[pulumi.Input['WlanBonjourArgs']] = None,
                 cisco_cwa: Optional[pulumi.Input['WlanCiscoCwaArgs']] = None,
                 client_limit_down: Optional[pulumi.Input[int]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 client_limit_up: Optional[pulumi.Input[int]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]] = None,
                 disable11ax: Optional[pulumi.Input[bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_wmm: Optional[pulumi.Input[bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input['WlanDnsServerRewriteArgs']] = None,
                 dtim: Optional[pulumi.Input[int]] = None,
                 dynamic_psk: Optional[pulumi.Input['WlanDynamicPskArgs']] = None,
                 dynamic_vlan: Optional[pulumi.Input['WlanDynamicVlanArgs']] = None,
                 enable_local_keycaching: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[bool]] = None,
                 hide_ssid: Optional[pulumi.Input[bool]] = None,
                 hostname_ie: Optional[pulumi.Input[bool]] = None,
                 hotspot20: Optional[pulumi.Input['WlanHotspot20Args']] = None,
                 inject_dhcp_option82: Optional[pulumi.Input['WlanInjectDhcpOption82Args']] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 isolation: Optional[pulumi.Input[bool]] = None,
                 l2_isolation: Optional[pulumi.Input[bool]] = None,
                 legacy_overds: Optional[pulumi.Input[bool]] = None,
                 limit_bcast: Optional[pulumi.Input[bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[bool]] = None,
                 max_idletime: Optional[pulumi.Input[int]] = None,
                 mist_nac: Optional[pulumi.Input['WlanMistNacArgs']] = None,
                 msp_id: Optional[pulumi.Input[str]] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[bool]] = None,
                 no_static_ip: Optional[pulumi.Input[bool]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 portal: Optional[pulumi.Input['WlanPortalArgs']] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_api_secret: Optional[pulumi.Input[str]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_image: Optional[pulumi.Input[str]] = None,
                 portal_sso_url: Optional[pulumi.Input[str]] = None,
                 portal_template_url: Optional[pulumi.Input[str]] = None,
                 qos: Optional[pulumi.Input['WlanQosArgs']] = None,
                 radsec: Optional[pulumi.Input['WlanRadsecArgs']] = None,
                 roam_mode: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input['WlanScheduleArgs']] = None,
                 site_id: Optional[pulumi.Input[str]] = None,
                 sle_excluded: Optional[pulumi.Input[bool]] = None,
                 ssid: Optional[pulumi.Input[str]] = None,
                 thumbnail: Optional[pulumi.Input[str]] = None,
                 use_eapol_v1: Optional[pulumi.Input[bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[int]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[int]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering Wlan resources.
        :param pulumi.Input[bool] acct_immediate_update: enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[int] acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]] acct_servers: list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input['WlanAirwatchArgs'] airwatch: airwatch wlan settings
        :param pulumi.Input[bool] allow_ipv6_ndp: only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[bool] allow_mdns: only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[bool] allow_ssdp: only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ap_ids: list of device ids
        :param pulumi.Input['WlanAppLimitArgs'] app_limit: bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input['WlanAppQosArgs'] app_qos: app qos wlan settings
        :param pulumi.Input[str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[bool] arp_filter: whether to enable smart arp filter
        :param pulumi.Input['WlanAuthArgs'] auth: authentication wlan settings
        :param pulumi.Input[str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]] auth_servers: list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[str] auth_servers_nas_id: optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[str] auth_servers_nas_ip: optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[int] auth_servers_retries: radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
               set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
               default value to 3.
        :param pulumi.Input[int] auth_servers_timeout: radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
               ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
               is also set when setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[bool] band_steer: whether to enable band_steering, this works only when band==both
        :param pulumi.Input[bool] band_steer_force_band5: force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[bool] block_blacklist_clients: whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input['WlanBonjourArgs'] bonjour: bonjour gateway wlan settings
        :param pulumi.Input['WlanCiscoCwaArgs'] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[int] client_limit_down: kbps
        :param pulumi.Input[bool] client_limit_down_enabled: if downlink limiting per-client is enabled
        :param pulumi.Input[int] client_limit_up: kbps
        :param pulumi.Input[bool] client_limit_up_enabled: if uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]] coa_servers: list of COA (change of authorization) servers, optional
        :param pulumi.Input[bool] disable11ax: some old WLAN drivers may not be compatible
        :param pulumi.Input[bool] disable_ht_vht_rates: to disable ht or vht rates
        :param pulumi.Input[bool] disable_uapsd: whether to disable U-APSD
        :param pulumi.Input[bool] disable_v1_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_v2_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_wmm: whether to disable WMM
        :param pulumi.Input['WlanDnsServerRewriteArgs'] dns_server_rewrite: for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input['WlanDynamicPskArgs'] dynamic_psk: for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input['WlanDynamicVlanArgs'] dynamic_vlan: for 802.1x
        :param pulumi.Input[bool] enable_local_keycaching: enable AP-AP keycaching via multicast
        :param pulumi.Input[bool] enable_wireless_bridging: by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        :param pulumi.Input[bool] enable_wireless_bridging_dhcp_tracking: if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[bool] enabled: if this wlan is enabled
        :param pulumi.Input[bool] fast_dot1x_timers: if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[bool] hide_ssid: whether to hide SSID in beacon
        :param pulumi.Input[bool] hostname_ie: include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input['WlanHotspot20Args'] hotspot20: hostspot 2.0 wlan settings
        :param pulumi.Input[str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[bool] isolation: whether to stop clients to talk to each other
        :param pulumi.Input[bool] l2_isolation: if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[bool] legacy_overds: legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[bool] limit_bcast: whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[bool] limit_probe_response: limit probe response base on some heuristic rules
        :param pulumi.Input[int] max_idletime: max idle time in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_ids: when `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_names: when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[bool] no_static_dns: whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[bool] no_static_ip: whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input['WlanPortalArgs'] portal: portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_hostnames: list of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_subnets: list of CIDRs
        :param pulumi.Input[str] portal_api_secret: api secret (auto-generated) that can be used to sign guest authorization requests
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_denied_hostnames: list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input[str] portal_image: Url of portal background image
        :param pulumi.Input[str] portal_template_url: N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
               To update portal_template, use Wlan Portal Template.
        :param pulumi.Input['WlanRadsecArgs'] radsec: Radsec settings
        :param pulumi.Input[str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input['WlanScheduleArgs'] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[bool] sle_excluded: whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[str] ssid: the name of the SSID
        :param pulumi.Input[str] thumbnail: Url of portal background image thumbnail
        :param pulumi.Input[bool] use_eapol_v1: if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[bool] vlan_enabled: if vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlan_ids: vlan_ids to use when there’s no match from RA
        :param pulumi.Input[bool] vlan_pooling: vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        :param pulumi.Input[int] wlan_limit_down: kbps
        :param pulumi.Input[bool] wlan_limit_down_enabled: if downlink limiting for whole wlan is enabled
        :param pulumi.Input[int] wlan_limit_up: kbps
        :param pulumi.Input[bool] wlan_limit_up_enabled: if uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wxtag_ids: list of wxtag_ids
        :param pulumi.Input[str] wxtunnel_id: when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[str] wxtunnel_remote_id: when `interface`=`wxtunnel`, remote tunnel identifier
        """
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if airwatch is not None:
            pulumi.set(__self__, "airwatch", airwatch)
        if allow_ipv6_ndp is not None:
            pulumi.set(__self__, "allow_ipv6_ndp", allow_ipv6_ndp)
        if allow_mdns is not None:
            pulumi.set(__self__, "allow_mdns", allow_mdns)
        if allow_ssdp is not None:
            pulumi.set(__self__, "allow_ssdp", allow_ssdp)
        if ap_ids is not None:
            pulumi.set(__self__, "ap_ids", ap_ids)
        if app_limit is not None:
            pulumi.set(__self__, "app_limit", app_limit)
        if app_qos is not None:
            pulumi.set(__self__, "app_qos", app_qos)
        if apply_to is not None:
            pulumi.set(__self__, "apply_to", apply_to)
        if arp_filter is not None:
            pulumi.set(__self__, "arp_filter", arp_filter)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_nas_id is not None:
            pulumi.set(__self__, "auth_servers_nas_id", auth_servers_nas_id)
        if auth_servers_nas_ip is not None:
            pulumi.set(__self__, "auth_servers_nas_ip", auth_servers_nas_ip)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if band_steer is not None:
            pulumi.set(__self__, "band_steer", band_steer)
        if band_steer_force_band5 is not None:
            pulumi.set(__self__, "band_steer_force_band5", band_steer_force_band5)
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if block_blacklist_clients is not None:
            pulumi.set(__self__, "block_blacklist_clients", block_blacklist_clients)
        if bonjour is not None:
            pulumi.set(__self__, "bonjour", bonjour)
        if cisco_cwa is not None:
            pulumi.set(__self__, "cisco_cwa", cisco_cwa)
        if client_limit_down is not None:
            pulumi.set(__self__, "client_limit_down", client_limit_down)
        if client_limit_down_enabled is not None:
            pulumi.set(__self__, "client_limit_down_enabled", client_limit_down_enabled)
        if client_limit_up is not None:
            pulumi.set(__self__, "client_limit_up", client_limit_up)
        if client_limit_up_enabled is not None:
            pulumi.set(__self__, "client_limit_up_enabled", client_limit_up_enabled)
        if coa_servers is not None:
            pulumi.set(__self__, "coa_servers", coa_servers)
        if disable11ax is not None:
            pulumi.set(__self__, "disable11ax", disable11ax)
        if disable_ht_vht_rates is not None:
            pulumi.set(__self__, "disable_ht_vht_rates", disable_ht_vht_rates)
        if disable_uapsd is not None:
            pulumi.set(__self__, "disable_uapsd", disable_uapsd)
        if disable_v1_roam_notify is not None:
            pulumi.set(__self__, "disable_v1_roam_notify", disable_v1_roam_notify)
        if disable_v2_roam_notify is not None:
            pulumi.set(__self__, "disable_v2_roam_notify", disable_v2_roam_notify)
        if disable_wmm is not None:
            pulumi.set(__self__, "disable_wmm", disable_wmm)
        if dns_server_rewrite is not None:
            pulumi.set(__self__, "dns_server_rewrite", dns_server_rewrite)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if dynamic_psk is not None:
            pulumi.set(__self__, "dynamic_psk", dynamic_psk)
        if dynamic_vlan is not None:
            pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        if enable_local_keycaching is not None:
            pulumi.set(__self__, "enable_local_keycaching", enable_local_keycaching)
        if enable_wireless_bridging is not None:
            pulumi.set(__self__, "enable_wireless_bridging", enable_wireless_bridging)
        if enable_wireless_bridging_dhcp_tracking is not None:
            pulumi.set(__self__, "enable_wireless_bridging_dhcp_tracking", enable_wireless_bridging_dhcp_tracking)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if hide_ssid is not None:
            pulumi.set(__self__, "hide_ssid", hide_ssid)
        if hostname_ie is not None:
            pulumi.set(__self__, "hostname_ie", hostname_ie)
        if hotspot20 is not None:
            pulumi.set(__self__, "hotspot20", hotspot20)
        if inject_dhcp_option82 is not None:
            pulumi.set(__self__, "inject_dhcp_option82", inject_dhcp_option82)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if l2_isolation is not None:
            pulumi.set(__self__, "l2_isolation", l2_isolation)
        if legacy_overds is not None:
            pulumi.set(__self__, "legacy_overds", legacy_overds)
        if limit_bcast is not None:
            pulumi.set(__self__, "limit_bcast", limit_bcast)
        if limit_probe_response is not None:
            pulumi.set(__self__, "limit_probe_response", limit_probe_response)
        if max_idletime is not None:
            pulumi.set(__self__, "max_idletime", max_idletime)
        if mist_nac is not None:
            pulumi.set(__self__, "mist_nac", mist_nac)
        if msp_id is not None:
            pulumi.set(__self__, "msp_id", msp_id)
        if mxtunnel_ids is not None:
            pulumi.set(__self__, "mxtunnel_ids", mxtunnel_ids)
        if mxtunnel_names is not None:
            pulumi.set(__self__, "mxtunnel_names", mxtunnel_names)
        if no_static_dns is not None:
            pulumi.set(__self__, "no_static_dns", no_static_dns)
        if no_static_ip is not None:
            pulumi.set(__self__, "no_static_ip", no_static_ip)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if portal is not None:
            pulumi.set(__self__, "portal", portal)
        if portal_allowed_hostnames is not None:
            pulumi.set(__self__, "portal_allowed_hostnames", portal_allowed_hostnames)
        if portal_allowed_subnets is not None:
            pulumi.set(__self__, "portal_allowed_subnets", portal_allowed_subnets)
        if portal_api_secret is not None:
            pulumi.set(__self__, "portal_api_secret", portal_api_secret)
        if portal_denied_hostnames is not None:
            pulumi.set(__self__, "portal_denied_hostnames", portal_denied_hostnames)
        if portal_image is not None:
            pulumi.set(__self__, "portal_image", portal_image)
        if portal_sso_url is not None:
            pulumi.set(__self__, "portal_sso_url", portal_sso_url)
        if portal_template_url is not None:
            pulumi.set(__self__, "portal_template_url", portal_template_url)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if radsec is not None:
            pulumi.set(__self__, "radsec", radsec)
        if roam_mode is not None:
            pulumi.set(__self__, "roam_mode", roam_mode)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if sle_excluded is not None:
            pulumi.set(__self__, "sle_excluded", sle_excluded)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)
        if thumbnail is not None:
            pulumi.set(__self__, "thumbnail", thumbnail)
        if use_eapol_v1 is not None:
            pulumi.set(__self__, "use_eapol_v1", use_eapol_v1)
        if vlan_enabled is not None:
            pulumi.set(__self__, "vlan_enabled", vlan_enabled)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)
        if vlan_pooling is not None:
            pulumi.set(__self__, "vlan_pooling", vlan_pooling)
        if wlan_limit_down is not None:
            pulumi.set(__self__, "wlan_limit_down", wlan_limit_down)
        if wlan_limit_down_enabled is not None:
            pulumi.set(__self__, "wlan_limit_down_enabled", wlan_limit_down_enabled)
        if wlan_limit_up is not None:
            pulumi.set(__self__, "wlan_limit_up", wlan_limit_up)
        if wlan_limit_up_enabled is not None:
            pulumi.set(__self__, "wlan_limit_up_enabled", wlan_limit_up_enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)
        if wxtunnel_id is not None:
            pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        if wxtunnel_remote_id is not None:
            pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[pulumi.Input[bool]]:
        """
        enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @acct_immediate_update.setter
    def acct_immediate_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "acct_immediate_update", value)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[int]]:
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]:
        """
        list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter
    def airwatch(self) -> Optional[pulumi.Input['WlanAirwatchArgs']]:
        """
        airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @airwatch.setter
    def airwatch(self, value: Optional[pulumi.Input['WlanAirwatchArgs']]):
        pulumi.set(self, "airwatch", value)

    @property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> Optional[pulumi.Input[bool]]:
        """
        only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @allow_ipv6_ndp.setter
    def allow_ipv6_ndp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ipv6_ndp", value)

    @property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> Optional[pulumi.Input[bool]]:
        """
        only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @allow_mdns.setter
    def allow_mdns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_mdns", value)

    @property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> Optional[pulumi.Input[bool]]:
        """
        only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @allow_ssdp.setter
    def allow_ssdp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ssdp", value)

    @property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of device ids
        """
        return pulumi.get(self, "ap_ids")

    @ap_ids.setter
    def ap_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ap_ids", value)

    @property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> Optional[pulumi.Input['WlanAppLimitArgs']]:
        """
        bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @app_limit.setter
    def app_limit(self, value: Optional[pulumi.Input['WlanAppLimitArgs']]):
        pulumi.set(self, "app_limit", value)

    @property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> Optional[pulumi.Input['WlanAppQosArgs']]:
        """
        app qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @app_qos.setter
    def app_qos(self, value: Optional[pulumi.Input['WlanAppQosArgs']]):
        pulumi.set(self, "app_qos", value)

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @apply_to.setter
    def apply_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_to", value)

    @property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @arp_filter.setter
    def arp_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "arp_filter", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['WlanAuthArgs']]:
        """
        authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['WlanAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[pulumi.Input[str]]:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @auth_server_selection.setter
    def auth_server_selection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_server_selection", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]:
        """
        list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> Optional[pulumi.Input[str]]:
        """
        optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @auth_servers_nas_id.setter
    def auth_servers_nas_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_servers_nas_id", value)

    @property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> Optional[pulumi.Input[str]]:
        """
        optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @auth_servers_nas_ip.setter
    def auth_servers_nas_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_servers_nas_ip", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
        set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
        default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
        ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
        is also set when setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @band_steer.setter
    def band_steer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "band_steer", value)

    @property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> Optional[pulumi.Input[bool]]:
        """
        force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @band_steer_force_band5.setter
    def band_steer_force_band5(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "band_steer_force_band5", value)

    @property
    @pulumi.getter
    def bands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @bands.setter
    def bands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "bands", value)

    @property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @block_blacklist_clients.setter
    def block_blacklist_clients(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_blacklist_clients", value)

    @property
    @pulumi.getter
    def bonjour(self) -> Optional[pulumi.Input['WlanBonjourArgs']]:
        """
        bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @bonjour.setter
    def bonjour(self, value: Optional[pulumi.Input['WlanBonjourArgs']]):
        pulumi.set(self, "bonjour", value)

    @property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> Optional[pulumi.Input['WlanCiscoCwaArgs']]:
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @cisco_cwa.setter
    def cisco_cwa(self, value: Optional[pulumi.Input['WlanCiscoCwaArgs']]):
        pulumi.set(self, "cisco_cwa", value)

    @property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "client_limit_down")

    @client_limit_down.setter
    def client_limit_down(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_limit_down", value)

    @property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @client_limit_down_enabled.setter
    def client_limit_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_limit_down_enabled", value)

    @property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "client_limit_up")

    @client_limit_up.setter
    def client_limit_up(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_limit_up", value)

    @property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @client_limit_up_enabled.setter
    def client_limit_up_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_limit_up_enabled", value)

    @property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]:
        """
        list of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @coa_servers.setter
    def coa_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanCoaServerArgs']]]]):
        pulumi.set(self, "coa_servers", value)

    @property
    @pulumi.getter
    def disable11ax(self) -> Optional[pulumi.Input[bool]]:
        """
        some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @disable11ax.setter
    def disable11ax(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable11ax", value)

    @property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> Optional[pulumi.Input[bool]]:
        """
        to disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @disable_ht_vht_rates.setter
    def disable_ht_vht_rates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_ht_vht_rates", value)

    @property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @disable_uapsd.setter
    def disable_uapsd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_uapsd", value)

    @property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> Optional[pulumi.Input[bool]]:
        """
        disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @disable_v1_roam_notify.setter
    def disable_v1_roam_notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_v1_roam_notify", value)

    @property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> Optional[pulumi.Input[bool]]:
        """
        disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @disable_v2_roam_notify.setter
    def disable_v2_roam_notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_v2_roam_notify", value)

    @property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @disable_wmm.setter
    def disable_wmm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_wmm", value)

    @property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> Optional[pulumi.Input['WlanDnsServerRewriteArgs']]:
        """
        for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @dns_server_rewrite.setter
    def dns_server_rewrite(self, value: Optional[pulumi.Input['WlanDnsServerRewriteArgs']]):
        pulumi.set(self, "dns_server_rewrite", value)

    @property
    @pulumi.getter
    def dtim(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dtim")

    @dtim.setter
    def dtim(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dtim", value)

    @property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> Optional[pulumi.Input['WlanDynamicPskArgs']]:
        """
        for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @dynamic_psk.setter
    def dynamic_psk(self, value: Optional[pulumi.Input['WlanDynamicPskArgs']]):
        pulumi.set(self, "dynamic_psk", value)

    @property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> Optional[pulumi.Input['WlanDynamicVlanArgs']]:
        """
        for 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @dynamic_vlan.setter
    def dynamic_vlan(self, value: Optional[pulumi.Input['WlanDynamicVlanArgs']]):
        pulumi.set(self, "dynamic_vlan", value)

    @property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> Optional[pulumi.Input[bool]]:
        """
        enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @enable_local_keycaching.setter
    def enable_local_keycaching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_keycaching", value)

    @property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @enable_wireless_bridging.setter
    def enable_wireless_bridging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_wireless_bridging", value)

    @property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> Optional[pulumi.Input[bool]]:
        """
        if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @enable_wireless_bridging_dhcp_tracking.setter
    def enable_wireless_bridging_dhcp_tracking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_wireless_bridging_dhcp_tracking", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[pulumi.Input[bool]]:
        """
        if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @fast_dot1x_timers.setter
    def fast_dot1x_timers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fast_dot1x_timers", value)

    @property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @hide_ssid.setter
    def hide_ssid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_ssid", value)

    @property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> Optional[pulumi.Input[bool]]:
        """
        include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @hostname_ie.setter
    def hostname_ie(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hostname_ie", value)

    @property
    @pulumi.getter
    def hotspot20(self) -> Optional[pulumi.Input['WlanHotspot20Args']]:
        """
        hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @hotspot20.setter
    def hotspot20(self, value: Optional[pulumi.Input['WlanHotspot20Args']]):
        pulumi.set(self, "hotspot20", value)

    @property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> Optional[pulumi.Input['WlanInjectDhcpOption82Args']]:
        return pulumi.get(self, "inject_dhcp_option82")

    @inject_dhcp_option82.setter
    def inject_dhcp_option82(self, value: Optional[pulumi.Input['WlanInjectDhcpOption82Args']]):
        pulumi.set(self, "inject_dhcp_option82", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @l2_isolation.setter
    def l2_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "l2_isolation", value)

    @property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> Optional[pulumi.Input[bool]]:
        """
        legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @legacy_overds.setter
    def legacy_overds(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "legacy_overds", value)

    @property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @limit_bcast.setter
    def limit_bcast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_bcast", value)

    @property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> Optional[pulumi.Input[bool]]:
        """
        limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @limit_probe_response.setter
    def limit_probe_response(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "limit_probe_response", value)

    @property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> Optional[pulumi.Input[int]]:
        """
        max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @max_idletime.setter
    def max_idletime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_idletime", value)

    @property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> Optional[pulumi.Input['WlanMistNacArgs']]:
        return pulumi.get(self, "mist_nac")

    @mist_nac.setter
    def mist_nac(self, value: Optional[pulumi.Input['WlanMistNacArgs']]):
        pulumi.set(self, "mist_nac", value)

    @property
    @pulumi.getter(name="mspId")
    def msp_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "msp_id")

    @msp_id.setter
    def msp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msp_id", value)

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @mxtunnel_ids.setter
    def mxtunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mxtunnel_ids", value)

    @property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @mxtunnel_names.setter
    def mxtunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mxtunnel_names", value)

    @property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @no_static_dns.setter
    def no_static_dns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_static_dns", value)

    @property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @no_static_ip.setter
    def no_static_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_static_ip", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def portal(self) -> Optional[pulumi.Input['WlanPortalArgs']]:
        """
        portal wlan settings
        """
        return pulumi.get(self, "portal")

    @portal.setter
    def portal(self, value: Optional[pulumi.Input['WlanPortalArgs']]):
        pulumi.set(self, "portal", value)

    @property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @portal_allowed_hostnames.setter
    def portal_allowed_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "portal_allowed_hostnames", value)

    @property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @portal_allowed_subnets.setter
    def portal_allowed_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "portal_allowed_subnets", value)

    @property
    @pulumi.getter(name="portalApiSecret")
    def portal_api_secret(self) -> Optional[pulumi.Input[str]]:
        """
        api secret (auto-generated) that can be used to sign guest authorization requests
        """
        return pulumi.get(self, "portal_api_secret")

    @portal_api_secret.setter
    def portal_api_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "portal_api_secret", value)

    @property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @portal_denied_hostnames.setter
    def portal_denied_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "portal_denied_hostnames", value)

    @property
    @pulumi.getter(name="portalImage")
    def portal_image(self) -> Optional[pulumi.Input[str]]:
        """
        Url of portal background image
        """
        return pulumi.get(self, "portal_image")

    @portal_image.setter
    def portal_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "portal_image", value)

    @property
    @pulumi.getter(name="portalSsoUrl")
    def portal_sso_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "portal_sso_url")

    @portal_sso_url.setter
    def portal_sso_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "portal_sso_url", value)

    @property
    @pulumi.getter(name="portalTemplateUrl")
    def portal_template_url(self) -> Optional[pulumi.Input[str]]:
        """
        N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
        To update portal_template, use Wlan Portal Template.
        """
        return pulumi.get(self, "portal_template_url")

    @portal_template_url.setter
    def portal_template_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "portal_template_url", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input['WlanQosArgs']]:
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input['WlanQosArgs']]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter
    def radsec(self) -> Optional[pulumi.Input['WlanRadsecArgs']]:
        """
        Radsec settings
        """
        return pulumi.get(self, "radsec")

    @radsec.setter
    def radsec(self, value: Optional[pulumi.Input['WlanRadsecArgs']]):
        pulumi.set(self, "radsec", value)

    @property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @roam_mode.setter
    def roam_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roam_mode", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['WlanScheduleArgs']]:
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['WlanScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @sle_excluded.setter
    def sle_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sle_excluded", value)

    @property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[str]]:
        """
        the name of the SSID
        """
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssid", value)

    @property
    @pulumi.getter
    def thumbnail(self) -> Optional[pulumi.Input[str]]:
        """
        Url of portal background image thumbnail
        """
        return pulumi.get(self, "thumbnail")

    @thumbnail.setter
    def thumbnail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbnail", value)

    @property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> Optional[pulumi.Input[bool]]:
        """
        if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @use_eapol_v1.setter
    def use_eapol_v1(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_eapol_v1", value)

    @property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @vlan_enabled.setter
    def vlan_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vlan_enabled", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vlan_ids to use when there’s no match from RA
        """
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlan_ids", value)

    @property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> Optional[pulumi.Input[bool]]:
        """
        vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @vlan_pooling.setter
    def vlan_pooling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vlan_pooling", value)

    @property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "wlan_limit_down")

    @wlan_limit_down.setter
    def wlan_limit_down(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wlan_limit_down", value)

    @property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @wlan_limit_down_enabled.setter
    def wlan_limit_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wlan_limit_down_enabled", value)

    @property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> Optional[pulumi.Input[int]]:
        """
        kbps
        """
        return pulumi.get(self, "wlan_limit_up")

    @wlan_limit_up.setter
    def wlan_limit_up(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wlan_limit_up", value)

    @property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @wlan_limit_up_enabled.setter
    def wlan_limit_up_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wlan_limit_up_enabled", value)

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @wxtag_ids.setter
    def wxtag_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wxtag_ids", value)

    @property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @wxtunnel_id.setter
    def wxtunnel_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wxtunnel_id", value)

    @property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")

    @wxtunnel_remote_id.setter
    def wxtunnel_remote_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wxtunnel_remote_id", value)


class Wlan(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 acct_immediate_update: Optional[pulumi.Input[bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]]] = None,
                 airwatch: Optional[pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']]] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[bool]] = None,
                 allow_mdns: Optional[pulumi.Input[bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_limit: Optional[pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']]] = None,
                 app_qos: Optional[pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']]] = None,
                 apply_to: Optional[pulumi.Input[str]] = None,
                 arp_filter: Optional[pulumi.Input[bool]] = None,
                 auth: Optional[pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']]] = None,
                 auth_server_selection: Optional[pulumi.Input[str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[int]] = None,
                 band_steer: Optional[pulumi.Input[bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[bool]] = None,
                 bonjour: Optional[pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']]] = None,
                 cisco_cwa: Optional[pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']]] = None,
                 client_limit_down: Optional[pulumi.Input[int]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 client_limit_up: Optional[pulumi.Input[int]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]]] = None,
                 disable11ax: Optional[pulumi.Input[bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_wmm: Optional[pulumi.Input[bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']]] = None,
                 dtim: Optional[pulumi.Input[int]] = None,
                 dynamic_psk: Optional[pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']]] = None,
                 dynamic_vlan: Optional[pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']]] = None,
                 enable_local_keycaching: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[bool]] = None,
                 hide_ssid: Optional[pulumi.Input[bool]] = None,
                 hostname_ie: Optional[pulumi.Input[bool]] = None,
                 hotspot20: Optional[pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']]] = None,
                 inject_dhcp_option82: Optional[pulumi.Input[Union['WlanInjectDhcpOption82Args', 'WlanInjectDhcpOption82ArgsDict']]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 isolation: Optional[pulumi.Input[bool]] = None,
                 l2_isolation: Optional[pulumi.Input[bool]] = None,
                 legacy_overds: Optional[pulumi.Input[bool]] = None,
                 limit_bcast: Optional[pulumi.Input[bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[bool]] = None,
                 max_idletime: Optional[pulumi.Input[int]] = None,
                 mist_nac: Optional[pulumi.Input[Union['WlanMistNacArgs', 'WlanMistNacArgsDict']]] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[bool]] = None,
                 no_static_ip: Optional[pulumi.Input[bool]] = None,
                 portal: Optional[pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']]] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 qos: Optional[pulumi.Input[Union['WlanQosArgs', 'WlanQosArgsDict']]] = None,
                 radsec: Optional[pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']]] = None,
                 roam_mode: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']]] = None,
                 site_id: Optional[pulumi.Input[str]] = None,
                 sle_excluded: Optional[pulumi.Input[bool]] = None,
                 ssid: Optional[pulumi.Input[str]] = None,
                 use_eapol_v1: Optional[pulumi.Input[bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[int]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[int]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        This resource manages the Site Wlans.The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)

        ## Example Usage

        ```python
        import pulumi
        import pulumi_juniper_mist as junipermist

        wlan_one = junipermist.site.Wlan("wlan_one",
            ssid="wlan_one",
            site_id=terraform_test["id"],
            bands=[
                "5",
                "6",
            ],
            vlan_enabled=True,
            vlan_id="143",
            wlan_limit_up=10000,
            wlan_limit_down=20000,
            client_limit_up=512,
            client_limit_down=1000,
            auth={
                "type": "psk",
                "psk": "secretpsk",
            },
            interface="all")
        ```

        ## Import

        Using `pulumi import`, import `mist_site_wlan` with:

        Site WLAN can be imported by specifying the site_id and the wlan_id

        ```sh
        $ pulumi import junipermist:site/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] acct_immediate_update: enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[int] acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]] acct_servers: list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']] airwatch: airwatch wlan settings
        :param pulumi.Input[bool] allow_ipv6_ndp: only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[bool] allow_mdns: only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[bool] allow_ssdp: only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ap_ids: list of device ids
        :param pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']] app_limit: bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']] app_qos: app qos wlan settings
        :param pulumi.Input[str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[bool] arp_filter: whether to enable smart arp filter
        :param pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']] auth: authentication wlan settings
        :param pulumi.Input[str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]] auth_servers: list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[str] auth_servers_nas_id: optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[str] auth_servers_nas_ip: optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[int] auth_servers_retries: radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
               set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
               default value to 3.
        :param pulumi.Input[int] auth_servers_timeout: radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
               ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
               is also set when setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[bool] band_steer: whether to enable band_steering, this works only when band==both
        :param pulumi.Input[bool] band_steer_force_band5: force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[bool] block_blacklist_clients: whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']] bonjour: bonjour gateway wlan settings
        :param pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[int] client_limit_down: kbps
        :param pulumi.Input[bool] client_limit_down_enabled: if downlink limiting per-client is enabled
        :param pulumi.Input[int] client_limit_up: kbps
        :param pulumi.Input[bool] client_limit_up_enabled: if uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]] coa_servers: list of COA (change of authorization) servers, optional
        :param pulumi.Input[bool] disable11ax: some old WLAN drivers may not be compatible
        :param pulumi.Input[bool] disable_ht_vht_rates: to disable ht or vht rates
        :param pulumi.Input[bool] disable_uapsd: whether to disable U-APSD
        :param pulumi.Input[bool] disable_v1_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_v2_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_wmm: whether to disable WMM
        :param pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']] dns_server_rewrite: for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']] dynamic_psk: for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']] dynamic_vlan: for 802.1x
        :param pulumi.Input[bool] enable_local_keycaching: enable AP-AP keycaching via multicast
        :param pulumi.Input[bool] enable_wireless_bridging: by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        :param pulumi.Input[bool] enable_wireless_bridging_dhcp_tracking: if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[bool] enabled: if this wlan is enabled
        :param pulumi.Input[bool] fast_dot1x_timers: if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[bool] hide_ssid: whether to hide SSID in beacon
        :param pulumi.Input[bool] hostname_ie: include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']] hotspot20: hostspot 2.0 wlan settings
        :param pulumi.Input[str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[bool] isolation: whether to stop clients to talk to each other
        :param pulumi.Input[bool] l2_isolation: if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[bool] legacy_overds: legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[bool] limit_bcast: whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[bool] limit_probe_response: limit probe response base on some heuristic rules
        :param pulumi.Input[int] max_idletime: max idle time in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_ids: when `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_names: when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[bool] no_static_dns: whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[bool] no_static_ip: whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']] portal: portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_hostnames: list of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_subnets: list of CIDRs
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_denied_hostnames: list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']] radsec: Radsec settings
        :param pulumi.Input[str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[bool] sle_excluded: whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[str] ssid: the name of the SSID
        :param pulumi.Input[bool] use_eapol_v1: if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[bool] vlan_enabled: if vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlan_ids: vlan_ids to use when there’s no match from RA
        :param pulumi.Input[bool] vlan_pooling: vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        :param pulumi.Input[int] wlan_limit_down: kbps
        :param pulumi.Input[bool] wlan_limit_down_enabled: if downlink limiting for whole wlan is enabled
        :param pulumi.Input[int] wlan_limit_up: kbps
        :param pulumi.Input[bool] wlan_limit_up_enabled: if uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wxtag_ids: list of wxtag_ids
        :param pulumi.Input[str] wxtunnel_id: when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[str] wxtunnel_remote_id: when `interface`=`wxtunnel`, remote tunnel identifier
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: WlanArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        This resource manages the Site Wlans.The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)

        ## Example Usage

        ```python
        import pulumi
        import pulumi_juniper_mist as junipermist

        wlan_one = junipermist.site.Wlan("wlan_one",
            ssid="wlan_one",
            site_id=terraform_test["id"],
            bands=[
                "5",
                "6",
            ],
            vlan_enabled=True,
            vlan_id="143",
            wlan_limit_up=10000,
            wlan_limit_down=20000,
            client_limit_up=512,
            client_limit_down=1000,
            auth={
                "type": "psk",
                "psk": "secretpsk",
            },
            interface="all")
        ```

        ## Import

        Using `pulumi import`, import `mist_site_wlan` with:

        Site WLAN can be imported by specifying the site_id and the wlan_id

        ```sh
        $ pulumi import junipermist:site/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
        ```

        :param str resource_name: The name of the resource.
        :param WlanArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(WlanArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 acct_immediate_update: Optional[pulumi.Input[bool]] = None,
                 acct_interim_interval: Optional[pulumi.Input[int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]]] = None,
                 airwatch: Optional[pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']]] = None,
                 allow_ipv6_ndp: Optional[pulumi.Input[bool]] = None,
                 allow_mdns: Optional[pulumi.Input[bool]] = None,
                 allow_ssdp: Optional[pulumi.Input[bool]] = None,
                 ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_limit: Optional[pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']]] = None,
                 app_qos: Optional[pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']]] = None,
                 apply_to: Optional[pulumi.Input[str]] = None,
                 arp_filter: Optional[pulumi.Input[bool]] = None,
                 auth: Optional[pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']]] = None,
                 auth_server_selection: Optional[pulumi.Input[str]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]]] = None,
                 auth_servers_nas_id: Optional[pulumi.Input[str]] = None,
                 auth_servers_nas_ip: Optional[pulumi.Input[str]] = None,
                 auth_servers_retries: Optional[pulumi.Input[int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[int]] = None,
                 band_steer: Optional[pulumi.Input[bool]] = None,
                 band_steer_force_band5: Optional[pulumi.Input[bool]] = None,
                 bands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 block_blacklist_clients: Optional[pulumi.Input[bool]] = None,
                 bonjour: Optional[pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']]] = None,
                 cisco_cwa: Optional[pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']]] = None,
                 client_limit_down: Optional[pulumi.Input[int]] = None,
                 client_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 client_limit_up: Optional[pulumi.Input[int]] = None,
                 client_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]]] = None,
                 disable11ax: Optional[pulumi.Input[bool]] = None,
                 disable_ht_vht_rates: Optional[pulumi.Input[bool]] = None,
                 disable_uapsd: Optional[pulumi.Input[bool]] = None,
                 disable_v1_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_v2_roam_notify: Optional[pulumi.Input[bool]] = None,
                 disable_wmm: Optional[pulumi.Input[bool]] = None,
                 dns_server_rewrite: Optional[pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']]] = None,
                 dtim: Optional[pulumi.Input[int]] = None,
                 dynamic_psk: Optional[pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']]] = None,
                 dynamic_vlan: Optional[pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']]] = None,
                 enable_local_keycaching: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging: Optional[pulumi.Input[bool]] = None,
                 enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fast_dot1x_timers: Optional[pulumi.Input[bool]] = None,
                 hide_ssid: Optional[pulumi.Input[bool]] = None,
                 hostname_ie: Optional[pulumi.Input[bool]] = None,
                 hotspot20: Optional[pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']]] = None,
                 inject_dhcp_option82: Optional[pulumi.Input[Union['WlanInjectDhcpOption82Args', 'WlanInjectDhcpOption82ArgsDict']]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 isolation: Optional[pulumi.Input[bool]] = None,
                 l2_isolation: Optional[pulumi.Input[bool]] = None,
                 legacy_overds: Optional[pulumi.Input[bool]] = None,
                 limit_bcast: Optional[pulumi.Input[bool]] = None,
                 limit_probe_response: Optional[pulumi.Input[bool]] = None,
                 max_idletime: Optional[pulumi.Input[int]] = None,
                 mist_nac: Optional[pulumi.Input[Union['WlanMistNacArgs', 'WlanMistNacArgsDict']]] = None,
                 mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_static_dns: Optional[pulumi.Input[bool]] = None,
                 no_static_ip: Optional[pulumi.Input[bool]] = None,
                 portal: Optional[pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']]] = None,
                 portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 qos: Optional[pulumi.Input[Union['WlanQosArgs', 'WlanQosArgsDict']]] = None,
                 radsec: Optional[pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']]] = None,
                 roam_mode: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']]] = None,
                 site_id: Optional[pulumi.Input[str]] = None,
                 sle_excluded: Optional[pulumi.Input[bool]] = None,
                 ssid: Optional[pulumi.Input[str]] = None,
                 use_eapol_v1: Optional[pulumi.Input[bool]] = None,
                 vlan_enabled: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vlan_pooling: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_down: Optional[pulumi.Input[int]] = None,
                 wlan_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
                 wlan_limit_up: Optional[pulumi.Input[int]] = None,
                 wlan_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wxtunnel_id: Optional[pulumi.Input[str]] = None,
                 wxtunnel_remote_id: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = WlanArgs.__new__(WlanArgs)

            __props__.__dict__["acct_immediate_update"] = acct_immediate_update
            __props__.__dict__["acct_interim_interval"] = acct_interim_interval
            __props__.__dict__["acct_servers"] = acct_servers
            __props__.__dict__["airwatch"] = airwatch
            __props__.__dict__["allow_ipv6_ndp"] = allow_ipv6_ndp
            __props__.__dict__["allow_mdns"] = allow_mdns
            __props__.__dict__["allow_ssdp"] = allow_ssdp
            __props__.__dict__["ap_ids"] = ap_ids
            __props__.__dict__["app_limit"] = app_limit
            __props__.__dict__["app_qos"] = app_qos
            __props__.__dict__["apply_to"] = apply_to
            __props__.__dict__["arp_filter"] = arp_filter
            __props__.__dict__["auth"] = auth
            __props__.__dict__["auth_server_selection"] = auth_server_selection
            __props__.__dict__["auth_servers"] = auth_servers
            __props__.__dict__["auth_servers_nas_id"] = auth_servers_nas_id
            __props__.__dict__["auth_servers_nas_ip"] = auth_servers_nas_ip
            __props__.__dict__["auth_servers_retries"] = auth_servers_retries
            __props__.__dict__["auth_servers_timeout"] = auth_servers_timeout
            __props__.__dict__["band_steer"] = band_steer
            __props__.__dict__["band_steer_force_band5"] = band_steer_force_band5
            __props__.__dict__["bands"] = bands
            __props__.__dict__["block_blacklist_clients"] = block_blacklist_clients
            __props__.__dict__["bonjour"] = bonjour
            __props__.__dict__["cisco_cwa"] = cisco_cwa
            __props__.__dict__["client_limit_down"] = client_limit_down
            __props__.__dict__["client_limit_down_enabled"] = client_limit_down_enabled
            __props__.__dict__["client_limit_up"] = client_limit_up
            __props__.__dict__["client_limit_up_enabled"] = client_limit_up_enabled
            __props__.__dict__["coa_servers"] = coa_servers
            __props__.__dict__["disable11ax"] = disable11ax
            __props__.__dict__["disable_ht_vht_rates"] = disable_ht_vht_rates
            __props__.__dict__["disable_uapsd"] = disable_uapsd
            __props__.__dict__["disable_v1_roam_notify"] = disable_v1_roam_notify
            __props__.__dict__["disable_v2_roam_notify"] = disable_v2_roam_notify
            __props__.__dict__["disable_wmm"] = disable_wmm
            __props__.__dict__["dns_server_rewrite"] = dns_server_rewrite
            __props__.__dict__["dtim"] = dtim
            __props__.__dict__["dynamic_psk"] = dynamic_psk
            __props__.__dict__["dynamic_vlan"] = dynamic_vlan
            __props__.__dict__["enable_local_keycaching"] = enable_local_keycaching
            __props__.__dict__["enable_wireless_bridging"] = enable_wireless_bridging
            __props__.__dict__["enable_wireless_bridging_dhcp_tracking"] = enable_wireless_bridging_dhcp_tracking
            __props__.__dict__["enabled"] = enabled
            __props__.__dict__["fast_dot1x_timers"] = fast_dot1x_timers
            __props__.__dict__["hide_ssid"] = hide_ssid
            __props__.__dict__["hostname_ie"] = hostname_ie
            __props__.__dict__["hotspot20"] = hotspot20
            __props__.__dict__["inject_dhcp_option82"] = inject_dhcp_option82
            __props__.__dict__["interface"] = interface
            __props__.__dict__["isolation"] = isolation
            __props__.__dict__["l2_isolation"] = l2_isolation
            __props__.__dict__["legacy_overds"] = legacy_overds
            __props__.__dict__["limit_bcast"] = limit_bcast
            __props__.__dict__["limit_probe_response"] = limit_probe_response
            __props__.__dict__["max_idletime"] = max_idletime
            __props__.__dict__["mist_nac"] = mist_nac
            __props__.__dict__["mxtunnel_ids"] = mxtunnel_ids
            __props__.__dict__["mxtunnel_names"] = mxtunnel_names
            __props__.__dict__["no_static_dns"] = no_static_dns
            __props__.__dict__["no_static_ip"] = no_static_ip
            __props__.__dict__["portal"] = portal
            __props__.__dict__["portal_allowed_hostnames"] = portal_allowed_hostnames
            __props__.__dict__["portal_allowed_subnets"] = portal_allowed_subnets
            __props__.__dict__["portal_denied_hostnames"] = portal_denied_hostnames
            __props__.__dict__["qos"] = qos
            __props__.__dict__["radsec"] = radsec
            __props__.__dict__["roam_mode"] = roam_mode
            __props__.__dict__["schedule"] = schedule
            if site_id is None and not opts.urn:
                raise TypeError("Missing required property 'site_id'")
            __props__.__dict__["site_id"] = site_id
            __props__.__dict__["sle_excluded"] = sle_excluded
            if ssid is None and not opts.urn:
                raise TypeError("Missing required property 'ssid'")
            __props__.__dict__["ssid"] = ssid
            __props__.__dict__["use_eapol_v1"] = use_eapol_v1
            __props__.__dict__["vlan_enabled"] = vlan_enabled
            __props__.__dict__["vlan_id"] = vlan_id
            __props__.__dict__["vlan_ids"] = vlan_ids
            __props__.__dict__["vlan_pooling"] = vlan_pooling
            __props__.__dict__["wlan_limit_down"] = wlan_limit_down
            __props__.__dict__["wlan_limit_down_enabled"] = wlan_limit_down_enabled
            __props__.__dict__["wlan_limit_up"] = wlan_limit_up
            __props__.__dict__["wlan_limit_up_enabled"] = wlan_limit_up_enabled
            __props__.__dict__["wxtag_ids"] = wxtag_ids
            __props__.__dict__["wxtunnel_id"] = wxtunnel_id
            __props__.__dict__["wxtunnel_remote_id"] = wxtunnel_remote_id
            __props__.__dict__["msp_id"] = None
            __props__.__dict__["org_id"] = None
            __props__.__dict__["portal_api_secret"] = None
            __props__.__dict__["portal_image"] = None
            __props__.__dict__["portal_sso_url"] = None
            __props__.__dict__["portal_template_url"] = None
            __props__.__dict__["thumbnail"] = None
        super(Wlan, __self__).__init__(
            'junipermist:site/wlan:Wlan',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            acct_immediate_update: Optional[pulumi.Input[bool]] = None,
            acct_interim_interval: Optional[pulumi.Input[int]] = None,
            acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]]] = None,
            airwatch: Optional[pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']]] = None,
            allow_ipv6_ndp: Optional[pulumi.Input[bool]] = None,
            allow_mdns: Optional[pulumi.Input[bool]] = None,
            allow_ssdp: Optional[pulumi.Input[bool]] = None,
            ap_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            app_limit: Optional[pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']]] = None,
            app_qos: Optional[pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']]] = None,
            apply_to: Optional[pulumi.Input[str]] = None,
            arp_filter: Optional[pulumi.Input[bool]] = None,
            auth: Optional[pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']]] = None,
            auth_server_selection: Optional[pulumi.Input[str]] = None,
            auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]]] = None,
            auth_servers_nas_id: Optional[pulumi.Input[str]] = None,
            auth_servers_nas_ip: Optional[pulumi.Input[str]] = None,
            auth_servers_retries: Optional[pulumi.Input[int]] = None,
            auth_servers_timeout: Optional[pulumi.Input[int]] = None,
            band_steer: Optional[pulumi.Input[bool]] = None,
            band_steer_force_band5: Optional[pulumi.Input[bool]] = None,
            bands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            block_blacklist_clients: Optional[pulumi.Input[bool]] = None,
            bonjour: Optional[pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']]] = None,
            cisco_cwa: Optional[pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']]] = None,
            client_limit_down: Optional[pulumi.Input[int]] = None,
            client_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
            client_limit_up: Optional[pulumi.Input[int]] = None,
            client_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
            coa_servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]]] = None,
            disable11ax: Optional[pulumi.Input[bool]] = None,
            disable_ht_vht_rates: Optional[pulumi.Input[bool]] = None,
            disable_uapsd: Optional[pulumi.Input[bool]] = None,
            disable_v1_roam_notify: Optional[pulumi.Input[bool]] = None,
            disable_v2_roam_notify: Optional[pulumi.Input[bool]] = None,
            disable_wmm: Optional[pulumi.Input[bool]] = None,
            dns_server_rewrite: Optional[pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']]] = None,
            dtim: Optional[pulumi.Input[int]] = None,
            dynamic_psk: Optional[pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']]] = None,
            dynamic_vlan: Optional[pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']]] = None,
            enable_local_keycaching: Optional[pulumi.Input[bool]] = None,
            enable_wireless_bridging: Optional[pulumi.Input[bool]] = None,
            enable_wireless_bridging_dhcp_tracking: Optional[pulumi.Input[bool]] = None,
            enabled: Optional[pulumi.Input[bool]] = None,
            fast_dot1x_timers: Optional[pulumi.Input[bool]] = None,
            hide_ssid: Optional[pulumi.Input[bool]] = None,
            hostname_ie: Optional[pulumi.Input[bool]] = None,
            hotspot20: Optional[pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']]] = None,
            inject_dhcp_option82: Optional[pulumi.Input[Union['WlanInjectDhcpOption82Args', 'WlanInjectDhcpOption82ArgsDict']]] = None,
            interface: Optional[pulumi.Input[str]] = None,
            isolation: Optional[pulumi.Input[bool]] = None,
            l2_isolation: Optional[pulumi.Input[bool]] = None,
            legacy_overds: Optional[pulumi.Input[bool]] = None,
            limit_bcast: Optional[pulumi.Input[bool]] = None,
            limit_probe_response: Optional[pulumi.Input[bool]] = None,
            max_idletime: Optional[pulumi.Input[int]] = None,
            mist_nac: Optional[pulumi.Input[Union['WlanMistNacArgs', 'WlanMistNacArgsDict']]] = None,
            msp_id: Optional[pulumi.Input[str]] = None,
            mxtunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            mxtunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            no_static_dns: Optional[pulumi.Input[bool]] = None,
            no_static_ip: Optional[pulumi.Input[bool]] = None,
            org_id: Optional[pulumi.Input[str]] = None,
            portal: Optional[pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']]] = None,
            portal_allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            portal_allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            portal_api_secret: Optional[pulumi.Input[str]] = None,
            portal_denied_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            portal_image: Optional[pulumi.Input[str]] = None,
            portal_sso_url: Optional[pulumi.Input[str]] = None,
            portal_template_url: Optional[pulumi.Input[str]] = None,
            qos: Optional[pulumi.Input[Union['WlanQosArgs', 'WlanQosArgsDict']]] = None,
            radsec: Optional[pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']]] = None,
            roam_mode: Optional[pulumi.Input[str]] = None,
            schedule: Optional[pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']]] = None,
            site_id: Optional[pulumi.Input[str]] = None,
            sle_excluded: Optional[pulumi.Input[bool]] = None,
            ssid: Optional[pulumi.Input[str]] = None,
            thumbnail: Optional[pulumi.Input[str]] = None,
            use_eapol_v1: Optional[pulumi.Input[bool]] = None,
            vlan_enabled: Optional[pulumi.Input[bool]] = None,
            vlan_id: Optional[pulumi.Input[str]] = None,
            vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            vlan_pooling: Optional[pulumi.Input[bool]] = None,
            wlan_limit_down: Optional[pulumi.Input[int]] = None,
            wlan_limit_down_enabled: Optional[pulumi.Input[bool]] = None,
            wlan_limit_up: Optional[pulumi.Input[int]] = None,
            wlan_limit_up_enabled: Optional[pulumi.Input[bool]] = None,
            wxtag_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            wxtunnel_id: Optional[pulumi.Input[str]] = None,
            wxtunnel_remote_id: Optional[pulumi.Input[str]] = None) -> 'Wlan':
        """
        Get an existing Wlan resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] acct_immediate_update: enable coa-immediate-update and address-change-immediate-update on the access profile.
        :param pulumi.Input[int] acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
               from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
               when enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAcctServerArgs', 'WlanAcctServerArgsDict']]]] acct_servers: list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        :param pulumi.Input[Union['WlanAirwatchArgs', 'WlanAirwatchArgsDict']] airwatch: airwatch wlan settings
        :param pulumi.Input[bool] allow_ipv6_ndp: only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        :param pulumi.Input[bool] allow_mdns: only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        :param pulumi.Input[bool] allow_ssdp: only applicable when `limit_bcast`==`true`, which allows SSDP
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ap_ids: list of device ids
        :param pulumi.Input[Union['WlanAppLimitArgs', 'WlanAppLimitArgsDict']] app_limit: bandwidth limiting for apps (applies to up/down)
        :param pulumi.Input[Union['WlanAppQosArgs', 'WlanAppQosArgsDict']] app_qos: app qos wlan settings
        :param pulumi.Input[str] apply_to: enum: `aps`, `site`, `wxtags`
        :param pulumi.Input[bool] arp_filter: whether to enable smart arp filter
        :param pulumi.Input[Union['WlanAuthArgs', 'WlanAuthArgsDict']] auth: authentication wlan settings
        :param pulumi.Input[str] auth_server_selection: When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanAuthServerArgs', 'WlanAuthServerArgsDict']]]] auth_servers: list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
               is treated as primary
        :param pulumi.Input[str] auth_servers_nas_id: optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        :param pulumi.Input[str] auth_servers_nas_ip: optional, NAS-IP-ADDRESS to use
        :param pulumi.Input[int] auth_servers_retries: radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
               set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
               default value to 3.
        :param pulumi.Input[int] auth_servers_timeout: radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
               ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
               is also set when setting auth_servers_timeout and is set to default value of 10.
        :param pulumi.Input[bool] band_steer: whether to enable band_steering, this works only when band==both
        :param pulumi.Input[bool] band_steer_force_band5: force dual_band capable client to connect to 5G
        :param pulumi.Input[Sequence[pulumi.Input[str]]] bands: list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        :param pulumi.Input[bool] block_blacklist_clients: whether to block the clients in the blacklist (up to first 256 macs)
        :param pulumi.Input[Union['WlanBonjourArgs', 'WlanBonjourArgsDict']] bonjour: bonjour gateway wlan settings
        :param pulumi.Input[Union['WlanCiscoCwaArgs', 'WlanCiscoCwaArgsDict']] cisco_cwa: Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
               https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        :param pulumi.Input[int] client_limit_down: kbps
        :param pulumi.Input[bool] client_limit_down_enabled: if downlink limiting per-client is enabled
        :param pulumi.Input[int] client_limit_up: kbps
        :param pulumi.Input[bool] client_limit_up_enabled: if uplink limiting per-client is enabled
        :param pulumi.Input[Sequence[pulumi.Input[Union['WlanCoaServerArgs', 'WlanCoaServerArgsDict']]]] coa_servers: list of COA (change of authorization) servers, optional
        :param pulumi.Input[bool] disable11ax: some old WLAN drivers may not be compatible
        :param pulumi.Input[bool] disable_ht_vht_rates: to disable ht or vht rates
        :param pulumi.Input[bool] disable_uapsd: whether to disable U-APSD
        :param pulumi.Input[bool] disable_v1_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_v2_roam_notify: disable sending v2 roam notification messages
        :param pulumi.Input[bool] disable_wmm: whether to disable WMM
        :param pulumi.Input[Union['WlanDnsServerRewriteArgs', 'WlanDnsServerRewriteArgsDict']] dns_server_rewrite: for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        :param pulumi.Input[Union['WlanDynamicPskArgs', 'WlanDynamicPskArgsDict']] dynamic_psk: for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
               context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
               AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
               Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
               be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
               now, wpa3 support on the roadmap)
        :param pulumi.Input[Union['WlanDynamicVlanArgs', 'WlanDynamicVlanArgsDict']] dynamic_vlan: for 802.1x
        :param pulumi.Input[bool] enable_local_keycaching: enable AP-AP keycaching via multicast
        :param pulumi.Input[bool] enable_wireless_bridging: by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
               client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        :param pulumi.Input[bool] enable_wireless_bridging_dhcp_tracking: if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
               packets to be forwarded to wireless
        :param pulumi.Input[bool] enabled: if this wlan is enabled
        :param pulumi.Input[bool] fast_dot1x_timers: if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
               ‘auth_server_retries’ .
        :param pulumi.Input[bool] hide_ssid: whether to hide SSID in beacon
        :param pulumi.Input[bool] hostname_ie: include hostname inside IE in AP beacons / probe responses
        :param pulumi.Input[Union['WlanHotspot20Args', 'WlanHotspot20ArgsDict']] hotspot20: hostspot 2.0 wlan settings
        :param pulumi.Input[str] interface: where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        :param pulumi.Input[bool] isolation: whether to stop clients to talk to each other
        :param pulumi.Input[bool] l2_isolation: if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        :param pulumi.Input[bool] legacy_overds: legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
               Enabling this will cause problem for iOS devices.
        :param pulumi.Input[bool] limit_bcast: whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        :param pulumi.Input[bool] limit_probe_response: limit probe response base on some heuristic rules
        :param pulumi.Input[int] max_idletime: max idle time in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_ids: when `interface`=`mxtunnel`, id of the Mist Tunnel
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxtunnel_names: when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        :param pulumi.Input[bool] no_static_dns: whether to only allow client to use DNS that we’ve learned from DHCP response
        :param pulumi.Input[bool] no_static_ip: whether to only allow client that we’ve learned from DHCP exchange to talk
        :param pulumi.Input[Union['WlanPortalArgs', 'WlanPortalArgsDict']] portal: portal wlan settings
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_hostnames: list of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_allowed_subnets: list of CIDRs
        :param pulumi.Input[str] portal_api_secret: api secret (auto-generated) that can be used to sign guest authorization requests
        :param pulumi.Input[Sequence[pulumi.Input[str]]] portal_denied_hostnames: list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        :param pulumi.Input[str] portal_image: Url of portal background image
        :param pulumi.Input[str] portal_template_url: N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
               To update portal_template, use Wlan Portal Template.
        :param pulumi.Input[Union['WlanRadsecArgs', 'WlanRadsecArgsDict']] radsec: Radsec settings
        :param pulumi.Input[str] roam_mode: enum: `11r`, `OKC`, `NONE`
        :param pulumi.Input[Union['WlanScheduleArgs', 'WlanScheduleArgsDict']] schedule: WLAN operating schedule, default is disabled
        :param pulumi.Input[bool] sle_excluded: whether to exclude this WLAN from SLE metrics
        :param pulumi.Input[str] ssid: the name of the SSID
        :param pulumi.Input[str] thumbnail: Url of portal background image thumbnail
        :param pulumi.Input[bool] use_eapol_v1: if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        :param pulumi.Input[bool] vlan_enabled: if vlan tagging is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vlan_ids: vlan_ids to use when there’s no match from RA
        :param pulumi.Input[bool] vlan_pooling: vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        :param pulumi.Input[int] wlan_limit_down: kbps
        :param pulumi.Input[bool] wlan_limit_down_enabled: if downlink limiting for whole wlan is enabled
        :param pulumi.Input[int] wlan_limit_up: kbps
        :param pulumi.Input[bool] wlan_limit_up_enabled: if uplink limiting for whole wlan is enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wxtag_ids: list of wxtag_ids
        :param pulumi.Input[str] wxtunnel_id: when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        :param pulumi.Input[str] wxtunnel_remote_id: when `interface`=`wxtunnel`, remote tunnel identifier
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _WlanState.__new__(_WlanState)

        __props__.__dict__["acct_immediate_update"] = acct_immediate_update
        __props__.__dict__["acct_interim_interval"] = acct_interim_interval
        __props__.__dict__["acct_servers"] = acct_servers
        __props__.__dict__["airwatch"] = airwatch
        __props__.__dict__["allow_ipv6_ndp"] = allow_ipv6_ndp
        __props__.__dict__["allow_mdns"] = allow_mdns
        __props__.__dict__["allow_ssdp"] = allow_ssdp
        __props__.__dict__["ap_ids"] = ap_ids
        __props__.__dict__["app_limit"] = app_limit
        __props__.__dict__["app_qos"] = app_qos
        __props__.__dict__["apply_to"] = apply_to
        __props__.__dict__["arp_filter"] = arp_filter
        __props__.__dict__["auth"] = auth
        __props__.__dict__["auth_server_selection"] = auth_server_selection
        __props__.__dict__["auth_servers"] = auth_servers
        __props__.__dict__["auth_servers_nas_id"] = auth_servers_nas_id
        __props__.__dict__["auth_servers_nas_ip"] = auth_servers_nas_ip
        __props__.__dict__["auth_servers_retries"] = auth_servers_retries
        __props__.__dict__["auth_servers_timeout"] = auth_servers_timeout
        __props__.__dict__["band_steer"] = band_steer
        __props__.__dict__["band_steer_force_band5"] = band_steer_force_band5
        __props__.__dict__["bands"] = bands
        __props__.__dict__["block_blacklist_clients"] = block_blacklist_clients
        __props__.__dict__["bonjour"] = bonjour
        __props__.__dict__["cisco_cwa"] = cisco_cwa
        __props__.__dict__["client_limit_down"] = client_limit_down
        __props__.__dict__["client_limit_down_enabled"] = client_limit_down_enabled
        __props__.__dict__["client_limit_up"] = client_limit_up
        __props__.__dict__["client_limit_up_enabled"] = client_limit_up_enabled
        __props__.__dict__["coa_servers"] = coa_servers
        __props__.__dict__["disable11ax"] = disable11ax
        __props__.__dict__["disable_ht_vht_rates"] = disable_ht_vht_rates
        __props__.__dict__["disable_uapsd"] = disable_uapsd
        __props__.__dict__["disable_v1_roam_notify"] = disable_v1_roam_notify
        __props__.__dict__["disable_v2_roam_notify"] = disable_v2_roam_notify
        __props__.__dict__["disable_wmm"] = disable_wmm
        __props__.__dict__["dns_server_rewrite"] = dns_server_rewrite
        __props__.__dict__["dtim"] = dtim
        __props__.__dict__["dynamic_psk"] = dynamic_psk
        __props__.__dict__["dynamic_vlan"] = dynamic_vlan
        __props__.__dict__["enable_local_keycaching"] = enable_local_keycaching
        __props__.__dict__["enable_wireless_bridging"] = enable_wireless_bridging
        __props__.__dict__["enable_wireless_bridging_dhcp_tracking"] = enable_wireless_bridging_dhcp_tracking
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["fast_dot1x_timers"] = fast_dot1x_timers
        __props__.__dict__["hide_ssid"] = hide_ssid
        __props__.__dict__["hostname_ie"] = hostname_ie
        __props__.__dict__["hotspot20"] = hotspot20
        __props__.__dict__["inject_dhcp_option82"] = inject_dhcp_option82
        __props__.__dict__["interface"] = interface
        __props__.__dict__["isolation"] = isolation
        __props__.__dict__["l2_isolation"] = l2_isolation
        __props__.__dict__["legacy_overds"] = legacy_overds
        __props__.__dict__["limit_bcast"] = limit_bcast
        __props__.__dict__["limit_probe_response"] = limit_probe_response
        __props__.__dict__["max_idletime"] = max_idletime
        __props__.__dict__["mist_nac"] = mist_nac
        __props__.__dict__["msp_id"] = msp_id
        __props__.__dict__["mxtunnel_ids"] = mxtunnel_ids
        __props__.__dict__["mxtunnel_names"] = mxtunnel_names
        __props__.__dict__["no_static_dns"] = no_static_dns
        __props__.__dict__["no_static_ip"] = no_static_ip
        __props__.__dict__["org_id"] = org_id
        __props__.__dict__["portal"] = portal
        __props__.__dict__["portal_allowed_hostnames"] = portal_allowed_hostnames
        __props__.__dict__["portal_allowed_subnets"] = portal_allowed_subnets
        __props__.__dict__["portal_api_secret"] = portal_api_secret
        __props__.__dict__["portal_denied_hostnames"] = portal_denied_hostnames
        __props__.__dict__["portal_image"] = portal_image
        __props__.__dict__["portal_sso_url"] = portal_sso_url
        __props__.__dict__["portal_template_url"] = portal_template_url
        __props__.__dict__["qos"] = qos
        __props__.__dict__["radsec"] = radsec
        __props__.__dict__["roam_mode"] = roam_mode
        __props__.__dict__["schedule"] = schedule
        __props__.__dict__["site_id"] = site_id
        __props__.__dict__["sle_excluded"] = sle_excluded
        __props__.__dict__["ssid"] = ssid
        __props__.__dict__["thumbnail"] = thumbnail
        __props__.__dict__["use_eapol_v1"] = use_eapol_v1
        __props__.__dict__["vlan_enabled"] = vlan_enabled
        __props__.__dict__["vlan_id"] = vlan_id
        __props__.__dict__["vlan_ids"] = vlan_ids
        __props__.__dict__["vlan_pooling"] = vlan_pooling
        __props__.__dict__["wlan_limit_down"] = wlan_limit_down
        __props__.__dict__["wlan_limit_down_enabled"] = wlan_limit_down_enabled
        __props__.__dict__["wlan_limit_up"] = wlan_limit_up
        __props__.__dict__["wlan_limit_up_enabled"] = wlan_limit_up_enabled
        __props__.__dict__["wxtag_ids"] = wxtag_ids
        __props__.__dict__["wxtunnel_id"] = wxtunnel_id
        __props__.__dict__["wxtunnel_remote_id"] = wxtunnel_remote_id
        return Wlan(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> pulumi.Output[bool]:
        """
        enable coa-immediate-update and address-change-immediate-update on the access profile.
        """
        return pulumi.get(self, "acct_immediate_update")

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> pulumi.Output[int]:
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> pulumi.Output[Sequence['outputs.WlanAcctServer']]:
        """
        list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        """
        return pulumi.get(self, "acct_servers")

    @property
    @pulumi.getter
    def airwatch(self) -> pulumi.Output[Optional['outputs.WlanAirwatch']]:
        """
        airwatch wlan settings
        """
        return pulumi.get(self, "airwatch")

    @property
    @pulumi.getter(name="allowIpv6Ndp")
    def allow_ipv6_ndp(self) -> pulumi.Output[bool]:
        """
        only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        """
        return pulumi.get(self, "allow_ipv6_ndp")

    @property
    @pulumi.getter(name="allowMdns")
    def allow_mdns(self) -> pulumi.Output[bool]:
        """
        only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        """
        return pulumi.get(self, "allow_mdns")

    @property
    @pulumi.getter(name="allowSsdp")
    def allow_ssdp(self) -> pulumi.Output[bool]:
        """
        only applicable when `limit_bcast`==`true`, which allows SSDP
        """
        return pulumi.get(self, "allow_ssdp")

    @property
    @pulumi.getter(name="apIds")
    def ap_ids(self) -> pulumi.Output[Sequence[str]]:
        """
        list of device ids
        """
        return pulumi.get(self, "ap_ids")

    @property
    @pulumi.getter(name="appLimit")
    def app_limit(self) -> pulumi.Output[Optional['outputs.WlanAppLimit']]:
        """
        bandwidth limiting for apps (applies to up/down)
        """
        return pulumi.get(self, "app_limit")

    @property
    @pulumi.getter(name="appQos")
    def app_qos(self) -> pulumi.Output[Optional['outputs.WlanAppQos']]:
        """
        app qos wlan settings
        """
        return pulumi.get(self, "app_qos")

    @property
    @pulumi.getter(name="applyTo")
    def apply_to(self) -> pulumi.Output[Optional[str]]:
        """
        enum: `aps`, `site`, `wxtags`
        """
        return pulumi.get(self, "apply_to")

    @property
    @pulumi.getter(name="arpFilter")
    def arp_filter(self) -> pulumi.Output[bool]:
        """
        whether to enable smart arp filter
        """
        return pulumi.get(self, "arp_filter")

    @property
    @pulumi.getter
    def auth(self) -> pulumi.Output[Optional['outputs.WlanAuth']]:
        """
        authentication wlan settings
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> pulumi.Output[str]:
        """
        When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> pulumi.Output[Sequence['outputs.WlanAuthServer']]:
        """
        list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        is treated as primary
        """
        return pulumi.get(self, "auth_servers")

    @property
    @pulumi.getter(name="authServersNasId")
    def auth_servers_nas_id(self) -> pulumi.Output[Optional[str]]:
        """
        optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        """
        return pulumi.get(self, "auth_servers_nas_id")

    @property
    @pulumi.getter(name="authServersNasIp")
    def auth_servers_nas_ip(self) -> pulumi.Output[Optional[str]]:
        """
        optional, NAS-IP-ADDRESS to use
        """
        return pulumi.get(self, "auth_servers_nas_ip")

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> pulumi.Output[int]:
        """
        radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
        set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
        default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> pulumi.Output[int]:
        """
        radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
        ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
        is also set when setting auth_servers_timeout and is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @property
    @pulumi.getter(name="bandSteer")
    def band_steer(self) -> pulumi.Output[bool]:
        """
        whether to enable band_steering, this works only when band==both
        """
        return pulumi.get(self, "band_steer")

    @property
    @pulumi.getter(name="bandSteerForceBand5")
    def band_steer_force_band5(self) -> pulumi.Output[bool]:
        """
        force dual_band capable client to connect to 5G
        """
        return pulumi.get(self, "band_steer_force_band5")

    @property
    @pulumi.getter
    def bands(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @property
    @pulumi.getter(name="blockBlacklistClients")
    def block_blacklist_clients(self) -> pulumi.Output[bool]:
        """
        whether to block the clients in the blacklist (up to first 256 macs)
        """
        return pulumi.get(self, "block_blacklist_clients")

    @property
    @pulumi.getter
    def bonjour(self) -> pulumi.Output[Optional['outputs.WlanBonjour']]:
        """
        bonjour gateway wlan settings
        """
        return pulumi.get(self, "bonjour")

    @property
    @pulumi.getter(name="ciscoCwa")
    def cisco_cwa(self) -> pulumi.Output[Optional['outputs.WlanCiscoCwa']]:
        """
        Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        """
        return pulumi.get(self, "cisco_cwa")

    @property
    @pulumi.getter(name="clientLimitDown")
    def client_limit_down(self) -> pulumi.Output[Optional[int]]:
        """
        kbps
        """
        return pulumi.get(self, "client_limit_down")

    @property
    @pulumi.getter(name="clientLimitDownEnabled")
    def client_limit_down_enabled(self) -> pulumi.Output[bool]:
        """
        if downlink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_down_enabled")

    @property
    @pulumi.getter(name="clientLimitUp")
    def client_limit_up(self) -> pulumi.Output[Optional[int]]:
        """
        kbps
        """
        return pulumi.get(self, "client_limit_up")

    @property
    @pulumi.getter(name="clientLimitUpEnabled")
    def client_limit_up_enabled(self) -> pulumi.Output[bool]:
        """
        if uplink limiting per-client is enabled
        """
        return pulumi.get(self, "client_limit_up_enabled")

    @property
    @pulumi.getter(name="coaServers")
    def coa_servers(self) -> pulumi.Output[Sequence['outputs.WlanCoaServer']]:
        """
        list of COA (change of authorization) servers, optional
        """
        return pulumi.get(self, "coa_servers")

    @property
    @pulumi.getter
    def disable11ax(self) -> pulumi.Output[bool]:
        """
        some old WLAN drivers may not be compatible
        """
        return pulumi.get(self, "disable11ax")

    @property
    @pulumi.getter(name="disableHtVhtRates")
    def disable_ht_vht_rates(self) -> pulumi.Output[bool]:
        """
        to disable ht or vht rates
        """
        return pulumi.get(self, "disable_ht_vht_rates")

    @property
    @pulumi.getter(name="disableUapsd")
    def disable_uapsd(self) -> pulumi.Output[bool]:
        """
        whether to disable U-APSD
        """
        return pulumi.get(self, "disable_uapsd")

    @property
    @pulumi.getter(name="disableV1RoamNotify")
    def disable_v1_roam_notify(self) -> pulumi.Output[bool]:
        """
        disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v1_roam_notify")

    @property
    @pulumi.getter(name="disableV2RoamNotify")
    def disable_v2_roam_notify(self) -> pulumi.Output[bool]:
        """
        disable sending v2 roam notification messages
        """
        return pulumi.get(self, "disable_v2_roam_notify")

    @property
    @pulumi.getter(name="disableWmm")
    def disable_wmm(self) -> pulumi.Output[bool]:
        """
        whether to disable WMM
        """
        return pulumi.get(self, "disable_wmm")

    @property
    @pulumi.getter(name="dnsServerRewrite")
    def dns_server_rewrite(self) -> pulumi.Output[Optional['outputs.WlanDnsServerRewrite']]:
        """
        for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        """
        return pulumi.get(self, "dns_server_rewrite")

    @property
    @pulumi.getter
    def dtim(self) -> pulumi.Output[int]:
        return pulumi.get(self, "dtim")

    @property
    @pulumi.getter(name="dynamicPsk")
    def dynamic_psk(self) -> pulumi.Output[Optional['outputs.WlanDynamicPsk']]:
        """
        for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        now, wpa3 support on the roadmap)
        """
        return pulumi.get(self, "dynamic_psk")

    @property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> pulumi.Output[Optional['outputs.WlanDynamicVlan']]:
        """
        for 802.1x
        """
        return pulumi.get(self, "dynamic_vlan")

    @property
    @pulumi.getter(name="enableLocalKeycaching")
    def enable_local_keycaching(self) -> pulumi.Output[bool]:
        """
        enable AP-AP keycaching via multicast
        """
        return pulumi.get(self, "enable_local_keycaching")

    @property
    @pulumi.getter(name="enableWirelessBridging")
    def enable_wireless_bridging(self) -> pulumi.Output[bool]:
        """
        by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        """
        return pulumi.get(self, "enable_wireless_bridging")

    @property
    @pulumi.getter(name="enableWirelessBridgingDhcpTracking")
    def enable_wireless_bridging_dhcp_tracking(self) -> pulumi.Output[bool]:
        """
        if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        packets to be forwarded to wireless
        """
        return pulumi.get(self, "enable_wireless_bridging_dhcp_tracking")

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[bool]:
        """
        if this wlan is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> pulumi.Output[bool]:
        """
        if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        ‘auth_server_retries’ .
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @property
    @pulumi.getter(name="hideSsid")
    def hide_ssid(self) -> pulumi.Output[bool]:
        """
        whether to hide SSID in beacon
        """
        return pulumi.get(self, "hide_ssid")

    @property
    @pulumi.getter(name="hostnameIe")
    def hostname_ie(self) -> pulumi.Output[bool]:
        """
        include hostname inside IE in AP beacons / probe responses
        """
        return pulumi.get(self, "hostname_ie")

    @property
    @pulumi.getter
    def hotspot20(self) -> pulumi.Output[Optional['outputs.WlanHotspot20']]:
        """
        hostspot 2.0 wlan settings
        """
        return pulumi.get(self, "hotspot20")

    @property
    @pulumi.getter(name="injectDhcpOption82")
    def inject_dhcp_option82(self) -> pulumi.Output[Optional['outputs.WlanInjectDhcpOption82']]:
        return pulumi.get(self, "inject_dhcp_option82")

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Output[str]:
        """
        where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def isolation(self) -> pulumi.Output[bool]:
        """
        whether to stop clients to talk to each other
        """
        return pulumi.get(self, "isolation")

    @property
    @pulumi.getter(name="l2Isolation")
    def l2_isolation(self) -> pulumi.Output[bool]:
        """
        if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        """
        return pulumi.get(self, "l2_isolation")

    @property
    @pulumi.getter(name="legacyOverds")
    def legacy_overds(self) -> pulumi.Output[bool]:
        """
        legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        Enabling this will cause problem for iOS devices.
        """
        return pulumi.get(self, "legacy_overds")

    @property
    @pulumi.getter(name="limitBcast")
    def limit_bcast(self) -> pulumi.Output[bool]:
        """
        whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        """
        return pulumi.get(self, "limit_bcast")

    @property
    @pulumi.getter(name="limitProbeResponse")
    def limit_probe_response(self) -> pulumi.Output[bool]:
        """
        limit probe response base on some heuristic rules
        """
        return pulumi.get(self, "limit_probe_response")

    @property
    @pulumi.getter(name="maxIdletime")
    def max_idletime(self) -> pulumi.Output[int]:
        """
        max idle time in seconds
        """
        return pulumi.get(self, "max_idletime")

    @property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> pulumi.Output[Optional['outputs.WlanMistNac']]:
        return pulumi.get(self, "mist_nac")

    @property
    @pulumi.getter(name="mspId")
    def msp_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "msp_id")

    @property
    @pulumi.getter(name="mxtunnelIds")
    def mxtunnel_ids(self) -> pulumi.Output[Sequence[str]]:
        """
        when `interface`=`mxtunnel`, id of the Mist Tunnel
        """
        return pulumi.get(self, "mxtunnel_ids")

    @property
    @pulumi.getter(name="mxtunnelNames")
    def mxtunnel_names(self) -> pulumi.Output[Sequence[str]]:
        """
        when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        """
        return pulumi.get(self, "mxtunnel_names")

    @property
    @pulumi.getter(name="noStaticDns")
    def no_static_dns(self) -> pulumi.Output[bool]:
        """
        whether to only allow client to use DNS that we’ve learned from DHCP response
        """
        return pulumi.get(self, "no_static_dns")

    @property
    @pulumi.getter(name="noStaticIp")
    def no_static_ip(self) -> pulumi.Output[bool]:
        """
        whether to only allow client that we’ve learned from DHCP exchange to talk
        """
        return pulumi.get(self, "no_static_ip")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def portal(self) -> pulumi.Output[Optional['outputs.WlanPortal']]:
        """
        portal wlan settings
        """
        return pulumi.get(self, "portal")

    @property
    @pulumi.getter(name="portalAllowedHostnames")
    def portal_allowed_hostnames(self) -> pulumi.Output[Sequence[str]]:
        """
        list of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "portal_allowed_hostnames")

    @property
    @pulumi.getter(name="portalAllowedSubnets")
    def portal_allowed_subnets(self) -> pulumi.Output[Sequence[str]]:
        """
        list of CIDRs
        """
        return pulumi.get(self, "portal_allowed_subnets")

    @property
    @pulumi.getter(name="portalApiSecret")
    def portal_api_secret(self) -> pulumi.Output[str]:
        """
        api secret (auto-generated) that can be used to sign guest authorization requests
        """
        return pulumi.get(self, "portal_api_secret")

    @property
    @pulumi.getter(name="portalDeniedHostnames")
    def portal_denied_hostnames(self) -> pulumi.Output[Sequence[str]]:
        """
        list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        """
        return pulumi.get(self, "portal_denied_hostnames")

    @property
    @pulumi.getter(name="portalImage")
    def portal_image(self) -> pulumi.Output[str]:
        """
        Url of portal background image
        """
        return pulumi.get(self, "portal_image")

    @property
    @pulumi.getter(name="portalSsoUrl")
    def portal_sso_url(self) -> pulumi.Output[str]:
        return pulumi.get(self, "portal_sso_url")

    @property
    @pulumi.getter(name="portalTemplateUrl")
    def portal_template_url(self) -> pulumi.Output[str]:
        """
        N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
        To update portal_template, use Wlan Portal Template.
        """
        return pulumi.get(self, "portal_template_url")

    @property
    @pulumi.getter
    def qos(self) -> pulumi.Output[Optional['outputs.WlanQos']]:
        return pulumi.get(self, "qos")

    @property
    @pulumi.getter
    def radsec(self) -> pulumi.Output[Optional['outputs.WlanRadsec']]:
        """
        Radsec settings
        """
        return pulumi.get(self, "radsec")

    @property
    @pulumi.getter(name="roamMode")
    def roam_mode(self) -> pulumi.Output[str]:
        """
        enum: `11r`, `OKC`, `NONE`
        """
        return pulumi.get(self, "roam_mode")

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Output[Optional['outputs.WlanSchedule']]:
        """
        WLAN operating schedule, default is disabled
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="sleExcluded")
    def sle_excluded(self) -> pulumi.Output[bool]:
        """
        whether to exclude this WLAN from SLE metrics
        """
        return pulumi.get(self, "sle_excluded")

    @property
    @pulumi.getter
    def ssid(self) -> pulumi.Output[str]:
        """
        the name of the SSID
        """
        return pulumi.get(self, "ssid")

    @property
    @pulumi.getter
    def thumbnail(self) -> pulumi.Output[str]:
        """
        Url of portal background image thumbnail
        """
        return pulumi.get(self, "thumbnail")

    @property
    @pulumi.getter(name="useEapolV1")
    def use_eapol_v1(self) -> pulumi.Output[bool]:
        """
        if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        """
        return pulumi.get(self, "use_eapol_v1")

    @property
    @pulumi.getter(name="vlanEnabled")
    def vlan_enabled(self) -> pulumi.Output[bool]:
        """
        if vlan tagging is enabled
        """
        return pulumi.get(self, "vlan_enabled")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> pulumi.Output[Sequence[str]]:
        """
        vlan_ids to use when there’s no match from RA
        """
        return pulumi.get(self, "vlan_ids")

    @property
    @pulumi.getter(name="vlanPooling")
    def vlan_pooling(self) -> pulumi.Output[bool]:
        """
        vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
        """
        return pulumi.get(self, "vlan_pooling")

    @property
    @pulumi.getter(name="wlanLimitDown")
    def wlan_limit_down(self) -> pulumi.Output[int]:
        """
        kbps
        """
        return pulumi.get(self, "wlan_limit_down")

    @property
    @pulumi.getter(name="wlanLimitDownEnabled")
    def wlan_limit_down_enabled(self) -> pulumi.Output[bool]:
        """
        if downlink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_down_enabled")

    @property
    @pulumi.getter(name="wlanLimitUp")
    def wlan_limit_up(self) -> pulumi.Output[int]:
        """
        kbps
        """
        return pulumi.get(self, "wlan_limit_up")

    @property
    @pulumi.getter(name="wlanLimitUpEnabled")
    def wlan_limit_up_enabled(self) -> pulumi.Output[bool]:
        """
        if uplink limiting for whole wlan is enabled
        """
        return pulumi.get(self, "wlan_limit_up_enabled")

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> pulumi.Output[Sequence[str]]:
        """
        list of wxtag_ids
        """
        return pulumi.get(self, "wxtag_ids")

    @property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> pulumi.Output[str]:
        """
        when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        """
        return pulumi.get(self, "wxtunnel_id")

    @property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> pulumi.Output[str]:
        """
        when `interface`=`wxtunnel`, remote tunnel identifier
        """
        return pulumi.get(self, "wxtunnel_remote_id")

