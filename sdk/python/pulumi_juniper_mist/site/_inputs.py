# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'NetworktemplateAclPolicyArgs',
    'NetworktemplateAclPolicyActionArgs',
    'NetworktemplateAclTagsArgs',
    'NetworktemplateAclTagsSpecArgs',
    'NetworktemplateDhcpSnoopingArgs',
    'NetworktemplateExtraRoutes6Args',
    'NetworktemplateExtraRoutes6NextQualifiedArgs',
    'NetworktemplateExtraRoutesArgs',
    'NetworktemplateExtraRoutesNextQualifiedArgs',
    'NetworktemplateMistNacArgs',
    'NetworktemplateNetworksArgs',
    'NetworktemplatePortMirroringArgs',
    'NetworktemplatePortUsagesArgs',
    'NetworktemplatePortUsagesRuleArgs',
    'NetworktemplatePortUsagesStormControlArgs',
    'NetworktemplateRadiusConfigArgs',
    'NetworktemplateRadiusConfigAcctServerArgs',
    'NetworktemplateRadiusConfigAuthServerArgs',
    'NetworktemplateRemoteSyslogArgs',
    'NetworktemplateRemoteSyslogArchiveArgs',
    'NetworktemplateRemoteSyslogConsoleArgs',
    'NetworktemplateRemoteSyslogConsoleContentArgs',
    'NetworktemplateRemoteSyslogFileArgs',
    'NetworktemplateRemoteSyslogFileArchiveArgs',
    'NetworktemplateRemoteSyslogFileContentArgs',
    'NetworktemplateRemoteSyslogServerArgs',
    'NetworktemplateRemoteSyslogServerContentArgs',
    'NetworktemplateRemoteSyslogUserArgs',
    'NetworktemplateRemoteSyslogUserContentArgs',
    'NetworktemplateSnmpConfigArgs',
    'NetworktemplateSnmpConfigClientListArgs',
    'NetworktemplateSnmpConfigTrapGroupArgs',
    'NetworktemplateSnmpConfigV2cConfigArgs',
    'NetworktemplateSnmpConfigV3ConfigArgs',
    'NetworktemplateSnmpConfigV3ConfigNotifyArgs',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs',
    'NetworktemplateSnmpConfigV3ConfigTargetAddressArgs',
    'NetworktemplateSnmpConfigV3ConfigTargetParameterArgs',
    'NetworktemplateSnmpConfigV3ConfigUsmArgs',
    'NetworktemplateSnmpConfigV3ConfigUsmUserArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs',
    'NetworktemplateSnmpConfigViewArgs',
    'NetworktemplateSwitchMatchingArgs',
    'NetworktemplateSwitchMatchingRuleArgs',
    'NetworktemplateSwitchMatchingRulePortConfigArgs',
    'NetworktemplateSwitchMatchingRulePortMirroringArgs',
    'NetworktemplateSwitchMgmtArgs',
    'NetworktemplateSwitchMgmtProtectReArgs',
    'NetworktemplateSwitchMgmtProtectReCustomArgs',
    'NetworktemplateSwitchMgmtTacacsArgs',
    'NetworktemplateSwitchMgmtTacacsAcctServerArgs',
    'NetworktemplateSwitchMgmtTacacsTacplusServerArgs',
    'NetworktemplateUplinkPortConfigArgs',
    'NetworktemplateVrfConfigArgs',
    'NetworktemplateVrfInstancesArgs',
    'NetworktemplateVrfInstancesVrfExtraRoutesArgs',
    'SettingAnalyticArgs',
    'SettingAutoUpgradeArgs',
    'SettingBleConfigArgs',
    'SettingConfigPushPolicyArgs',
    'SettingConfigPushPolicyPushWindowArgs',
    'SettingConfigPushPolicyPushWindowHoursArgs',
    'SettingCriticalUrlMonitoringArgs',
    'SettingCriticalUrlMonitoringMonitorArgs',
    'SettingEngagementArgs',
    'SettingEngagementDwellTagNamesArgs',
    'SettingEngagementDwellTagsArgs',
    'SettingEngagementHoursArgs',
    'SettingGatewayMgmtArgs',
    'SettingGatewayMgmtAppProbingArgs',
    'SettingGatewayMgmtAppProbingCustomAppArgs',
    'SettingGatewayMgmtAutoSignatureUpdateArgs',
    'SettingLedArgs',
    'SettingOccupancyArgs',
    'SettingProxyArgs',
    'SettingRogueArgs',
    'SettingRtsaArgs',
    'SettingSimpleAlertArgs',
    'SettingSimpleAlertArpFailureArgs',
    'SettingSimpleAlertDhcpFailureArgs',
    'SettingSimpleAlertDnsFailureArgs',
    'SettingSkyatpArgs',
    'SettingSrxAppArgs',
    'SettingSsrArgs',
    'SettingSyntheticTestArgs',
    'SettingSyntheticTestVlanArgs',
    'SettingSyntheticTestWanSpeedtestArgs',
    'SettingUplinkPortConfigArgs',
    'SettingVnaArgs',
    'SettingVsInstanceArgs',
    'SettingWanVnaArgs',
    'SettingWidsArgs',
    'SettingWidsRepeatedAuthFailuresArgs',
    'SettingWifiArgs',
    'SettingWiredVnaArgs',
    'SettingZoneOccupancyAlertArgs',
    'WlanAcctServerArgs',
    'WlanAirwatchArgs',
    'WlanAppLimitArgs',
    'WlanAppQosArgs',
    'WlanAppQosAppsArgs',
    'WlanAppQosOtherArgs',
    'WlanAuthArgs',
    'WlanAuthServerArgs',
    'WlanBonjourArgs',
    'WlanBonjourServicesArgs',
    'WlanCiscoCwaArgs',
    'WlanCoaServerArgs',
    'WlanDnsServerRewriteArgs',
    'WlanDynamicPskArgs',
    'WlanDynamicVlanArgs',
    'WlanHotspot20Args',
    'WlanInjectDhcpOption82Args',
    'WlanMistNacArgs',
    'WlanPortalArgs',
    'WlanQosArgs',
    'WlanRadsecArgs',
    'WlanRadsecServerArgs',
    'WlanScheduleArgs',
    'WlanScheduleHoursArgs',
    'WxtagSpecArgs',
    'BaseLatlngArgs',
]

@pulumi.input_type
class NetworktemplateAclPolicyArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 src_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]] actions: - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
               - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        :param pulumi.Input[Sequence[pulumi.Input[str]]] src_tags: - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
               - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_tags is not None:
            pulumi.set(__self__, "src_tags", src_tags)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]]]:
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclPolicyActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="srcTags")
    def src_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "src_tags")

    @src_tags.setter
    def src_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "src_tags", value)


@pulumi.input_type
class NetworktemplateAclPolicyActionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 dst_tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: enum: `allow`, `deny`
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if dst_tag is not None:
            pulumi.set(__self__, "dst_tag", dst_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="dstTag")
    def dst_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dst_tag")

    @dst_tag.setter
    def dst_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_tag", value)


@pulumi.input_type
class NetworktemplateAclTagsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 gbp_tag: Optional[pulumi.Input[int]] = None,
                 macs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 radius_group: Optional[pulumi.Input[str]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
        :param pulumi.Input[int] gbp_tag: required if
               - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
               - `type`==`static_gbp` (applying gbp tag against matching conditions)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] macs: required if 
               - `type`==`mac`
               - `type`==`static_gbp` if from matching mac
        :param pulumi.Input[str] network: if:
                 * `type`==`mac` (optional. default is `any`)
                 * `type`==`subnet` (optional. default is `any`)
                 * `type`==`network`
                 * `type`==`resource` (optional. default is `any`)
                 * `type`==`static_gbp` if from matching network (vlan)'
        :param pulumi.Input[str] radius_group: required if:
                 * `type`==`radius_group`
                 * `type`==`static_gbp`
               if from matching radius_group
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]] specs: if `type`==`resource`
               empty means unrestricted, i.e. any
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: if 
               - `type`==`subnet` 
               - `type`==`resource` (optional. default is `any`)
               - `type`==`static_gbp` if from matching subnet
        """
        pulumi.set(__self__, "type", type)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if macs is not None:
            pulumi.set(__self__, "macs", macs)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[pulumi.Input[int]]:
        """
        required if
        - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
        - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        return pulumi.get(self, "gbp_tag")

    @gbp_tag.setter
    def gbp_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gbp_tag", value)

    @property
    @pulumi.getter
    def macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        return pulumi.get(self, "macs")

    @macs.setter
    def macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "macs", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        if:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)'
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[pulumi.Input[str]]:
        """
        required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        return pulumi.get(self, "radius_group")

    @radius_group.setter
    def radius_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "radius_group", value)

    @property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]]]:
        """
        if `type`==`resource`
        empty means unrestricted, i.e. any
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateAclTagsSpecArgs']]]]):
        pulumi.set(self, "specs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


@pulumi.input_type
class NetworktemplateAclTagsSpecArgs:
    def __init__(__self__, *,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port_range: matched dst port, "0" means any
        :param pulumi.Input[str] protocol: `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class NetworktemplateDhcpSnoopingArgs:
    def __init__(__self__, *,
                 all_networks: Optional[pulumi.Input[bool]] = None,
                 enable_arp_spoof_check: Optional[pulumi.Input[bool]] = None,
                 enable_ip_source_guard: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enable_arp_spoof_check: Enable for dynamic ARP inspection check
        :param pulumi.Input[bool] enable_ip_source_guard: Enable for check for forging source IP address
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_ip_source_guard is not None:
            pulumi.set(__self__, "enable_ip_source_guard", enable_ip_source_guard)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "all_networks")

    @all_networks.setter
    def all_networks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all_networks", value)

    @property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable for dynamic ARP inspection check
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @enable_arp_spoof_check.setter
    def enable_arp_spoof_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_arp_spoof_check", value)

    @property
    @pulumi.getter(name="enableIpSourceGuard")
    def enable_ip_source_guard(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable for check for forging source IP address
        """
        return pulumi.get(self, "enable_ip_source_guard")

    @enable_ip_source_guard.setter
    def enable_ip_source_guard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_source_guard", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)


@pulumi.input_type
class NetworktemplateExtraRoutes6Args:
    def __init__(__self__, *,
                 via: pulumi.Input[str],
                 discard: Optional[pulumi.Input[bool]] = None,
                 metric: Optional[pulumi.Input[int]] = None,
                 next_qualified: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgs']]]] = None,
                 no_resolve: Optional[pulumi.Input[bool]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] via: next-hop IP Address
        :param pulumi.Input[bool] discard: this takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        """
        next-hop IP Address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[bool]]:
        """
        this takes precedence
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgs']]]]:
        return pulumi.get(self, "next_qualified")

    @next_qualified.setter
    def next_qualified(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutes6NextQualifiedArgs']]]]):
        pulumi.set(self, "next_qualified", value)

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "no_resolve")

    @no_resolve.setter
    def no_resolve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_resolve", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


@pulumi.input_type
class NetworktemplateExtraRoutes6NextQualifiedArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[int]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


@pulumi.input_type
class NetworktemplateExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[str],
                 discard: Optional[pulumi.Input[bool]] = None,
                 metric: Optional[pulumi.Input[int]] = None,
                 next_qualified: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgs']]]] = None,
                 no_resolve: Optional[pulumi.Input[bool]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] via: next-hop IP Address
        :param pulumi.Input[bool] discard: this takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        """
        next-hop IP Address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[bool]]:
        """
        this takes precedence
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgs']]]]:
        return pulumi.get(self, "next_qualified")

    @next_qualified.setter
    def next_qualified(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateExtraRoutesNextQualifiedArgs']]]]):
        pulumi.set(self, "next_qualified", value)

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "no_resolve")

    @no_resolve.setter
    def no_resolve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_resolve", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


@pulumi.input_type
class NetworktemplateExtraRoutesNextQualifiedArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[int]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


@pulumi.input_type
class NetworktemplateMistNacArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 network: Optional[pulumi.Input[str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)


@pulumi.input_type
class NetworktemplateNetworksArgs:
    def __init__(__self__, *,
                 vlan_id: pulumi.Input[str],
                 isolation: Optional[pulumi.Input[bool]] = None,
                 isolation_vlan_id: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] isolation: whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
               NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        :param pulumi.Input[str] subnet: optional for pure switching, required when L3 / routing features are used
        """
        pulumi.set(__self__, "vlan_id", vlan_id)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if isolation_vlan_id is not None:
            pulumi.set(__self__, "isolation_vlan_id", isolation_vlan_id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
        NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="isolationVlanId")
    def isolation_vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "isolation_vlan_id")

    @isolation_vlan_id.setter
    def isolation_vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "isolation_vlan_id", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)


@pulumi.input_type
class NetworktemplatePortMirroringArgs:
    def __init__(__self__, *,
                 input_networks_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_port_ids_egresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_port_ids_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_network: Optional[pulumi.Input[str]] = None,
                 output_port_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_networks_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_port_ids_egresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_port_ids_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[str] output_network: exaclty one of the `output_port_id` or `output_network` should be provided
        :param pulumi.Input[str] output_port_id: exaclty one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @input_networks_ingresses.setter
    def input_networks_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_networks_ingresses", value)

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @input_port_ids_egresses.setter
    def input_port_ids_egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_port_ids_egresses", value)

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @input_port_ids_ingresses.setter
    def input_port_ids_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_port_ids_ingresses", value)

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[pulumi.Input[str]]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @output_network.setter
    def output_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_network", value)

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[pulumi.Input[str]]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")

    @output_port_id.setter
    def output_port_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_port_id", value)


@pulumi.input_type
class NetworktemplatePortUsagesArgs:
    def __init__(__self__, *,
                 all_networks: Optional[pulumi.Input[bool]] = None,
                 allow_dhcpd: Optional[pulumi.Input[bool]] = None,
                 allow_multiple_supplicants: Optional[pulumi.Input[bool]] = None,
                 bypass_auth_when_server_down: Optional[pulumi.Input[bool]] = None,
                 bypass_auth_when_server_down_for_unkonwn_client: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_autoneg: Optional[pulumi.Input[bool]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 duplex: Optional[pulumi.Input[str]] = None,
                 dynamic_vlan_networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_mac_auth: Optional[pulumi.Input[bool]] = None,
                 enable_qos: Optional[pulumi.Input[bool]] = None,
                 guest_network: Optional[pulumi.Input[str]] = None,
                 inter_switch_link: Optional[pulumi.Input[bool]] = None,
                 mac_auth_only: Optional[pulumi.Input[bool]] = None,
                 mac_auth_protocol: Optional[pulumi.Input[str]] = None,
                 mac_limit: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 persist_mac: Optional[pulumi.Input[bool]] = None,
                 poe_disabled: Optional[pulumi.Input[bool]] = None,
                 port_auth: Optional[pulumi.Input[str]] = None,
                 port_network: Optional[pulumi.Input[str]] = None,
                 reauth_interval: Optional[pulumi.Input[int]] = None,
                 rejected_network: Optional[pulumi.Input[str]] = None,
                 reset_default_when: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]]] = None,
                 speed: Optional[pulumi.Input[str]] = None,
                 storm_control: Optional[pulumi.Input['NetworktemplatePortUsagesStormControlArgs']] = None,
                 stp_edge: Optional[pulumi.Input[bool]] = None,
                 voip_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param pulumi.Input[bool] allow_dhcpd: Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
               
               When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        :param pulumi.Input[bool] allow_multiple_supplicants: Only if `mode`!=`dynamic`
        :param pulumi.Input[bool] bypass_auth_when_server_down: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param pulumi.Input[bool] bypass_auth_when_server_down_for_unkonwn_client: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param pulumi.Input[str] description: Only if `mode`!=`dynamic`
        :param pulumi.Input[bool] disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param pulumi.Input[bool] disabled: Only if `mode`!=`dynamic` whether the port is disabled
        :param pulumi.Input[str] duplex: Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dynamic_vlan_networks: Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param pulumi.Input[bool] enable_mac_auth: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        :param pulumi.Input[bool] enable_qos: Only if `mode`!=`dynamic`
        :param pulumi.Input[str] guest_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param pulumi.Input[bool] inter_switch_link: Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
               NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param pulumi.Input[bool] mac_auth_only: Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        :param pulumi.Input[str] mac_auth_protocol: Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param pulumi.Input[int] mac_limit: Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        :param pulumi.Input[str] mode: `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        :param pulumi.Input[int] mtu: Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param pulumi.Input[bool] persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param pulumi.Input[bool] poe_disabled: Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        :param pulumi.Input[str] port_auth: Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        :param pulumi.Input[str] port_network: Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        :param pulumi.Input[int] reauth_interval: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        :param pulumi.Input[str] rejected_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        :param pulumi.Input[str] reset_default_when: Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        :param pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]] rules: Only if `mode`==`dynamic`
        :param pulumi.Input[str] speed: Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        :param pulumi.Input['NetworktemplatePortUsagesStormControlArgs'] storm_control: Switch storm control
               Only if `mode`!=`dynamic`
        :param pulumi.Input[bool] stp_edge: Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        :param pulumi.Input[str] voip_network: Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unkonwn_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unkonwn_client", bypass_auth_when_server_down_for_unkonwn_client)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if rejected_network is not None:
            pulumi.set(__self__, "rejected_network", rejected_network)
        if reset_default_when is not None:
            pulumi.set(__self__, "reset_default_when", reset_default_when)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @all_networks.setter
    def all_networks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all_networks", value)

    @property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.

        When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @allow_dhcpd.setter
    def allow_dhcpd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_dhcpd", value)

    @property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "allow_multiple_supplicants")

    @allow_multiple_supplicants.setter
    def allow_multiple_supplicants(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_multiple_supplicants", value)

    @property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @bypass_auth_when_server_down.setter
    def bypass_auth_when_server_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_auth_when_server_down", value)

    @property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnkonwnClient")
    def bypass_auth_when_server_down_for_unkonwn_client(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unkonwn_client")

    @bypass_auth_when_server_down_for_unkonwn_client.setter
    def bypass_auth_when_server_down_for_unkonwn_client(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_auth_when_server_down_for_unkonwn_client", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @dynamic_vlan_networks.setter
    def dynamic_vlan_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dynamic_vlan_networks", value)

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @enable_mac_auth.setter
    def enable_mac_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_mac_auth", value)

    @property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "enable_qos")

    @enable_qos.setter
    def enable_qos(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_qos", value)

    @property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @guest_network.setter
    def guest_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_network", value)

    @property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
        NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @inter_switch_link.setter
    def inter_switch_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inter_switch_link", value)

    @property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @mac_auth_only.setter
    def mac_auth_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mac_auth_only", value)

    @property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @mac_auth_protocol.setter
    def mac_auth_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_auth_protocol", value)

    @property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        """
        return pulumi.get(self, "mac_limit")

    @mac_limit.setter
    def mac_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mac_limit", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @persist_mac.setter
    def persist_mac(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "persist_mac", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @port_auth.setter
    def port_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_auth", value)

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @port_network.setter
    def port_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_network", value)

    @property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        """
        return pulumi.get(self, "reauth_interval")

    @reauth_interval.setter
    def reauth_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reauth_interval", value)

    @property
    @pulumi.getter(name="rejectedNetwork")
    def rejected_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "rejected_network")

    @rejected_network.setter
    def rejected_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rejected_network", value)

    @property
    @pulumi.getter(name="resetDefaultWhen")
    def reset_default_when(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        return pulumi.get(self, "reset_default_when")

    @reset_default_when.setter
    def reset_default_when(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reset_default_when", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]]]:
        """
        Only if `mode`==`dynamic`
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplatePortUsagesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional[pulumi.Input['NetworktemplatePortUsagesStormControlArgs']]:
        """
        Switch storm control
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "storm_control")

    @storm_control.setter
    def storm_control(self, value: Optional[pulumi.Input['NetworktemplatePortUsagesStormControlArgs']]):
        pulumi.set(self, "storm_control", value)

    @property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @stp_edge.setter
    def stp_edge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stp_edge", value)

    @property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")

    @voip_network.setter
    def voip_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "voip_network", value)


@pulumi.input_type
class NetworktemplatePortUsagesRuleArgs:
    def __init__(__self__, *,
                 src: pulumi.Input[str],
                 equals: Optional[pulumi.Input[str]] = None,
                 equals_anies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 usage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] src: enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] equals_anies: use `equals_any` to match any item in a list
        :param pulumi.Input[str] expression: "[0:3]":"abcdef" > "abc"
               "split(.)[1]": "a.b.c" > "b"
               "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        :param pulumi.Input[str] usage: `port_usage` name
        """
        pulumi.set(__self__, "src", src)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if equals_anies is not None:
            pulumi.set(__self__, "equals_anies", equals_anies)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def src(self) -> pulumi.Input[str]:
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        return pulumi.get(self, "src")

    @src.setter
    def src(self, value: pulumi.Input[str]):
        pulumi.set(self, "src", value)

    @property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "equals", value)

    @property
    @pulumi.getter(name="equalsAnies")
    def equals_anies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        use `equals_any` to match any item in a list
        """
        return pulumi.get(self, "equals_anies")

    @equals_anies.setter
    def equals_anies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "equals_anies", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[str]]:
        """
        `port_usage` name
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage", value)


@pulumi.input_type
class NetworktemplatePortUsagesStormControlArgs:
    def __init__(__self__, *,
                 no_broadcast: Optional[pulumi.Input[bool]] = None,
                 no_multicast: Optional[pulumi.Input[bool]] = None,
                 no_registered_multicast: Optional[pulumi.Input[bool]] = None,
                 no_unknown_unicast: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] no_broadcast: whether to disable storm control on broadcast traffic
        :param pulumi.Input[bool] no_multicast: whether to disable storm control on multicast traffic
        :param pulumi.Input[bool] no_registered_multicast: whether to disable storm control on registered multicast traffic
        :param pulumi.Input[bool] no_unknown_unicast: whether to disable storm control on unknown unicast traffic
        :param pulumi.Input[int] percentage: bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @no_broadcast.setter
    def no_broadcast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_broadcast", value)

    @property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @no_multicast.setter
    def no_multicast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_multicast", value)

    @property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @no_registered_multicast.setter
    def no_registered_multicast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_registered_multicast", value)

    @property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @no_unknown_unicast.setter
    def no_unknown_unicast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_unknown_unicast", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


@pulumi.input_type
class NetworktemplateRadiusConfigArgs:
    def __init__(__self__, *,
                 acct_interim_interval: Optional[pulumi.Input[int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgs']]]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgs']]]] = None,
                 auth_servers_retries: Optional[pulumi.Input[int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[int]] = None,
                 coa_enabled: Optional[pulumi.Input[bool]] = None,
                 coa_port: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param pulumi.Input[int] auth_servers_retries: radius auth session retries
        :param pulumi.Input[int] auth_servers_timeout: radius auth session timeout
        :param pulumi.Input[str] network: use `network`or `source_ip`
               which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param pulumi.Input[str] source_ip: use `network`or `source_ip`
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[int]]:
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgs']]]]:
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgs']]]]:
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRadiusConfigAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "coa_enabled")

    @coa_enabled.setter
    def coa_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "coa_enabled", value)

    @property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "coa_port")

    @coa_port.setter
    def coa_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "coa_port", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        use `network`or `source_ip`
        which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        """
        use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)


@pulumi.input_type
class NetworktemplateRadiusConfigAcctServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 keywrap_enabled: Optional[pulumi.Input[bool]] = None,
                 keywrap_format: Optional[pulumi.Input[str]] = None,
                 keywrap_kek: Optional[pulumi.Input[str]] = None,
                 keywrap_mack: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: ip / hostname of RADIUS server
        :param pulumi.Input[str] secret: secret of RADIUS server
        :param pulumi.Input[str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[int] port: Acct port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Acct port of RADIUS server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class NetworktemplateRadiusConfigAuthServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 keywrap_enabled: Optional[pulumi.Input[bool]] = None,
                 keywrap_format: Optional[pulumi.Input[str]] = None,
                 keywrap_kek: Optional[pulumi.Input[str]] = None,
                 keywrap_mack: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: ip / hostname of RADIUS server
        :param pulumi.Input[str] secret: secret of RADIUS server
        :param pulumi.Input[str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[int] port: Auth port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Auth port of RADIUS server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgs']] = None,
                 console: Optional[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 files: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgs']]]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 send_to_all_servers: Optional[pulumi.Input[bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgs']]]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgs']]]] = None):
        """
        :param pulumi.Input[str] network: if source_address is configured, will use the vlan firstly otherwise use source_ip
        :param pulumi.Input[str] time_format: enum: `millisecond`, `year`, `year millisecond`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if console is not None:
            pulumi.set(__self__, "console", console)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if send_to_all_servers is not None:
            pulumi.set(__self__, "send_to_all_servers", send_to_all_servers)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgs']]:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input['NetworktemplateRemoteSyslogArchiveArgs']]):
        pulumi.set(self, "archive", value)

    @property
    @pulumi.getter
    def console(self) -> Optional[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgs']]:
        return pulumi.get(self, "console")

    @console.setter
    def console(self, value: Optional[pulumi.Input['NetworktemplateRemoteSyslogConsoleArgs']]):
        pulumi.set(self, "console", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgs']]]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileArgs']]]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sendToAllServers")
    def send_to_all_servers(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "send_to_all_servers")

    @send_to_all_servers.setter
    def send_to_all_servers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_to_all_servers", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgs']]]]:
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgs']]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogArchiveArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[int]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogConsoleArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgs']]]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogConsoleContentArgs']]]]):
        pulumi.set(self, "contents", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogConsoleContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogFileArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgs']] = None,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgs']]]] = None,
                 explicit_priority: Optional[pulumi.Input[bool]] = None,
                 file: Optional[pulumi.Input[str]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 structured_data: Optional[pulumi.Input[bool]] = None):
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)

    @property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgs']]:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input['NetworktemplateRemoteSyslogFileArchiveArgs']]):
        pulumi.set(self, "archive", value)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogFileContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "explicit_priority")

    @explicit_priority.setter
    def explicit_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "explicit_priority", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "structured_data")

    @structured_data.setter
    def structured_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "structured_data", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogFileArchiveArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[int]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogFileContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogServerArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgs']]]] = None,
                 explicit_priority: Optional[pulumi.Input[bool]] = None,
                 facility: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 routing_instance: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 source_address: Optional[pulumi.Input[str]] = None,
                 structured_data: Optional[pulumi.Input[bool]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] protocol: enum: `tcp`, `udp`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        :param pulumi.Input[str] source_address: if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routing_instance is not None:
            pulumi.set(__self__, "routing_instance", routing_instance)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogServerContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "explicit_priority")

    @explicit_priority.setter
    def explicit_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "explicit_priority", value)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="routingInstance")
    def routing_instance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "routing_instance")

    @routing_instance.setter
    def routing_instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_instance", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[str]]:
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_address", value)

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "structured_data")

    @structured_data.setter
    def structured_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "structured_data", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogServerContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogUserArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgs']]]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateRemoteSyslogUserContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class NetworktemplateRemoteSyslogUserContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class NetworktemplateSnmpConfigArgs:
    def __init__(__self__, *,
                 client_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgs']]]] = None,
                 contact: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 engine_id: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 trap_groups: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgs']]]] = None,
                 v2c_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgs']]]] = None,
                 v3_config: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgs']] = None,
                 views: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgs']]]] = None):
        """
        :param pulumi.Input[str] engine_id: enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        if client_lists is not None:
            pulumi.set(__self__, "client_lists", client_lists)
        if contact is not None:
            pulumi.set(__self__, "contact", contact)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if trap_groups is not None:
            pulumi.set(__self__, "trap_groups", trap_groups)
        if v2c_configs is not None:
            pulumi.set(__self__, "v2c_configs", v2c_configs)
        if v3_config is not None:
            pulumi.set(__self__, "v3_config", v3_config)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter(name="clientLists")
    def client_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgs']]]]:
        return pulumi.get(self, "client_lists")

    @client_lists.setter
    def client_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigClientListArgs']]]]):
        pulumi.set(self, "client_lists", value)

    @property
    @pulumi.getter
    def contact(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "contact")

    @contact.setter
    def contact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        return pulumi.get(self, "engine_id")

    @engine_id.setter
    def engine_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engine_id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="trapGroups")
    def trap_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgs']]]]:
        return pulumi.get(self, "trap_groups")

    @trap_groups.setter
    def trap_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigTrapGroupArgs']]]]):
        pulumi.set(self, "trap_groups", value)

    @property
    @pulumi.getter(name="v2cConfigs")
    def v2c_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgs']]]]:
        return pulumi.get(self, "v2c_configs")

    @v2c_configs.setter
    def v2c_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV2cConfigArgs']]]]):
        pulumi.set(self, "v2c_configs", value)

    @property
    @pulumi.getter(name="v3Config")
    def v3_config(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgs']]:
        return pulumi.get(self, "v3_config")

    @v3_config.setter
    def v3_config(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigArgs']]):
        pulumi.set(self, "v3_config", value)

    @property
    @pulumi.getter
    def views(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgs']]]]:
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigViewArgs']]]]):
        pulumi.set(self, "views", value)


@pulumi.input_type
class NetworktemplateSnmpConfigClientListArgs:
    def __init__(__self__, *,
                 client_list_name: Optional[pulumi.Input[str]] = None,
                 clients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_list_name")

    @client_list_name.setter
    def client_list_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_list_name", value)

    @property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class NetworktemplateSnmpConfigTrapGroupArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_name: Optional[pulumi.Input[str]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group_name: Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        :param pulumi.Input[str] version: enum: `all`, `v1`, `v2`
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `all`, `v1`, `v2`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV2cConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input[str]] = None,
                 client_list_name: Optional[pulumi.Input[str]] = None,
                 community_name: Optional[pulumi.Input[str]] = None,
                 view: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_list_name: client_list_name here should refer to client_list above
        :param pulumi.Input[str] view: view name here should be defined in views above
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[pulumi.Input[str]]:
        """
        client_list_name here should refer to client_list above
        """
        return pulumi.get(self, "client_list_name")

    @client_list_name.setter
    def client_list_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_list_name", value)

    @property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "community_name")

    @community_name.setter
    def community_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_name", value)

    @property
    @pulumi.getter
    def view(self) -> Optional[pulumi.Input[str]]:
        """
        view name here should be defined in views above
        """
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigArgs:
    def __init__(__self__, *,
                 notifies: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgs']]]] = None,
                 notify_filters: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs']]]] = None,
                 target_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgs']]]] = None,
                 target_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgs']]]] = None,
                 usm: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgs']] = None,
                 vacm: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgs']] = None):
        if notifies is not None:
            pulumi.set(__self__, "notifies", notifies)
        if notify_filters is not None:
            pulumi.set(__self__, "notify_filters", notify_filters)
        if target_addresses is not None:
            pulumi.set(__self__, "target_addresses", target_addresses)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)
        if usm is not None:
            pulumi.set(__self__, "usm", usm)
        if vacm is not None:
            pulumi.set(__self__, "vacm", vacm)

    @property
    @pulumi.getter
    def notifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgs']]]]:
        return pulumi.get(self, "notifies")

    @notifies.setter
    def notifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyArgs']]]]):
        pulumi.set(self, "notifies", value)

    @property
    @pulumi.getter(name="notifyFilters")
    def notify_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs']]]]:
        return pulumi.get(self, "notify_filters")

    @notify_filters.setter
    def notify_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs']]]]):
        pulumi.set(self, "notify_filters", value)

    @property
    @pulumi.getter(name="targetAddresses")
    def target_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgs']]]]:
        return pulumi.get(self, "target_addresses")

    @target_addresses.setter
    def target_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetAddressArgs']]]]):
        pulumi.set(self, "target_addresses", value)

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgs']]]]:
        return pulumi.get(self, "target_parameters")

    @target_parameters.setter
    def target_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigTargetParameterArgs']]]]):
        pulumi.set(self, "target_parameters", value)

    @property
    @pulumi.getter
    def usm(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgs']]:
        return pulumi.get(self, "usm")

    @usm.setter
    def usm(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmArgs']]):
        pulumi.set(self, "usm", value)

    @property
    @pulumi.getter
    def vacm(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgs']]:
        return pulumi.get(self, "vacm")

    @vacm.setter
    def vacm(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmArgs']]):
        pulumi.set(self, "vacm", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigNotifyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: enum: `inform`, `trap`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `inform`, `trap`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilterArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs']]]] = None,
                 profile_name: Optional[pulumi.Input[str]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile_name", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilterContentArgs:
    def __init__(__self__, *,
                 include: Optional[pulumi.Input[bool]] = None,
                 oid: Optional[pulumi.Input[str]] = None):
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter
    def oid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oid")

    @oid.setter
    def oid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oid", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigTargetAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 address_mask: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 tag_list: Optional[pulumi.Input[str]] = None,
                 target_address_name: Optional[pulumi.Input[str]] = None,
                 target_parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] tag_list: <refer to notify tag, can be multiple with blank
        :param pulumi.Input[str] target_parameters: refer to notify target parameters name
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_mask is not None:
            pulumi.set(__self__, "address_mask", address_mask)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if target_address_name is not None:
            pulumi.set(__self__, "target_address_name", target_address_name)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressMask")
    def address_mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address_mask")

    @address_mask.setter
    def address_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_mask", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[pulumi.Input[str]]:
        """
        <refer to notify tag, can be multiple with blank
        """
        return pulumi.get(self, "tag_list")

    @tag_list.setter
    def tag_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_list", value)

    @property
    @pulumi.getter(name="targetAddressName")
    def target_address_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_address_name")

    @target_address_name.setter
    def target_address_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_address_name", value)

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        refer to notify target parameters name
        """
        return pulumi.get(self, "target_parameters")

    @target_parameters.setter
    def target_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_parameters", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigTargetParameterArgs:
    def __init__(__self__, *,
                 message_processing_model: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 notify_filter: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 security_model: Optional[pulumi.Input[str]] = None,
                 security_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message_processing_model: enum: `v1`, `v2c`, `v3`
        :param pulumi.Input[str] notify_filter: refer to profile-name in notify_filter
        :param pulumi.Input[str] security_level: enum: `authentication`, `none`, `privacy`
        :param pulumi.Input[str] security_model: enum: `usm`, `v1`, `v2c`
        :param pulumi.Input[str] security_name: refer to security_name in usm
        """
        if message_processing_model is not None:
            pulumi.set(__self__, "message_processing_model", message_processing_model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notify_filter is not None:
            pulumi.set(__self__, "notify_filter", notify_filter)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter(name="messageProcessingModel")
    def message_processing_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `v1`, `v2c`, `v3`
        """
        return pulumi.get(self, "message_processing_model")

    @message_processing_model.setter
    def message_processing_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_processing_model", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notifyFilter")
    def notify_filter(self) -> Optional[pulumi.Input[str]]:
        """
        refer to profile-name in notify_filter
        """
        return pulumi.get(self, "notify_filter")

    @notify_filter.setter
    def notify_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_filter", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_model", value)

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[pulumi.Input[str]]:
        """
        refer to security_name in usm
        """
        return pulumi.get(self, "security_name")

    @security_name.setter
    def security_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_name", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigUsmArgs:
    def __init__(__self__, *,
                 engine_type: Optional[pulumi.Input[str]] = None,
                 engineid: Optional[pulumi.Input[str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgs']]]] = None):
        """
        :param pulumi.Input[str] engine_type: enum: `local_engine`, `remote_engine`
        :param pulumi.Input[str] engineid: required only if `engine_type`==`remote_engine`
        """
        if engine_type is not None:
            pulumi.set(__self__, "engine_type", engine_type)
        if engineid is not None:
            pulumi.set(__self__, "engineid", engineid)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `local_engine`, `remote_engine`
        """
        return pulumi.get(self, "engine_type")

    @engine_type.setter
    def engine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engine_type", value)

    @property
    @pulumi.getter
    def engineid(self) -> Optional[pulumi.Input[str]]:
        """
        required only if `engine_type`==`remote_engine`
        """
        return pulumi.get(self, "engineid")

    @engineid.setter
    def engineid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engineid", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgs']]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigUsmUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigUsmUserArgs:
    def __init__(__self__, *,
                 authentication_password: Optional[pulumi.Input[str]] = None,
                 authentication_type: Optional[pulumi.Input[str]] = None,
                 encryption_password: Optional[pulumi.Input[str]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authentication_password: Not required if `authentication_type`==`authentication_none`
               include alphabetic, numeric, and special characters, but it cannot include control characters.
        :param pulumi.Input[str] authentication_type: sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        :param pulumi.Input[str] encryption_password: Not required if `encryption_type`==`privacy-none`
               include alphabetic, numeric, and special characters, but it cannot include control characters
        :param pulumi.Input[str] encryption_type: enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        if authentication_password is not None:
            pulumi.set(__self__, "authentication_password", authentication_password)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="authenticationPassword")
    def authentication_password(self) -> Optional[pulumi.Input[str]]:
        """
        Not required if `authentication_type`==`authentication_none`
        include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        return pulumi.get(self, "authentication_password")

    @authentication_password.setter
    def authentication_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_password", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[str]]:
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[pulumi.Input[str]]:
        """
        Not required if `encryption_type`==`privacy-none`
        include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        return pulumi.get(self, "encryption_password")

    @encryption_password.setter
    def encryption_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_password", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmArgs:
    def __init__(__self__, *,
                 accesses: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgs']]]] = None,
                 security_to_group: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs']] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if security_to_group is not None:
            pulumi.set(__self__, "security_to_group", security_to_group)

    @property
    @pulumi.getter
    def accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgs']]]]:
        return pulumi.get(self, "accesses")

    @accesses.setter
    def accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessArgs']]]]):
        pulumi.set(self, "accesses", value)

    @property
    @pulumi.getter(name="securityToGroup")
    def security_to_group(self) -> Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs']]:
        return pulumi.get(self, "security_to_group")

    @security_to_group.setter
    def security_to_group(self, value: Optional[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs']]):
        pulumi.set(self, "security_to_group", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmAccessArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[str]] = None,
                 prefix_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]]:
        return pulumi.get(self, "prefix_lists")

    @prefix_lists.setter
    def prefix_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]]):
        pulumi.set(self, "prefix_lists", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixListArgs:
    def __init__(__self__, *,
                 context_prefix: Optional[pulumi.Input[str]] = None,
                 notify_view: Optional[pulumi.Input[str]] = None,
                 read_view: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 security_model: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 write_view: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context_prefix: only required if `type`==`context_prefix`
        :param pulumi.Input[str] notify_view: refer to view name
        :param pulumi.Input[str] read_view: refer to view name
        :param pulumi.Input[str] security_level: enum: `authentication`, `none`, `privacy`
        :param pulumi.Input[str] security_model: enum: `any`, `usm`, `v1`, `v2c`
        :param pulumi.Input[str] type: enum: `context_prefix`, `default_context_prefix`
        :param pulumi.Input[str] write_view: refer to view name
        """
        if context_prefix is not None:
            pulumi.set(__self__, "context_prefix", context_prefix)
        if notify_view is not None:
            pulumi.set(__self__, "notify_view", notify_view)
        if read_view is not None:
            pulumi.set(__self__, "read_view", read_view)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if write_view is not None:
            pulumi.set(__self__, "write_view", write_view)

    @property
    @pulumi.getter(name="contextPrefix")
    def context_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        only required if `type`==`context_prefix`
        """
        return pulumi.get(self, "context_prefix")

    @context_prefix.setter
    def context_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_prefix", value)

    @property
    @pulumi.getter(name="notifyView")
    def notify_view(self) -> Optional[pulumi.Input[str]]:
        """
        refer to view name
        """
        return pulumi.get(self, "notify_view")

    @notify_view.setter
    def notify_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_view", value)

    @property
    @pulumi.getter(name="readView")
    def read_view(self) -> Optional[pulumi.Input[str]]:
        """
        refer to view name
        """
        return pulumi.get(self, "read_view")

    @read_view.setter
    def read_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_view", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_model", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="writeView")
    def write_view(self) -> Optional[pulumi.Input[str]]:
        """
        refer to view name
        """
        return pulumi.get(self, "write_view")

    @write_view.setter
    def write_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "write_view", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]] = None,
                 security_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] security_model: enum: `usm`, `v1`, `v2c`
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_model", value)


@pulumi.input_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContentArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 security_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group: refer to group_name under access
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        refer to group_name under access
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_name")

    @security_name.setter
    def security_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_name", value)


@pulumi.input_type
class NetworktemplateSnmpConfigViewArgs:
    def __init__(__self__, *,
                 include: Optional[pulumi.Input[bool]] = None,
                 oid: Optional[pulumi.Input[str]] = None,
                 view_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include: if the root oid configured is included
        """
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[bool]]:
        """
        if the root oid configured is included
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter
    def oid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oid")

    @oid.setter
    def oid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oid", value)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "view_name")

    @view_name.setter
    def view_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view_name", value)


@pulumi.input_type
class NetworktemplateSwitchMatchingArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]]] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMatchingRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class NetworktemplateSwitchMatchingRuleArgs:
    def __init__(__self__, *,
                 additional_config_cmds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 match_role: Optional[pulumi.Input[str]] = None,
                 match_type: Optional[pulumi.Input[str]] = None,
                 match_value: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port_config: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]]] = None,
                 port_mirroring: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_config_cmds: additional CLI commands to append to the generated Junos config
               
               **Note**: no check is done
        :param pulumi.Input[str] match_role: role to match
        :param pulumi.Input[str] match_type: 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]] port_config: Propery key is the interface name or interface range
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]] port_mirroring: Property key is the port mirroring instance name
               port_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
        """
        if additional_config_cmds is not None:
            pulumi.set(__self__, "additional_config_cmds", additional_config_cmds)
        if match_role is not None:
            pulumi.set(__self__, "match_role", match_role)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_config is not None:
            pulumi.set(__self__, "port_config", port_config)
        if port_mirroring is not None:
            pulumi.set(__self__, "port_mirroring", port_mirroring)

    @property
    @pulumi.getter(name="additionalConfigCmds")
    def additional_config_cmds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        additional CLI commands to append to the generated Junos config

        **Note**: no check is done
        """
        return pulumi.get(self, "additional_config_cmds")

    @additional_config_cmds.setter
    def additional_config_cmds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_config_cmds", value)

    @property
    @pulumi.getter(name="matchRole")
    def match_role(self) -> Optional[pulumi.Input[str]]:
        """
        role to match
        """
        return pulumi.get(self, "match_role")

    @match_role.setter
    def match_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_role", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]]]:
        """
        Propery key is the interface name or interface range
        """
        return pulumi.get(self, "port_config")

    @port_config.setter
    def port_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortConfigArgs']]]]):
        pulumi.set(self, "port_config", value)

    @property
    @pulumi.getter(name="portMirroring")
    def port_mirroring(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]]]:
        """
        Property key is the port mirroring instance name
        port_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
        """
        return pulumi.get(self, "port_mirroring")

    @port_mirroring.setter
    def port_mirroring(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateSwitchMatchingRulePortMirroringArgs']]]]):
        pulumi.set(self, "port_mirroring", value)


@pulumi.input_type
class NetworktemplateSwitchMatchingRulePortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[str],
                 ae_disable_lacp: Optional[pulumi.Input[bool]] = None,
                 ae_idx: Optional[pulumi.Input[int]] = None,
                 ae_lacp_slow: Optional[pulumi.Input[bool]] = None,
                 aggregated: Optional[pulumi.Input[bool]] = None,
                 critical: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_autoneg: Optional[pulumi.Input[bool]] = None,
                 duplex: Optional[pulumi.Input[str]] = None,
                 dynamic_usage: Optional[pulumi.Input[str]] = None,
                 esilag: Optional[pulumi.Input[bool]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 no_local_overwrite: Optional[pulumi.Input[bool]] = None,
                 poe_disabled: Optional[pulumi.Input[bool]] = None,
                 speed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] usage: port usage name. 
               
               If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param pulumi.Input[bool] ae_disable_lacp: To disable LACP support for the AE interface
        :param pulumi.Input[int] ae_idx: Users could force to use the designated AE name
        :param pulumi.Input[bool] ae_lacp_slow: to use fast timeout
        :param pulumi.Input[bool] critical: if want to generate port up/down alarm
        :param pulumi.Input[bool] disable_autoneg: if `speed` and `duplex` are specified, whether to disable autonegotiation
        :param pulumi.Input[str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input[str] dynamic_usage: Enable dynamic usage for this port. Set to `dynamic` to enable.
        :param pulumi.Input[int] mtu: media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param pulumi.Input[bool] no_local_overwrite: prevent helpdesk to override the port config
        :param pulumi.Input[str] speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_slow is not None:
            pulumi.set(__self__, "ae_lacp_slow", ae_lacp_slow)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_usage is not None:
            pulumi.set(__self__, "dynamic_usage", dynamic_usage)
        if esilag is not None:
            pulumi.set(__self__, "esilag", esilag)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if no_local_overwrite is not None:
            pulumi.set(__self__, "no_local_overwrite", no_local_overwrite)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[str]:
        """
        port usage name. 

        If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[pulumi.Input[bool]]:
        """
        To disable LACP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @ae_disable_lacp.setter
    def ae_disable_lacp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ae_disable_lacp", value)

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[pulumi.Input[int]]:
        """
        Users could force to use the designated AE name
        """
        return pulumi.get(self, "ae_idx")

    @ae_idx.setter
    def ae_idx(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ae_idx", value)

    @property
    @pulumi.getter(name="aeLacpSlow")
    def ae_lacp_slow(self) -> Optional[pulumi.Input[bool]]:
        """
        to use fast timeout
        """
        return pulumi.get(self, "ae_lacp_slow")

    @ae_lacp_slow.setter
    def ae_lacp_slow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ae_lacp_slow", value)

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "aggregated")

    @aggregated.setter
    def aggregated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aggregated", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[bool]]:
        """
        if want to generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[bool]]:
        """
        if `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="dynamicUsage")
    def dynamic_usage(self) -> Optional[pulumi.Input[str]]:
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        return pulumi.get(self, "dynamic_usage")

    @dynamic_usage.setter
    def dynamic_usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamic_usage", value)

    @property
    @pulumi.getter
    def esilag(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "esilag")

    @esilag.setter
    def esilag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "esilag", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="noLocalOverwrite")
    def no_local_overwrite(self) -> Optional[pulumi.Input[bool]]:
        """
        prevent helpdesk to override the port config
        """
        return pulumi.get(self, "no_local_overwrite")

    @no_local_overwrite.setter
    def no_local_overwrite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_local_overwrite", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed", value)


@pulumi.input_type
class NetworktemplateSwitchMatchingRulePortMirroringArgs:
    def __init__(__self__, *,
                 input_networks_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_port_ids_egresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_port_ids_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_network: Optional[pulumi.Input[str]] = None,
                 output_port_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_networks_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_port_ids_egresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_port_ids_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[str] output_network: exaclty one of the `output_port_id` or `output_network` should be provided
        :param pulumi.Input[str] output_port_id: exaclty one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @input_networks_ingresses.setter
    def input_networks_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_networks_ingresses", value)

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @input_port_ids_egresses.setter
    def input_port_ids_egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_port_ids_egresses", value)

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @input_port_ids_ingresses.setter
    def input_port_ids_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_port_ids_ingresses", value)

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[pulumi.Input[str]]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @output_network.setter
    def output_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_network", value)

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[pulumi.Input[str]]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")

    @output_port_id.setter
    def output_port_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_port_id", value)


@pulumi.input_type
class NetworktemplateSwitchMgmtArgs:
    def __init__(__self__, *,
                 config_revert: Optional[pulumi.Input[int]] = None,
                 protect_re: Optional[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs']] = None,
                 root_password: Optional[pulumi.Input[str]] = None,
                 tacacs: Optional[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgs']] = None):
        """
        :param pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs'] protect_re: restrict inbound-traffic to host
               when enabled, all traffic that is not essential to our operation will be dropped 
               e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        if config_revert is not None:
            pulumi.set(__self__, "config_revert", config_revert)
        if protect_re is not None:
            pulumi.set(__self__, "protect_re", protect_re)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if tacacs is not None:
            pulumi.set(__self__, "tacacs", tacacs)

    @property
    @pulumi.getter(name="configRevert")
    def config_revert(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "config_revert")

    @config_revert.setter
    def config_revert(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "config_revert", value)

    @property
    @pulumi.getter(name="protectRe")
    def protect_re(self) -> Optional[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs']]:
        """
        restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "protect_re")

    @protect_re.setter
    def protect_re(self, value: Optional[pulumi.Input['NetworktemplateSwitchMgmtProtectReArgs']]):
        pulumi.set(self, "protect_re", value)

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "root_password")

    @root_password.setter
    def root_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_password", value)

    @property
    @pulumi.getter
    def tacacs(self) -> Optional[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgs']]:
        return pulumi.get(self, "tacacs")

    @tacacs.setter
    def tacacs(self, value: Optional[pulumi.Input['NetworktemplateSwitchMgmtTacacsArgs']]):
        pulumi.set(self, "tacacs", value)


@pulumi.input_type
class NetworktemplateSwitchMgmtProtectReArgs:
    def __init__(__self__, *,
                 allowed_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 trusted_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_services: optionally, services we'll allow
        :param pulumi.Input[bool] enabled: when enabled, all traffic that is not essential to our operation will be dropped
               e.g. ntp / dns / traffic to mist will be allowed by default
                    if dhcpd is enabled, we'll make sure it works
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trusted_hosts: host/subnets we'll allow traffic to/from
        """
        if allowed_services is not None:
            pulumi.set(__self__, "allowed_services", allowed_services)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if trusted_hosts is not None:
            pulumi.set(__self__, "trusted_hosts", trusted_hosts)

    @property
    @pulumi.getter(name="allowedServices")
    def allowed_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        optionally, services we'll allow
        """
        return pulumi.get(self, "allowed_services")

    @allowed_services.setter
    def allowed_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_services", value)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgs']]]]:
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtProtectReCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        when enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="trustedHosts")
    def trusted_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        host/subnets we'll allow traffic to/from
        """
        return pulumi.get(self, "trusted_hosts")

    @trusted_hosts.setter
    def trusted_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "trusted_hosts", value)


@pulumi.input_type
class NetworktemplateSwitchMgmtProtectReCustomArgs:
    def __init__(__self__, *,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] port_range: matched dst port, "0" means any
        :param pulumi.Input[str] protocol: enum: `any`, `icmp`, `tcp`, `udp`
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `icmp`, `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


@pulumi.input_type
class NetworktemplateSwitchMgmtTacacsArgs:
    def __init__(__self__, *,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgs']]]] = None,
                 default_role: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 tacplus_servers: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgs']]]] = None):
        """
        :param pulumi.Input[str] default_role: enum: `admin`, `helpdesk`, `none`, `read`
        :param pulumi.Input[str] network: which network the TACACS server resides
        """
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if default_role is not None:
            pulumi.set(__self__, "default_role", default_role)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if tacplus_servers is not None:
            pulumi.set(__self__, "tacplus_servers", tacplus_servers)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgs']]]]:
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter(name="defaultRole")
    def default_role(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "default_role")

    @default_role.setter
    def default_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_role", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        which network the TACACS server resides
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="tacplusServers")
    def tacplus_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgs']]]]:
        return pulumi.get(self, "tacplus_servers")

    @tacplus_servers.setter
    def tacplus_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworktemplateSwitchMgmtTacacsTacplusServerArgs']]]]):
        pulumi.set(self, "tacplus_servers", value)


@pulumi.input_type
class NetworktemplateSwitchMgmtTacacsAcctServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class NetworktemplateSwitchMgmtTacacsTacplusServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class NetworktemplateUplinkPortConfigArgs:
    def __init__(__self__, *,
                 dot1x: Optional[pulumi.Input[bool]] = None,
                 keep_wlans_up_if_down: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] dot1x: Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param pulumi.Input[bool] keep_wlans_up_if_down: by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @property
    @pulumi.getter
    def dot1x(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @dot1x.setter
    def dot1x(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dot1x", value)

    @property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")

    @keep_wlans_up_if_down.setter
    def keep_wlans_up_if_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_wlans_up_if_down", value)


@pulumi.input_type
class NetworktemplateVrfConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class NetworktemplateVrfInstancesArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vrf_extra_routes: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesVrfExtraRoutesArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesVrfExtraRoutesArgs']]] vrf_extra_routes: Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if vrf_extra_routes is not None:
            pulumi.set(__self__, "vrf_extra_routes", vrf_extra_routes)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="vrfExtraRoutes")
    def vrf_extra_routes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesVrfExtraRoutesArgs']]]]:
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        return pulumi.get(self, "vrf_extra_routes")

    @vrf_extra_routes.setter
    def vrf_extra_routes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['NetworktemplateVrfInstancesVrfExtraRoutesArgs']]]]):
        pulumi.set(self, "vrf_extra_routes", value)


@pulumi.input_type
class NetworktemplateVrfInstancesVrfExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[str]):
        """
        :param pulumi.Input[str] via: Next-hop address
        """
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)


@pulumi.input_type
class SettingAnalyticArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: enable Advanced Analytic feature (using SUB-ANA license)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        enable Advanced Analytic feature (using SUB-ANA license)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingAutoUpgradeArgs:
    def __init__(__self__, *,
                 custom_versions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 time_of_day: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_versions: custom versions for different models. Property key is the model name (e.g. "AP41")
        :param pulumi.Input[str] day_of_week: enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        :param pulumi.Input[bool] enabled: whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
        :param pulumi.Input[str] time_of_day: any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
        :param pulumi.Input[str] version: desired version. enum: `beta`, `custom`, `stable`
        """
        if custom_versions is not None:
            pulumi.set(__self__, "custom_versions", custom_versions)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_of_day is not None:
            pulumi.set(__self__, "time_of_day", time_of_day)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="customVersions")
    def custom_versions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        custom versions for different models. Property key is the model name (e.g. "AP41")
        """
        return pulumi.get(self, "custom_versions")

    @custom_versions.setter
    def custom_versions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_versions", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> Optional[pulumi.Input[str]]:
        """
        any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
        """
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_of_day", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        desired version. enum: `beta`, `custom`, `stable`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SettingBleConfigArgs:
    def __init__(__self__, *,
                 beacon_enabled: Optional[pulumi.Input[bool]] = None,
                 beacon_rate: Optional[pulumi.Input[int]] = None,
                 beacon_rate_mode: Optional[pulumi.Input[str]] = None,
                 beam_disableds: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 custom_ble_packet_enabled: Optional[pulumi.Input[bool]] = None,
                 custom_ble_packet_frame: Optional[pulumi.Input[str]] = None,
                 custom_ble_packet_freq_msec: Optional[pulumi.Input[int]] = None,
                 eddystone_uid_adv_power: Optional[pulumi.Input[int]] = None,
                 eddystone_uid_beams: Optional[pulumi.Input[str]] = None,
                 eddystone_uid_enabled: Optional[pulumi.Input[bool]] = None,
                 eddystone_uid_freq_msec: Optional[pulumi.Input[int]] = None,
                 eddystone_uid_instance: Optional[pulumi.Input[str]] = None,
                 eddystone_uid_namespace: Optional[pulumi.Input[str]] = None,
                 eddystone_url_adv_power: Optional[pulumi.Input[int]] = None,
                 eddystone_url_beams: Optional[pulumi.Input[str]] = None,
                 eddystone_url_enabled: Optional[pulumi.Input[bool]] = None,
                 eddystone_url_freq_msec: Optional[pulumi.Input[int]] = None,
                 eddystone_url_url: Optional[pulumi.Input[str]] = None,
                 ibeacon_adv_power: Optional[pulumi.Input[int]] = None,
                 ibeacon_beams: Optional[pulumi.Input[str]] = None,
                 ibeacon_enabled: Optional[pulumi.Input[bool]] = None,
                 ibeacon_freq_msec: Optional[pulumi.Input[int]] = None,
                 ibeacon_major: Optional[pulumi.Input[int]] = None,
                 ibeacon_minor: Optional[pulumi.Input[int]] = None,
                 ibeacon_uuid: Optional[pulumi.Input[str]] = None,
                 power: Optional[pulumi.Input[int]] = None,
                 power_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] beacon_enabled: whether Mist beacons is enabled
        :param pulumi.Input[int] beacon_rate: required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        :param pulumi.Input[str] beacon_rate_mode: enum: `custom`, `default`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] beam_disableds: list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        :param pulumi.Input[bool] custom_ble_packet_enabled: can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        :param pulumi.Input[str] custom_ble_packet_frame: The custom frame to be sent out in this beacon. The frame must be a hexstring
        :param pulumi.Input[int] custom_ble_packet_freq_msec: Frequency (msec) of data emitted by custom ble beacon
        :param pulumi.Input[int] eddystone_uid_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[bool] eddystone_uid_enabled: only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        :param pulumi.Input[int] eddystone_uid_freq_msec: Frequency (msec) of data emmit by Eddystone-UID beacon
        :param pulumi.Input[str] eddystone_uid_instance: Eddystone-UID instance for the device
        :param pulumi.Input[str] eddystone_uid_namespace: Eddystone-UID namespace
        :param pulumi.Input[int] eddystone_url_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[bool] eddystone_url_enabled: only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        :param pulumi.Input[int] eddystone_url_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param pulumi.Input[str] eddystone_url_url: URL pointed by Eddystone-URL beacon
        :param pulumi.Input[int] ibeacon_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[bool] ibeacon_enabled: can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        :param pulumi.Input[int] ibeacon_freq_msec: Frequency (msec) of data emmit for iBeacon
        :param pulumi.Input[int] ibeacon_major: Major number for iBeacon
        :param pulumi.Input[int] ibeacon_minor: Minor number for iBeacon
        :param pulumi.Input[str] ibeacon_uuid: optional, if not specified, the same UUID as the beacon will be used
        :param pulumi.Input[int] power: required if `power_mode`==`custom`
        :param pulumi.Input[str] power_mode: enum: `custom`, `default`
        """
        if beacon_enabled is not None:
            pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        if beacon_rate is not None:
            pulumi.set(__self__, "beacon_rate", beacon_rate)
        if beacon_rate_mode is not None:
            pulumi.set(__self__, "beacon_rate_mode", beacon_rate_mode)
        if beam_disableds is not None:
            pulumi.set(__self__, "beam_disableds", beam_disableds)
        if custom_ble_packet_enabled is not None:
            pulumi.set(__self__, "custom_ble_packet_enabled", custom_ble_packet_enabled)
        if custom_ble_packet_frame is not None:
            pulumi.set(__self__, "custom_ble_packet_frame", custom_ble_packet_frame)
        if custom_ble_packet_freq_msec is not None:
            pulumi.set(__self__, "custom_ble_packet_freq_msec", custom_ble_packet_freq_msec)
        if eddystone_uid_adv_power is not None:
            pulumi.set(__self__, "eddystone_uid_adv_power", eddystone_uid_adv_power)
        if eddystone_uid_beams is not None:
            pulumi.set(__self__, "eddystone_uid_beams", eddystone_uid_beams)
        if eddystone_uid_enabled is not None:
            pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        if eddystone_uid_freq_msec is not None:
            pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        if eddystone_uid_instance is not None:
            pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        if eddystone_uid_namespace is not None:
            pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        if eddystone_url_adv_power is not None:
            pulumi.set(__self__, "eddystone_url_adv_power", eddystone_url_adv_power)
        if eddystone_url_beams is not None:
            pulumi.set(__self__, "eddystone_url_beams", eddystone_url_beams)
        if eddystone_url_enabled is not None:
            pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        if eddystone_url_freq_msec is not None:
            pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        if eddystone_url_url is not None:
            pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        if ibeacon_adv_power is not None:
            pulumi.set(__self__, "ibeacon_adv_power", ibeacon_adv_power)
        if ibeacon_beams is not None:
            pulumi.set(__self__, "ibeacon_beams", ibeacon_beams)
        if ibeacon_enabled is not None:
            pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        if ibeacon_freq_msec is not None:
            pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        if ibeacon_major is not None:
            pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        if ibeacon_minor is not None:
            pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        if ibeacon_uuid is not None:
            pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)

    @property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether Mist beacons is enabled
        """
        return pulumi.get(self, "beacon_enabled")

    @beacon_enabled.setter
    def beacon_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "beacon_enabled", value)

    @property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> Optional[pulumi.Input[int]]:
        """
        required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        return pulumi.get(self, "beacon_rate")

    @beacon_rate.setter
    def beacon_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "beacon_rate", value)

    @property
    @pulumi.getter(name="beaconRateMode")
    def beacon_rate_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "beacon_rate_mode")

    @beacon_rate_mode.setter
    def beacon_rate_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "beacon_rate_mode", value)

    @property
    @pulumi.getter(name="beamDisableds")
    def beam_disableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        return pulumi.get(self, "beam_disableds")

    @beam_disableds.setter
    def beam_disableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "beam_disableds", value)

    @property
    @pulumi.getter(name="customBlePacketEnabled")
    def custom_ble_packet_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        return pulumi.get(self, "custom_ble_packet_enabled")

    @custom_ble_packet_enabled.setter
    def custom_ble_packet_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_ble_packet_enabled", value)

    @property
    @pulumi.getter(name="customBlePacketFrame")
    def custom_ble_packet_frame(self) -> Optional[pulumi.Input[str]]:
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        return pulumi.get(self, "custom_ble_packet_frame")

    @custom_ble_packet_frame.setter
    def custom_ble_packet_frame(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_ble_packet_frame", value)

    @property
    @pulumi.getter(name="customBlePacketFreqMsec")
    def custom_ble_packet_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        return pulumi.get(self, "custom_ble_packet_freq_msec")

    @custom_ble_packet_freq_msec.setter
    def custom_ble_packet_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_ble_packet_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUidAdvPower")
    def eddystone_uid_adv_power(self) -> Optional[pulumi.Input[int]]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_uid_adv_power")

    @eddystone_uid_adv_power.setter
    def eddystone_uid_adv_power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_uid_adv_power", value)

    @property
    @pulumi.getter(name="eddystoneUidBeams")
    def eddystone_uid_beams(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "eddystone_uid_beams")

    @eddystone_uid_beams.setter
    def eddystone_uid_beams(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_uid_beams", value)

    @property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        return pulumi.get(self, "eddystone_uid_enabled")

    @eddystone_uid_enabled.setter
    def eddystone_uid_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eddystone_uid_enabled", value)

    @property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @eddystone_uid_freq_msec.setter
    def eddystone_uid_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_uid_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> Optional[pulumi.Input[str]]:
        """
        Eddystone-UID instance for the device
        """
        return pulumi.get(self, "eddystone_uid_instance")

    @eddystone_uid_instance.setter
    def eddystone_uid_instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_uid_instance", value)

    @property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Eddystone-UID namespace
        """
        return pulumi.get(self, "eddystone_uid_namespace")

    @eddystone_uid_namespace.setter
    def eddystone_uid_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_uid_namespace", value)

    @property
    @pulumi.getter(name="eddystoneUrlAdvPower")
    def eddystone_url_adv_power(self) -> Optional[pulumi.Input[int]]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_url_adv_power")

    @eddystone_url_adv_power.setter
    def eddystone_url_adv_power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_url_adv_power", value)

    @property
    @pulumi.getter(name="eddystoneUrlBeams")
    def eddystone_url_beams(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "eddystone_url_beams")

    @eddystone_url_beams.setter
    def eddystone_url_beams(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_url_beams", value)

    @property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        return pulumi.get(self, "eddystone_url_enabled")

    @eddystone_url_enabled.setter
    def eddystone_url_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eddystone_url_enabled", value)

    @property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @eddystone_url_freq_msec.setter
    def eddystone_url_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_url_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL pointed by Eddystone-URL beacon
        """
        return pulumi.get(self, "eddystone_url_url")

    @eddystone_url_url.setter
    def eddystone_url_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_url_url", value)

    @property
    @pulumi.getter(name="ibeaconAdvPower")
    def ibeacon_adv_power(self) -> Optional[pulumi.Input[int]]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "ibeacon_adv_power")

    @ibeacon_adv_power.setter
    def ibeacon_adv_power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_adv_power", value)

    @property
    @pulumi.getter(name="ibeaconBeams")
    def ibeacon_beams(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ibeacon_beams")

    @ibeacon_beams.setter
    def ibeacon_beams(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ibeacon_beams", value)

    @property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        return pulumi.get(self, "ibeacon_enabled")

    @ibeacon_enabled.setter
    def ibeacon_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ibeacon_enabled", value)

    @property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emmit for iBeacon
        """
        return pulumi.get(self, "ibeacon_freq_msec")

    @ibeacon_freq_msec.setter
    def ibeacon_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_freq_msec", value)

    @property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> Optional[pulumi.Input[int]]:
        """
        Major number for iBeacon
        """
        return pulumi.get(self, "ibeacon_major")

    @ibeacon_major.setter
    def ibeacon_major(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_major", value)

    @property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> Optional[pulumi.Input[int]]:
        """
        Minor number for iBeacon
        """
        return pulumi.get(self, "ibeacon_minor")

    @ibeacon_minor.setter
    def ibeacon_minor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_minor", value)

    @property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        optional, if not specified, the same UUID as the beacon will be used
        """
        return pulumi.get(self, "ibeacon_uuid")

    @ibeacon_uuid.setter
    def ibeacon_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ibeacon_uuid", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[int]]:
        """
        required if `power_mode`==`custom`
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "power_mode")

    @power_mode.setter
    def power_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "power_mode", value)


@pulumi.input_type
class SettingConfigPushPolicyArgs:
    def __init__(__self__, *,
                 no_push: Optional[pulumi.Input[bool]] = None,
                 push_window: Optional[pulumi.Input['SettingConfigPushPolicyPushWindowArgs']] = None):
        """
        :param pulumi.Input[bool] no_push: stop any new config from being pushed to the device
        :param pulumi.Input['SettingConfigPushPolicyPushWindowArgs'] push_window: if enabled, new config will only be pushed to device within the specified time window
        """
        if no_push is not None:
            pulumi.set(__self__, "no_push", no_push)
        if push_window is not None:
            pulumi.set(__self__, "push_window", push_window)

    @property
    @pulumi.getter(name="noPush")
    def no_push(self) -> Optional[pulumi.Input[bool]]:
        """
        stop any new config from being pushed to the device
        """
        return pulumi.get(self, "no_push")

    @no_push.setter
    def no_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_push", value)

    @property
    @pulumi.getter(name="pushWindow")
    def push_window(self) -> Optional[pulumi.Input['SettingConfigPushPolicyPushWindowArgs']]:
        """
        if enabled, new config will only be pushed to device within the specified time window
        """
        return pulumi.get(self, "push_window")

    @push_window.setter
    def push_window(self, value: Optional[pulumi.Input['SettingConfigPushPolicyPushWindowArgs']]):
        pulumi.set(self, "push_window", value)


@pulumi.input_type
class SettingConfigPushPolicyPushWindowArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input['SettingConfigPushPolicyPushWindowHoursArgs']] = None):
        """
        :param pulumi.Input['SettingConfigPushPolicyPushWindowHoursArgs'] hours: hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input['SettingConfigPushPolicyPushWindowHoursArgs']]:
        """
        hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun).
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input['SettingConfigPushPolicyPushWindowHoursArgs']]):
        pulumi.set(self, "hours", value)


@pulumi.input_type
class SettingConfigPushPolicyPushWindowHoursArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[str]] = None,
                 mon: Optional[pulumi.Input[str]] = None,
                 sat: Optional[pulumi.Input[str]] = None,
                 sun: Optional[pulumi.Input[str]] = None,
                 thu: Optional[pulumi.Input[str]] = None,
                 tue: Optional[pulumi.Input[str]] = None,
                 wed: Optional[pulumi.Input[str]] = None):
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fri", value)

    @property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mon", value)

    @property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sat", value)

    @property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sun", value)

    @property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thu", value)

    @property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tue", value)

    @property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wed", value)


@pulumi.input_type
class SettingCriticalUrlMonitoringArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 monitors: Optional[pulumi.Input[Sequence[pulumi.Input['SettingCriticalUrlMonitoringMonitorArgs']]]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if monitors is not None:
            pulumi.set(__self__, "monitors", monitors)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def monitors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingCriticalUrlMonitoringMonitorArgs']]]]:
        return pulumi.get(self, "monitors")

    @monitors.setter
    def monitors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingCriticalUrlMonitoringMonitorArgs']]]]):
        pulumi.set(self, "monitors", value)


@pulumi.input_type
class SettingCriticalUrlMonitoringMonitorArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        if url is not None:
            pulumi.set(__self__, "url", url)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class SettingEngagementArgs:
    def __init__(__self__, *,
                 dwell_tag_names: Optional[pulumi.Input['SettingEngagementDwellTagNamesArgs']] = None,
                 dwell_tags: Optional[pulumi.Input['SettingEngagementDwellTagsArgs']] = None,
                 hours: Optional[pulumi.Input['SettingEngagementHoursArgs']] = None,
                 max_dwell: Optional[pulumi.Input[int]] = None,
                 min_dwell: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['SettingEngagementDwellTagsArgs'] dwell_tags: add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
        :param pulumi.Input['SettingEngagementHoursArgs'] hours: hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun).
        :param pulumi.Input[int] max_dwell: max time, default is 43200(12h), max is 68400 (18h)
        :param pulumi.Input[int] min_dwell: min time
        """
        if dwell_tag_names is not None:
            pulumi.set(__self__, "dwell_tag_names", dwell_tag_names)
        if dwell_tags is not None:
            pulumi.set(__self__, "dwell_tags", dwell_tags)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if max_dwell is not None:
            pulumi.set(__self__, "max_dwell", max_dwell)
        if min_dwell is not None:
            pulumi.set(__self__, "min_dwell", min_dwell)

    @property
    @pulumi.getter(name="dwellTagNames")
    def dwell_tag_names(self) -> Optional[pulumi.Input['SettingEngagementDwellTagNamesArgs']]:
        return pulumi.get(self, "dwell_tag_names")

    @dwell_tag_names.setter
    def dwell_tag_names(self, value: Optional[pulumi.Input['SettingEngagementDwellTagNamesArgs']]):
        pulumi.set(self, "dwell_tag_names", value)

    @property
    @pulumi.getter(name="dwellTags")
    def dwell_tags(self) -> Optional[pulumi.Input['SettingEngagementDwellTagsArgs']]:
        """
        add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
        """
        return pulumi.get(self, "dwell_tags")

    @dwell_tags.setter
    def dwell_tags(self, value: Optional[pulumi.Input['SettingEngagementDwellTagsArgs']]):
        pulumi.set(self, "dwell_tags", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input['SettingEngagementHoursArgs']]:
        """
        hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun).
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input['SettingEngagementHoursArgs']]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter(name="maxDwell")
    def max_dwell(self) -> Optional[pulumi.Input[int]]:
        """
        max time, default is 43200(12h), max is 68400 (18h)
        """
        return pulumi.get(self, "max_dwell")

    @max_dwell.setter
    def max_dwell(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_dwell", value)

    @property
    @pulumi.getter(name="minDwell")
    def min_dwell(self) -> Optional[pulumi.Input[int]]:
        """
        min time
        """
        return pulumi.get(self, "min_dwell")

    @min_dwell.setter
    def min_dwell(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_dwell", value)


@pulumi.input_type
class SettingEngagementDwellTagNamesArgs:
    def __init__(__self__, *,
                 bounce: Optional[pulumi.Input[str]] = None,
                 engaged: Optional[pulumi.Input[str]] = None,
                 passerby: Optional[pulumi.Input[str]] = None,
                 stationed: Optional[pulumi.Input[str]] = None):
        if bounce is not None:
            pulumi.set(__self__, "bounce", bounce)
        if engaged is not None:
            pulumi.set(__self__, "engaged", engaged)
        if passerby is not None:
            pulumi.set(__self__, "passerby", passerby)
        if stationed is not None:
            pulumi.set(__self__, "stationed", stationed)

    @property
    @pulumi.getter
    def bounce(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bounce")

    @bounce.setter
    def bounce(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bounce", value)

    @property
    @pulumi.getter
    def engaged(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "engaged")

    @engaged.setter
    def engaged(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engaged", value)

    @property
    @pulumi.getter
    def passerby(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "passerby")

    @passerby.setter
    def passerby(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passerby", value)

    @property
    @pulumi.getter
    def stationed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "stationed")

    @stationed.setter
    def stationed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stationed", value)


@pulumi.input_type
class SettingEngagementDwellTagsArgs:
    def __init__(__self__, *,
                 bounce: Optional[pulumi.Input[str]] = None,
                 engaged: Optional[pulumi.Input[str]] = None,
                 passerby: Optional[pulumi.Input[str]] = None,
                 stationed: Optional[pulumi.Input[str]] = None):
        if bounce is not None:
            pulumi.set(__self__, "bounce", bounce)
        if engaged is not None:
            pulumi.set(__self__, "engaged", engaged)
        if passerby is not None:
            pulumi.set(__self__, "passerby", passerby)
        if stationed is not None:
            pulumi.set(__self__, "stationed", stationed)

    @property
    @pulumi.getter
    def bounce(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bounce")

    @bounce.setter
    def bounce(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bounce", value)

    @property
    @pulumi.getter
    def engaged(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "engaged")

    @engaged.setter
    def engaged(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engaged", value)

    @property
    @pulumi.getter
    def passerby(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "passerby")

    @passerby.setter
    def passerby(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passerby", value)

    @property
    @pulumi.getter
    def stationed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "stationed")

    @stationed.setter
    def stationed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stationed", value)


@pulumi.input_type
class SettingEngagementHoursArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[str]] = None,
                 mon: Optional[pulumi.Input[str]] = None,
                 sat: Optional[pulumi.Input[str]] = None,
                 sun: Optional[pulumi.Input[str]] = None,
                 thu: Optional[pulumi.Input[str]] = None,
                 tue: Optional[pulumi.Input[str]] = None,
                 wed: Optional[pulumi.Input[str]] = None):
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fri", value)

    @property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mon", value)

    @property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sat", value)

    @property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sun", value)

    @property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thu", value)

    @property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tue", value)

    @property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wed", value)


@pulumi.input_type
class SettingGatewayMgmtArgs:
    def __init__(__self__, *,
                 admin_sshkeys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 app_probing: Optional[pulumi.Input['SettingGatewayMgmtAppProbingArgs']] = None,
                 app_usage: Optional[pulumi.Input[bool]] = None,
                 auto_signature_update: Optional[pulumi.Input['SettingGatewayMgmtAutoSignatureUpdateArgs']] = None,
                 config_revert_timer: Optional[pulumi.Input[int]] = None,
                 probe_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 root_password: Optional[pulumi.Input[str]] = None,
                 security_log_source_address: Optional[pulumi.Input[str]] = None,
                 security_log_source_interface: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] admin_sshkeys: for SSR only, as direct root access is not allowed
        :param pulumi.Input[bool] app_usage: consumes uplink bandwidth, requires WA license
        :param pulumi.Input[int] config_revert_timer: he rollback timer for commit confirmed
        :param pulumi.Input[str] root_password: for SRX only
        """
        if admin_sshkeys is not None:
            pulumi.set(__self__, "admin_sshkeys", admin_sshkeys)
        if app_probing is not None:
            pulumi.set(__self__, "app_probing", app_probing)
        if app_usage is not None:
            pulumi.set(__self__, "app_usage", app_usage)
        if auto_signature_update is not None:
            pulumi.set(__self__, "auto_signature_update", auto_signature_update)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if probe_hosts is not None:
            pulumi.set(__self__, "probe_hosts", probe_hosts)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if security_log_source_address is not None:
            pulumi.set(__self__, "security_log_source_address", security_log_source_address)
        if security_log_source_interface is not None:
            pulumi.set(__self__, "security_log_source_interface", security_log_source_interface)

    @property
    @pulumi.getter(name="adminSshkeys")
    def admin_sshkeys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        for SSR only, as direct root access is not allowed
        """
        return pulumi.get(self, "admin_sshkeys")

    @admin_sshkeys.setter
    def admin_sshkeys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "admin_sshkeys", value)

    @property
    @pulumi.getter(name="appProbing")
    def app_probing(self) -> Optional[pulumi.Input['SettingGatewayMgmtAppProbingArgs']]:
        return pulumi.get(self, "app_probing")

    @app_probing.setter
    def app_probing(self, value: Optional[pulumi.Input['SettingGatewayMgmtAppProbingArgs']]):
        pulumi.set(self, "app_probing", value)

    @property
    @pulumi.getter(name="appUsage")
    def app_usage(self) -> Optional[pulumi.Input[bool]]:
        """
        consumes uplink bandwidth, requires WA license
        """
        return pulumi.get(self, "app_usage")

    @app_usage.setter
    def app_usage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "app_usage", value)

    @property
    @pulumi.getter(name="autoSignatureUpdate")
    def auto_signature_update(self) -> Optional[pulumi.Input['SettingGatewayMgmtAutoSignatureUpdateArgs']]:
        return pulumi.get(self, "auto_signature_update")

    @auto_signature_update.setter
    def auto_signature_update(self, value: Optional[pulumi.Input['SettingGatewayMgmtAutoSignatureUpdateArgs']]):
        pulumi.set(self, "auto_signature_update", value)

    @property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[pulumi.Input[int]]:
        """
        he rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @config_revert_timer.setter
    def config_revert_timer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "config_revert_timer", value)

    @property
    @pulumi.getter(name="probeHosts")
    def probe_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "probe_hosts")

    @probe_hosts.setter
    def probe_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "probe_hosts", value)

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[pulumi.Input[str]]:
        """
        for SRX only
        """
        return pulumi.get(self, "root_password")

    @root_password.setter
    def root_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_password", value)

    @property
    @pulumi.getter(name="securityLogSourceAddress")
    def security_log_source_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_log_source_address")

    @security_log_source_address.setter
    def security_log_source_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_log_source_address", value)

    @property
    @pulumi.getter(name="securityLogSourceInterface")
    def security_log_source_interface(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_log_source_interface")

    @security_log_source_interface.setter
    def security_log_source_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_log_source_interface", value)


@pulumi.input_type
class SettingGatewayMgmtAppProbingArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_apps: Optional[pulumi.Input[Sequence[pulumi.Input['SettingGatewayMgmtAppProbingCustomAppArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: app-keys from /api/v1/const/applications
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if custom_apps is not None:
            pulumi.set(__self__, "custom_apps", custom_apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        app-keys from /api/v1/const/applications
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter(name="customApps")
    def custom_apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingGatewayMgmtAppProbingCustomAppArgs']]]]:
        return pulumi.get(self, "custom_apps")

    @custom_apps.setter
    def custom_apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingGatewayMgmtAppProbingCustomAppArgs']]]]):
        pulumi.set(self, "custom_apps", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingGatewayMgmtAppProbingCustomAppArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 app_type: Optional[pulumi.Input[str]] = None,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 vrf: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: if `protocol`==`icmp`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: if `protocol`==`http`
        :param pulumi.Input[str] protocol: enum: `http`, `udp`
        :param pulumi.Input[str] url: if `protocol`==`http`
        """
        pulumi.set(__self__, "address", address)
        if app_type is not None:
            pulumi.set(__self__, "app_type", app_type)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if vrf is not None:
            pulumi.set(__self__, "vrf", vrf)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        if `protocol`==`icmp`
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="appType")
    def app_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "app_type")

    @app_type.setter
    def app_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_type", value)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `protocol`==`http`
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `http`, `udp`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        if `protocol`==`http`
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def vrf(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vrf")

    @vrf.setter
    def vrf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vrf", value)


@pulumi.input_type
class SettingGatewayMgmtAutoSignatureUpdateArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 enable: Optional[pulumi.Input[bool]] = None,
                 time_of_day: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] day_of_week: enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        :param pulumi.Input[str] time_of_day: optional, Mist will decide the timing
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if time_of_day is not None:
            pulumi.set(__self__, "time_of_day", time_of_day)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> Optional[pulumi.Input[str]]:
        """
        optional, Mist will decide the timing
        """
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_of_day", value)


@pulumi.input_type
class SettingLedArgs:
    def __init__(__self__, *,
                 brightness: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def brightness(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "brightness")

    @brightness.setter
    def brightness(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "brightness", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingOccupancyArgs:
    def __init__(__self__, *,
                 assets_enabled: Optional[pulumi.Input[bool]] = None,
                 clients_enabled: Optional[pulumi.Input[bool]] = None,
                 min_duration: Optional[pulumi.Input[int]] = None,
                 sdkclients_enabled: Optional[pulumi.Input[bool]] = None,
                 unconnected_clients_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] assets_enabled: indicate whether named BLE assets should be included in the zone occupancy calculation
        :param pulumi.Input[bool] clients_enabled: indicate whether connected WiFi clients should be included in the zone occupancy calculation
        :param pulumi.Input[int] min_duration: minimum duration
        :param pulumi.Input[bool] sdkclients_enabled: indicate whether SDK clients should be included in the zone occupancy calculation
        :param pulumi.Input[bool] unconnected_clients_enabled: indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
        """
        if assets_enabled is not None:
            pulumi.set(__self__, "assets_enabled", assets_enabled)
        if clients_enabled is not None:
            pulumi.set(__self__, "clients_enabled", clients_enabled)
        if min_duration is not None:
            pulumi.set(__self__, "min_duration", min_duration)
        if sdkclients_enabled is not None:
            pulumi.set(__self__, "sdkclients_enabled", sdkclients_enabled)
        if unconnected_clients_enabled is not None:
            pulumi.set(__self__, "unconnected_clients_enabled", unconnected_clients_enabled)

    @property
    @pulumi.getter(name="assetsEnabled")
    def assets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        indicate whether named BLE assets should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "assets_enabled")

    @assets_enabled.setter
    def assets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assets_enabled", value)

    @property
    @pulumi.getter(name="clientsEnabled")
    def clients_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        indicate whether connected WiFi clients should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "clients_enabled")

    @clients_enabled.setter
    def clients_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clients_enabled", value)

    @property
    @pulumi.getter(name="minDuration")
    def min_duration(self) -> Optional[pulumi.Input[int]]:
        """
        minimum duration
        """
        return pulumi.get(self, "min_duration")

    @min_duration.setter
    def min_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_duration", value)

    @property
    @pulumi.getter(name="sdkclientsEnabled")
    def sdkclients_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        indicate whether SDK clients should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "sdkclients_enabled")

    @sdkclients_enabled.setter
    def sdkclients_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sdkclients_enabled", value)

    @property
    @pulumi.getter(name="unconnectedClientsEnabled")
    def unconnected_clients_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "unconnected_clients_enabled")

    @unconnected_clients_enabled.setter
    def unconnected_clients_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unconnected_clients_enabled", value)


@pulumi.input_type
class SettingProxyArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SettingRogueArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 honeypot_enabled: Optional[pulumi.Input[bool]] = None,
                 min_duration: Optional[pulumi.Input[int]] = None,
                 min_rssi: Optional[pulumi.Input[int]] = None,
                 whitelisted_bssids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 whitelisted_ssids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: whether or not rogue detection is enabled
        :param pulumi.Input[bool] honeypot_enabled: whether or not honeypot detection is enabled
        :param pulumi.Input[int] min_duration: minimum duration for a bssid to be considered rogue
        :param pulumi.Input[int] min_rssi: minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] whitelisted_bssids: list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] whitelisted_ssids: list of SSIDs to whitelist
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if honeypot_enabled is not None:
            pulumi.set(__self__, "honeypot_enabled", honeypot_enabled)
        if min_duration is not None:
            pulumi.set(__self__, "min_duration", min_duration)
        if min_rssi is not None:
            pulumi.set(__self__, "min_rssi", min_rssi)
        if whitelisted_bssids is not None:
            pulumi.set(__self__, "whitelisted_bssids", whitelisted_bssids)
        if whitelisted_ssids is not None:
            pulumi.set(__self__, "whitelisted_ssids", whitelisted_ssids)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether or not rogue detection is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="honeypotEnabled")
    def honeypot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether or not honeypot detection is enabled
        """
        return pulumi.get(self, "honeypot_enabled")

    @honeypot_enabled.setter
    def honeypot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "honeypot_enabled", value)

    @property
    @pulumi.getter(name="minDuration")
    def min_duration(self) -> Optional[pulumi.Input[int]]:
        """
        minimum duration for a bssid to be considered rogue
        """
        return pulumi.get(self, "min_duration")

    @min_duration.setter
    def min_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_duration", value)

    @property
    @pulumi.getter(name="minRssi")
    def min_rssi(self) -> Optional[pulumi.Input[int]]:
        """
        minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
        """
        return pulumi.get(self, "min_rssi")

    @min_rssi.setter
    def min_rssi(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_rssi", value)

    @property
    @pulumi.getter(name="whitelistedBssids")
    def whitelisted_bssids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
        """
        return pulumi.get(self, "whitelisted_bssids")

    @whitelisted_bssids.setter
    def whitelisted_bssids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "whitelisted_bssids", value)

    @property
    @pulumi.getter(name="whitelistedSsids")
    def whitelisted_ssids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of SSIDs to whitelist
        """
        return pulumi.get(self, "whitelisted_ssids")

    @whitelisted_ssids.setter
    def whitelisted_ssids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "whitelisted_ssids", value)


@pulumi.input_type
class SettingRtsaArgs:
    def __init__(__self__, *,
                 app_waking: Optional[pulumi.Input[bool]] = None,
                 disable_dead_reckoning: Optional[pulumi.Input[bool]] = None,
                 disable_pressure_sensor: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 track_asset: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] track_asset: asset tracking related
        """
        if app_waking is not None:
            pulumi.set(__self__, "app_waking", app_waking)
        if disable_dead_reckoning is not None:
            pulumi.set(__self__, "disable_dead_reckoning", disable_dead_reckoning)
        if disable_pressure_sensor is not None:
            pulumi.set(__self__, "disable_pressure_sensor", disable_pressure_sensor)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if track_asset is not None:
            pulumi.set(__self__, "track_asset", track_asset)

    @property
    @pulumi.getter(name="appWaking")
    def app_waking(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "app_waking")

    @app_waking.setter
    def app_waking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "app_waking", value)

    @property
    @pulumi.getter(name="disableDeadReckoning")
    def disable_dead_reckoning(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_dead_reckoning")

    @disable_dead_reckoning.setter
    def disable_dead_reckoning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_dead_reckoning", value)

    @property
    @pulumi.getter(name="disablePressureSensor")
    def disable_pressure_sensor(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_pressure_sensor")

    @disable_pressure_sensor.setter
    def disable_pressure_sensor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_pressure_sensor", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="trackAsset")
    def track_asset(self) -> Optional[pulumi.Input[bool]]:
        """
        asset tracking related
        """
        return pulumi.get(self, "track_asset")

    @track_asset.setter
    def track_asset(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "track_asset", value)


@pulumi.input_type
class SettingSimpleAlertArgs:
    def __init__(__self__, *,
                 arp_failure: Optional[pulumi.Input['SettingSimpleAlertArpFailureArgs']] = None,
                 dhcp_failure: Optional[pulumi.Input['SettingSimpleAlertDhcpFailureArgs']] = None,
                 dns_failure: Optional[pulumi.Input['SettingSimpleAlertDnsFailureArgs']] = None):
        if arp_failure is not None:
            pulumi.set(__self__, "arp_failure", arp_failure)
        if dhcp_failure is not None:
            pulumi.set(__self__, "dhcp_failure", dhcp_failure)
        if dns_failure is not None:
            pulumi.set(__self__, "dns_failure", dns_failure)

    @property
    @pulumi.getter(name="arpFailure")
    def arp_failure(self) -> Optional[pulumi.Input['SettingSimpleAlertArpFailureArgs']]:
        return pulumi.get(self, "arp_failure")

    @arp_failure.setter
    def arp_failure(self, value: Optional[pulumi.Input['SettingSimpleAlertArpFailureArgs']]):
        pulumi.set(self, "arp_failure", value)

    @property
    @pulumi.getter(name="dhcpFailure")
    def dhcp_failure(self) -> Optional[pulumi.Input['SettingSimpleAlertDhcpFailureArgs']]:
        return pulumi.get(self, "dhcp_failure")

    @dhcp_failure.setter
    def dhcp_failure(self, value: Optional[pulumi.Input['SettingSimpleAlertDhcpFailureArgs']]):
        pulumi.set(self, "dhcp_failure", value)

    @property
    @pulumi.getter(name="dnsFailure")
    def dns_failure(self) -> Optional[pulumi.Input['SettingSimpleAlertDnsFailureArgs']]:
        return pulumi.get(self, "dns_failure")

    @dns_failure.setter
    def dns_failure(self, value: Optional[pulumi.Input['SettingSimpleAlertDnsFailureArgs']]):
        pulumi.set(self, "dns_failure", value)


@pulumi.input_type
class SettingSimpleAlertArpFailureArgs:
    def __init__(__self__, *,
                 client_count: Optional[pulumi.Input[int]] = None,
                 duration: Optional[pulumi.Input[int]] = None,
                 incident_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration: failing within minutes
        """
        if client_count is not None:
            pulumi.set(__self__, "client_count", client_count)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if incident_count is not None:
            pulumi.set(__self__, "incident_count", incident_count)

    @property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "client_count")

    @client_count.setter
    def client_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_count", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        failing within minutes
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="incidentCount")
    def incident_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "incident_count")

    @incident_count.setter
    def incident_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "incident_count", value)


@pulumi.input_type
class SettingSimpleAlertDhcpFailureArgs:
    def __init__(__self__, *,
                 client_count: Optional[pulumi.Input[int]] = None,
                 duration: Optional[pulumi.Input[int]] = None,
                 incident_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration: failing within minutes
        """
        if client_count is not None:
            pulumi.set(__self__, "client_count", client_count)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if incident_count is not None:
            pulumi.set(__self__, "incident_count", incident_count)

    @property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "client_count")

    @client_count.setter
    def client_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_count", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        failing within minutes
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="incidentCount")
    def incident_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "incident_count")

    @incident_count.setter
    def incident_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "incident_count", value)


@pulumi.input_type
class SettingSimpleAlertDnsFailureArgs:
    def __init__(__self__, *,
                 client_count: Optional[pulumi.Input[int]] = None,
                 duration: Optional[pulumi.Input[int]] = None,
                 incident_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration: failing within minutes
        """
        if client_count is not None:
            pulumi.set(__self__, "client_count", client_count)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if incident_count is not None:
            pulumi.set(__self__, "incident_count", incident_count)

    @property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "client_count")

    @client_count.setter
    def client_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_count", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        failing within minutes
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="incidentCount")
    def incident_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "incident_count")

    @incident_count.setter
    def incident_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "incident_count", value)


@pulumi.input_type
class SettingSkyatpArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 send_ip_mac_mapping: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] send_ip_mac_mapping: whether to send IP-MAC mapping to SkyATP
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if send_ip_mac_mapping is not None:
            pulumi.set(__self__, "send_ip_mac_mapping", send_ip_mac_mapping)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="sendIpMacMapping")
    def send_ip_mac_mapping(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to send IP-MAC mapping to SkyATP
        """
        return pulumi.get(self, "send_ip_mac_mapping")

    @send_ip_mac_mapping.setter
    def send_ip_mac_mapping(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_ip_mac_mapping", value)


@pulumi.input_type
class SettingSrxAppArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingSsrArgs:
    def __init__(__self__, *,
                 conductor_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disable_stats: Optional[pulumi.Input[bool]] = None):
        if conductor_hosts is not None:
            pulumi.set(__self__, "conductor_hosts", conductor_hosts)
        if disable_stats is not None:
            pulumi.set(__self__, "disable_stats", disable_stats)

    @property
    @pulumi.getter(name="conductorHosts")
    def conductor_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "conductor_hosts")

    @conductor_hosts.setter
    def conductor_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conductor_hosts", value)

    @property
    @pulumi.getter(name="disableStats")
    def disable_stats(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_stats")

    @disable_stats.setter
    def disable_stats(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_stats", value)


@pulumi.input_type
class SettingSyntheticTestArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 vlans: Optional[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgs']]]] = None,
                 wan_speedtest: Optional[pulumi.Input['SettingSyntheticTestWanSpeedtestArgs']] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)
        if wan_speedtest is not None:
            pulumi.set(__self__, "wan_speedtest", wan_speedtest)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgs']]]]:
        return pulumi.get(self, "vlans")

    @vlans.setter
    def vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SettingSyntheticTestVlanArgs']]]]):
        pulumi.set(self, "vlans", value)

    @property
    @pulumi.getter(name="wanSpeedtest")
    def wan_speedtest(self) -> Optional[pulumi.Input['SettingSyntheticTestWanSpeedtestArgs']]:
        return pulumi.get(self, "wan_speedtest")

    @wan_speedtest.setter
    def wan_speedtest(self, value: Optional[pulumi.Input['SettingSyntheticTestWanSpeedtestArgs']]):
        pulumi.set(self, "wan_speedtest", value)


@pulumi.input_type
class SettingSyntheticTestVlanArgs:
    def __init__(__self__, *,
                 custom_test_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] disabled: for some vlans where we don't want this to run
        """
        if custom_test_urls is not None:
            pulumi.set(__self__, "custom_test_urls", custom_test_urls)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @property
    @pulumi.getter(name="customTestUrls")
    def custom_test_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_test_urls")

    @custom_test_urls.setter
    def custom_test_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_test_urls", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        for some vlans where we don't want this to run
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlan_ids", value)


@pulumi.input_type
class SettingSyntheticTestWanSpeedtestArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 time_od_fay: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_od_fay: any / HH:MM (24-hour format)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_od_fay is not None:
            pulumi.set(__self__, "time_od_fay", time_od_fay)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="timeOdFay")
    def time_od_fay(self) -> Optional[pulumi.Input[str]]:
        """
        any / HH:MM (24-hour format)
        """
        return pulumi.get(self, "time_od_fay")

    @time_od_fay.setter
    def time_od_fay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_od_fay", value)


@pulumi.input_type
class SettingUplinkPortConfigArgs:
    def __init__(__self__, *,
                 dot1x: Optional[pulumi.Input[bool]] = None,
                 keep_wlans_up_if_down: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] dot1x: Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param pulumi.Input[bool] keep_wlans_up_if_down: by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @property
    @pulumi.getter
    def dot1x(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @dot1x.setter
    def dot1x(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dot1x", value)

    @property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")

    @keep_wlans_up_if_down.setter
    def keep_wlans_up_if_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_wlans_up_if_down", value)


@pulumi.input_type
class SettingVnaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingVsInstanceArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)


@pulumi.input_type
class SettingWanVnaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingWidsArgs:
    def __init__(__self__, *,
                 repeated_auth_failures: Optional[pulumi.Input['SettingWidsRepeatedAuthFailuresArgs']] = None):
        if repeated_auth_failures is not None:
            pulumi.set(__self__, "repeated_auth_failures", repeated_auth_failures)

    @property
    @pulumi.getter(name="repeatedAuthFailures")
    def repeated_auth_failures(self) -> Optional[pulumi.Input['SettingWidsRepeatedAuthFailuresArgs']]:
        return pulumi.get(self, "repeated_auth_failures")

    @repeated_auth_failures.setter
    def repeated_auth_failures(self, value: Optional[pulumi.Input['SettingWidsRepeatedAuthFailuresArgs']]):
        pulumi.set(self, "repeated_auth_failures", value)


@pulumi.input_type
class SettingWidsRepeatedAuthFailuresArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration: window where a trigger will be detected and action to be taken (in seconds)
        :param pulumi.Input[int] threshold: count of events to trigger
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        window where a trigger will be detected and action to be taken (in seconds)
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[int]]:
        """
        count of events to trigger
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class SettingWifiArgs:
    def __init__(__self__, *,
                 cisco_enabled: Optional[pulumi.Input[bool]] = None,
                 disable11k: Optional[pulumi.Input[bool]] = None,
                 disable_radios_when_power_constrained: Optional[pulumi.Input[bool]] = None,
                 enable_arp_spoof_check: Optional[pulumi.Input[bool]] = None,
                 enable_shared_radio_scanning: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 locate_connected: Optional[pulumi.Input[bool]] = None,
                 locate_unconnected: Optional[pulumi.Input[bool]] = None,
                 mesh_allow_dfs: Optional[pulumi.Input[bool]] = None,
                 mesh_enable_crm: Optional[pulumi.Input[bool]] = None,
                 mesh_enabled: Optional[pulumi.Input[bool]] = None,
                 mesh_psk: Optional[pulumi.Input[str]] = None,
                 mesh_ssid: Optional[pulumi.Input[str]] = None,
                 proxy_arp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable11k: whether to disable 11k
        :param pulumi.Input[bool] enable_arp_spoof_check: when proxy_arp is enabled, check for arp spoofing.
        :param pulumi.Input[bool] enabled: enable WIFI feature (using SUB-MAN license)
        :param pulumi.Input[bool] locate_connected: whether to locate connected clients
        :param pulumi.Input[bool] locate_unconnected: whether to locate unconnected clients
        :param pulumi.Input[bool] mesh_allow_dfs: whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
        :param pulumi.Input[bool] mesh_enable_crm: used to enable/disable CRM
        :param pulumi.Input[bool] mesh_enabled: whether to enable Mesh feature for the site
        :param pulumi.Input[str] mesh_psk: optional passphrase of mesh networking, default is generated randomly
        :param pulumi.Input[str] mesh_ssid: optional ssid of mesh networking, default is based on site_id
        :param pulumi.Input[str] proxy_arp: enum: `default`, `disabled`, `enabled`
        """
        if cisco_enabled is not None:
            pulumi.set(__self__, "cisco_enabled", cisco_enabled)
        if disable11k is not None:
            pulumi.set(__self__, "disable11k", disable11k)
        if disable_radios_when_power_constrained is not None:
            pulumi.set(__self__, "disable_radios_when_power_constrained", disable_radios_when_power_constrained)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_shared_radio_scanning is not None:
            pulumi.set(__self__, "enable_shared_radio_scanning", enable_shared_radio_scanning)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if locate_connected is not None:
            pulumi.set(__self__, "locate_connected", locate_connected)
        if locate_unconnected is not None:
            pulumi.set(__self__, "locate_unconnected", locate_unconnected)
        if mesh_allow_dfs is not None:
            pulumi.set(__self__, "mesh_allow_dfs", mesh_allow_dfs)
        if mesh_enable_crm is not None:
            pulumi.set(__self__, "mesh_enable_crm", mesh_enable_crm)
        if mesh_enabled is not None:
            pulumi.set(__self__, "mesh_enabled", mesh_enabled)
        if mesh_psk is not None:
            pulumi.set(__self__, "mesh_psk", mesh_psk)
        if mesh_ssid is not None:
            pulumi.set(__self__, "mesh_ssid", mesh_ssid)
        if proxy_arp is not None:
            pulumi.set(__self__, "proxy_arp", proxy_arp)

    @property
    @pulumi.getter(name="ciscoEnabled")
    def cisco_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cisco_enabled")

    @cisco_enabled.setter
    def cisco_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cisco_enabled", value)

    @property
    @pulumi.getter
    def disable11k(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable 11k
        """
        return pulumi.get(self, "disable11k")

    @disable11k.setter
    def disable11k(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable11k", value)

    @property
    @pulumi.getter(name="disableRadiosWhenPowerConstrained")
    def disable_radios_when_power_constrained(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_radios_when_power_constrained")

    @disable_radios_when_power_constrained.setter
    def disable_radios_when_power_constrained(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_radios_when_power_constrained", value)

    @property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[pulumi.Input[bool]]:
        """
        when proxy_arp is enabled, check for arp spoofing.
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @enable_arp_spoof_check.setter
    def enable_arp_spoof_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_arp_spoof_check", value)

    @property
    @pulumi.getter(name="enableSharedRadioScanning")
    def enable_shared_radio_scanning(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_shared_radio_scanning")

    @enable_shared_radio_scanning.setter
    def enable_shared_radio_scanning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_shared_radio_scanning", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        enable WIFI feature (using SUB-MAN license)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="locateConnected")
    def locate_connected(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to locate connected clients
        """
        return pulumi.get(self, "locate_connected")

    @locate_connected.setter
    def locate_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "locate_connected", value)

    @property
    @pulumi.getter(name="locateUnconnected")
    def locate_unconnected(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to locate unconnected clients
        """
        return pulumi.get(self, "locate_unconnected")

    @locate_unconnected.setter
    def locate_unconnected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "locate_unconnected", value)

    @property
    @pulumi.getter(name="meshAllowDfs")
    def mesh_allow_dfs(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
        """
        return pulumi.get(self, "mesh_allow_dfs")

    @mesh_allow_dfs.setter
    def mesh_allow_dfs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mesh_allow_dfs", value)

    @property
    @pulumi.getter(name="meshEnableCrm")
    def mesh_enable_crm(self) -> Optional[pulumi.Input[bool]]:
        """
        used to enable/disable CRM
        """
        return pulumi.get(self, "mesh_enable_crm")

    @mesh_enable_crm.setter
    def mesh_enable_crm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mesh_enable_crm", value)

    @property
    @pulumi.getter(name="meshEnabled")
    def mesh_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable Mesh feature for the site
        """
        return pulumi.get(self, "mesh_enabled")

    @mesh_enabled.setter
    def mesh_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mesh_enabled", value)

    @property
    @pulumi.getter(name="meshPsk")
    def mesh_psk(self) -> Optional[pulumi.Input[str]]:
        """
        optional passphrase of mesh networking, default is generated randomly
        """
        return pulumi.get(self, "mesh_psk")

    @mesh_psk.setter
    def mesh_psk(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mesh_psk", value)

    @property
    @pulumi.getter(name="meshSsid")
    def mesh_ssid(self) -> Optional[pulumi.Input[str]]:
        """
        optional ssid of mesh networking, default is based on site_id
        """
        return pulumi.get(self, "mesh_ssid")

    @mesh_ssid.setter
    def mesh_ssid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mesh_ssid", value)

    @property
    @pulumi.getter(name="proxyArp")
    def proxy_arp(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `default`, `disabled`, `enabled`
        """
        return pulumi.get(self, "proxy_arp")

    @proxy_arp.setter
    def proxy_arp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_arp", value)


@pulumi.input_type
class SettingWiredVnaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SettingZoneOccupancyAlertArgs:
    def __init__(__self__, *,
                 email_notifiers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_notifiers: list of email addresses to send email notifications when the alert threshold is reached
        :param pulumi.Input[bool] enabled: indicate whether zone occupancy alert is enabled for the site
        :param pulumi.Input[int] threshold: sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
        """
        if email_notifiers is not None:
            pulumi.set(__self__, "email_notifiers", email_notifiers)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="emailNotifiers")
    def email_notifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of email addresses to send email notifications when the alert threshold is reached
        """
        return pulumi.get(self, "email_notifiers")

    @email_notifiers.setter
    def email_notifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_notifiers", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        indicate whether zone occupancy alert is enabled for the site
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[int]]:
        """
        sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class WlanAcctServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 keywrap_enabled: Optional[pulumi.Input[bool]] = None,
                 keywrap_format: Optional[pulumi.Input[str]] = None,
                 keywrap_kek: Optional[pulumi.Input[str]] = None,
                 keywrap_mack: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: ip / hostname of RADIUS server
        :param pulumi.Input[str] secret: secret of RADIUS server
        :param pulumi.Input[str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[int] port: Acct port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Acct port of RADIUS server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class WlanAirwatchArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 console_url: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_key: API Key
        :param pulumi.Input[str] console_url: console URL
        :param pulumi.Input[str] password: password
        :param pulumi.Input[str] username: username
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "console_url", console_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="consoleUrl")
    def console_url(self) -> pulumi.Input[str]:
        """
        console URL
        """
        return pulumi.get(self, "console_url")

    @console_url.setter
    def console_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "console_url", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class WlanAppLimitArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 wxtag_ids: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] apps: Map from app key to bandwidth in kbps. 
               Property key is the app key, defined in Get Application List
        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] wxtag_ids: Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps
               Property key is the wxtag id
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]:
        """
        Map from app key to bandwidth in kbps. 
        Property key is the app key, defined in Get Application List
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]:
        """
        Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps
        Property key is the wxtag id
        """
        return pulumi.get(self, "wxtag_ids")

    @wxtag_ids.setter
    def wxtag_ids(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]):
        pulumi.set(self, "wxtag_ids", value)


@pulumi.input_type
class WlanAppQosArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 others: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgs']]]] = None):
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if others is not None:
            pulumi.set(__self__, "others", others)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgs']]]]:
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['WlanAppQosAppsArgs']]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def others(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgs']]]]:
        return pulumi.get(self, "others")

    @others.setter
    def others(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanAppQosOtherArgs']]]]):
        pulumi.set(self, "others", value)


@pulumi.input_type
class WlanAppQosAppsArgs:
    def __init__(__self__, *,
                 dscp: Optional[pulumi.Input[int]] = None,
                 dst_subnet: Optional[pulumi.Input[str]] = None,
                 src_subnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dst_subnet: subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        :param pulumi.Input[str] src_subnet: subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "dst_subnet")

    @dst_subnet.setter
    def dst_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_subnet", value)

    @property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "src_subnet")

    @src_subnet.setter
    def src_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_subnet", value)


@pulumi.input_type
class WlanAppQosOtherArgs:
    def __init__(__self__, *,
                 dscp: Optional[pulumi.Input[int]] = None,
                 dst_subnet: Optional[pulumi.Input[str]] = None,
                 port_ranges: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 src_subnet: Optional[pulumi.Input[str]] = None):
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dst_subnet")

    @dst_subnet.setter
    def dst_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_subnet", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "src_subnet")

    @src_subnet.setter
    def src_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_subnet", value)


@pulumi.input_type
class WlanAuthArgs:
    def __init__(__self__, *,
                 anticlog_threshold: Optional[pulumi.Input[int]] = None,
                 eap_reauth: Optional[pulumi.Input[bool]] = None,
                 enable_mac_auth: Optional[pulumi.Input[bool]] = None,
                 key_idx: Optional[pulumi.Input[int]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 multi_psk_only: Optional[pulumi.Input[bool]] = None,
                 owe: Optional[pulumi.Input[str]] = None,
                 pairwises: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_wlan: Optional[pulumi.Input[bool]] = None,
                 psk: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 wep_as_secondary_auth: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] anticlog_threshold: SAE anti-clogging token threshold
        :param pulumi.Input[bool] eap_reauth: whether to trigger EAP reauth when the session ends
        :param pulumi.Input[bool] enable_mac_auth: whether to enable MAC Auth, uses the same auth_servers
        :param pulumi.Input[int] key_idx: when `type`==`wep`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        :param pulumi.Input[bool] multi_psk_only: when `type`==`psk`, whether to only use multi_psk
        :param pulumi.Input[str] owe: if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pairwises: when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        :param pulumi.Input[bool] private_wlan: when `multi_psk_only`==`true`, whether private wlan is enabled
        :param pulumi.Input[str] psk: when `type`==`psk`, 8-64 characters, or 64 hex characters
        :param pulumi.Input[str] type: enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        :param pulumi.Input[bool] wep_as_secondary_auth: enable WEP as secondary auth
        """
        if anticlog_threshold is not None:
            pulumi.set(__self__, "anticlog_threshold", anticlog_threshold)
        if eap_reauth is not None:
            pulumi.set(__self__, "eap_reauth", eap_reauth)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if key_idx is not None:
            pulumi.set(__self__, "key_idx", key_idx)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if multi_psk_only is not None:
            pulumi.set(__self__, "multi_psk_only", multi_psk_only)
        if owe is not None:
            pulumi.set(__self__, "owe", owe)
        if pairwises is not None:
            pulumi.set(__self__, "pairwises", pairwises)
        if private_wlan is not None:
            pulumi.set(__self__, "private_wlan", private_wlan)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wep_as_secondary_auth is not None:
            pulumi.set(__self__, "wep_as_secondary_auth", wep_as_secondary_auth)

    @property
    @pulumi.getter(name="anticlogThreshold")
    def anticlog_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        SAE anti-clogging token threshold
        """
        return pulumi.get(self, "anticlog_threshold")

    @anticlog_threshold.setter
    def anticlog_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "anticlog_threshold", value)

    @property
    @pulumi.getter(name="eapReauth")
    def eap_reauth(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to trigger EAP reauth when the session ends
        """
        return pulumi.get(self, "eap_reauth")

    @eap_reauth.setter
    def eap_reauth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eap_reauth", value)

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable MAC Auth, uses the same auth_servers
        """
        return pulumi.get(self, "enable_mac_auth")

    @enable_mac_auth.setter
    def enable_mac_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_mac_auth", value)

    @property
    @pulumi.getter(name="keyIdx")
    def key_idx(self) -> Optional[pulumi.Input[int]]:
        """
        when `type`==`wep`
        """
        return pulumi.get(self, "key_idx")

    @key_idx.setter
    def key_idx(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key_idx", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="multiPskOnly")
    def multi_psk_only(self) -> Optional[pulumi.Input[bool]]:
        """
        when `type`==`psk`, whether to only use multi_psk
        """
        return pulumi.get(self, "multi_psk_only")

    @multi_psk_only.setter
    def multi_psk_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multi_psk_only", value)

    @property
    @pulumi.getter
    def owe(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        """
        return pulumi.get(self, "owe")

    @owe.setter
    def owe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owe", value)

    @property
    @pulumi.getter
    def pairwises(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        """
        return pulumi.get(self, "pairwises")

    @pairwises.setter
    def pairwises(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pairwises", value)

    @property
    @pulumi.getter(name="privateWlan")
    def private_wlan(self) -> Optional[pulumi.Input[bool]]:
        """
        when `multi_psk_only`==`true`, whether private wlan is enabled
        """
        return pulumi.get(self, "private_wlan")

    @private_wlan.setter
    def private_wlan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_wlan", value)

    @property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[str]]:
        """
        when `type`==`psk`, 8-64 characters, or 64 hex characters
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psk", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="wepAsSecondaryAuth")
    def wep_as_secondary_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        enable WEP as secondary auth
        """
        return pulumi.get(self, "wep_as_secondary_auth")

    @wep_as_secondary_auth.setter
    def wep_as_secondary_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wep_as_secondary_auth", value)


@pulumi.input_type
class WlanAuthServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 keywrap_enabled: Optional[pulumi.Input[bool]] = None,
                 keywrap_format: Optional[pulumi.Input[str]] = None,
                 keywrap_kek: Optional[pulumi.Input[str]] = None,
                 keywrap_mack: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: ip / hostname of RADIUS server
        :param pulumi.Input[str] secret: secret of RADIUS server
        :param pulumi.Input[str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[int] port: Auth port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Auth port of RADIUS server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class WlanBonjourArgs:
    def __init__(__self__, *,
                 additional_vlan_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 services: pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_vlan_ids: additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        :param pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]] services: what services are allowed. 
               Property key is the service name
        :param pulumi.Input[bool] enabled: whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        pulumi.set(__self__, "additional_vlan_ids", additional_vlan_ids)
        pulumi.set(__self__, "services", services)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="additionalVlanIds")
    def additional_vlan_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        """
        return pulumi.get(self, "additional_vlan_ids")

    @additional_vlan_ids.setter
    def additional_vlan_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "additional_vlan_ids", value)

    @property
    @pulumi.getter
    def services(self) -> pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]]:
        """
        what services are allowed. 
        Property key is the service name
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: pulumi.Input[Mapping[str, pulumi.Input['WlanBonjourServicesArgs']]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class WlanBonjourServicesArgs:
    def __init__(__self__, *,
                 disable_local: Optional[pulumi.Input[bool]] = None,
                 radius_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_local: whether to prevent wireless clients to discover bonjour devices on the same WLAN
        :param pulumi.Input[Sequence[pulumi.Input[str]]] radius_groups: optional, if the service is further restricted for certain RADIUS groups
        :param pulumi.Input[str] scope: how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        if disable_local is not None:
            pulumi.set(__self__, "disable_local", disable_local)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="disableLocal")
    def disable_local(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to prevent wireless clients to discover bonjour devices on the same WLAN
        """
        return pulumi.get(self, "disable_local")

    @disable_local.setter
    def disable_local(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local", value)

    @property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        optional, if the service is further restricted for certain RADIUS groups
        """
        return pulumi.get(self, "radius_groups")

    @radius_groups.setter
    def radius_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "radius_groups", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class WlanCiscoCwaArgs:
    def __init__(__self__, *,
                 allowed_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 blocked_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_hostnames: list of hostnames without http(s):// (matched by substring)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_subnets: list of CIDRs
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_subnets: list of blocked CIDRs
        """
        if allowed_hostnames is not None:
            pulumi.set(__self__, "allowed_hostnames", allowed_hostnames)
        if allowed_subnets is not None:
            pulumi.set(__self__, "allowed_subnets", allowed_subnets)
        if blocked_subnets is not None:
            pulumi.set(__self__, "blocked_subnets", blocked_subnets)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="allowedHostnames")
    def allowed_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "allowed_hostnames")

    @allowed_hostnames.setter
    def allowed_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_hostnames", value)

    @property
    @pulumi.getter(name="allowedSubnets")
    def allowed_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of CIDRs
        """
        return pulumi.get(self, "allowed_subnets")

    @allowed_subnets.setter
    def allowed_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_subnets", value)

    @property
    @pulumi.getter(name="blockedSubnets")
    def blocked_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of blocked CIDRs
        """
        return pulumi.get(self, "blocked_subnets")

    @blocked_subnets.setter
    def blocked_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "blocked_subnets", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class WlanCoaServerArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 disable_event_timestamp_check: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disable_event_timestamp_check: whether to disable Event-Timestamp Check
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "secret", secret)
        if disable_event_timestamp_check is not None:
            pulumi.set(__self__, "disable_event_timestamp_check", disable_event_timestamp_check)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="disableEventTimestampCheck")
    def disable_event_timestamp_check(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable Event-Timestamp Check
        """
        return pulumi.get(self, "disable_event_timestamp_check")

    @disable_event_timestamp_check.setter
    def disable_event_timestamp_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_event_timestamp_check", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class WlanDnsServerRewriteArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 radius_groups: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] radius_groups: map between radius_group and the desired DNS server (IPv4 only)
               Property key is the RADIUS group, property value is the desired DNS Server
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        map between radius_group and the desired DNS server (IPv4 only)
        Property key is the RADIUS group, property value is the desired DNS Server
        """
        return pulumi.get(self, "radius_groups")

    @radius_groups.setter
    def radius_groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "radius_groups", value)


@pulumi.input_type
class WlanDynamicPskArgs:
    def __init__(__self__, *,
                 default_psk: Optional[pulumi.Input[str]] = None,
                 default_vlan_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 force_lookup: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] default_psk: default PSK to use if cloud WLC is not available, 8-63 characters
        :param pulumi.Input[bool] force_lookup: when 11r is enabled, we'll try to use the cached PMK, this can be disabled
               `false` means auto
        :param pulumi.Input[str] source: enum: `cloud_psks`, `radius`
        """
        if default_psk is not None:
            pulumi.set(__self__, "default_psk", default_psk)
        if default_vlan_id is not None:
            pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force_lookup is not None:
            pulumi.set(__self__, "force_lookup", force_lookup)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @property
    @pulumi.getter(name="defaultPsk")
    def default_psk(self) -> Optional[pulumi.Input[str]]:
        """
        default PSK to use if cloud WLC is not available, 8-63 characters
        """
        return pulumi.get(self, "default_psk")

    @default_psk.setter
    def default_psk(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_psk", value)

    @property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_vlan_id")

    @default_vlan_id.setter
    def default_vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_vlan_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="forceLookup")
    def force_lookup(self) -> Optional[pulumi.Input[bool]]:
        """
        when 11r is enabled, we'll try to use the cached PMK, this can be disabled
        `false` means auto
        """
        return pulumi.get(self, "force_lookup")

    @force_lookup.setter
    def force_lookup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_lookup", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `cloud_psks`, `radius`
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "vlan_ids")

    @vlan_ids.setter
    def vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlan_ids", value)


@pulumi.input_type
class WlanDynamicVlanArgs:
    def __init__(__self__, *,
                 default_vlan_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 local_vlan_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vlans: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_vlan_ids: Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        :param pulumi.Input[bool] enabled: whether to enable dynamic vlan
        :param pulumi.Input[Sequence[pulumi.Input[str]]] local_vlan_ids: vlan_ids to be locally bridged
        :param pulumi.Input[str] type: standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] vlans: map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping
                 * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
                 * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        pulumi.set(__self__, "default_vlan_ids", default_vlan_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if local_vlan_ids is not None:
            pulumi.set(__self__, "local_vlan_ids", local_vlan_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="defaultVlanIds")
    def default_vlan_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        """
        return pulumi.get(self, "default_vlan_ids")

    @default_vlan_ids.setter
    def default_vlan_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "default_vlan_ids", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable dynamic vlan
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="localVlanIds")
    def local_vlan_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vlan_ids to be locally bridged
        """
        return pulumi.get(self, "local_vlan_ids")

    @local_vlan_ids.setter
    def local_vlan_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "local_vlan_ids", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def vlans(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping
          * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
          * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        return pulumi.get(self, "vlans")

    @vlans.setter
    def vlans(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "vlans", value)


@pulumi.input_type
class WlanHotspot20Args:
    def __init__(__self__, *,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 nai_realms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rcois: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 venue_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: whether to enable hotspot 2.0 config
        :param pulumi.Input[Sequence[pulumi.Input[str]]] operators: list of operators to support
        :param pulumi.Input[str] venue_name: venue name, default is site name
        """
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if nai_realms is not None:
            pulumi.set(__self__, "nai_realms", nai_realms)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)
        if rcois is not None:
            pulumi.set(__self__, "rcois", rcois)
        if venue_name is not None:
            pulumi.set(__self__, "venue_name", venue_name)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable hotspot 2.0 config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="naiRealms")
    def nai_realms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "nai_realms")

    @nai_realms.setter
    def nai_realms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nai_realms", value)

    @property
    @pulumi.getter
    def operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of operators to support
        """
        return pulumi.get(self, "operators")

    @operators.setter
    def operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "operators", value)

    @property
    @pulumi.getter
    def rcois(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "rcois")

    @rcois.setter
    def rcois(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "rcois", value)

    @property
    @pulumi.getter(name="venueName")
    def venue_name(self) -> Optional[pulumi.Input[str]]:
        """
        venue name, default is site name
        """
        return pulumi.get(self, "venue_name")

    @venue_name.setter
    def venue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "venue_name", value)


@pulumi.input_type
class WlanInjectDhcpOption82Args:
    def __init__(__self__, *,
                 circuit_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: whether to inject option 82 when forwarding DHCP packets
        """
        if circuit_id is not None:
            pulumi.set(__self__, "circuit_id", circuit_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="circuitId")
    def circuit_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "circuit_id")

    @circuit_id.setter
    def circuit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "circuit_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to inject option 82 when forwarding DHCP packets
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class WlanMistNacArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: when enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed'
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        when enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed'
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class WlanPortalArgs:
    def __init__(__self__, *,
                 amazon_client_id: Optional[pulumi.Input[str]] = None,
                 amazon_client_secret: Optional[pulumi.Input[str]] = None,
                 amazon_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 amazon_enabled: Optional[pulumi.Input[bool]] = None,
                 amazon_expire: Optional[pulumi.Input[float]] = None,
                 auth: Optional[pulumi.Input[str]] = None,
                 azure_client_id: Optional[pulumi.Input[str]] = None,
                 azure_client_secret: Optional[pulumi.Input[str]] = None,
                 azure_enabled: Optional[pulumi.Input[bool]] = None,
                 azure_expire: Optional[pulumi.Input[float]] = None,
                 azure_tenant_id: Optional[pulumi.Input[str]] = None,
                 broadnet_password: Optional[pulumi.Input[str]] = None,
                 broadnet_sid: Optional[pulumi.Input[str]] = None,
                 broadnet_user_id: Optional[pulumi.Input[str]] = None,
                 bypass_when_cloud_down: Optional[pulumi.Input[bool]] = None,
                 clickatell_api_key: Optional[pulumi.Input[str]] = None,
                 cross_site: Optional[pulumi.Input[bool]] = None,
                 email_enabled: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expire: Optional[pulumi.Input[float]] = None,
                 external_portal_url: Optional[pulumi.Input[str]] = None,
                 facebook_client_id: Optional[pulumi.Input[str]] = None,
                 facebook_client_secret: Optional[pulumi.Input[str]] = None,
                 facebook_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 facebook_enabled: Optional[pulumi.Input[bool]] = None,
                 facebook_expire: Optional[pulumi.Input[float]] = None,
                 forward: Optional[pulumi.Input[bool]] = None,
                 forward_url: Optional[pulumi.Input[str]] = None,
                 google_client_id: Optional[pulumi.Input[str]] = None,
                 google_client_secret: Optional[pulumi.Input[str]] = None,
                 google_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 google_enabled: Optional[pulumi.Input[bool]] = None,
                 google_expire: Optional[pulumi.Input[float]] = None,
                 gupshup_password: Optional[pulumi.Input[str]] = None,
                 gupshup_userid: Optional[pulumi.Input[str]] = None,
                 microsoft_client_id: Optional[pulumi.Input[str]] = None,
                 microsoft_client_secret: Optional[pulumi.Input[str]] = None,
                 microsoft_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 microsoft_enabled: Optional[pulumi.Input[bool]] = None,
                 microsoft_expire: Optional[pulumi.Input[float]] = None,
                 passphrase_enabled: Optional[pulumi.Input[bool]] = None,
                 passphrase_expire: Optional[pulumi.Input[float]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 predefined_sponsors_enabled: Optional[pulumi.Input[bool]] = None,
                 privacy: Optional[pulumi.Input[bool]] = None,
                 puzzel_password: Optional[pulumi.Input[str]] = None,
                 puzzel_service_id: Optional[pulumi.Input[str]] = None,
                 puzzel_username: Optional[pulumi.Input[str]] = None,
                 sms_enabled: Optional[pulumi.Input[bool]] = None,
                 sms_expire: Optional[pulumi.Input[float]] = None,
                 sms_message_format: Optional[pulumi.Input[str]] = None,
                 sms_provider: Optional[pulumi.Input[str]] = None,
                 sponsor_auto_approve: Optional[pulumi.Input[bool]] = None,
                 sponsor_email_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sponsor_enabled: Optional[pulumi.Input[bool]] = None,
                 sponsor_expire: Optional[pulumi.Input[float]] = None,
                 sponsor_link_validity_duration: Optional[pulumi.Input[int]] = None,
                 sponsor_notify_all: Optional[pulumi.Input[bool]] = None,
                 sponsor_status_notify: Optional[pulumi.Input[bool]] = None,
                 sponsors: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 sso_default_role: Optional[pulumi.Input[str]] = None,
                 sso_forced_role: Optional[pulumi.Input[str]] = None,
                 sso_idp_cert: Optional[pulumi.Input[str]] = None,
                 sso_idp_sign_algo: Optional[pulumi.Input[str]] = None,
                 sso_idp_sso_url: Optional[pulumi.Input[str]] = None,
                 sso_issuer: Optional[pulumi.Input[str]] = None,
                 sso_nameid_format: Optional[pulumi.Input[str]] = None,
                 telstra_client_id: Optional[pulumi.Input[str]] = None,
                 telstra_client_secret: Optional[pulumi.Input[str]] = None,
                 twilio_auth_token: Optional[pulumi.Input[str]] = None,
                 twilio_phone_number: Optional[pulumi.Input[str]] = None,
                 twilio_sid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] amazon_client_id: amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[str] amazon_client_secret: amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] amazon_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[bool] amazon_enabled: whether amazon is enabled as a login method
        :param pulumi.Input[float] amazon_expire: interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[str] auth: authentication scheme. enum: `external`, `none`, `sso`
        :param pulumi.Input[str] azure_client_id: Required if `azure_enabled`==`true`.
               Azure active directory app client id
        :param pulumi.Input[str] azure_client_secret: Required if `azure_enabled`==`true`.
               Azure active directory app client secret
        :param pulumi.Input[bool] azure_enabled: whether Azure Active Directory is enabled as a login method
        :param pulumi.Input[float] azure_expire: interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[str] azure_tenant_id: Required if `azure_enabled`==`true`.
               Azure active directory tenant id.
        :param pulumi.Input[str] broadnet_password: when `sms_provider`==`broadnet`
        :param pulumi.Input[str] broadnet_sid: when `sms_provider`==`broadnet`
        :param pulumi.Input[str] broadnet_user_id: when `sms_provider`==`broadnet`
        :param pulumi.Input[bool] bypass_when_cloud_down: whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        :param pulumi.Input[str] clickatell_api_key: when `sms_provider`==`clickatell`
        :param pulumi.Input[bool] cross_site: whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        :param pulumi.Input[bool] email_enabled: whether email (access code verification) is enabled as a login method
        :param pulumi.Input[bool] enabled: whether guest portal is enabled
        :param pulumi.Input[float] expire: how long to remain authorized, in minutes
        :param pulumi.Input[str] external_portal_url: external portal URL (e.g. https://host/url) where we can append our query parameters to
        :param pulumi.Input[str] facebook_client_id: Required if `facebook_enabled`==`true`.
               Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[str] facebook_client_secret: Required if `facebook_enabled`==`true`.
               Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] facebook_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[bool] facebook_enabled: whether facebook is enabled as a login method
        :param pulumi.Input[float] facebook_expire: interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[bool] forward: whether to forward the user to another URL after authorized
        :param pulumi.Input[str] forward_url: the URL to forward the user to
        :param pulumi.Input[str] google_client_id: Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[str] google_client_secret: Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] google_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[bool] google_enabled: whether google is enabled as login method
        :param pulumi.Input[float] google_expire: interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[str] gupshup_password: when `sms_provider`==`gupshup`
        :param pulumi.Input[str] gupshup_userid: when `sms_provider`==`gupshup`
        :param pulumi.Input[str] microsoft_client_id: microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param pulumi.Input[str] microsoft_client_secret: microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] microsoft_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param pulumi.Input[bool] microsoft_enabled: whether microsoft 365 is enabled as a login method
        :param pulumi.Input[float] microsoft_expire: interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[bool] passphrase_enabled: whether password is enabled
        :param pulumi.Input[float] passphrase_expire: interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        :param pulumi.Input[str] password: passphrase
        :param pulumi.Input[bool] predefined_sponsors_enabled: whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        :param pulumi.Input[str] puzzel_password: when `sms_provider`==`puzzel`
        :param pulumi.Input[str] puzzel_service_id: when `sms_provider`==`puzzel`
        :param pulumi.Input[str] puzzel_username: when `sms_provider`==`puzzel`
        :param pulumi.Input[bool] sms_enabled: whether sms is enabled as a login method
        :param pulumi.Input[float] sms_expire: interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[str] sms_provider: enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        :param pulumi.Input[bool] sponsor_auto_approve: whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sponsor_email_domains: list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        :param pulumi.Input[bool] sponsor_enabled: whether sponsor is enabled
        :param pulumi.Input[float] sponsor_expire: interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        :param pulumi.Input[int] sponsor_link_validity_duration: how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
        :param pulumi.Input[bool] sponsor_notify_all: whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        :param pulumi.Input[bool] sponsor_status_notify: if enabled, guest will get email about sponsor's action (approve/deny)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] sponsors: object of allowed sponsors email with name. Required if `sponsor_enabled` is `true` and `sponsor_email_domains` is empty.
               Property key is the sponsor email, Property value is the sponsor name
        :param pulumi.Input[str] sso_default_role: default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        :param pulumi.Input[str] sso_idp_cert: IDP Cert (used to verify the signed response)
        :param pulumi.Input[str] sso_idp_sign_algo: signing algorithm for SAML Assertion
        :param pulumi.Input[str] sso_idp_sso_url: IDP Single-Sign-On URL
        :param pulumi.Input[str] sso_issuer: IDP issuer URL
        :param pulumi.Input[str] sso_nameid_format: enum: `email`, `unspecified`
        :param pulumi.Input[str] telstra_client_id: when `sms_provider`==`telstra`, Client ID provided by Telstra
        :param pulumi.Input[str] telstra_client_secret: when `sms_provider`==`telstra`, Client secret provided by Telstra
        :param pulumi.Input[str] twilio_auth_token: when `sms_provider`==`twilio`, Auth token account with twilio account
        :param pulumi.Input[str] twilio_phone_number: when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        :param pulumi.Input[str] twilio_sid: when `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        if amazon_client_id is not None:
            pulumi.set(__self__, "amazon_client_id", amazon_client_id)
        if amazon_client_secret is not None:
            pulumi.set(__self__, "amazon_client_secret", amazon_client_secret)
        if amazon_email_domains is not None:
            pulumi.set(__self__, "amazon_email_domains", amazon_email_domains)
        if amazon_enabled is not None:
            pulumi.set(__self__, "amazon_enabled", amazon_enabled)
        if amazon_expire is not None:
            pulumi.set(__self__, "amazon_expire", amazon_expire)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if azure_client_id is not None:
            pulumi.set(__self__, "azure_client_id", azure_client_id)
        if azure_client_secret is not None:
            pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        if azure_enabled is not None:
            pulumi.set(__self__, "azure_enabled", azure_enabled)
        if azure_expire is not None:
            pulumi.set(__self__, "azure_expire", azure_expire)
        if azure_tenant_id is not None:
            pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        if broadnet_password is not None:
            pulumi.set(__self__, "broadnet_password", broadnet_password)
        if broadnet_sid is not None:
            pulumi.set(__self__, "broadnet_sid", broadnet_sid)
        if broadnet_user_id is not None:
            pulumi.set(__self__, "broadnet_user_id", broadnet_user_id)
        if bypass_when_cloud_down is not None:
            pulumi.set(__self__, "bypass_when_cloud_down", bypass_when_cloud_down)
        if clickatell_api_key is not None:
            pulumi.set(__self__, "clickatell_api_key", clickatell_api_key)
        if cross_site is not None:
            pulumi.set(__self__, "cross_site", cross_site)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if external_portal_url is not None:
            pulumi.set(__self__, "external_portal_url", external_portal_url)
        if facebook_client_id is not None:
            pulumi.set(__self__, "facebook_client_id", facebook_client_id)
        if facebook_client_secret is not None:
            pulumi.set(__self__, "facebook_client_secret", facebook_client_secret)
        if facebook_email_domains is not None:
            pulumi.set(__self__, "facebook_email_domains", facebook_email_domains)
        if facebook_enabled is not None:
            pulumi.set(__self__, "facebook_enabled", facebook_enabled)
        if facebook_expire is not None:
            pulumi.set(__self__, "facebook_expire", facebook_expire)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if forward_url is not None:
            pulumi.set(__self__, "forward_url", forward_url)
        if google_client_id is not None:
            pulumi.set(__self__, "google_client_id", google_client_id)
        if google_client_secret is not None:
            pulumi.set(__self__, "google_client_secret", google_client_secret)
        if google_email_domains is not None:
            pulumi.set(__self__, "google_email_domains", google_email_domains)
        if google_enabled is not None:
            pulumi.set(__self__, "google_enabled", google_enabled)
        if google_expire is not None:
            pulumi.set(__self__, "google_expire", google_expire)
        if gupshup_password is not None:
            pulumi.set(__self__, "gupshup_password", gupshup_password)
        if gupshup_userid is not None:
            pulumi.set(__self__, "gupshup_userid", gupshup_userid)
        if microsoft_client_id is not None:
            pulumi.set(__self__, "microsoft_client_id", microsoft_client_id)
        if microsoft_client_secret is not None:
            pulumi.set(__self__, "microsoft_client_secret", microsoft_client_secret)
        if microsoft_email_domains is not None:
            pulumi.set(__self__, "microsoft_email_domains", microsoft_email_domains)
        if microsoft_enabled is not None:
            pulumi.set(__self__, "microsoft_enabled", microsoft_enabled)
        if microsoft_expire is not None:
            pulumi.set(__self__, "microsoft_expire", microsoft_expire)
        if passphrase_enabled is not None:
            pulumi.set(__self__, "passphrase_enabled", passphrase_enabled)
        if passphrase_expire is not None:
            pulumi.set(__self__, "passphrase_expire", passphrase_expire)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if predefined_sponsors_enabled is not None:
            pulumi.set(__self__, "predefined_sponsors_enabled", predefined_sponsors_enabled)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if puzzel_password is not None:
            pulumi.set(__self__, "puzzel_password", puzzel_password)
        if puzzel_service_id is not None:
            pulumi.set(__self__, "puzzel_service_id", puzzel_service_id)
        if puzzel_username is not None:
            pulumi.set(__self__, "puzzel_username", puzzel_username)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if sms_expire is not None:
            pulumi.set(__self__, "sms_expire", sms_expire)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_provider is not None:
            pulumi.set(__self__, "sms_provider", sms_provider)
        if sponsor_auto_approve is not None:
            pulumi.set(__self__, "sponsor_auto_approve", sponsor_auto_approve)
        if sponsor_email_domains is not None:
            pulumi.set(__self__, "sponsor_email_domains", sponsor_email_domains)
        if sponsor_enabled is not None:
            pulumi.set(__self__, "sponsor_enabled", sponsor_enabled)
        if sponsor_expire is not None:
            pulumi.set(__self__, "sponsor_expire", sponsor_expire)
        if sponsor_link_validity_duration is not None:
            pulumi.set(__self__, "sponsor_link_validity_duration", sponsor_link_validity_duration)
        if sponsor_notify_all is not None:
            pulumi.set(__self__, "sponsor_notify_all", sponsor_notify_all)
        if sponsor_status_notify is not None:
            pulumi.set(__self__, "sponsor_status_notify", sponsor_status_notify)
        if sponsors is not None:
            pulumi.set(__self__, "sponsors", sponsors)
        if sso_default_role is not None:
            pulumi.set(__self__, "sso_default_role", sso_default_role)
        if sso_forced_role is not None:
            pulumi.set(__self__, "sso_forced_role", sso_forced_role)
        if sso_idp_cert is not None:
            pulumi.set(__self__, "sso_idp_cert", sso_idp_cert)
        if sso_idp_sign_algo is not None:
            pulumi.set(__self__, "sso_idp_sign_algo", sso_idp_sign_algo)
        if sso_idp_sso_url is not None:
            pulumi.set(__self__, "sso_idp_sso_url", sso_idp_sso_url)
        if sso_issuer is not None:
            pulumi.set(__self__, "sso_issuer", sso_issuer)
        if sso_nameid_format is not None:
            pulumi.set(__self__, "sso_nameid_format", sso_nameid_format)
        if telstra_client_id is not None:
            pulumi.set(__self__, "telstra_client_id", telstra_client_id)
        if telstra_client_secret is not None:
            pulumi.set(__self__, "telstra_client_secret", telstra_client_secret)
        if twilio_auth_token is not None:
            pulumi.set(__self__, "twilio_auth_token", twilio_auth_token)
        if twilio_phone_number is not None:
            pulumi.set(__self__, "twilio_phone_number", twilio_phone_number)
        if twilio_sid is not None:
            pulumi.set(__self__, "twilio_sid", twilio_sid)

    @property
    @pulumi.getter(name="amazonClientId")
    def amazon_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "amazon_client_id")

    @amazon_client_id.setter
    def amazon_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "amazon_client_id", value)

    @property
    @pulumi.getter(name="amazonClientSecret")
    def amazon_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "amazon_client_secret")

    @amazon_client_secret.setter
    def amazon_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "amazon_client_secret", value)

    @property
    @pulumi.getter(name="amazonEmailDomains")
    def amazon_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "amazon_email_domains")

    @amazon_email_domains.setter
    def amazon_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "amazon_email_domains", value)

    @property
    @pulumi.getter(name="amazonEnabled")
    def amazon_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether amazon is enabled as a login method
        """
        return pulumi.get(self, "amazon_enabled")

    @amazon_enabled.setter
    def amazon_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "amazon_enabled", value)

    @property
    @pulumi.getter(name="amazonExpire")
    def amazon_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "amazon_expire")

    @amazon_expire.setter
    def amazon_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "amazon_expire", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[str]]:
        """
        authentication scheme. enum: `external`, `none`, `sso`
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `azure_enabled`==`true`.
        Azure active directory app client id
        """
        return pulumi.get(self, "azure_client_id")

    @azure_client_id.setter
    def azure_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_client_id", value)

    @property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `azure_enabled`==`true`.
        Azure active directory app client secret
        """
        return pulumi.get(self, "azure_client_secret")

    @azure_client_secret.setter
    def azure_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_client_secret", value)

    @property
    @pulumi.getter(name="azureEnabled")
    def azure_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether Azure Active Directory is enabled as a login method
        """
        return pulumi.get(self, "azure_enabled")

    @azure_enabled.setter
    def azure_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "azure_enabled", value)

    @property
    @pulumi.getter(name="azureExpire")
    def azure_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "azure_expire")

    @azure_expire.setter
    def azure_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "azure_expire", value)

    @property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `azure_enabled`==`true`.
        Azure active directory tenant id.
        """
        return pulumi.get(self, "azure_tenant_id")

    @azure_tenant_id.setter
    def azure_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_tenant_id", value)

    @property
    @pulumi.getter(name="broadnetPassword")
    def broadnet_password(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_password")

    @broadnet_password.setter
    def broadnet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broadnet_password", value)

    @property
    @pulumi.getter(name="broadnetSid")
    def broadnet_sid(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_sid")

    @broadnet_sid.setter
    def broadnet_sid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broadnet_sid", value)

    @property
    @pulumi.getter(name="broadnetUserId")
    def broadnet_user_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_user_id")

    @broadnet_user_id.setter
    def broadnet_user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broadnet_user_id", value)

    @property
    @pulumi.getter(name="bypassWhenCloudDown")
    def bypass_when_cloud_down(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        """
        return pulumi.get(self, "bypass_when_cloud_down")

    @bypass_when_cloud_down.setter
    def bypass_when_cloud_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_when_cloud_down", value)

    @property
    @pulumi.getter(name="clickatellApiKey")
    def clickatell_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`clickatell`
        """
        return pulumi.get(self, "clickatell_api_key")

    @clickatell_api_key.setter
    def clickatell_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clickatell_api_key", value)

    @property
    @pulumi.getter(name="crossSite")
    def cross_site(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "cross_site")

    @cross_site.setter
    def cross_site(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cross_site", value)

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether email (access code verification) is enabled as a login method
        """
        return pulumi.get(self, "email_enabled")

    @email_enabled.setter
    def email_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_enabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether guest portal is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expire(self) -> Optional[pulumi.Input[float]]:
        """
        how long to remain authorized, in minutes
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "expire", value)

    @property
    @pulumi.getter(name="externalPortalUrl")
    def external_portal_url(self) -> Optional[pulumi.Input[str]]:
        """
        external portal URL (e.g. https://host/url) where we can append our query parameters to
        """
        return pulumi.get(self, "external_portal_url")

    @external_portal_url.setter
    def external_portal_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_portal_url", value)

    @property
    @pulumi.getter(name="facebookClientId")
    def facebook_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `facebook_enabled`==`true`.
        Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "facebook_client_id")

    @facebook_client_id.setter
    def facebook_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facebook_client_id", value)

    @property
    @pulumi.getter(name="facebookClientSecret")
    def facebook_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `facebook_enabled`==`true`.
        Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "facebook_client_secret")

    @facebook_client_secret.setter
    def facebook_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facebook_client_secret", value)

    @property
    @pulumi.getter(name="facebookEmailDomains")
    def facebook_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "facebook_email_domains")

    @facebook_email_domains.setter
    def facebook_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "facebook_email_domains", value)

    @property
    @pulumi.getter(name="facebookEnabled")
    def facebook_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether facebook is enabled as a login method
        """
        return pulumi.get(self, "facebook_enabled")

    @facebook_enabled.setter
    def facebook_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "facebook_enabled", value)

    @property
    @pulumi.getter(name="facebookExpire")
    def facebook_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "facebook_expire")

    @facebook_expire.setter
    def facebook_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "facebook_expire", value)

    @property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to forward the user to another URL after authorized
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "forward", value)

    @property
    @pulumi.getter(name="forwardUrl")
    def forward_url(self) -> Optional[pulumi.Input[str]]:
        """
        the URL to forward the user to
        """
        return pulumi.get(self, "forward_url")

    @forward_url.setter
    def forward_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_url", value)

    @property
    @pulumi.getter(name="googleClientId")
    def google_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "google_client_id")

    @google_client_id.setter
    def google_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_client_id", value)

    @property
    @pulumi.getter(name="googleClientSecret")
    def google_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "google_client_secret")

    @google_client_secret.setter
    def google_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_client_secret", value)

    @property
    @pulumi.getter(name="googleEmailDomains")
    def google_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "google_email_domains")

    @google_email_domains.setter
    def google_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "google_email_domains", value)

    @property
    @pulumi.getter(name="googleEnabled")
    def google_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether google is enabled as login method
        """
        return pulumi.get(self, "google_enabled")

    @google_enabled.setter
    def google_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "google_enabled", value)

    @property
    @pulumi.getter(name="googleExpire")
    def google_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "google_expire")

    @google_expire.setter
    def google_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "google_expire", value)

    @property
    @pulumi.getter(name="gupshupPassword")
    def gupshup_password(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_password")

    @gupshup_password.setter
    def gupshup_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gupshup_password", value)

    @property
    @pulumi.getter(name="gupshupUserid")
    def gupshup_userid(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_userid")

    @gupshup_userid.setter
    def gupshup_userid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gupshup_userid", value)

    @property
    @pulumi.getter(name="microsoftClientId")
    def microsoft_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "microsoft_client_id")

    @microsoft_client_id.setter
    def microsoft_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_client_id", value)

    @property
    @pulumi.getter(name="microsoftClientSecret")
    def microsoft_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "microsoft_client_secret")

    @microsoft_client_secret.setter
    def microsoft_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_client_secret", value)

    @property
    @pulumi.getter(name="microsoftEmailDomains")
    def microsoft_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "microsoft_email_domains")

    @microsoft_email_domains.setter
    def microsoft_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "microsoft_email_domains", value)

    @property
    @pulumi.getter(name="microsoftEnabled")
    def microsoft_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether microsoft 365 is enabled as a login method
        """
        return pulumi.get(self, "microsoft_enabled")

    @microsoft_enabled.setter
    def microsoft_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "microsoft_enabled", value)

    @property
    @pulumi.getter(name="microsoftExpire")
    def microsoft_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "microsoft_expire")

    @microsoft_expire.setter
    def microsoft_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "microsoft_expire", value)

    @property
    @pulumi.getter(name="passphraseEnabled")
    def passphrase_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether password is enabled
        """
        return pulumi.get(self, "passphrase_enabled")

    @passphrase_enabled.setter
    def passphrase_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "passphrase_enabled", value)

    @property
    @pulumi.getter(name="passphraseExpire")
    def passphrase_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        """
        return pulumi.get(self, "passphrase_expire")

    @passphrase_expire.setter
    def passphrase_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "passphrase_expire", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        passphrase
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="predefinedSponsorsEnabled")
    def predefined_sponsors_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        """
        return pulumi.get(self, "predefined_sponsors_enabled")

    @predefined_sponsors_enabled.setter
    def predefined_sponsors_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "predefined_sponsors_enabled", value)

    @property
    @pulumi.getter
    def privacy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privacy")

    @privacy.setter
    def privacy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privacy", value)

    @property
    @pulumi.getter(name="puzzelPassword")
    def puzzel_password(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_password")

    @puzzel_password.setter
    def puzzel_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "puzzel_password", value)

    @property
    @pulumi.getter(name="puzzelServiceId")
    def puzzel_service_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_service_id")

    @puzzel_service_id.setter
    def puzzel_service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "puzzel_service_id", value)

    @property
    @pulumi.getter(name="puzzelUsername")
    def puzzel_username(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_username")

    @puzzel_username.setter
    def puzzel_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "puzzel_username", value)

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether sms is enabled as a login method
        """
        return pulumi.get(self, "sms_enabled")

    @sms_enabled.setter
    def sms_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sms_enabled", value)

    @property
    @pulumi.getter(name="smsExpire")
    def sms_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sms_expire")

    @sms_expire.setter
    def sms_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sms_expire", value)

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sms_message_format")

    @sms_message_format.setter
    def sms_message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sms_message_format", value)

    @property
    @pulumi.getter(name="smsProvider")
    def sms_provider(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        """
        return pulumi.get(self, "sms_provider")

    @sms_provider.setter
    def sms_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sms_provider", value)

    @property
    @pulumi.getter(name="sponsorAutoApprove")
    def sponsor_auto_approve(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        """
        return pulumi.get(self, "sponsor_auto_approve")

    @sponsor_auto_approve.setter
    def sponsor_auto_approve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sponsor_auto_approve", value)

    @property
    @pulumi.getter(name="sponsorEmailDomains")
    def sponsor_email_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        """
        return pulumi.get(self, "sponsor_email_domains")

    @sponsor_email_domains.setter
    def sponsor_email_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sponsor_email_domains", value)

    @property
    @pulumi.getter(name="sponsorEnabled")
    def sponsor_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether sponsor is enabled
        """
        return pulumi.get(self, "sponsor_enabled")

    @sponsor_enabled.setter
    def sponsor_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sponsor_enabled", value)

    @property
    @pulumi.getter(name="sponsorExpire")
    def sponsor_expire(self) -> Optional[pulumi.Input[float]]:
        """
        interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sponsor_expire")

    @sponsor_expire.setter
    def sponsor_expire(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sponsor_expire", value)

    @property
    @pulumi.getter(name="sponsorLinkValidityDuration")
    def sponsor_link_validity_duration(self) -> Optional[pulumi.Input[int]]:
        """
        how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
        """
        return pulumi.get(self, "sponsor_link_validity_duration")

    @sponsor_link_validity_duration.setter
    def sponsor_link_validity_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sponsor_link_validity_duration", value)

    @property
    @pulumi.getter(name="sponsorNotifyAll")
    def sponsor_notify_all(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        """
        return pulumi.get(self, "sponsor_notify_all")

    @sponsor_notify_all.setter
    def sponsor_notify_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sponsor_notify_all", value)

    @property
    @pulumi.getter(name="sponsorStatusNotify")
    def sponsor_status_notify(self) -> Optional[pulumi.Input[bool]]:
        """
        if enabled, guest will get email about sponsor's action (approve/deny)
        """
        return pulumi.get(self, "sponsor_status_notify")

    @sponsor_status_notify.setter
    def sponsor_status_notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sponsor_status_notify", value)

    @property
    @pulumi.getter
    def sponsors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        object of allowed sponsors email with name. Required if `sponsor_enabled` is `true` and `sponsor_email_domains` is empty.
        Property key is the sponsor email, Property value is the sponsor name
        """
        return pulumi.get(self, "sponsors")

    @sponsors.setter
    def sponsors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "sponsors", value)

    @property
    @pulumi.getter(name="ssoDefaultRole")
    def sso_default_role(self) -> Optional[pulumi.Input[str]]:
        """
        default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        """
        return pulumi.get(self, "sso_default_role")

    @sso_default_role.setter
    def sso_default_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_default_role", value)

    @property
    @pulumi.getter(name="ssoForcedRole")
    def sso_forced_role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sso_forced_role")

    @sso_forced_role.setter
    def sso_forced_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_forced_role", value)

    @property
    @pulumi.getter(name="ssoIdpCert")
    def sso_idp_cert(self) -> Optional[pulumi.Input[str]]:
        """
        IDP Cert (used to verify the signed response)
        """
        return pulumi.get(self, "sso_idp_cert")

    @sso_idp_cert.setter
    def sso_idp_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_idp_cert", value)

    @property
    @pulumi.getter(name="ssoIdpSignAlgo")
    def sso_idp_sign_algo(self) -> Optional[pulumi.Input[str]]:
        """
        signing algorithm for SAML Assertion
        """
        return pulumi.get(self, "sso_idp_sign_algo")

    @sso_idp_sign_algo.setter
    def sso_idp_sign_algo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_idp_sign_algo", value)

    @property
    @pulumi.getter(name="ssoIdpSsoUrl")
    def sso_idp_sso_url(self) -> Optional[pulumi.Input[str]]:
        """
        IDP Single-Sign-On URL
        """
        return pulumi.get(self, "sso_idp_sso_url")

    @sso_idp_sso_url.setter
    def sso_idp_sso_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_idp_sso_url", value)

    @property
    @pulumi.getter(name="ssoIssuer")
    def sso_issuer(self) -> Optional[pulumi.Input[str]]:
        """
        IDP issuer URL
        """
        return pulumi.get(self, "sso_issuer")

    @sso_issuer.setter
    def sso_issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_issuer", value)

    @property
    @pulumi.getter(name="ssoNameidFormat")
    def sso_nameid_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `email`, `unspecified`
        """
        return pulumi.get(self, "sso_nameid_format")

    @sso_nameid_format.setter
    def sso_nameid_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_nameid_format", value)

    @property
    @pulumi.getter(name="telstraClientId")
    def telstra_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`telstra`, Client ID provided by Telstra
        """
        return pulumi.get(self, "telstra_client_id")

    @telstra_client_id.setter
    def telstra_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "telstra_client_id", value)

    @property
    @pulumi.getter(name="telstraClientSecret")
    def telstra_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`telstra`, Client secret provided by Telstra
        """
        return pulumi.get(self, "telstra_client_secret")

    @telstra_client_secret.setter
    def telstra_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "telstra_client_secret", value)

    @property
    @pulumi.getter(name="twilioAuthToken")
    def twilio_auth_token(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`twilio`, Auth token account with twilio account
        """
        return pulumi.get(self, "twilio_auth_token")

    @twilio_auth_token.setter
    def twilio_auth_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "twilio_auth_token", value)

    @property
    @pulumi.getter(name="twilioPhoneNumber")
    def twilio_phone_number(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        """
        return pulumi.get(self, "twilio_phone_number")

    @twilio_phone_number.setter
    def twilio_phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "twilio_phone_number", value)

    @property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> Optional[pulumi.Input[str]]:
        """
        when `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        return pulumi.get(self, "twilio_sid")

    @twilio_sid.setter
    def twilio_sid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "twilio_sid", value)


@pulumi.input_type
class WlanQosArgs:
    def __init__(__self__, *,
                 class_: Optional[pulumi.Input[str]] = None,
                 overwrite: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] class_: enum: `background`, `best_effort`, `video`, `voice`
        :param pulumi.Input[bool] overwrite: whether to overwrite QoS
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `background`, `best_effort`, `video`, `voice`
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to overwrite QoS
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "overwrite", value)


@pulumi.input_type
class WlanRadsecArgs:
    def __init__(__self__, *,
                 coa_enabled: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 idle_timeout: Optional[pulumi.Input[int]] = None,
                 mxcluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_name: Optional[pulumi.Input[str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]]] = None,
                 use_mxedge: Optional[pulumi.Input[bool]] = None,
                 use_site_mxedge: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
               Org mxedge(s) identified by mxcluster_ids
        :param pulumi.Input[Sequence[pulumi.Input[str]]] proxy_hosts: default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
               when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
        :param pulumi.Input[str] server_name: name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]] servers: List of Radsec Servers. Only if not Mist Edge.
        :param pulumi.Input[bool] use_mxedge: use mxedge(s) as radsecproxy
        :param pulumi.Input[bool] use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if mxcluster_ids is not None:
            pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        if proxy_hosts is not None:
            pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if use_mxedge is not None:
            pulumi.set(__self__, "use_mxedge", use_mxedge)
        if use_site_mxedge is not None:
            pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "coa_enabled")

    @coa_enabled.setter
    def coa_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "coa_enabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
        Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @mxcluster_ids.setter
    def mxcluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mxcluster_ids", value)

    @property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
        when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
        """
        return pulumi.get(self, "proxy_hosts")

    @proxy_hosts.setter
    def proxy_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "proxy_hosts", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_name", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]]]:
        """
        List of Radsec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WlanRadsecServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> Optional[pulumi.Input[bool]]:
        """
        use mxedge(s) as radsecproxy
        """
        return pulumi.get(self, "use_mxedge")

    @use_mxedge.setter
    def use_mxedge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mxedge", value)

    @property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> Optional[pulumi.Input[bool]]:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")

    @use_site_mxedge.setter
    def use_site_mxedge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_site_mxedge", value)


@pulumi.input_type
class WlanRadsecServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class WlanScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input['WlanScheduleHoursArgs']] = None):
        """
        :param pulumi.Input['WlanScheduleHoursArgs'] hours: hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
               
               **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input['WlanScheduleHoursArgs']]:
        """
        hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 

        **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input['WlanScheduleHoursArgs']]):
        pulumi.set(self, "hours", value)


@pulumi.input_type
class WlanScheduleHoursArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[str]] = None,
                 mon: Optional[pulumi.Input[str]] = None,
                 sat: Optional[pulumi.Input[str]] = None,
                 sun: Optional[pulumi.Input[str]] = None,
                 thu: Optional[pulumi.Input[str]] = None,
                 tue: Optional[pulumi.Input[str]] = None,
                 wed: Optional[pulumi.Input[str]] = None):
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fri", value)

    @property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mon", value)

    @property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sat", value)

    @property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sun", value)

    @property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thu", value)

    @property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tue", value)

    @property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wed", value)


@pulumi.input_type
class WxtagSpecArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: matched destination subnets and/or IP Addresses
        :param pulumi.Input[str] port_range: matched destination port, "0" means any
        :param pulumi.Input[str] protocol: tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        pulumi.set(__self__, "subnets", subnets)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        matched destination subnets and/or IP Addresses
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        matched destination port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class BaseLatlngArgs:
    def __init__(__self__, *,
                 lat: pulumi.Input[float],
                 lng: pulumi.Input[float]):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @property
    @pulumi.getter
    def lat(self) -> pulumi.Input[float]:
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: pulumi.Input[float]):
        pulumi.set(self, "lat", value)

    @property
    @pulumi.getter
    def lng(self) -> pulumi.Input[float]:
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: pulumi.Input[float]):
        pulumi.set(self, "lng", value)


