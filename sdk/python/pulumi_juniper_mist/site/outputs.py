# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'NetworktemplateAclPolicy',
    'NetworktemplateAclPolicyAction',
    'NetworktemplateAclTags',
    'NetworktemplateAclTagsSpec',
    'NetworktemplateDhcpSnooping',
    'NetworktemplateExtraRoutes6',
    'NetworktemplateExtraRoutes6NextQualified',
    'NetworktemplateExtraRoutes',
    'NetworktemplateExtraRoutesNextQualified',
    'NetworktemplateMistNac',
    'NetworktemplateNetworks',
    'NetworktemplatePortMirroring',
    'NetworktemplatePortUsages',
    'NetworktemplatePortUsagesRule',
    'NetworktemplatePortUsagesStormControl',
    'NetworktemplateRadiusConfig',
    'NetworktemplateRadiusConfigAcctServer',
    'NetworktemplateRadiusConfigAuthServer',
    'NetworktemplateRemoteSyslog',
    'NetworktemplateRemoteSyslogArchive',
    'NetworktemplateRemoteSyslogConsole',
    'NetworktemplateRemoteSyslogConsoleContent',
    'NetworktemplateRemoteSyslogFile',
    'NetworktemplateRemoteSyslogFileArchive',
    'NetworktemplateRemoteSyslogFileContent',
    'NetworktemplateRemoteSyslogServer',
    'NetworktemplateRemoteSyslogServerContent',
    'NetworktemplateRemoteSyslogUser',
    'NetworktemplateRemoteSyslogUserContent',
    'NetworktemplateSnmpConfig',
    'NetworktemplateSnmpConfigClientList',
    'NetworktemplateSnmpConfigTrapGroup',
    'NetworktemplateSnmpConfigV2cConfig',
    'NetworktemplateSnmpConfigV3Config',
    'NetworktemplateSnmpConfigV3ConfigNotify',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilter',
    'NetworktemplateSnmpConfigV3ConfigNotifyFilterContent',
    'NetworktemplateSnmpConfigV3ConfigTargetAddress',
    'NetworktemplateSnmpConfigV3ConfigTargetParameter',
    'NetworktemplateSnmpConfigV3ConfigUsm',
    'NetworktemplateSnmpConfigV3ConfigUsmUser',
    'NetworktemplateSnmpConfigV3ConfigVacm',
    'NetworktemplateSnmpConfigV3ConfigVacmAccess',
    'NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup',
    'NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent',
    'NetworktemplateSnmpConfigView',
    'NetworktemplateSwitchMatching',
    'NetworktemplateSwitchMatchingRule',
    'NetworktemplateSwitchMatchingRuleIpConfig',
    'NetworktemplateSwitchMatchingRuleOobIpConfig',
    'NetworktemplateSwitchMatchingRulePortConfig',
    'NetworktemplateSwitchMatchingRulePortMirroring',
    'NetworktemplateSwitchMgmt',
    'NetworktemplateSwitchMgmtLocalAccounts',
    'NetworktemplateSwitchMgmtProtectRe',
    'NetworktemplateSwitchMgmtProtectReCustom',
    'NetworktemplateSwitchMgmtTacacs',
    'NetworktemplateSwitchMgmtTacacsAcctServer',
    'NetworktemplateSwitchMgmtTacacsTacplusServer',
    'NetworktemplateUplinkPortConfig',
    'NetworktemplateVrfConfig',
    'NetworktemplateVrfInstances',
    'NetworktemplateVrfInstancesExtraRoutes',
    'SettingAnalytic',
    'SettingAutoUpgrade',
    'SettingBleConfig',
    'SettingConfigPushPolicy',
    'SettingConfigPushPolicyPushWindow',
    'SettingConfigPushPolicyPushWindowHours',
    'SettingCriticalUrlMonitoring',
    'SettingCriticalUrlMonitoringMonitor',
    'SettingEngagement',
    'SettingEngagementDwellTagNames',
    'SettingEngagementDwellTags',
    'SettingEngagementHours',
    'SettingGatewayMgmt',
    'SettingGatewayMgmtAppProbing',
    'SettingGatewayMgmtAppProbingCustomApp',
    'SettingGatewayMgmtAutoSignatureUpdate',
    'SettingLed',
    'SettingOccupancy',
    'SettingProxy',
    'SettingRogue',
    'SettingRtsa',
    'SettingSimpleAlert',
    'SettingSimpleAlertArpFailure',
    'SettingSimpleAlertDhcpFailure',
    'SettingSimpleAlertDnsFailure',
    'SettingSkyatp',
    'SettingSrxApp',
    'SettingSsr',
    'SettingSyntheticTest',
    'SettingSyntheticTestVlan',
    'SettingSyntheticTestWanSpeedtest',
    'SettingUplinkPortConfig',
    'SettingVna',
    'SettingVsInstance',
    'SettingWanVna',
    'SettingWids',
    'SettingWidsRepeatedAuthFailures',
    'SettingWifi',
    'SettingWiredVna',
    'SettingZoneOccupancyAlert',
    'WlanAcctServer',
    'WlanAirwatch',
    'WlanAppLimit',
    'WlanAppQos',
    'WlanAppQosApps',
    'WlanAppQosOther',
    'WlanAuth',
    'WlanAuthServer',
    'WlanBonjour',
    'WlanBonjourServices',
    'WlanCiscoCwa',
    'WlanCoaServer',
    'WlanDnsServerRewrite',
    'WlanDynamicPsk',
    'WlanDynamicVlan',
    'WlanHotspot20',
    'WlanInjectDhcpOption82',
    'WlanMistNac',
    'WlanPortal',
    'WlanPortalTemplatePortalTemplate',
    'WlanPortalTemplatePortalTemplateLocales',
    'WlanQos',
    'WlanRadsec',
    'WlanRadsecServer',
    'WlanSchedule',
    'WlanScheduleHours',
    'WxtagSpec',
    'BaseLatlng',
    'GetPsksSitePskResult',
    'GetWebhooksSiteWebhookResult',
]

@pulumi.output_type
class NetworktemplateAclPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "srcTags":
            suggest = "src_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.NetworktemplateAclPolicyAction']] = None,
                 name: Optional[str] = None,
                 src_tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['NetworktemplateAclPolicyActionArgs'] actions: - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
               - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        :param Sequence[str] src_tags: - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
               - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_tags is not None:
            pulumi.set(__self__, "src_tags", src_tags)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.NetworktemplateAclPolicyAction']]:
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="srcTags")
    def src_tags(self) -> Optional[Sequence[str]]:
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "src_tags")


@pulumi.output_type
class NetworktemplateAclPolicyAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstTag":
            suggest = "dst_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclPolicyAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclPolicyAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclPolicyAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dst_tag: str,
                 action: Optional[str] = None):
        """
        :param str action: enum: `allow`, `deny`
        """
        pulumi.set(__self__, "dst_tag", dst_tag)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="dstTag")
    def dst_tag(self) -> str:
        return pulumi.get(self, "dst_tag")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class NetworktemplateAclTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gbpTag":
            suggest = "gbp_tag"
        elif key == "radiusGroup":
            suggest = "radius_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 gbp_tag: Optional[int] = None,
                 macs: Optional[Sequence[str]] = None,
                 network: Optional[str] = None,
                 radius_group: Optional[str] = None,
                 specs: Optional[Sequence['outputs.NetworktemplateAclTagsSpec']] = None,
                 subnets: Optional[Sequence[str]] = None):
        """
        :param str type: enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
        :param int gbp_tag: required if
               - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
               - `type`==`static_gbp` (applying gbp tag against matching conditions)
        :param Sequence[str] macs: required if 
               - `type`==`mac`
               - `type`==`static_gbp` if from matching mac
        :param str network: if:
                 * `type`==`mac` (optional. default is `any`)
                 * `type`==`subnet` (optional. default is `any`)
                 * `type`==`network`
                 * `type`==`resource` (optional. default is `any`)
                 * `type`==`static_gbp` if from matching network (vlan)'
        :param str radius_group: required if:
                 * `type`==`radius_group`
                 * `type`==`static_gbp`
               if from matching radius_group
        :param Sequence['NetworktemplateAclTagsSpecArgs'] specs: if `type`==`resource`
               empty means unrestricted, i.e. any
        :param Sequence[str] subnets: if 
               - `type`==`subnet` 
               - `type`==`resource` (optional. default is `any`)
               - `type`==`static_gbp` if from matching subnet
        """
        pulumi.set(__self__, "type", type)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if macs is not None:
            pulumi.set(__self__, "macs", macs)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[int]:
        """
        required if
        - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
        - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        return pulumi.get(self, "gbp_tag")

    @property
    @pulumi.getter
    def macs(self) -> Optional[Sequence[str]]:
        """
        required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        return pulumi.get(self, "macs")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        if:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)'
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[str]:
        """
        required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        return pulumi.get(self, "radius_group")

    @property
    @pulumi.getter
    def specs(self) -> Optional[Sequence['outputs.NetworktemplateAclTagsSpec']]:
        """
        if `type`==`resource`
        empty means unrestricted, i.e. any
        """
        return pulumi.get(self, "specs")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        if 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class NetworktemplateAclTagsSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateAclTagsSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateAclTagsSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateAclTagsSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str port_range: matched dst port, "0" means any
        :param str protocol: `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class NetworktemplateDhcpSnooping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "enableArpSpoofCheck":
            suggest = "enable_arp_spoof_check"
        elif key == "enableIpSourceGuard":
            suggest = "enable_ip_source_guard"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateDhcpSnooping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateDhcpSnooping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateDhcpSnooping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_networks: Optional[bool] = None,
                 enable_arp_spoof_check: Optional[bool] = None,
                 enable_ip_source_guard: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 networks: Optional[Sequence[str]] = None):
        """
        :param bool enable_arp_spoof_check: Enable for dynamic ARP inspection check
        :param bool enable_ip_source_guard: Enable for check for forging source IP address
        :param Sequence[str] networks: if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_ip_source_guard is not None:
            pulumi.set(__self__, "enable_ip_source_guard", enable_ip_source_guard)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[bool]:
        return pulumi.get(self, "all_networks")

    @property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[bool]:
        """
        Enable for dynamic ARP inspection check
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @property
    @pulumi.getter(name="enableIpSourceGuard")
    def enable_ip_source_guard(self) -> Optional[bool]:
        """
        Enable for check for forging source IP address
        """
        return pulumi.get(self, "enable_ip_source_guard")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[str]]:
        """
        if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class NetworktemplateExtraRoutes6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextQualified":
            suggest = "next_qualified"
        elif key == "noResolve":
            suggest = "no_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateExtraRoutes6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateExtraRoutes6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateExtraRoutes6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: str,
                 discard: Optional[bool] = None,
                 metric: Optional[int] = None,
                 next_qualified: Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutes6NextQualified']] = None,
                 no_resolve: Optional[bool] = None,
                 preference: Optional[int] = None):
        """
        :param str via: next-hop IP Address
        :param bool discard: this takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> str:
        """
        next-hop IP Address
        """
        return pulumi.get(self, "via")

    @property
    @pulumi.getter
    def discard(self) -> Optional[bool]:
        """
        this takes precedence
        """
        return pulumi.get(self, "discard")

    @property
    @pulumi.getter
    def metric(self) -> Optional[int]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutes6NextQualified']]:
        return pulumi.get(self, "next_qualified")

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[bool]:
        return pulumi.get(self, "no_resolve")

    @property
    @pulumi.getter
    def preference(self) -> Optional[int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateExtraRoutes6NextQualified(dict):
    def __init__(__self__, *,
                 metric: Optional[int] = None,
                 preference: Optional[int] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[int]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def preference(self) -> Optional[int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateExtraRoutes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextQualified":
            suggest = "next_qualified"
        elif key == "noResolve":
            suggest = "no_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateExtraRoutes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateExtraRoutes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateExtraRoutes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: str,
                 discard: Optional[bool] = None,
                 metric: Optional[int] = None,
                 next_qualified: Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutesNextQualified']] = None,
                 no_resolve: Optional[bool] = None,
                 preference: Optional[int] = None):
        """
        :param str via: next-hop IP Address
        :param bool discard: this takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> str:
        """
        next-hop IP Address
        """
        return pulumi.get(self, "via")

    @property
    @pulumi.getter
    def discard(self) -> Optional[bool]:
        """
        this takes precedence
        """
        return pulumi.get(self, "discard")

    @property
    @pulumi.getter
    def metric(self) -> Optional[int]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[Mapping[str, 'outputs.NetworktemplateExtraRoutesNextQualified']]:
        return pulumi.get(self, "next_qualified")

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[bool]:
        return pulumi.get(self, "no_resolve")

    @property
    @pulumi.getter
    def preference(self) -> Optional[int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateExtraRoutesNextQualified(dict):
    def __init__(__self__, *,
                 metric: Optional[int] = None,
                 preference: Optional[int] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[int]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def preference(self) -> Optional[int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class NetworktemplateMistNac(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 network: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")


@pulumi.output_type
class NetworktemplateNetworks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"
        elif key == "isolationVlanId":
            suggest = "isolation_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateNetworks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateNetworks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateNetworks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_id: str,
                 isolation: Optional[bool] = None,
                 isolation_vlan_id: Optional[str] = None,
                 subnet: Optional[str] = None):
        """
        :param bool isolation: whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
               NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        :param str subnet: optional for pure switching, required when L3 / routing features are used
        """
        pulumi.set(__self__, "vlan_id", vlan_id)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if isolation_vlan_id is not None:
            pulumi.set(__self__, "isolation_vlan_id", isolation_vlan_id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter
    def isolation(self) -> Optional[bool]:
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
        NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        """
        return pulumi.get(self, "isolation")

    @property
    @pulumi.getter(name="isolationVlanId")
    def isolation_vlan_id(self) -> Optional[str]:
        return pulumi.get(self, "isolation_vlan_id")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class NetworktemplatePortMirroring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputNetworksIngresses":
            suggest = "input_networks_ingresses"
        elif key == "inputPortIdsEgresses":
            suggest = "input_port_ids_egresses"
        elif key == "inputPortIdsIngresses":
            suggest = "input_port_ids_ingresses"
        elif key == "outputNetwork":
            suggest = "output_network"
        elif key == "outputPortId":
            suggest = "output_port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortMirroring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortMirroring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortMirroring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_networks_ingresses: Optional[Sequence[str]] = None,
                 input_port_ids_egresses: Optional[Sequence[str]] = None,
                 input_port_ids_ingresses: Optional[Sequence[str]] = None,
                 output_network: Optional[str] = None,
                 output_port_id: Optional[str] = None):
        """
        :param Sequence[str] input_networks_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[str] input_port_ids_egresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[str] input_port_ids_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param str output_network: exaclty one of the `output_port_id` or `output_network` should be provided
        :param str output_port_id: exaclty one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[Sequence[str]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[Sequence[str]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[Sequence[str]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[str]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[str]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")


@pulumi.output_type
class NetworktemplatePortUsages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "allowDhcpd":
            suggest = "allow_dhcpd"
        elif key == "allowMultipleSupplicants":
            suggest = "allow_multiple_supplicants"
        elif key == "bypassAuthWhenServerDown":
            suggest = "bypass_auth_when_server_down"
        elif key == "bypassAuthWhenServerDownForUnkonwnClient":
            suggest = "bypass_auth_when_server_down_for_unkonwn_client"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicVlanNetworks":
            suggest = "dynamic_vlan_networks"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "enableQos":
            suggest = "enable_qos"
        elif key == "guestNetwork":
            suggest = "guest_network"
        elif key == "interSwitchLink":
            suggest = "inter_switch_link"
        elif key == "macAuthOnly":
            suggest = "mac_auth_only"
        elif key == "macAuthPreferred":
            suggest = "mac_auth_preferred"
        elif key == "macAuthProtocol":
            suggest = "mac_auth_protocol"
        elif key == "macLimit":
            suggest = "mac_limit"
        elif key == "persistMac":
            suggest = "persist_mac"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portAuth":
            suggest = "port_auth"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "reauthInterval":
            suggest = "reauth_interval"
        elif key == "resetDefaultWhen":
            suggest = "reset_default_when"
        elif key == "serverFailNetwork":
            suggest = "server_fail_network"
        elif key == "serverRejectNetwork":
            suggest = "server_reject_network"
        elif key == "stormControl":
            suggest = "storm_control"
        elif key == "stpEdge":
            suggest = "stp_edge"
        elif key == "stpNoRootPort":
            suggest = "stp_no_root_port"
        elif key == "stpP2p":
            suggest = "stp_p2p"
        elif key == "voipNetwork":
            suggest = "voip_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortUsages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortUsages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortUsages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_networks: Optional[bool] = None,
                 allow_dhcpd: Optional[bool] = None,
                 allow_multiple_supplicants: Optional[bool] = None,
                 bypass_auth_when_server_down: Optional[bool] = None,
                 bypass_auth_when_server_down_for_unkonwn_client: Optional[bool] = None,
                 description: Optional[str] = None,
                 disable_autoneg: Optional[bool] = None,
                 disabled: Optional[bool] = None,
                 duplex: Optional[str] = None,
                 dynamic_vlan_networks: Optional[Sequence[str]] = None,
                 enable_mac_auth: Optional[bool] = None,
                 enable_qos: Optional[bool] = None,
                 guest_network: Optional[str] = None,
                 inter_switch_link: Optional[bool] = None,
                 mac_auth_only: Optional[bool] = None,
                 mac_auth_preferred: Optional[bool] = None,
                 mac_auth_protocol: Optional[str] = None,
                 mac_limit: Optional[int] = None,
                 mode: Optional[str] = None,
                 mtu: Optional[int] = None,
                 networks: Optional[Sequence[str]] = None,
                 persist_mac: Optional[bool] = None,
                 poe_disabled: Optional[bool] = None,
                 port_auth: Optional[str] = None,
                 port_network: Optional[str] = None,
                 reauth_interval: Optional[int] = None,
                 reset_default_when: Optional[str] = None,
                 rules: Optional[Sequence['outputs.NetworktemplatePortUsagesRule']] = None,
                 server_fail_network: Optional[str] = None,
                 server_reject_network: Optional[str] = None,
                 speed: Optional[str] = None,
                 storm_control: Optional['outputs.NetworktemplatePortUsagesStormControl'] = None,
                 stp_edge: Optional[bool] = None,
                 stp_no_root_port: Optional[bool] = None,
                 stp_p2p: Optional[bool] = None,
                 voip_network: Optional[str] = None):
        """
        :param bool all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param bool allow_dhcpd: Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
               
               When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        :param bool allow_multiple_supplicants: Only if `mode`!=`dynamic`
        :param bool bypass_auth_when_server_down: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param bool bypass_auth_when_server_down_for_unkonwn_client: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param str description: Only if `mode`!=`dynamic`
        :param bool disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param bool disabled: Only if `mode`!=`dynamic` whether the port is disabled
        :param str duplex: Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        :param Sequence[str] dynamic_vlan_networks: Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param bool enable_mac_auth: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        :param bool enable_qos: Only if `mode`!=`dynamic`
        :param str guest_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param bool inter_switch_link: Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
               NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param bool mac_auth_only: Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        :param bool mac_auth_preferred: Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        :param str mac_auth_protocol: Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param int mac_limit: Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        :param str mode: `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        :param int mtu: Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        :param Sequence[str] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param bool persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param bool poe_disabled: Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        :param str port_auth: Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        :param str port_network: Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        :param int reauth_interval: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        :param str reset_default_when: Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        :param Sequence['NetworktemplatePortUsagesRuleArgs'] rules: Only if `mode`==`dynamic`
        :param str server_fail_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        :param str server_reject_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        :param str speed: Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        :param 'NetworktemplatePortUsagesStormControlArgs' storm_control: Switch storm control
               Only if `mode`!=`dynamic`
        :param bool stp_edge: Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        :param str voip_network: Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unkonwn_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unkonwn_client", bypass_auth_when_server_down_for_unkonwn_client)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if reset_default_when is not None:
            pulumi.set(__self__, "reset_default_when", reset_default_when)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if server_fail_network is not None:
            pulumi.set(__self__, "server_fail_network", server_fail_network)
        if server_reject_network is not None:
            pulumi.set(__self__, "server_reject_network", server_reject_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if stp_no_root_port is not None:
            pulumi.set(__self__, "stp_no_root_port", stp_no_root_port)
        if stp_p2p is not None:
            pulumi.set(__self__, "stp_p2p", stp_p2p)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[bool]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.

        When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "allow_multiple_supplicants")

    @property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnkonwnClient")
    def bypass_auth_when_server_down_for_unkonwn_client(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unkonwn_client")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def duplex(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[Sequence[str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "enable_qos")

    @property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
        NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        return pulumi.get(self, "mac_auth_preferred")

    @property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[int]:
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        """
        return pulumi.get(self, "mac_limit")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[str]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[bool]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[int]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        """
        return pulumi.get(self, "reauth_interval")

    @property
    @pulumi.getter(name="resetDefaultWhen")
    def reset_default_when(self) -> Optional[str]:
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        return pulumi.get(self, "reset_default_when")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.NetworktemplatePortUsagesRule']]:
        """
        Only if `mode`==`dynamic`
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serverFailNetwork")
    def server_fail_network(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        return pulumi.get(self, "server_fail_network")

    @property
    @pulumi.getter(name="serverRejectNetwork")
    def server_reject_network(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "server_reject_network")

    @property
    @pulumi.getter
    def speed(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional['outputs.NetworktemplatePortUsagesStormControl']:
        """
        Switch storm control
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "storm_control")

    @property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[bool]:
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @property
    @pulumi.getter(name="stpNoRootPort")
    def stp_no_root_port(self) -> Optional[bool]:
        return pulumi.get(self, "stp_no_root_port")

    @property
    @pulumi.getter(name="stpP2p")
    def stp_p2p(self) -> Optional[bool]:
        return pulumi.get(self, "stp_p2p")

    @property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[str]:
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")


@pulumi.output_type
class NetworktemplatePortUsagesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "equalsAnies":
            suggest = "equals_anies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortUsagesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortUsagesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortUsagesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 src: str,
                 equals: Optional[str] = None,
                 equals_anies: Optional[Sequence[str]] = None,
                 expression: Optional[str] = None,
                 usage: Optional[str] = None):
        """
        :param str src: enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        :param Sequence[str] equals_anies: use `equals_any` to match any item in a list
        :param str expression: "[0:3]":"abcdef" > "abc"
               "split(.)[1]": "a.b.c" > "b"
               "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        :param str usage: `port_usage` name
        """
        pulumi.set(__self__, "src", src)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if equals_anies is not None:
            pulumi.set(__self__, "equals_anies", equals_anies)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def src(self) -> str:
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        return pulumi.get(self, "src")

    @property
    @pulumi.getter
    def equals(self) -> Optional[str]:
        return pulumi.get(self, "equals")

    @property
    @pulumi.getter(name="equalsAnies")
    def equals_anies(self) -> Optional[Sequence[str]]:
        """
        use `equals_any` to match any item in a list
        """
        return pulumi.get(self, "equals_anies")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        """
        `port_usage` name
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class NetworktemplatePortUsagesStormControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noBroadcast":
            suggest = "no_broadcast"
        elif key == "noMulticast":
            suggest = "no_multicast"
        elif key == "noRegisteredMulticast":
            suggest = "no_registered_multicast"
        elif key == "noUnknownUnicast":
            suggest = "no_unknown_unicast"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplatePortUsagesStormControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplatePortUsagesStormControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplatePortUsagesStormControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_broadcast: Optional[bool] = None,
                 no_multicast: Optional[bool] = None,
                 no_registered_multicast: Optional[bool] = None,
                 no_unknown_unicast: Optional[bool] = None,
                 percentage: Optional[int] = None):
        """
        :param bool no_broadcast: whether to disable storm control on broadcast traffic
        :param bool no_multicast: whether to disable storm control on multicast traffic
        :param bool no_registered_multicast: whether to disable storm control on registered multicast traffic
        :param bool no_unknown_unicast: whether to disable storm control on unknown unicast traffic
        :param int percentage: bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[bool]:
        """
        whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[bool]:
        """
        whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[bool]:
        """
        whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[bool]:
        """
        whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[int]:
        """
        bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class NetworktemplateRadiusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "acctServers":
            suggest = "acct_servers"
        elif key == "authServers":
            suggest = "auth_servers"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRadiusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRadiusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRadiusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_interim_interval: Optional[int] = None,
                 acct_servers: Optional[Sequence['outputs.NetworktemplateRadiusConfigAcctServer']] = None,
                 auth_servers: Optional[Sequence['outputs.NetworktemplateRadiusConfigAuthServer']] = None,
                 auth_servers_retries: Optional[int] = None,
                 auth_servers_timeout: Optional[int] = None,
                 coa_enabled: Optional[bool] = None,
                 coa_port: Optional[int] = None,
                 network: Optional[str] = None,
                 source_ip: Optional[str] = None):
        """
        :param int acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param int auth_servers_retries: radius auth session retries
        :param int auth_servers_timeout: radius auth session timeout
        :param str network: use `network`or `source_ip`
               which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param str source_ip: use `network`or `source_ip`
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[int]:
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.NetworktemplateRadiusConfigAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[Sequence['outputs.NetworktemplateRadiusConfigAuthServer']]:
        return pulumi.get(self, "auth_servers")

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[int]:
        """
        radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[int]:
        """
        radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "coa_enabled")

    @property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[int]:
        return pulumi.get(self, "coa_port")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        use `network`or `source_ip`
        which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        """
        use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class NetworktemplateRadiusConfigAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRadiusConfigAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRadiusConfigAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRadiusConfigAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 secret: str,
                 keywrap_enabled: Optional[bool] = None,
                 keywrap_format: Optional[str] = None,
                 keywrap_kek: Optional[str] = None,
                 keywrap_mack: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: ip / hostname of RADIUS server
        :param str secret: secret of RADIUS server
        :param str keywrap_format: enum: `ascii`, `hex`
        :param int port: Acct port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "keywrap_enabled")

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_kek")

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_mack")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Acct port of RADIUS server
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworktemplateRadiusConfigAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"
        elif key == "requireMessageAuthenticator":
            suggest = "require_message_authenticator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRadiusConfigAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRadiusConfigAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRadiusConfigAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 secret: str,
                 keywrap_enabled: Optional[bool] = None,
                 keywrap_format: Optional[str] = None,
                 keywrap_kek: Optional[str] = None,
                 keywrap_mack: Optional[str] = None,
                 port: Optional[int] = None,
                 require_message_authenticator: Optional[bool] = None):
        """
        :param str host: ip / hostname of RADIUS server
        :param str secret: secret of RADIUS server
        :param str keywrap_format: enum: `ascii`, `hex`
        :param int port: Auth port of RADIUS server
        :param bool require_message_authenticator: whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "keywrap_enabled")

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_kek")

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_mack")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Auth port of RADIUS server
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[bool]:
        """
        whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")


@pulumi.output_type
class NetworktemplateRemoteSyslog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendToAllServers":
            suggest = "send_to_all_servers"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRemoteSyslog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRemoteSyslog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRemoteSyslog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional['outputs.NetworktemplateRemoteSyslogArchive'] = None,
                 console: Optional['outputs.NetworktemplateRemoteSyslogConsole'] = None,
                 enabled: Optional[bool] = None,
                 files: Optional[Sequence['outputs.NetworktemplateRemoteSyslogFile']] = None,
                 network: Optional[str] = None,
                 send_to_all_servers: Optional[bool] = None,
                 servers: Optional[Sequence['outputs.NetworktemplateRemoteSyslogServer']] = None,
                 time_format: Optional[str] = None,
                 users: Optional[Sequence['outputs.NetworktemplateRemoteSyslogUser']] = None):
        """
        :param str network: if source_address is configured, will use the vlan firstly otherwise use source_ip
        :param str time_format: enum: `millisecond`, `year`, `year millisecond`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if console is not None:
            pulumi.set(__self__, "console", console)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if send_to_all_servers is not None:
            pulumi.set(__self__, "send_to_all_servers", send_to_all_servers)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def archive(self) -> Optional['outputs.NetworktemplateRemoteSyslogArchive']:
        return pulumi.get(self, "archive")

    @property
    @pulumi.getter
    def console(self) -> Optional['outputs.NetworktemplateRemoteSyslogConsole']:
        return pulumi.get(self, "console")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogFile']]:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="sendToAllServers")
    def send_to_all_servers(self) -> Optional[bool]:
        return pulumi.get(self, "send_to_all_servers")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogServer']]:
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[str]:
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        return pulumi.get(self, "time_format")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class NetworktemplateRemoteSyslogArchive(dict):
    def __init__(__self__, *,
                 files: Optional[int] = None,
                 size: Optional[str] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[int]:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")


@pulumi.output_type
class NetworktemplateRemoteSyslogConsole(dict):
    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogConsoleContent']] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogConsoleContent']]:
        return pulumi.get(self, "contents")


@pulumi.output_type
class NetworktemplateRemoteSyslogConsoleContent(dict):
    def __init__(__self__, *,
                 facility: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        :param str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateRemoteSyslogFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "explicitPriority":
            suggest = "explicit_priority"
        elif key == "structuredData":
            suggest = "structured_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRemoteSyslogFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRemoteSyslogFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRemoteSyslogFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional['outputs.NetworktemplateRemoteSyslogFileArchive'] = None,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogFileContent']] = None,
                 explicit_priority: Optional[bool] = None,
                 file: Optional[str] = None,
                 match: Optional[str] = None,
                 structured_data: Optional[bool] = None):
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)

    @property
    @pulumi.getter
    def archive(self) -> Optional['outputs.NetworktemplateRemoteSyslogFileArchive']:
        return pulumi.get(self, "archive")

    @property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogFileContent']]:
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[bool]:
        return pulumi.get(self, "explicit_priority")

    @property
    @pulumi.getter
    def file(self) -> Optional[str]:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[bool]:
        return pulumi.get(self, "structured_data")


@pulumi.output_type
class NetworktemplateRemoteSyslogFileArchive(dict):
    def __init__(__self__, *,
                 files: Optional[int] = None,
                 size: Optional[str] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[int]:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")


@pulumi.output_type
class NetworktemplateRemoteSyslogFileContent(dict):
    def __init__(__self__, *,
                 facility: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        :param str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateRemoteSyslogServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "explicitPriority":
            suggest = "explicit_priority"
        elif key == "routingInstance":
            suggest = "routing_instance"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "structuredData":
            suggest = "structured_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateRemoteSyslogServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateRemoteSyslogServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateRemoteSyslogServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogServerContent']] = None,
                 explicit_priority: Optional[bool] = None,
                 facility: Optional[str] = None,
                 host: Optional[str] = None,
                 match: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 routing_instance: Optional[str] = None,
                 severity: Optional[str] = None,
                 source_address: Optional[str] = None,
                 structured_data: Optional[bool] = None,
                 tag: Optional[str] = None):
        """
        :param str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param str protocol: enum: `tcp`, `udp`
        :param str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        :param str source_address: if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routing_instance is not None:
            pulumi.set(__self__, "routing_instance", routing_instance)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogServerContent']]:
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[bool]:
        return pulumi.get(self, "explicit_priority")

    @property
    @pulumi.getter
    def facility(self) -> Optional[str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        enum: `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="routingInstance")
    def routing_instance(self) -> Optional[str]:
        return pulumi.get(self, "routing_instance")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[str]:
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "source_address")

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[bool]:
        return pulumi.get(self, "structured_data")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class NetworktemplateRemoteSyslogServerContent(dict):
    def __init__(__self__, *,
                 facility: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        :param str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateRemoteSyslogUser(dict):
    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateRemoteSyslogUserContent']] = None,
                 match: Optional[str] = None,
                 user: Optional[str] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateRemoteSyslogUserContent']]:
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class NetworktemplateRemoteSyslogUserContent(dict):
    def __init__(__self__, *,
                 facility: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        :param str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NetworktemplateSnmpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientLists":
            suggest = "client_lists"
        elif key == "engineId":
            suggest = "engine_id"
        elif key == "trapGroups":
            suggest = "trap_groups"
        elif key == "v2cConfigs":
            suggest = "v2c_configs"
        elif key == "v3Config":
            suggest = "v3_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_lists: Optional[Sequence['outputs.NetworktemplateSnmpConfigClientList']] = None,
                 contact: Optional[str] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 engine_id: Optional[str] = None,
                 location: Optional[str] = None,
                 name: Optional[str] = None,
                 network: Optional[str] = None,
                 trap_groups: Optional[Sequence['outputs.NetworktemplateSnmpConfigTrapGroup']] = None,
                 v2c_configs: Optional[Sequence['outputs.NetworktemplateSnmpConfigV2cConfig']] = None,
                 v3_config: Optional['outputs.NetworktemplateSnmpConfigV3Config'] = None,
                 views: Optional[Sequence['outputs.NetworktemplateSnmpConfigView']] = None):
        """
        :param str engine_id: enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        if client_lists is not None:
            pulumi.set(__self__, "client_lists", client_lists)
        if contact is not None:
            pulumi.set(__self__, "contact", contact)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if trap_groups is not None:
            pulumi.set(__self__, "trap_groups", trap_groups)
        if v2c_configs is not None:
            pulumi.set(__self__, "v2c_configs", v2c_configs)
        if v3_config is not None:
            pulumi.set(__self__, "v3_config", v3_config)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter(name="clientLists")
    def client_lists(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigClientList']]:
        return pulumi.get(self, "client_lists")

    @property
    @pulumi.getter
    def contact(self) -> Optional[str]:
        return pulumi.get(self, "contact")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[str]:
        """
        enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        return pulumi.get(self, "engine_id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="trapGroups")
    def trap_groups(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigTrapGroup']]:
        return pulumi.get(self, "trap_groups")

    @property
    @pulumi.getter(name="v2cConfigs")
    def v2c_configs(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV2cConfig']]:
        return pulumi.get(self, "v2c_configs")

    @property
    @pulumi.getter(name="v3Config")
    def v3_config(self) -> Optional['outputs.NetworktemplateSnmpConfigV3Config']:
        return pulumi.get(self, "v3_config")

    @property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class NetworktemplateSnmpConfigClientList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientListName":
            suggest = "client_list_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigClientList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigClientList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigClientList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_list_name: Optional[str] = None,
                 clients: Optional[Sequence[str]] = None):
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[str]:
        return pulumi.get(self, "client_list_name")

    @property
    @pulumi.getter
    def clients(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "clients")


@pulumi.output_type
class NetworktemplateSnmpConfigTrapGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigTrapGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigTrapGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigTrapGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Optional[Sequence[str]] = None,
                 group_name: Optional[str] = None,
                 targets: Optional[Sequence[str]] = None,
                 version: Optional[str] = None):
        """
        :param str group_name: Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        :param str version: enum: `all`, `v1`, `v2`
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        enum: `all`, `v1`, `v2`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NetworktemplateSnmpConfigV2cConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientListName":
            suggest = "client_list_name"
        elif key == "communityName":
            suggest = "community_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV2cConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV2cConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV2cConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization: Optional[str] = None,
                 client_list_name: Optional[str] = None,
                 community_name: Optional[str] = None,
                 view: Optional[str] = None):
        """
        :param str client_list_name: client_list_name here should refer to client_list above
        :param str view: view name here should be defined in views above
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[str]:
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[str]:
        """
        client_list_name here should refer to client_list above
        """
        return pulumi.get(self, "client_list_name")

    @property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[str]:
        return pulumi.get(self, "community_name")

    @property
    @pulumi.getter
    def view(self) -> Optional[str]:
        """
        view name here should be defined in views above
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class NetworktemplateSnmpConfigV3Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyFilters":
            suggest = "notify_filters"
        elif key == "targetAddresses":
            suggest = "target_addresses"
        elif key == "targetParameters":
            suggest = "target_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notifies: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotify']] = None,
                 notify_filters: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilter']] = None,
                 target_addresses: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetAddress']] = None,
                 target_parameters: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetParameter']] = None,
                 usm: Optional['outputs.NetworktemplateSnmpConfigV3ConfigUsm'] = None,
                 vacm: Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacm'] = None):
        if notifies is not None:
            pulumi.set(__self__, "notifies", notifies)
        if notify_filters is not None:
            pulumi.set(__self__, "notify_filters", notify_filters)
        if target_addresses is not None:
            pulumi.set(__self__, "target_addresses", target_addresses)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)
        if usm is not None:
            pulumi.set(__self__, "usm", usm)
        if vacm is not None:
            pulumi.set(__self__, "vacm", vacm)

    @property
    @pulumi.getter
    def notifies(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotify']]:
        return pulumi.get(self, "notifies")

    @property
    @pulumi.getter(name="notifyFilters")
    def notify_filters(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilter']]:
        return pulumi.get(self, "notify_filters")

    @property
    @pulumi.getter(name="targetAddresses")
    def target_addresses(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetAddress']]:
        return pulumi.get(self, "target_addresses")

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigTargetParameter']]:
        return pulumi.get(self, "target_parameters")

    @property
    @pulumi.getter
    def usm(self) -> Optional['outputs.NetworktemplateSnmpConfigV3ConfigUsm']:
        return pulumi.get(self, "usm")

    @property
    @pulumi.getter
    def vacm(self) -> Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacm']:
        return pulumi.get(self, "vacm")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigNotify(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 tag: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str type: enum: `inform`, `trap`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        enum: `inform`, `trap`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileName":
            suggest = "profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigNotifyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigNotifyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigNotifyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent']] = None,
                 profile_name: Optional[str] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent']]:
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[str]:
        return pulumi.get(self, "profile_name")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigNotifyFilterContent(dict):
    def __init__(__self__, *,
                 include: Optional[bool] = None,
                 oid: Optional[str] = None):
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)

    @property
    @pulumi.getter
    def include(self) -> Optional[bool]:
        return pulumi.get(self, "include")

    @property
    @pulumi.getter
    def oid(self) -> Optional[str]:
        return pulumi.get(self, "oid")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigTargetAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressMask":
            suggest = "address_mask"
        elif key == "tagList":
            suggest = "tag_list"
        elif key == "targetAddressName":
            suggest = "target_address_name"
        elif key == "targetParameters":
            suggest = "target_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigTargetAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 address_mask: Optional[str] = None,
                 port: Optional[int] = None,
                 tag_list: Optional[str] = None,
                 target_address_name: Optional[str] = None,
                 target_parameters: Optional[str] = None):
        """
        :param str tag_list: <refer to notify tag, can be multiple with blank
        :param str target_parameters: refer to notify target parameters name
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_mask is not None:
            pulumi.set(__self__, "address_mask", address_mask)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if target_address_name is not None:
            pulumi.set(__self__, "target_address_name", target_address_name)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressMask")
    def address_mask(self) -> Optional[str]:
        return pulumi.get(self, "address_mask")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[str]:
        """
        <refer to notify tag, can be multiple with blank
        """
        return pulumi.get(self, "tag_list")

    @property
    @pulumi.getter(name="targetAddressName")
    def target_address_name(self) -> Optional[str]:
        return pulumi.get(self, "target_address_name")

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[str]:
        """
        refer to notify target parameters name
        """
        return pulumi.get(self, "target_parameters")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigTargetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageProcessingModel":
            suggest = "message_processing_model"
        elif key == "notifyFilter":
            suggest = "notify_filter"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "securityModel":
            suggest = "security_model"
        elif key == "securityName":
            suggest = "security_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigTargetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigTargetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_processing_model: Optional[str] = None,
                 name: Optional[str] = None,
                 notify_filter: Optional[str] = None,
                 security_level: Optional[str] = None,
                 security_model: Optional[str] = None,
                 security_name: Optional[str] = None):
        """
        :param str message_processing_model: enum: `v1`, `v2c`, `v3`
        :param str notify_filter: refer to profile-name in notify_filter
        :param str security_level: enum: `authentication`, `none`, `privacy`
        :param str security_model: enum: `usm`, `v1`, `v2c`
        :param str security_name: refer to security_name in usm
        """
        if message_processing_model is not None:
            pulumi.set(__self__, "message_processing_model", message_processing_model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notify_filter is not None:
            pulumi.set(__self__, "notify_filter", notify_filter)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter(name="messageProcessingModel")
    def message_processing_model(self) -> Optional[str]:
        """
        enum: `v1`, `v2c`, `v3`
        """
        return pulumi.get(self, "message_processing_model")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notifyFilter")
    def notify_filter(self) -> Optional[str]:
        """
        refer to profile-name in notify_filter
        """
        return pulumi.get(self, "notify_filter")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[str]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[str]:
        """
        refer to security_name in usm
        """
        return pulumi.get(self, "security_name")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigUsm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engineType":
            suggest = "engine_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigUsm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine_type: Optional[str] = None,
                 engineid: Optional[str] = None,
                 users: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigUsmUser']] = None):
        """
        :param str engine_type: enum: `local_engine`, `remote_engine`
        :param str engineid: required only if `engine_type`==`remote_engine`
        """
        if engine_type is not None:
            pulumi.set(__self__, "engine_type", engine_type)
        if engineid is not None:
            pulumi.set(__self__, "engineid", engineid)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> Optional[str]:
        """
        enum: `local_engine`, `remote_engine`
        """
        return pulumi.get(self, "engine_type")

    @property
    @pulumi.getter
    def engineid(self) -> Optional[str]:
        """
        required only if `engine_type`==`remote_engine`
        """
        return pulumi.get(self, "engineid")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigUsmUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigUsmUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationPassword":
            suggest = "authentication_password"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "encryptionPassword":
            suggest = "encryption_password"
        elif key == "encryptionType":
            suggest = "encryption_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigUsmUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsmUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigUsmUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_password: Optional[str] = None,
                 authentication_type: Optional[str] = None,
                 encryption_password: Optional[str] = None,
                 encryption_type: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str authentication_password: Not required if `authentication_type`==`authentication_none`
               include alphabetic, numeric, and special characters, but it cannot include control characters.
        :param str authentication_type: sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        :param str encryption_password: Not required if `encryption_type`==`privacy-none`
               include alphabetic, numeric, and special characters, but it cannot include control characters
        :param str encryption_type: enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        if authentication_password is not None:
            pulumi.set(__self__, "authentication_password", authentication_password)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="authenticationPassword")
    def authentication_password(self) -> Optional[str]:
        """
        Not required if `authentication_type`==`authentication_none`
        include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        return pulumi.get(self, "authentication_password")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[str]:
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[str]:
        """
        Not required if `encryption_type`==`privacy-none`
        include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        return pulumi.get(self, "encryption_password")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityToGroup":
            suggest = "security_to_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accesses: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccess']] = None,
                 security_to_group: Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup'] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if security_to_group is not None:
            pulumi.set(__self__, "security_to_group", security_to_group)

    @property
    @pulumi.getter
    def accesses(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccess']]:
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter(name="securityToGroup")
    def security_to_group(self) -> Optional['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup']:
        return pulumi.get(self, "security_to_group")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "prefixLists":
            suggest = "prefix_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[str] = None,
                 prefix_lists: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList']] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList']]:
        return pulumi.get(self, "prefix_lists")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextPrefix":
            suggest = "context_prefix"
        elif key == "notifyView":
            suggest = "notify_view"
        elif key == "readView":
            suggest = "read_view"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "securityModel":
            suggest = "security_model"
        elif key == "writeView":
            suggest = "write_view"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_prefix: Optional[str] = None,
                 notify_view: Optional[str] = None,
                 read_view: Optional[str] = None,
                 security_level: Optional[str] = None,
                 security_model: Optional[str] = None,
                 type: Optional[str] = None,
                 write_view: Optional[str] = None):
        """
        :param str context_prefix: only required if `type`==`context_prefix`
        :param str notify_view: refer to view name
        :param str read_view: refer to view name
        :param str security_level: enum: `authentication`, `none`, `privacy`
        :param str security_model: enum: `any`, `usm`, `v1`, `v2c`
        :param str type: enum: `context_prefix`, `default_context_prefix`
        :param str write_view: refer to view name
        """
        if context_prefix is not None:
            pulumi.set(__self__, "context_prefix", context_prefix)
        if notify_view is not None:
            pulumi.set(__self__, "notify_view", notify_view)
        if read_view is not None:
            pulumi.set(__self__, "read_view", read_view)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if write_view is not None:
            pulumi.set(__self__, "write_view", write_view)

    @property
    @pulumi.getter(name="contextPrefix")
    def context_prefix(self) -> Optional[str]:
        """
        only required if `type`==`context_prefix`
        """
        return pulumi.get(self, "context_prefix")

    @property
    @pulumi.getter(name="notifyView")
    def notify_view(self) -> Optional[str]:
        """
        refer to view name
        """
        return pulumi.get(self, "notify_view")

    @property
    @pulumi.getter(name="readView")
    def read_view(self) -> Optional[str]:
        """
        refer to view name
        """
        return pulumi.get(self, "read_view")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[str]:
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="writeView")
    def write_view(self) -> Optional[str]:
        """
        refer to view name
        """
        return pulumi.get(self, "write_view")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityModel":
            suggest = "security_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent']] = None,
                 security_model: Optional[str] = None):
        """
        :param str security_model: enum: `usm`, `v1`, `v2c`
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)

    @property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent']]:
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[str]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")


@pulumi.output_type
class NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityName":
            suggest = "security_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[str] = None,
                 security_name: Optional[str] = None):
        """
        :param str group: refer to group_name under access
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        refer to group_name under access
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[str]:
        return pulumi.get(self, "security_name")


@pulumi.output_type
class NetworktemplateSnmpConfigView(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewName":
            suggest = "view_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSnmpConfigView. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSnmpConfigView.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSnmpConfigView.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include: Optional[bool] = None,
                 oid: Optional[str] = None,
                 view_name: Optional[str] = None):
        """
        :param bool include: if the root oid configured is included
        """
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter
    def include(self) -> Optional[bool]:
        """
        if the root oid configured is included
        """
        return pulumi.get(self, "include")

    @property
    @pulumi.getter
    def oid(self) -> Optional[str]:
        return pulumi.get(self, "oid")

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[str]:
        return pulumi.get(self, "view_name")


@pulumi.output_type
class NetworktemplateSwitchMatching(dict):
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.NetworktemplateSwitchMatchingRule']] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMatchingRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class NetworktemplateSwitchMatchingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalConfigCmds":
            suggest = "additional_config_cmds"
        elif key == "ipConfig":
            suggest = "ip_config"
        elif key == "matchRole":
            suggest = "match_role"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"
        elif key == "oobIpConfig":
            suggest = "oob_ip_config"
        elif key == "portConfig":
            suggest = "port_config"
        elif key == "portMirroring":
            suggest = "port_mirroring"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_config_cmds: Optional[Sequence[str]] = None,
                 ip_config: Optional['outputs.NetworktemplateSwitchMatchingRuleIpConfig'] = None,
                 match_role: Optional[str] = None,
                 match_type: Optional[str] = None,
                 match_value: Optional[str] = None,
                 name: Optional[str] = None,
                 oob_ip_config: Optional['outputs.NetworktemplateSwitchMatchingRuleOobIpConfig'] = None,
                 port_config: Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortConfig']] = None,
                 port_mirroring: Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortMirroring']] = None):
        """
        :param Sequence[str] additional_config_cmds: additional CLI commands to append to the generated Junos config
               
               **Note**: no check is done
        :param 'NetworktemplateSwitchMatchingRuleIpConfigArgs' ip_config: In-Band Management interface configuration
        :param str match_role: role to match
        :param str match_type: 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        :param 'NetworktemplateSwitchMatchingRuleOobIpConfigArgs' oob_ip_config: Out-of-Band Management interface configuration
        :param Mapping[str, 'NetworktemplateSwitchMatchingRulePortConfigArgs'] port_config: Propery key is the interface name or interface range
        :param Mapping[str, 'NetworktemplateSwitchMatchingRulePortMirroringArgs'] port_mirroring: Property key is the port mirroring instance name
               port_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
        """
        if additional_config_cmds is not None:
            pulumi.set(__self__, "additional_config_cmds", additional_config_cmds)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if match_role is not None:
            pulumi.set(__self__, "match_role", match_role)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if oob_ip_config is not None:
            pulumi.set(__self__, "oob_ip_config", oob_ip_config)
        if port_config is not None:
            pulumi.set(__self__, "port_config", port_config)
        if port_mirroring is not None:
            pulumi.set(__self__, "port_mirroring", port_mirroring)

    @property
    @pulumi.getter(name="additionalConfigCmds")
    def additional_config_cmds(self) -> Optional[Sequence[str]]:
        """
        additional CLI commands to append to the generated Junos config

        **Note**: no check is done
        """
        return pulumi.get(self, "additional_config_cmds")

    @property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional['outputs.NetworktemplateSwitchMatchingRuleIpConfig']:
        """
        In-Band Management interface configuration
        """
        return pulumi.get(self, "ip_config")

    @property
    @pulumi.getter(name="matchRole")
    def match_role(self) -> Optional[str]:
        """
        role to match
        """
        return pulumi.get(self, "match_role")

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[str]:
        """
        'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
        """
        return pulumi.get(self, "match_type")

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[str]:
        return pulumi.get(self, "match_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="oobIpConfig")
    def oob_ip_config(self) -> Optional['outputs.NetworktemplateSwitchMatchingRuleOobIpConfig']:
        """
        Out-of-Band Management interface configuration
        """
        return pulumi.get(self, "oob_ip_config")

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortConfig']]:
        """
        Propery key is the interface name or interface range
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="portMirroring")
    def port_mirroring(self) -> Optional[Mapping[str, 'outputs.NetworktemplateSwitchMatchingRulePortMirroring']]:
        """
        Property key is the port mirroring instance name
        port_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
        """
        return pulumi.get(self, "port_mirroring")


@pulumi.output_type
class NetworktemplateSwitchMatchingRuleIpConfig(dict):
    def __init__(__self__, *,
                 network: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str network: VLAN Name for the management interface
        :param str type: enum: `dhcp`, `static`
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        VLAN Name for the management interface
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworktemplateSwitchMatchingRuleOobIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRuleOobIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRuleOobIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRuleOobIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 use_mgmt_vrf: Optional[bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[bool] = None):
        """
        :param str type: enum: `dhcp`, `static`
        :param bool use_mgmt_vrf: f supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param bool use_mgmt_vrf_for_host_out: for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[bool]:
        """
        f supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[bool]:
        """
        for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")


@pulumi.output_type
class NetworktemplateSwitchMatchingRulePortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeDisableLacp":
            suggest = "ae_disable_lacp"
        elif key == "aeIdx":
            suggest = "ae_idx"
        elif key == "aeLacpSlow":
            suggest = "ae_lacp_slow"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicUsage":
            suggest = "dynamic_usage"
        elif key == "noLocalOverwrite":
            suggest = "no_local_overwrite"
        elif key == "poeDisabled":
            suggest = "poe_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRulePortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRulePortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRulePortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: str,
                 ae_disable_lacp: Optional[bool] = None,
                 ae_idx: Optional[int] = None,
                 ae_lacp_slow: Optional[bool] = None,
                 aggregated: Optional[bool] = None,
                 critical: Optional[bool] = None,
                 description: Optional[str] = None,
                 disable_autoneg: Optional[bool] = None,
                 duplex: Optional[str] = None,
                 dynamic_usage: Optional[str] = None,
                 esilag: Optional[bool] = None,
                 mtu: Optional[int] = None,
                 no_local_overwrite: Optional[bool] = None,
                 poe_disabled: Optional[bool] = None,
                 speed: Optional[str] = None):
        """
        :param str usage: port usage name. 
               
               If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param bool ae_disable_lacp: To disable LACP support for the AE interface
        :param int ae_idx: Users could force to use the designated AE name
        :param bool ae_lacp_slow: to use fast timeout
        :param bool critical: if want to generate port up/down alarm
        :param bool disable_autoneg: if `speed` and `duplex` are specified, whether to disable autonegotiation
        :param str duplex: enum: `auto`, `full`, `half`
        :param str dynamic_usage: Enable dynamic usage for this port. Set to `dynamic` to enable.
        :param int mtu: media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param bool no_local_overwrite: prevent helpdesk to override the port config
        :param str speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_slow is not None:
            pulumi.set(__self__, "ae_lacp_slow", ae_lacp_slow)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_usage is not None:
            pulumi.set(__self__, "dynamic_usage", dynamic_usage)
        if esilag is not None:
            pulumi.set(__self__, "esilag", esilag)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if no_local_overwrite is not None:
            pulumi.set(__self__, "no_local_overwrite", no_local_overwrite)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def usage(self) -> str:
        """
        port usage name. 

        If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[bool]:
        """
        To disable LACP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[int]:
        """
        Users could force to use the designated AE name
        """
        return pulumi.get(self, "ae_idx")

    @property
    @pulumi.getter(name="aeLacpSlow")
    def ae_lacp_slow(self) -> Optional[bool]:
        """
        to use fast timeout
        """
        return pulumi.get(self, "ae_lacp_slow")

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[bool]:
        return pulumi.get(self, "aggregated")

    @property
    @pulumi.getter
    def critical(self) -> Optional[bool]:
        """
        if want to generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[bool]:
        """
        if `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @property
    @pulumi.getter
    def duplex(self) -> Optional[str]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @property
    @pulumi.getter(name="dynamicUsage")
    def dynamic_usage(self) -> Optional[str]:
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        return pulumi.get(self, "dynamic_usage")

    @property
    @pulumi.getter
    def esilag(self) -> Optional[bool]:
        return pulumi.get(self, "esilag")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="noLocalOverwrite")
    def no_local_overwrite(self) -> Optional[bool]:
        """
        prevent helpdesk to override the port config
        """
        return pulumi.get(self, "no_local_overwrite")

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[bool]:
        return pulumi.get(self, "poe_disabled")

    @property
    @pulumi.getter
    def speed(self) -> Optional[str]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class NetworktemplateSwitchMatchingRulePortMirroring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputNetworksIngresses":
            suggest = "input_networks_ingresses"
        elif key == "inputPortIdsEgresses":
            suggest = "input_port_ids_egresses"
        elif key == "inputPortIdsIngresses":
            suggest = "input_port_ids_ingresses"
        elif key == "outputNetwork":
            suggest = "output_network"
        elif key == "outputPortId":
            suggest = "output_port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMatchingRulePortMirroring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMatchingRulePortMirroring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMatchingRulePortMirroring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_networks_ingresses: Optional[Sequence[str]] = None,
                 input_port_ids_egresses: Optional[Sequence[str]] = None,
                 input_port_ids_ingresses: Optional[Sequence[str]] = None,
                 output_network: Optional[str] = None,
                 output_port_id: Optional[str] = None):
        """
        :param Sequence[str] input_networks_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[str] input_port_ids_egresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[str] input_port_ids_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param str output_network: exaclty one of the `output_port_id` or `output_network` should be provided
        :param str output_port_id: exaclty one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[Sequence[str]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[Sequence[str]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[Sequence[str]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[str]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[str]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")


@pulumi.output_type
class NetworktemplateSwitchMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apAffinityThreshold":
            suggest = "ap_affinity_threshold"
        elif key == "cliBanner":
            suggest = "cli_banner"
        elif key == "cliIdleTimeout":
            suggest = "cli_idle_timeout"
        elif key == "configRevertTimer":
            suggest = "config_revert_timer"
        elif key == "dhcpOptionFqdn":
            suggest = "dhcp_option_fqdn"
        elif key == "disableOobDownAlarm":
            suggest = "disable_oob_down_alarm"
        elif key == "localAccounts":
            suggest = "local_accounts"
        elif key == "mxedgeProxyHost":
            suggest = "mxedge_proxy_host"
        elif key == "mxedgeProxyPort":
            suggest = "mxedge_proxy_port"
        elif key == "protectRe":
            suggest = "protect_re"
        elif key == "rootPassword":
            suggest = "root_password"
        elif key == "useMxedgeProxy":
            suggest = "use_mxedge_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[int] = None,
                 cli_banner: Optional[str] = None,
                 cli_idle_timeout: Optional[int] = None,
                 config_revert_timer: Optional[int] = None,
                 dhcp_option_fqdn: Optional[bool] = None,
                 disable_oob_down_alarm: Optional[bool] = None,
                 local_accounts: Optional[Mapping[str, 'outputs.NetworktemplateSwitchMgmtLocalAccounts']] = None,
                 mxedge_proxy_host: Optional[str] = None,
                 mxedge_proxy_port: Optional[int] = None,
                 protect_re: Optional['outputs.NetworktemplateSwitchMgmtProtectRe'] = None,
                 root_password: Optional[str] = None,
                 tacacs: Optional['outputs.NetworktemplateSwitchMgmtTacacs'] = None,
                 use_mxedge_proxy: Optional[bool] = None):
        """
        :param int ap_affinity_threshold: ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        :param str cli_banner: Set Banners for switches. Allows markup formatting
        :param int cli_idle_timeout: Sets timeout for switches
        :param int config_revert_timer: the rollback timer for commit confirmed
        :param bool dhcp_option_fqdn: Enable to provide the FQDN with DHCP option 81
        :param Mapping[str, 'NetworktemplateSwitchMgmtLocalAccountsArgs'] local_accounts: Property key is the user name. For Local user authentication
        :param 'NetworktemplateSwitchMgmtProtectReArgs' protect_re: restrict inbound-traffic to host
               when enabled, all traffic that is not essential to our operation will be dropped 
               e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        :param bool use_mxedge_proxy: to use mxedge as proxy
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)
        if cli_banner is not None:
            pulumi.set(__self__, "cli_banner", cli_banner)
        if cli_idle_timeout is not None:
            pulumi.set(__self__, "cli_idle_timeout", cli_idle_timeout)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if dhcp_option_fqdn is not None:
            pulumi.set(__self__, "dhcp_option_fqdn", dhcp_option_fqdn)
        if disable_oob_down_alarm is not None:
            pulumi.set(__self__, "disable_oob_down_alarm", disable_oob_down_alarm)
        if local_accounts is not None:
            pulumi.set(__self__, "local_accounts", local_accounts)
        if mxedge_proxy_host is not None:
            pulumi.set(__self__, "mxedge_proxy_host", mxedge_proxy_host)
        if mxedge_proxy_port is not None:
            pulumi.set(__self__, "mxedge_proxy_port", mxedge_proxy_port)
        if protect_re is not None:
            pulumi.set(__self__, "protect_re", protect_re)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if tacacs is not None:
            pulumi.set(__self__, "tacacs", tacacs)
        if use_mxedge_proxy is not None:
            pulumi.set(__self__, "use_mxedge_proxy", use_mxedge_proxy)

    @property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[int]:
        """
        ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")

    @property
    @pulumi.getter(name="cliBanner")
    def cli_banner(self) -> Optional[str]:
        """
        Set Banners for switches. Allows markup formatting
        """
        return pulumi.get(self, "cli_banner")

    @property
    @pulumi.getter(name="cliIdleTimeout")
    def cli_idle_timeout(self) -> Optional[int]:
        """
        Sets timeout for switches
        """
        return pulumi.get(self, "cli_idle_timeout")

    @property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[int]:
        """
        the rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @property
    @pulumi.getter(name="dhcpOptionFqdn")
    def dhcp_option_fqdn(self) -> Optional[bool]:
        """
        Enable to provide the FQDN with DHCP option 81
        """
        return pulumi.get(self, "dhcp_option_fqdn")

    @property
    @pulumi.getter(name="disableOobDownAlarm")
    def disable_oob_down_alarm(self) -> Optional[bool]:
        return pulumi.get(self, "disable_oob_down_alarm")

    @property
    @pulumi.getter(name="localAccounts")
    def local_accounts(self) -> Optional[Mapping[str, 'outputs.NetworktemplateSwitchMgmtLocalAccounts']]:
        """
        Property key is the user name. For Local user authentication
        """
        return pulumi.get(self, "local_accounts")

    @property
    @pulumi.getter(name="mxedgeProxyHost")
    def mxedge_proxy_host(self) -> Optional[str]:
        return pulumi.get(self, "mxedge_proxy_host")

    @property
    @pulumi.getter(name="mxedgeProxyPort")
    def mxedge_proxy_port(self) -> Optional[int]:
        return pulumi.get(self, "mxedge_proxy_port")

    @property
    @pulumi.getter(name="protectRe")
    def protect_re(self) -> Optional['outputs.NetworktemplateSwitchMgmtProtectRe']:
        """
        restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "protect_re")

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[str]:
        return pulumi.get(self, "root_password")

    @property
    @pulumi.getter
    def tacacs(self) -> Optional['outputs.NetworktemplateSwitchMgmtTacacs']:
        return pulumi.get(self, "tacacs")

    @property
    @pulumi.getter(name="useMxedgeProxy")
    def use_mxedge_proxy(self) -> Optional[bool]:
        """
        to use mxedge as proxy
        """
        return pulumi.get(self, "use_mxedge_proxy")


@pulumi.output_type
class NetworktemplateSwitchMgmtLocalAccounts(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 role: Optional[str] = None):
        """
        :param str role: enum: `admin`, `helpdesk`, `none`, `read`
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class NetworktemplateSwitchMgmtProtectRe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedServices":
            suggest = "allowed_services"
        elif key == "trustedHosts":
            suggest = "trusted_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmtProtectRe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmtProtectRe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmtProtectRe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_services: Optional[Sequence[str]] = None,
                 customs: Optional[Sequence['outputs.NetworktemplateSwitchMgmtProtectReCustom']] = None,
                 enabled: Optional[bool] = None,
                 trusted_hosts: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allowed_services: optionally, services we'll allow
        :param bool enabled: when enabled, all traffic that is not essential to our operation will be dropped
               e.g. ntp / dns / traffic to mist will be allowed by default
                    if dhcpd is enabled, we'll make sure it works
        :param Sequence[str] trusted_hosts: host/subnets we'll allow traffic to/from
        """
        if allowed_services is not None:
            pulumi.set(__self__, "allowed_services", allowed_services)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if trusted_hosts is not None:
            pulumi.set(__self__, "trusted_hosts", trusted_hosts)

    @property
    @pulumi.getter(name="allowedServices")
    def allowed_services(self) -> Optional[Sequence[str]]:
        """
        optionally, services we'll allow
        """
        return pulumi.get(self, "allowed_services")

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMgmtProtectReCustom']]:
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        when enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="trustedHosts")
    def trusted_hosts(self) -> Optional[Sequence[str]]:
        """
        host/subnets we'll allow traffic to/from
        """
        return pulumi.get(self, "trusted_hosts")


@pulumi.output_type
class NetworktemplateSwitchMgmtProtectReCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmtProtectReCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmtProtectReCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmtProtectReCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None,
                 subnets: Optional[Sequence[str]] = None):
        """
        :param str port_range: matched dst port, "0" means any
        :param str protocol: enum: `any`, `icmp`, `tcp`, `udp`
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        enum: `any`, `icmp`, `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class NetworktemplateSwitchMgmtTacacs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctServers":
            suggest = "acct_servers"
        elif key == "defaultRole":
            suggest = "default_role"
        elif key == "tacplusServers":
            suggest = "tacplus_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateSwitchMgmtTacacs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateSwitchMgmtTacacs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateSwitchMgmtTacacs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_servers: Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsAcctServer']] = None,
                 default_role: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 network: Optional[str] = None,
                 tacplus_servers: Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsTacplusServer']] = None):
        """
        :param str default_role: enum: `admin`, `helpdesk`, `none`, `read`
        :param str network: which network the TACACS server resides
        """
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if default_role is not None:
            pulumi.set(__self__, "default_role", default_role)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if tacplus_servers is not None:
            pulumi.set(__self__, "tacplus_servers", tacplus_servers)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @property
    @pulumi.getter(name="defaultRole")
    def default_role(self) -> Optional[str]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "default_role")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        which network the TACACS server resides
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="tacplusServers")
    def tacplus_servers(self) -> Optional[Sequence['outputs.NetworktemplateSwitchMgmtTacacsTacplusServer']]:
        return pulumi.get(self, "tacplus_servers")


@pulumi.output_type
class NetworktemplateSwitchMgmtTacacsAcctServer(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[str] = None,
                 secret: Optional[str] = None,
                 timeout: Optional[int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NetworktemplateSwitchMgmtTacacsTacplusServer(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[str] = None,
                 secret: Optional[str] = None,
                 timeout: Optional[int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NetworktemplateUplinkPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepWlansUpIfDown":
            suggest = "keep_wlans_up_if_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateUplinkPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateUplinkPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateUplinkPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dot1x: Optional[bool] = None,
                 keep_wlans_up_if_down: Optional[bool] = None):
        """
        :param bool dot1x: Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param bool keep_wlans_up_if_down: by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @property
    @pulumi.getter
    def dot1x(self) -> Optional[bool]:
        """
        Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[bool]:
        """
        by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")


@pulumi.output_type
class NetworktemplateVrfConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworktemplateVrfInstances(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraRoutes":
            suggest = "extra_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworktemplateVrfInstances. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworktemplateVrfInstances.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworktemplateVrfInstances.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_routes: Optional[Mapping[str, 'outputs.NetworktemplateVrfInstancesExtraRoutes']] = None,
                 networks: Optional[Sequence[str]] = None):
        """
        :param Mapping[str, 'NetworktemplateVrfInstancesExtraRoutesArgs'] extra_routes: Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        if extra_routes is not None:
            pulumi.set(__self__, "extra_routes", extra_routes)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="extraRoutes")
    def extra_routes(self) -> Optional[Mapping[str, 'outputs.NetworktemplateVrfInstancesExtraRoutes']]:
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        return pulumi.get(self, "extra_routes")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class NetworktemplateVrfInstancesExtraRoutes(dict):
    def __init__(__self__, *,
                 via: str):
        """
        :param str via: Next-hop address
        """
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> str:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")


@pulumi.output_type
class SettingAnalytic(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: enable Advanced Analytic feature (using SUB-ANA license)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        enable Advanced Analytic feature (using SUB-ANA license)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingAutoUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customVersions":
            suggest = "custom_versions"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "timeOfDay":
            suggest = "time_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingAutoUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingAutoUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingAutoUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_versions: Optional[Mapping[str, str]] = None,
                 day_of_week: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 time_of_day: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param Mapping[str, str] custom_versions: custom versions for different models. Property key is the model name (e.g. "AP41")
        :param str day_of_week: enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        :param bool enabled: whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
        :param str time_of_day: any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
        :param str version: desired version. enum: `beta`, `custom`, `stable`
        """
        if custom_versions is not None:
            pulumi.set(__self__, "custom_versions", custom_versions)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_of_day is not None:
            pulumi.set(__self__, "time_of_day", time_of_day)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="customVersions")
    def custom_versions(self) -> Optional[Mapping[str, str]]:
        """
        custom versions for different models. Property key is the model name (e.g. "AP41")
        """
        return pulumi.get(self, "custom_versions")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> Optional[str]:
        """
        any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
        """
        return pulumi.get(self, "time_of_day")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        desired version. enum: `beta`, `custom`, `stable`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SettingBleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beaconEnabled":
            suggest = "beacon_enabled"
        elif key == "beaconRate":
            suggest = "beacon_rate"
        elif key == "beaconRateMode":
            suggest = "beacon_rate_mode"
        elif key == "beamDisableds":
            suggest = "beam_disableds"
        elif key == "customBlePacketEnabled":
            suggest = "custom_ble_packet_enabled"
        elif key == "customBlePacketFrame":
            suggest = "custom_ble_packet_frame"
        elif key == "customBlePacketFreqMsec":
            suggest = "custom_ble_packet_freq_msec"
        elif key == "eddystoneUidAdvPower":
            suggest = "eddystone_uid_adv_power"
        elif key == "eddystoneUidBeams":
            suggest = "eddystone_uid_beams"
        elif key == "eddystoneUidEnabled":
            suggest = "eddystone_uid_enabled"
        elif key == "eddystoneUidFreqMsec":
            suggest = "eddystone_uid_freq_msec"
        elif key == "eddystoneUidInstance":
            suggest = "eddystone_uid_instance"
        elif key == "eddystoneUidNamespace":
            suggest = "eddystone_uid_namespace"
        elif key == "eddystoneUrlAdvPower":
            suggest = "eddystone_url_adv_power"
        elif key == "eddystoneUrlBeams":
            suggest = "eddystone_url_beams"
        elif key == "eddystoneUrlEnabled":
            suggest = "eddystone_url_enabled"
        elif key == "eddystoneUrlFreqMsec":
            suggest = "eddystone_url_freq_msec"
        elif key == "eddystoneUrlUrl":
            suggest = "eddystone_url_url"
        elif key == "ibeaconAdvPower":
            suggest = "ibeacon_adv_power"
        elif key == "ibeaconBeams":
            suggest = "ibeacon_beams"
        elif key == "ibeaconEnabled":
            suggest = "ibeacon_enabled"
        elif key == "ibeaconFreqMsec":
            suggest = "ibeacon_freq_msec"
        elif key == "ibeaconMajor":
            suggest = "ibeacon_major"
        elif key == "ibeaconMinor":
            suggest = "ibeacon_minor"
        elif key == "ibeaconUuid":
            suggest = "ibeacon_uuid"
        elif key == "powerMode":
            suggest = "power_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingBleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingBleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingBleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 beacon_enabled: Optional[bool] = None,
                 beacon_rate: Optional[int] = None,
                 beacon_rate_mode: Optional[str] = None,
                 beam_disableds: Optional[Sequence[int]] = None,
                 custom_ble_packet_enabled: Optional[bool] = None,
                 custom_ble_packet_frame: Optional[str] = None,
                 custom_ble_packet_freq_msec: Optional[int] = None,
                 eddystone_uid_adv_power: Optional[int] = None,
                 eddystone_uid_beams: Optional[str] = None,
                 eddystone_uid_enabled: Optional[bool] = None,
                 eddystone_uid_freq_msec: Optional[int] = None,
                 eddystone_uid_instance: Optional[str] = None,
                 eddystone_uid_namespace: Optional[str] = None,
                 eddystone_url_adv_power: Optional[int] = None,
                 eddystone_url_beams: Optional[str] = None,
                 eddystone_url_enabled: Optional[bool] = None,
                 eddystone_url_freq_msec: Optional[int] = None,
                 eddystone_url_url: Optional[str] = None,
                 ibeacon_adv_power: Optional[int] = None,
                 ibeacon_beams: Optional[str] = None,
                 ibeacon_enabled: Optional[bool] = None,
                 ibeacon_freq_msec: Optional[int] = None,
                 ibeacon_major: Optional[int] = None,
                 ibeacon_minor: Optional[int] = None,
                 ibeacon_uuid: Optional[str] = None,
                 power: Optional[int] = None,
                 power_mode: Optional[str] = None):
        """
        :param bool beacon_enabled: whether Mist beacons is enabled
        :param int beacon_rate: required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        :param str beacon_rate_mode: enum: `custom`, `default`
        :param Sequence[int] beam_disableds: list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        :param bool custom_ble_packet_enabled: can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        :param str custom_ble_packet_frame: The custom frame to be sent out in this beacon. The frame must be a hexstring
        :param int custom_ble_packet_freq_msec: Frequency (msec) of data emitted by custom ble beacon
        :param int eddystone_uid_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param bool eddystone_uid_enabled: only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        :param int eddystone_uid_freq_msec: Frequency (msec) of data emmit by Eddystone-UID beacon
        :param str eddystone_uid_instance: Eddystone-UID instance for the device
        :param str eddystone_uid_namespace: Eddystone-UID namespace
        :param int eddystone_url_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param bool eddystone_url_enabled: only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        :param int eddystone_url_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param str eddystone_url_url: URL pointed by Eddystone-URL beacon
        :param int ibeacon_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param bool ibeacon_enabled: can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        :param int ibeacon_freq_msec: Frequency (msec) of data emmit for iBeacon
        :param int ibeacon_major: Major number for iBeacon
        :param int ibeacon_minor: Minor number for iBeacon
        :param str ibeacon_uuid: optional, if not specified, the same UUID as the beacon will be used
        :param int power: required if `power_mode`==`custom`
        :param str power_mode: enum: `custom`, `default`
        """
        if beacon_enabled is not None:
            pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        if beacon_rate is not None:
            pulumi.set(__self__, "beacon_rate", beacon_rate)
        if beacon_rate_mode is not None:
            pulumi.set(__self__, "beacon_rate_mode", beacon_rate_mode)
        if beam_disableds is not None:
            pulumi.set(__self__, "beam_disableds", beam_disableds)
        if custom_ble_packet_enabled is not None:
            pulumi.set(__self__, "custom_ble_packet_enabled", custom_ble_packet_enabled)
        if custom_ble_packet_frame is not None:
            pulumi.set(__self__, "custom_ble_packet_frame", custom_ble_packet_frame)
        if custom_ble_packet_freq_msec is not None:
            pulumi.set(__self__, "custom_ble_packet_freq_msec", custom_ble_packet_freq_msec)
        if eddystone_uid_adv_power is not None:
            pulumi.set(__self__, "eddystone_uid_adv_power", eddystone_uid_adv_power)
        if eddystone_uid_beams is not None:
            pulumi.set(__self__, "eddystone_uid_beams", eddystone_uid_beams)
        if eddystone_uid_enabled is not None:
            pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        if eddystone_uid_freq_msec is not None:
            pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        if eddystone_uid_instance is not None:
            pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        if eddystone_uid_namespace is not None:
            pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        if eddystone_url_adv_power is not None:
            pulumi.set(__self__, "eddystone_url_adv_power", eddystone_url_adv_power)
        if eddystone_url_beams is not None:
            pulumi.set(__self__, "eddystone_url_beams", eddystone_url_beams)
        if eddystone_url_enabled is not None:
            pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        if eddystone_url_freq_msec is not None:
            pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        if eddystone_url_url is not None:
            pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        if ibeacon_adv_power is not None:
            pulumi.set(__self__, "ibeacon_adv_power", ibeacon_adv_power)
        if ibeacon_beams is not None:
            pulumi.set(__self__, "ibeacon_beams", ibeacon_beams)
        if ibeacon_enabled is not None:
            pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        if ibeacon_freq_msec is not None:
            pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        if ibeacon_major is not None:
            pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        if ibeacon_minor is not None:
            pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        if ibeacon_uuid is not None:
            pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)

    @property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> Optional[bool]:
        """
        whether Mist beacons is enabled
        """
        return pulumi.get(self, "beacon_enabled")

    @property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> Optional[int]:
        """
        required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        return pulumi.get(self, "beacon_rate")

    @property
    @pulumi.getter(name="beaconRateMode")
    def beacon_rate_mode(self) -> Optional[str]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "beacon_rate_mode")

    @property
    @pulumi.getter(name="beamDisableds")
    def beam_disableds(self) -> Optional[Sequence[int]]:
        """
        list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        return pulumi.get(self, "beam_disableds")

    @property
    @pulumi.getter(name="customBlePacketEnabled")
    def custom_ble_packet_enabled(self) -> Optional[bool]:
        """
        can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        return pulumi.get(self, "custom_ble_packet_enabled")

    @property
    @pulumi.getter(name="customBlePacketFrame")
    def custom_ble_packet_frame(self) -> Optional[str]:
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        return pulumi.get(self, "custom_ble_packet_frame")

    @property
    @pulumi.getter(name="customBlePacketFreqMsec")
    def custom_ble_packet_freq_msec(self) -> Optional[int]:
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        return pulumi.get(self, "custom_ble_packet_freq_msec")

    @property
    @pulumi.getter(name="eddystoneUidAdvPower")
    def eddystone_uid_adv_power(self) -> Optional[int]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_uid_adv_power")

    @property
    @pulumi.getter(name="eddystoneUidBeams")
    def eddystone_uid_beams(self) -> Optional[str]:
        return pulumi.get(self, "eddystone_uid_beams")

    @property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> Optional[bool]:
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        return pulumi.get(self, "eddystone_uid_enabled")

    @property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> Optional[int]:
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> Optional[str]:
        """
        Eddystone-UID instance for the device
        """
        return pulumi.get(self, "eddystone_uid_instance")

    @property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> Optional[str]:
        """
        Eddystone-UID namespace
        """
        return pulumi.get(self, "eddystone_uid_namespace")

    @property
    @pulumi.getter(name="eddystoneUrlAdvPower")
    def eddystone_url_adv_power(self) -> Optional[int]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_url_adv_power")

    @property
    @pulumi.getter(name="eddystoneUrlBeams")
    def eddystone_url_beams(self) -> Optional[str]:
        return pulumi.get(self, "eddystone_url_beams")

    @property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> Optional[bool]:
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        return pulumi.get(self, "eddystone_url_enabled")

    @property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> Optional[int]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> Optional[str]:
        """
        URL pointed by Eddystone-URL beacon
        """
        return pulumi.get(self, "eddystone_url_url")

    @property
    @pulumi.getter(name="ibeaconAdvPower")
    def ibeacon_adv_power(self) -> Optional[int]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "ibeacon_adv_power")

    @property
    @pulumi.getter(name="ibeaconBeams")
    def ibeacon_beams(self) -> Optional[str]:
        return pulumi.get(self, "ibeacon_beams")

    @property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> Optional[bool]:
        """
        can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        return pulumi.get(self, "ibeacon_enabled")

    @property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> Optional[int]:
        """
        Frequency (msec) of data emmit for iBeacon
        """
        return pulumi.get(self, "ibeacon_freq_msec")

    @property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> Optional[int]:
        """
        Major number for iBeacon
        """
        return pulumi.get(self, "ibeacon_major")

    @property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> Optional[int]:
        """
        Minor number for iBeacon
        """
        return pulumi.get(self, "ibeacon_minor")

    @property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> Optional[str]:
        """
        optional, if not specified, the same UUID as the beacon will be used
        """
        return pulumi.get(self, "ibeacon_uuid")

    @property
    @pulumi.getter
    def power(self) -> Optional[int]:
        """
        required if `power_mode`==`custom`
        """
        return pulumi.get(self, "power")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "power_mode")


@pulumi.output_type
class SettingConfigPushPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noPush":
            suggest = "no_push"
        elif key == "pushWindow":
            suggest = "push_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingConfigPushPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingConfigPushPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingConfigPushPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_push: Optional[bool] = None,
                 push_window: Optional['outputs.SettingConfigPushPolicyPushWindow'] = None):
        """
        :param bool no_push: stop any new config from being pushed to the device
        :param 'SettingConfigPushPolicyPushWindowArgs' push_window: if enabled, new config will only be pushed to device within the specified time window
        """
        if no_push is not None:
            pulumi.set(__self__, "no_push", no_push)
        if push_window is not None:
            pulumi.set(__self__, "push_window", push_window)

    @property
    @pulumi.getter(name="noPush")
    def no_push(self) -> Optional[bool]:
        """
        stop any new config from being pushed to the device
        """
        return pulumi.get(self, "no_push")

    @property
    @pulumi.getter(name="pushWindow")
    def push_window(self) -> Optional['outputs.SettingConfigPushPolicyPushWindow']:
        """
        if enabled, new config will only be pushed to device within the specified time window
        """
        return pulumi.get(self, "push_window")


@pulumi.output_type
class SettingConfigPushPolicyPushWindow(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 hours: Optional['outputs.SettingConfigPushPolicyPushWindowHours'] = None):
        """
        :param 'SettingConfigPushPolicyPushWindowHoursArgs' hours: hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
               
               **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def hours(self) -> Optional['outputs.SettingConfigPushPolicyPushWindowHours']:
        """
        hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 

        **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        return pulumi.get(self, "hours")


@pulumi.output_type
class SettingConfigPushPolicyPushWindowHours(dict):
    def __init__(__self__, *,
                 fri: Optional[str] = None,
                 mon: Optional[str] = None,
                 sat: Optional[str] = None,
                 sun: Optional[str] = None,
                 thu: Optional[str] = None,
                 tue: Optional[str] = None,
                 wed: Optional[str] = None):
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[str]:
        return pulumi.get(self, "fri")

    @property
    @pulumi.getter
    def mon(self) -> Optional[str]:
        return pulumi.get(self, "mon")

    @property
    @pulumi.getter
    def sat(self) -> Optional[str]:
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def sun(self) -> Optional[str]:
        return pulumi.get(self, "sun")

    @property
    @pulumi.getter
    def thu(self) -> Optional[str]:
        return pulumi.get(self, "thu")

    @property
    @pulumi.getter
    def tue(self) -> Optional[str]:
        return pulumi.get(self, "tue")

    @property
    @pulumi.getter
    def wed(self) -> Optional[str]:
        return pulumi.get(self, "wed")


@pulumi.output_type
class SettingCriticalUrlMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 monitors: Optional[Sequence['outputs.SettingCriticalUrlMonitoringMonitor']] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if monitors is not None:
            pulumi.set(__self__, "monitors", monitors)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def monitors(self) -> Optional[Sequence['outputs.SettingCriticalUrlMonitoringMonitor']]:
        return pulumi.get(self, "monitors")


@pulumi.output_type
class SettingCriticalUrlMonitoringMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingCriticalUrlMonitoringMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingCriticalUrlMonitoringMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingCriticalUrlMonitoringMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: Optional[str] = None,
                 vlan_id: Optional[str] = None):
        if url is not None:
            pulumi.set(__self__, "url", url)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class SettingEngagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dwellTagNames":
            suggest = "dwell_tag_names"
        elif key == "dwellTags":
            suggest = "dwell_tags"
        elif key == "maxDwell":
            suggest = "max_dwell"
        elif key == "minDwell":
            suggest = "min_dwell"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingEngagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingEngagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingEngagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dwell_tag_names: Optional['outputs.SettingEngagementDwellTagNames'] = None,
                 dwell_tags: Optional['outputs.SettingEngagementDwellTags'] = None,
                 hours: Optional['outputs.SettingEngagementHours'] = None,
                 max_dwell: Optional[int] = None,
                 min_dwell: Optional[int] = None):
        """
        :param 'SettingEngagementDwellTagsArgs' dwell_tags: add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
        :param 'SettingEngagementHoursArgs' hours: hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
               
               **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        :param int max_dwell: max time, default is 43200(12h), max is 68400 (18h)
        :param int min_dwell: min time
        """
        if dwell_tag_names is not None:
            pulumi.set(__self__, "dwell_tag_names", dwell_tag_names)
        if dwell_tags is not None:
            pulumi.set(__self__, "dwell_tags", dwell_tags)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if max_dwell is not None:
            pulumi.set(__self__, "max_dwell", max_dwell)
        if min_dwell is not None:
            pulumi.set(__self__, "min_dwell", min_dwell)

    @property
    @pulumi.getter(name="dwellTagNames")
    def dwell_tag_names(self) -> Optional['outputs.SettingEngagementDwellTagNames']:
        return pulumi.get(self, "dwell_tag_names")

    @property
    @pulumi.getter(name="dwellTags")
    def dwell_tags(self) -> Optional['outputs.SettingEngagementDwellTags']:
        """
        add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
        """
        return pulumi.get(self, "dwell_tags")

    @property
    @pulumi.getter
    def hours(self) -> Optional['outputs.SettingEngagementHours']:
        """
        hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 

        **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter(name="maxDwell")
    def max_dwell(self) -> Optional[int]:
        """
        max time, default is 43200(12h), max is 68400 (18h)
        """
        return pulumi.get(self, "max_dwell")

    @property
    @pulumi.getter(name="minDwell")
    def min_dwell(self) -> Optional[int]:
        """
        min time
        """
        return pulumi.get(self, "min_dwell")


@pulumi.output_type
class SettingEngagementDwellTagNames(dict):
    def __init__(__self__, *,
                 bounce: Optional[str] = None,
                 engaged: Optional[str] = None,
                 passerby: Optional[str] = None,
                 stationed: Optional[str] = None):
        if bounce is not None:
            pulumi.set(__self__, "bounce", bounce)
        if engaged is not None:
            pulumi.set(__self__, "engaged", engaged)
        if passerby is not None:
            pulumi.set(__self__, "passerby", passerby)
        if stationed is not None:
            pulumi.set(__self__, "stationed", stationed)

    @property
    @pulumi.getter
    def bounce(self) -> Optional[str]:
        return pulumi.get(self, "bounce")

    @property
    @pulumi.getter
    def engaged(self) -> Optional[str]:
        return pulumi.get(self, "engaged")

    @property
    @pulumi.getter
    def passerby(self) -> Optional[str]:
        return pulumi.get(self, "passerby")

    @property
    @pulumi.getter
    def stationed(self) -> Optional[str]:
        return pulumi.get(self, "stationed")


@pulumi.output_type
class SettingEngagementDwellTags(dict):
    def __init__(__self__, *,
                 bounce: Optional[str] = None,
                 engaged: Optional[str] = None,
                 passerby: Optional[str] = None,
                 stationed: Optional[str] = None):
        if bounce is not None:
            pulumi.set(__self__, "bounce", bounce)
        if engaged is not None:
            pulumi.set(__self__, "engaged", engaged)
        if passerby is not None:
            pulumi.set(__self__, "passerby", passerby)
        if stationed is not None:
            pulumi.set(__self__, "stationed", stationed)

    @property
    @pulumi.getter
    def bounce(self) -> Optional[str]:
        return pulumi.get(self, "bounce")

    @property
    @pulumi.getter
    def engaged(self) -> Optional[str]:
        return pulumi.get(self, "engaged")

    @property
    @pulumi.getter
    def passerby(self) -> Optional[str]:
        return pulumi.get(self, "passerby")

    @property
    @pulumi.getter
    def stationed(self) -> Optional[str]:
        return pulumi.get(self, "stationed")


@pulumi.output_type
class SettingEngagementHours(dict):
    def __init__(__self__, *,
                 fri: Optional[str] = None,
                 mon: Optional[str] = None,
                 sat: Optional[str] = None,
                 sun: Optional[str] = None,
                 thu: Optional[str] = None,
                 tue: Optional[str] = None,
                 wed: Optional[str] = None):
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[str]:
        return pulumi.get(self, "fri")

    @property
    @pulumi.getter
    def mon(self) -> Optional[str]:
        return pulumi.get(self, "mon")

    @property
    @pulumi.getter
    def sat(self) -> Optional[str]:
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def sun(self) -> Optional[str]:
        return pulumi.get(self, "sun")

    @property
    @pulumi.getter
    def thu(self) -> Optional[str]:
        return pulumi.get(self, "thu")

    @property
    @pulumi.getter
    def tue(self) -> Optional[str]:
        return pulumi.get(self, "tue")

    @property
    @pulumi.getter
    def wed(self) -> Optional[str]:
        return pulumi.get(self, "wed")


@pulumi.output_type
class SettingGatewayMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminSshkeys":
            suggest = "admin_sshkeys"
        elif key == "appProbing":
            suggest = "app_probing"
        elif key == "appUsage":
            suggest = "app_usage"
        elif key == "autoSignatureUpdate":
            suggest = "auto_signature_update"
        elif key == "configRevertTimer":
            suggest = "config_revert_timer"
        elif key == "disableConsole":
            suggest = "disable_console"
        elif key == "disableOob":
            suggest = "disable_oob"
        elif key == "probeHosts":
            suggest = "probe_hosts"
        elif key == "rootPassword":
            suggest = "root_password"
        elif key == "securityLogSourceAddress":
            suggest = "security_log_source_address"
        elif key == "securityLogSourceInterface":
            suggest = "security_log_source_interface"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingGatewayMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingGatewayMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingGatewayMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_sshkeys: Optional[Sequence[str]] = None,
                 app_probing: Optional['outputs.SettingGatewayMgmtAppProbing'] = None,
                 app_usage: Optional[bool] = None,
                 auto_signature_update: Optional['outputs.SettingGatewayMgmtAutoSignatureUpdate'] = None,
                 config_revert_timer: Optional[int] = None,
                 disable_console: Optional[bool] = None,
                 disable_oob: Optional[bool] = None,
                 probe_hosts: Optional[Sequence[str]] = None,
                 root_password: Optional[str] = None,
                 security_log_source_address: Optional[str] = None,
                 security_log_source_interface: Optional[str] = None):
        """
        :param Sequence[str] admin_sshkeys: for SSR only, as direct root access is not allowed
        :param bool app_usage: consumes uplink bandwidth, requires WA license
        :param int config_revert_timer: he rollback timer for commit confirmed
        :param bool disable_console: for both SSR and SRX disable console port
        :param bool disable_oob: for both SSR and SRX disable management interface
        :param str root_password: for SRX only
        """
        if admin_sshkeys is not None:
            pulumi.set(__self__, "admin_sshkeys", admin_sshkeys)
        if app_probing is not None:
            pulumi.set(__self__, "app_probing", app_probing)
        if app_usage is not None:
            pulumi.set(__self__, "app_usage", app_usage)
        if auto_signature_update is not None:
            pulumi.set(__self__, "auto_signature_update", auto_signature_update)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if disable_console is not None:
            pulumi.set(__self__, "disable_console", disable_console)
        if disable_oob is not None:
            pulumi.set(__self__, "disable_oob", disable_oob)
        if probe_hosts is not None:
            pulumi.set(__self__, "probe_hosts", probe_hosts)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if security_log_source_address is not None:
            pulumi.set(__self__, "security_log_source_address", security_log_source_address)
        if security_log_source_interface is not None:
            pulumi.set(__self__, "security_log_source_interface", security_log_source_interface)

    @property
    @pulumi.getter(name="adminSshkeys")
    def admin_sshkeys(self) -> Optional[Sequence[str]]:
        """
        for SSR only, as direct root access is not allowed
        """
        return pulumi.get(self, "admin_sshkeys")

    @property
    @pulumi.getter(name="appProbing")
    def app_probing(self) -> Optional['outputs.SettingGatewayMgmtAppProbing']:
        return pulumi.get(self, "app_probing")

    @property
    @pulumi.getter(name="appUsage")
    def app_usage(self) -> Optional[bool]:
        """
        consumes uplink bandwidth, requires WA license
        """
        return pulumi.get(self, "app_usage")

    @property
    @pulumi.getter(name="autoSignatureUpdate")
    def auto_signature_update(self) -> Optional['outputs.SettingGatewayMgmtAutoSignatureUpdate']:
        return pulumi.get(self, "auto_signature_update")

    @property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[int]:
        """
        he rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @property
    @pulumi.getter(name="disableConsole")
    def disable_console(self) -> Optional[bool]:
        """
        for both SSR and SRX disable console port
        """
        return pulumi.get(self, "disable_console")

    @property
    @pulumi.getter(name="disableOob")
    def disable_oob(self) -> Optional[bool]:
        """
        for both SSR and SRX disable management interface
        """
        return pulumi.get(self, "disable_oob")

    @property
    @pulumi.getter(name="probeHosts")
    def probe_hosts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "probe_hosts")

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[str]:
        """
        for SRX only
        """
        return pulumi.get(self, "root_password")

    @property
    @pulumi.getter(name="securityLogSourceAddress")
    def security_log_source_address(self) -> Optional[str]:
        return pulumi.get(self, "security_log_source_address")

    @property
    @pulumi.getter(name="securityLogSourceInterface")
    def security_log_source_interface(self) -> Optional[str]:
        return pulumi.get(self, "security_log_source_interface")


@pulumi.output_type
class SettingGatewayMgmtAppProbing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customApps":
            suggest = "custom_apps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingGatewayMgmtAppProbing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingGatewayMgmtAppProbing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingGatewayMgmtAppProbing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apps: Optional[Sequence[str]] = None,
                 custom_apps: Optional[Sequence['outputs.SettingGatewayMgmtAppProbingCustomApp']] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] apps: app-keys from /api/v1/const/applications
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if custom_apps is not None:
            pulumi.set(__self__, "custom_apps", custom_apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def apps(self) -> Optional[Sequence[str]]:
        """
        app-keys from /api/v1/const/applications
        """
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter(name="customApps")
    def custom_apps(self) -> Optional[Sequence['outputs.SettingGatewayMgmtAppProbingCustomApp']]:
        return pulumi.get(self, "custom_apps")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingGatewayMgmtAppProbingCustomApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appType":
            suggest = "app_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingGatewayMgmtAppProbingCustomApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingGatewayMgmtAppProbingCustomApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingGatewayMgmtAppProbingCustomApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostnames: Sequence[str],
                 name: str,
                 protocol: str,
                 address: Optional[str] = None,
                 app_type: Optional[str] = None,
                 key: Optional[str] = None,
                 network: Optional[str] = None,
                 url: Optional[str] = None,
                 vrf: Optional[str] = None):
        """
        :param Sequence[str] hostnames: Only 1 entry is allowed:
                   * if `protocol`==`http`: URL (e.g. `http://test.com` or `https://test.com`)
                   * if `protocol`==`icmp`: IP Address (e.g. `1.2.3.4`)
        :param str protocol: enum: `http`, `icmp`
        """
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if app_type is not None:
            pulumi.set(__self__, "app_type", app_type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if vrf is not None:
            pulumi.set(__self__, "vrf", vrf)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Only 1 entry is allowed:
            * if `protocol`==`http`: URL (e.g. `http://test.com` or `https://test.com`)
            * if `protocol`==`icmp`: IP Address (e.g. `1.2.3.4`)
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="appType")
    def app_type(self) -> Optional[str]:
        return pulumi.get(self, "app_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def vrf(self) -> Optional[str]:
        return pulumi.get(self, "vrf")


@pulumi.output_type
class SettingGatewayMgmtAutoSignatureUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "timeOfDay":
            suggest = "time_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingGatewayMgmtAutoSignatureUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingGatewayMgmtAutoSignatureUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingGatewayMgmtAutoSignatureUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[str] = None,
                 enable: Optional[bool] = None,
                 time_of_day: Optional[str] = None):
        """
        :param str day_of_week: enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        :param str time_of_day: optional, Mist will decide the timing
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if time_of_day is not None:
            pulumi.set(__self__, "time_of_day", time_of_day)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> Optional[str]:
        """
        optional, Mist will decide the timing
        """
        return pulumi.get(self, "time_of_day")


@pulumi.output_type
class SettingLed(dict):
    def __init__(__self__, *,
                 brightness: Optional[int] = None,
                 enabled: Optional[bool] = None):
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def brightness(self) -> Optional[int]:
        return pulumi.get(self, "brightness")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingOccupancy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetsEnabled":
            suggest = "assets_enabled"
        elif key == "clientsEnabled":
            suggest = "clients_enabled"
        elif key == "minDuration":
            suggest = "min_duration"
        elif key == "sdkclientsEnabled":
            suggest = "sdkclients_enabled"
        elif key == "unconnectedClientsEnabled":
            suggest = "unconnected_clients_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingOccupancy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingOccupancy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingOccupancy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assets_enabled: Optional[bool] = None,
                 clients_enabled: Optional[bool] = None,
                 min_duration: Optional[int] = None,
                 sdkclients_enabled: Optional[bool] = None,
                 unconnected_clients_enabled: Optional[bool] = None):
        """
        :param bool assets_enabled: indicate whether named BLE assets should be included in the zone occupancy calculation
        :param bool clients_enabled: indicate whether connected WiFi clients should be included in the zone occupancy calculation
        :param int min_duration: minimum duration
        :param bool sdkclients_enabled: indicate whether SDK clients should be included in the zone occupancy calculation
        :param bool unconnected_clients_enabled: indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
        """
        if assets_enabled is not None:
            pulumi.set(__self__, "assets_enabled", assets_enabled)
        if clients_enabled is not None:
            pulumi.set(__self__, "clients_enabled", clients_enabled)
        if min_duration is not None:
            pulumi.set(__self__, "min_duration", min_duration)
        if sdkclients_enabled is not None:
            pulumi.set(__self__, "sdkclients_enabled", sdkclients_enabled)
        if unconnected_clients_enabled is not None:
            pulumi.set(__self__, "unconnected_clients_enabled", unconnected_clients_enabled)

    @property
    @pulumi.getter(name="assetsEnabled")
    def assets_enabled(self) -> Optional[bool]:
        """
        indicate whether named BLE assets should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "assets_enabled")

    @property
    @pulumi.getter(name="clientsEnabled")
    def clients_enabled(self) -> Optional[bool]:
        """
        indicate whether connected WiFi clients should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "clients_enabled")

    @property
    @pulumi.getter(name="minDuration")
    def min_duration(self) -> Optional[int]:
        """
        minimum duration
        """
        return pulumi.get(self, "min_duration")

    @property
    @pulumi.getter(name="sdkclientsEnabled")
    def sdkclients_enabled(self) -> Optional[bool]:
        """
        indicate whether SDK clients should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "sdkclients_enabled")

    @property
    @pulumi.getter(name="unconnectedClientsEnabled")
    def unconnected_clients_enabled(self) -> Optional[bool]:
        """
        indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
        """
        return pulumi.get(self, "unconnected_clients_enabled")


@pulumi.output_type
class SettingProxy(dict):
    def __init__(__self__, *,
                 url: Optional[str] = None):
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class SettingRogue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "honeypotEnabled":
            suggest = "honeypot_enabled"
        elif key == "minDuration":
            suggest = "min_duration"
        elif key == "minRssi":
            suggest = "min_rssi"
        elif key == "whitelistedBssids":
            suggest = "whitelisted_bssids"
        elif key == "whitelistedSsids":
            suggest = "whitelisted_ssids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingRogue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingRogue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingRogue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 honeypot_enabled: Optional[bool] = None,
                 min_duration: Optional[int] = None,
                 min_rssi: Optional[int] = None,
                 whitelisted_bssids: Optional[Sequence[str]] = None,
                 whitelisted_ssids: Optional[Sequence[str]] = None):
        """
        :param bool enabled: whether or not rogue detection is enabled
        :param bool honeypot_enabled: whether or not honeypot detection is enabled
        :param int min_duration: minimum duration for a bssid to be considered rogue
        :param int min_rssi: minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
        :param Sequence[str] whitelisted_bssids: list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
        :param Sequence[str] whitelisted_ssids: list of SSIDs to whitelist
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if honeypot_enabled is not None:
            pulumi.set(__self__, "honeypot_enabled", honeypot_enabled)
        if min_duration is not None:
            pulumi.set(__self__, "min_duration", min_duration)
        if min_rssi is not None:
            pulumi.set(__self__, "min_rssi", min_rssi)
        if whitelisted_bssids is not None:
            pulumi.set(__self__, "whitelisted_bssids", whitelisted_bssids)
        if whitelisted_ssids is not None:
            pulumi.set(__self__, "whitelisted_ssids", whitelisted_ssids)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether or not rogue detection is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="honeypotEnabled")
    def honeypot_enabled(self) -> Optional[bool]:
        """
        whether or not honeypot detection is enabled
        """
        return pulumi.get(self, "honeypot_enabled")

    @property
    @pulumi.getter(name="minDuration")
    def min_duration(self) -> Optional[int]:
        """
        minimum duration for a bssid to be considered rogue
        """
        return pulumi.get(self, "min_duration")

    @property
    @pulumi.getter(name="minRssi")
    def min_rssi(self) -> Optional[int]:
        """
        minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
        """
        return pulumi.get(self, "min_rssi")

    @property
    @pulumi.getter(name="whitelistedBssids")
    def whitelisted_bssids(self) -> Optional[Sequence[str]]:
        """
        list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
        """
        return pulumi.get(self, "whitelisted_bssids")

    @property
    @pulumi.getter(name="whitelistedSsids")
    def whitelisted_ssids(self) -> Optional[Sequence[str]]:
        """
        list of SSIDs to whitelist
        """
        return pulumi.get(self, "whitelisted_ssids")


@pulumi.output_type
class SettingRtsa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appWaking":
            suggest = "app_waking"
        elif key == "disableDeadReckoning":
            suggest = "disable_dead_reckoning"
        elif key == "disablePressureSensor":
            suggest = "disable_pressure_sensor"
        elif key == "trackAsset":
            suggest = "track_asset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingRtsa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingRtsa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingRtsa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_waking: Optional[bool] = None,
                 disable_dead_reckoning: Optional[bool] = None,
                 disable_pressure_sensor: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 track_asset: Optional[bool] = None):
        """
        :param bool track_asset: asset tracking related
        """
        if app_waking is not None:
            pulumi.set(__self__, "app_waking", app_waking)
        if disable_dead_reckoning is not None:
            pulumi.set(__self__, "disable_dead_reckoning", disable_dead_reckoning)
        if disable_pressure_sensor is not None:
            pulumi.set(__self__, "disable_pressure_sensor", disable_pressure_sensor)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if track_asset is not None:
            pulumi.set(__self__, "track_asset", track_asset)

    @property
    @pulumi.getter(name="appWaking")
    def app_waking(self) -> Optional[bool]:
        return pulumi.get(self, "app_waking")

    @property
    @pulumi.getter(name="disableDeadReckoning")
    def disable_dead_reckoning(self) -> Optional[bool]:
        return pulumi.get(self, "disable_dead_reckoning")

    @property
    @pulumi.getter(name="disablePressureSensor")
    def disable_pressure_sensor(self) -> Optional[bool]:
        return pulumi.get(self, "disable_pressure_sensor")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="trackAsset")
    def track_asset(self) -> Optional[bool]:
        """
        asset tracking related
        """
        return pulumi.get(self, "track_asset")


@pulumi.output_type
class SettingSimpleAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arpFailure":
            suggest = "arp_failure"
        elif key == "dhcpFailure":
            suggest = "dhcp_failure"
        elif key == "dnsFailure":
            suggest = "dns_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSimpleAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSimpleAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSimpleAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arp_failure: Optional['outputs.SettingSimpleAlertArpFailure'] = None,
                 dhcp_failure: Optional['outputs.SettingSimpleAlertDhcpFailure'] = None,
                 dns_failure: Optional['outputs.SettingSimpleAlertDnsFailure'] = None):
        if arp_failure is not None:
            pulumi.set(__self__, "arp_failure", arp_failure)
        if dhcp_failure is not None:
            pulumi.set(__self__, "dhcp_failure", dhcp_failure)
        if dns_failure is not None:
            pulumi.set(__self__, "dns_failure", dns_failure)

    @property
    @pulumi.getter(name="arpFailure")
    def arp_failure(self) -> Optional['outputs.SettingSimpleAlertArpFailure']:
        return pulumi.get(self, "arp_failure")

    @property
    @pulumi.getter(name="dhcpFailure")
    def dhcp_failure(self) -> Optional['outputs.SettingSimpleAlertDhcpFailure']:
        return pulumi.get(self, "dhcp_failure")

    @property
    @pulumi.getter(name="dnsFailure")
    def dns_failure(self) -> Optional['outputs.SettingSimpleAlertDnsFailure']:
        return pulumi.get(self, "dns_failure")


@pulumi.output_type
class SettingSimpleAlertArpFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCount":
            suggest = "client_count"
        elif key == "incidentCount":
            suggest = "incident_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSimpleAlertArpFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSimpleAlertArpFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSimpleAlertArpFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_count: Optional[int] = None,
                 duration: Optional[int] = None,
                 incident_count: Optional[int] = None):
        """
        :param int duration: failing within minutes
        """
        if client_count is not None:
            pulumi.set(__self__, "client_count", client_count)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if incident_count is not None:
            pulumi.set(__self__, "incident_count", incident_count)

    @property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> Optional[int]:
        return pulumi.get(self, "client_count")

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        failing within minutes
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="incidentCount")
    def incident_count(self) -> Optional[int]:
        return pulumi.get(self, "incident_count")


@pulumi.output_type
class SettingSimpleAlertDhcpFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCount":
            suggest = "client_count"
        elif key == "incidentCount":
            suggest = "incident_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSimpleAlertDhcpFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSimpleAlertDhcpFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSimpleAlertDhcpFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_count: Optional[int] = None,
                 duration: Optional[int] = None,
                 incident_count: Optional[int] = None):
        """
        :param int duration: failing within minutes
        """
        if client_count is not None:
            pulumi.set(__self__, "client_count", client_count)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if incident_count is not None:
            pulumi.set(__self__, "incident_count", incident_count)

    @property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> Optional[int]:
        return pulumi.get(self, "client_count")

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        failing within minutes
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="incidentCount")
    def incident_count(self) -> Optional[int]:
        return pulumi.get(self, "incident_count")


@pulumi.output_type
class SettingSimpleAlertDnsFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCount":
            suggest = "client_count"
        elif key == "incidentCount":
            suggest = "incident_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSimpleAlertDnsFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSimpleAlertDnsFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSimpleAlertDnsFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_count: Optional[int] = None,
                 duration: Optional[int] = None,
                 incident_count: Optional[int] = None):
        """
        :param int duration: failing within minutes
        """
        if client_count is not None:
            pulumi.set(__self__, "client_count", client_count)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if incident_count is not None:
            pulumi.set(__self__, "incident_count", incident_count)

    @property
    @pulumi.getter(name="clientCount")
    def client_count(self) -> Optional[int]:
        return pulumi.get(self, "client_count")

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        failing within minutes
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="incidentCount")
    def incident_count(self) -> Optional[int]:
        return pulumi.get(self, "incident_count")


@pulumi.output_type
class SettingSkyatp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendIpMacMapping":
            suggest = "send_ip_mac_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSkyatp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSkyatp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSkyatp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 send_ip_mac_mapping: Optional[bool] = None):
        """
        :param bool send_ip_mac_mapping: whether to send IP-MAC mapping to SkyATP
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if send_ip_mac_mapping is not None:
            pulumi.set(__self__, "send_ip_mac_mapping", send_ip_mac_mapping)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sendIpMacMapping")
    def send_ip_mac_mapping(self) -> Optional[bool]:
        """
        whether to send IP-MAC mapping to SkyATP
        """
        return pulumi.get(self, "send_ip_mac_mapping")


@pulumi.output_type
class SettingSrxApp(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingSsr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conductorHosts":
            suggest = "conductor_hosts"
        elif key == "disableStats":
            suggest = "disable_stats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSsr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSsr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSsr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conductor_hosts: Optional[Sequence[str]] = None,
                 disable_stats: Optional[bool] = None):
        if conductor_hosts is not None:
            pulumi.set(__self__, "conductor_hosts", conductor_hosts)
        if disable_stats is not None:
            pulumi.set(__self__, "disable_stats", disable_stats)

    @property
    @pulumi.getter(name="conductorHosts")
    def conductor_hosts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "conductor_hosts")

    @property
    @pulumi.getter(name="disableStats")
    def disable_stats(self) -> Optional[bool]:
        return pulumi.get(self, "disable_stats")


@pulumi.output_type
class SettingSyntheticTest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanSpeedtest":
            suggest = "wan_speedtest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSyntheticTest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSyntheticTest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSyntheticTest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[bool] = None,
                 vlans: Optional[Sequence['outputs.SettingSyntheticTestVlan']] = None,
                 wan_speedtest: Optional['outputs.SettingSyntheticTestWanSpeedtest'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)
        if wan_speedtest is not None:
            pulumi.set(__self__, "wan_speedtest", wan_speedtest)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence['outputs.SettingSyntheticTestVlan']]:
        return pulumi.get(self, "vlans")

    @property
    @pulumi.getter(name="wanSpeedtest")
    def wan_speedtest(self) -> Optional['outputs.SettingSyntheticTestWanSpeedtest']:
        return pulumi.get(self, "wan_speedtest")


@pulumi.output_type
class SettingSyntheticTestVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTestUrls":
            suggest = "custom_test_urls"
        elif key == "vlanIds":
            suggest = "vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSyntheticTestVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSyntheticTestVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSyntheticTestVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_test_urls: Optional[Sequence[str]] = None,
                 disabled: Optional[bool] = None,
                 vlan_ids: Optional[Sequence[str]] = None):
        """
        :param bool disabled: for some vlans where we don't want this to run
        """
        if custom_test_urls is not None:
            pulumi.set(__self__, "custom_test_urls", custom_test_urls)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @property
    @pulumi.getter(name="customTestUrls")
    def custom_test_urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "custom_test_urls")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        for some vlans where we don't want this to run
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "vlan_ids")


@pulumi.output_type
class SettingSyntheticTestWanSpeedtest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeOdFay":
            suggest = "time_od_fay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSyntheticTestWanSpeedtest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSyntheticTestWanSpeedtest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSyntheticTestWanSpeedtest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 time_od_fay: Optional[str] = None):
        """
        :param str time_od_fay: any / HH:MM (24-hour format)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if time_od_fay is not None:
            pulumi.set(__self__, "time_od_fay", time_od_fay)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="timeOdFay")
    def time_od_fay(self) -> Optional[str]:
        """
        any / HH:MM (24-hour format)
        """
        return pulumi.get(self, "time_od_fay")


@pulumi.output_type
class SettingUplinkPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepWlansUpIfDown":
            suggest = "keep_wlans_up_if_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingUplinkPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingUplinkPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingUplinkPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dot1x: Optional[bool] = None,
                 keep_wlans_up_if_down: Optional[bool] = None):
        """
        :param bool dot1x: Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param bool keep_wlans_up_if_down: by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @property
    @pulumi.getter
    def dot1x(self) -> Optional[bool]:
        """
        Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[bool]:
        """
        by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")


@pulumi.output_type
class SettingVna(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingVsInstance(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[str]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class SettingWanVna(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingWids(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repeatedAuthFailures":
            suggest = "repeated_auth_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingWids. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingWids.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingWids.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repeated_auth_failures: Optional['outputs.SettingWidsRepeatedAuthFailures'] = None):
        if repeated_auth_failures is not None:
            pulumi.set(__self__, "repeated_auth_failures", repeated_auth_failures)

    @property
    @pulumi.getter(name="repeatedAuthFailures")
    def repeated_auth_failures(self) -> Optional['outputs.SettingWidsRepeatedAuthFailures']:
        return pulumi.get(self, "repeated_auth_failures")


@pulumi.output_type
class SettingWidsRepeatedAuthFailures(dict):
    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 threshold: Optional[int] = None):
        """
        :param int duration: window where a trigger will be detected and action to be taken (in seconds)
        :param int threshold: count of events to trigger
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        window where a trigger will be detected and action to be taken (in seconds)
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        count of events to trigger
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class SettingWifi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ciscoEnabled":
            suggest = "cisco_enabled"
        elif key == "disableRadiosWhenPowerConstrained":
            suggest = "disable_radios_when_power_constrained"
        elif key == "enableArpSpoofCheck":
            suggest = "enable_arp_spoof_check"
        elif key == "enableSharedRadioScanning":
            suggest = "enable_shared_radio_scanning"
        elif key == "locateConnected":
            suggest = "locate_connected"
        elif key == "locateUnconnected":
            suggest = "locate_unconnected"
        elif key == "meshAllowDfs":
            suggest = "mesh_allow_dfs"
        elif key == "meshEnableCrm":
            suggest = "mesh_enable_crm"
        elif key == "meshEnabled":
            suggest = "mesh_enabled"
        elif key == "meshPsk":
            suggest = "mesh_psk"
        elif key == "meshSsid":
            suggest = "mesh_ssid"
        elif key == "proxyArp":
            suggest = "proxy_arp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingWifi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingWifi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingWifi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cisco_enabled: Optional[bool] = None,
                 disable11k: Optional[bool] = None,
                 disable_radios_when_power_constrained: Optional[bool] = None,
                 enable_arp_spoof_check: Optional[bool] = None,
                 enable_shared_radio_scanning: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 locate_connected: Optional[bool] = None,
                 locate_unconnected: Optional[bool] = None,
                 mesh_allow_dfs: Optional[bool] = None,
                 mesh_enable_crm: Optional[bool] = None,
                 mesh_enabled: Optional[bool] = None,
                 mesh_psk: Optional[str] = None,
                 mesh_ssid: Optional[str] = None,
                 proxy_arp: Optional[str] = None):
        """
        :param bool disable11k: whether to disable 11k
        :param bool enable_arp_spoof_check: when proxy_arp is enabled, check for arp spoofing.
        :param bool enabled: enable WIFI feature (using SUB-MAN license)
        :param bool locate_connected: whether to locate connected clients
        :param bool locate_unconnected: whether to locate unconnected clients
        :param bool mesh_allow_dfs: whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
        :param bool mesh_enable_crm: used to enable/disable CRM
        :param bool mesh_enabled: whether to enable Mesh feature for the site
        :param str mesh_psk: optional passphrase of mesh networking, default is generated randomly
        :param str mesh_ssid: optional ssid of mesh networking, default is based on site_id
        :param str proxy_arp: enum: `default`, `disabled`, `enabled`
        """
        if cisco_enabled is not None:
            pulumi.set(__self__, "cisco_enabled", cisco_enabled)
        if disable11k is not None:
            pulumi.set(__self__, "disable11k", disable11k)
        if disable_radios_when_power_constrained is not None:
            pulumi.set(__self__, "disable_radios_when_power_constrained", disable_radios_when_power_constrained)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_shared_radio_scanning is not None:
            pulumi.set(__self__, "enable_shared_radio_scanning", enable_shared_radio_scanning)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if locate_connected is not None:
            pulumi.set(__self__, "locate_connected", locate_connected)
        if locate_unconnected is not None:
            pulumi.set(__self__, "locate_unconnected", locate_unconnected)
        if mesh_allow_dfs is not None:
            pulumi.set(__self__, "mesh_allow_dfs", mesh_allow_dfs)
        if mesh_enable_crm is not None:
            pulumi.set(__self__, "mesh_enable_crm", mesh_enable_crm)
        if mesh_enabled is not None:
            pulumi.set(__self__, "mesh_enabled", mesh_enabled)
        if mesh_psk is not None:
            pulumi.set(__self__, "mesh_psk", mesh_psk)
        if mesh_ssid is not None:
            pulumi.set(__self__, "mesh_ssid", mesh_ssid)
        if proxy_arp is not None:
            pulumi.set(__self__, "proxy_arp", proxy_arp)

    @property
    @pulumi.getter(name="ciscoEnabled")
    def cisco_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "cisco_enabled")

    @property
    @pulumi.getter
    def disable11k(self) -> Optional[bool]:
        """
        whether to disable 11k
        """
        return pulumi.get(self, "disable11k")

    @property
    @pulumi.getter(name="disableRadiosWhenPowerConstrained")
    def disable_radios_when_power_constrained(self) -> Optional[bool]:
        return pulumi.get(self, "disable_radios_when_power_constrained")

    @property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[bool]:
        """
        when proxy_arp is enabled, check for arp spoofing.
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @property
    @pulumi.getter(name="enableSharedRadioScanning")
    def enable_shared_radio_scanning(self) -> Optional[bool]:
        return pulumi.get(self, "enable_shared_radio_scanning")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        enable WIFI feature (using SUB-MAN license)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="locateConnected")
    def locate_connected(self) -> Optional[bool]:
        """
        whether to locate connected clients
        """
        return pulumi.get(self, "locate_connected")

    @property
    @pulumi.getter(name="locateUnconnected")
    def locate_unconnected(self) -> Optional[bool]:
        """
        whether to locate unconnected clients
        """
        return pulumi.get(self, "locate_unconnected")

    @property
    @pulumi.getter(name="meshAllowDfs")
    def mesh_allow_dfs(self) -> Optional[bool]:
        """
        whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
        """
        return pulumi.get(self, "mesh_allow_dfs")

    @property
    @pulumi.getter(name="meshEnableCrm")
    def mesh_enable_crm(self) -> Optional[bool]:
        """
        used to enable/disable CRM
        """
        return pulumi.get(self, "mesh_enable_crm")

    @property
    @pulumi.getter(name="meshEnabled")
    def mesh_enabled(self) -> Optional[bool]:
        """
        whether to enable Mesh feature for the site
        """
        return pulumi.get(self, "mesh_enabled")

    @property
    @pulumi.getter(name="meshPsk")
    def mesh_psk(self) -> Optional[str]:
        """
        optional passphrase of mesh networking, default is generated randomly
        """
        return pulumi.get(self, "mesh_psk")

    @property
    @pulumi.getter(name="meshSsid")
    def mesh_ssid(self) -> Optional[str]:
        """
        optional ssid of mesh networking, default is based on site_id
        """
        return pulumi.get(self, "mesh_ssid")

    @property
    @pulumi.getter(name="proxyArp")
    def proxy_arp(self) -> Optional[str]:
        """
        enum: `default`, `disabled`, `enabled`
        """
        return pulumi.get(self, "proxy_arp")


@pulumi.output_type
class SettingWiredVna(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SettingZoneOccupancyAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailNotifiers":
            suggest = "email_notifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingZoneOccupancyAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingZoneOccupancyAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingZoneOccupancyAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_notifiers: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 threshold: Optional[int] = None):
        """
        :param Sequence[str] email_notifiers: list of email addresses to send email notifications when the alert threshold is reached
        :param bool enabled: indicate whether zone occupancy alert is enabled for the site
        :param int threshold: sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
        """
        if email_notifiers is not None:
            pulumi.set(__self__, "email_notifiers", email_notifiers)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="emailNotifiers")
    def email_notifiers(self) -> Optional[Sequence[str]]:
        """
        list of email addresses to send email notifications when the alert threshold is reached
        """
        return pulumi.get(self, "email_notifiers")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        indicate whether zone occupancy alert is enabled for the site
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class WlanAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 secret: str,
                 keywrap_enabled: Optional[bool] = None,
                 keywrap_format: Optional[str] = None,
                 keywrap_kek: Optional[str] = None,
                 keywrap_mack: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: ip / hostname of RADIUS server
        :param str secret: secret of RADIUS server
        :param str keywrap_format: enum: `ascii`, `hex`
        :param int port: Acct port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "keywrap_enabled")

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_kek")

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_mack")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Acct port of RADIUS server
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanAirwatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "consoleUrl":
            suggest = "console_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAirwatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAirwatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAirwatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 console_url: str,
                 password: str,
                 username: str,
                 enabled: Optional[bool] = None):
        """
        :param str api_key: API Key
        :param str console_url: console URL
        :param str password: password
        :param str username: username
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "console_url", console_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="consoleUrl")
    def console_url(self) -> str:
        """
        console URL
        """
        return pulumi.get(self, "console_url")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        password
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        username
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanAppLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wxtagIds":
            suggest = "wxtag_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAppLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAppLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAppLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apps: Optional[Mapping[str, int]] = None,
                 enabled: Optional[bool] = None,
                 wxtag_ids: Optional[Mapping[str, int]] = None):
        """
        :param Mapping[str, int] apps: Map from app key to bandwidth in kbps. 
               Property key is the app key, defined in Get Application List
        :param Mapping[str, int] wxtag_ids: Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps
               Property key is the wxtag id
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if wxtag_ids is not None:
            pulumi.set(__self__, "wxtag_ids", wxtag_ids)

    @property
    @pulumi.getter
    def apps(self) -> Optional[Mapping[str, int]]:
        """
        Map from app key to bandwidth in kbps. 
        Property key is the app key, defined in Get Application List
        """
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="wxtagIds")
    def wxtag_ids(self) -> Optional[Mapping[str, int]]:
        """
        Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps
        Property key is the wxtag id
        """
        return pulumi.get(self, "wxtag_ids")


@pulumi.output_type
class WlanAppQos(dict):
    def __init__(__self__, *,
                 apps: Optional[Mapping[str, 'outputs.WlanAppQosApps']] = None,
                 enabled: Optional[bool] = None,
                 others: Optional[Sequence['outputs.WlanAppQosOther']] = None):
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if others is not None:
            pulumi.set(__self__, "others", others)

    @property
    @pulumi.getter
    def apps(self) -> Optional[Mapping[str, 'outputs.WlanAppQosApps']]:
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def others(self) -> Optional[Sequence['outputs.WlanAppQosOther']]:
        return pulumi.get(self, "others")


@pulumi.output_type
class WlanAppQosApps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstSubnet":
            suggest = "dst_subnet"
        elif key == "srcSubnet":
            suggest = "src_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAppQosApps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAppQosApps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAppQosApps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dscp: Optional[int] = None,
                 dst_subnet: Optional[str] = None,
                 src_subnet: Optional[str] = None):
        """
        :param str dst_subnet: subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        :param str src_subnet: subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[int]:
        return pulumi.get(self, "dscp")

    @property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[str]:
        """
        subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "dst_subnet")

    @property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[str]:
        """
        subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
        """
        return pulumi.get(self, "src_subnet")


@pulumi.output_type
class WlanAppQosOther(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstSubnet":
            suggest = "dst_subnet"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "srcSubnet":
            suggest = "src_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAppQosOther. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAppQosOther.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAppQosOther.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dscp: Optional[int] = None,
                 dst_subnet: Optional[str] = None,
                 port_ranges: Optional[str] = None,
                 protocol: Optional[str] = None,
                 src_subnet: Optional[str] = None):
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_subnet is not None:
            pulumi.set(__self__, "dst_subnet", dst_subnet)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if src_subnet is not None:
            pulumi.set(__self__, "src_subnet", src_subnet)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[int]:
        return pulumi.get(self, "dscp")

    @property
    @pulumi.getter(name="dstSubnet")
    def dst_subnet(self) -> Optional[str]:
        return pulumi.get(self, "dst_subnet")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[str]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="srcSubnet")
    def src_subnet(self) -> Optional[str]:
        return pulumi.get(self, "src_subnet")


@pulumi.output_type
class WlanAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anticlogThreshold":
            suggest = "anticlog_threshold"
        elif key == "eapReauth":
            suggest = "eap_reauth"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "keyIdx":
            suggest = "key_idx"
        elif key == "multiPskOnly":
            suggest = "multi_psk_only"
        elif key == "privateWlan":
            suggest = "private_wlan"
        elif key == "wepAsSecondaryAuth":
            suggest = "wep_as_secondary_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anticlog_threshold: Optional[int] = None,
                 eap_reauth: Optional[bool] = None,
                 enable_mac_auth: Optional[bool] = None,
                 key_idx: Optional[int] = None,
                 keys: Optional[Sequence[str]] = None,
                 multi_psk_only: Optional[bool] = None,
                 owe: Optional[str] = None,
                 pairwises: Optional[Sequence[str]] = None,
                 private_wlan: Optional[bool] = None,
                 psk: Optional[str] = None,
                 type: Optional[str] = None,
                 wep_as_secondary_auth: Optional[bool] = None):
        """
        :param int anticlog_threshold: SAE anti-clogging token threshold
        :param bool eap_reauth: whether to trigger EAP reauth when the session ends
        :param bool enable_mac_auth: whether to enable MAC Auth, uses the same auth_servers
        :param int key_idx: when `type`==`wep`
        :param Sequence[str] keys: when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        :param bool multi_psk_only: when `type`==`psk`, whether to only use multi_psk
        :param str owe: if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        :param Sequence[str] pairwises: when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        :param bool private_wlan: when `multi_psk_only`==`true`, whether private wlan is enabled
        :param str psk: when `type`==`psk`, 8-64 characters, or 64 hex characters
        :param str type: enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        :param bool wep_as_secondary_auth: enable WEP as secondary auth
        """
        if anticlog_threshold is not None:
            pulumi.set(__self__, "anticlog_threshold", anticlog_threshold)
        if eap_reauth is not None:
            pulumi.set(__self__, "eap_reauth", eap_reauth)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if key_idx is not None:
            pulumi.set(__self__, "key_idx", key_idx)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if multi_psk_only is not None:
            pulumi.set(__self__, "multi_psk_only", multi_psk_only)
        if owe is not None:
            pulumi.set(__self__, "owe", owe)
        if pairwises is not None:
            pulumi.set(__self__, "pairwises", pairwises)
        if private_wlan is not None:
            pulumi.set(__self__, "private_wlan", private_wlan)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wep_as_secondary_auth is not None:
            pulumi.set(__self__, "wep_as_secondary_auth", wep_as_secondary_auth)

    @property
    @pulumi.getter(name="anticlogThreshold")
    def anticlog_threshold(self) -> Optional[int]:
        """
        SAE anti-clogging token threshold
        """
        return pulumi.get(self, "anticlog_threshold")

    @property
    @pulumi.getter(name="eapReauth")
    def eap_reauth(self) -> Optional[bool]:
        """
        whether to trigger EAP reauth when the session ends
        """
        return pulumi.get(self, "eap_reauth")

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[bool]:
        """
        whether to enable MAC Auth, uses the same auth_servers
        """
        return pulumi.get(self, "enable_mac_auth")

    @property
    @pulumi.getter(name="keyIdx")
    def key_idx(self) -> Optional[int]:
        """
        when `type`==`wep`
        """
        return pulumi.get(self, "key_idx")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[str]]:
        """
        when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="multiPskOnly")
    def multi_psk_only(self) -> Optional[bool]:
        """
        when `type`==`psk`, whether to only use multi_psk
        """
        return pulumi.get(self, "multi_psk_only")

    @property
    @pulumi.getter
    def owe(self) -> Optional[str]:
        """
        if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
        """
        return pulumi.get(self, "owe")

    @property
    @pulumi.getter
    def pairwises(self) -> Optional[Sequence[str]]:
        """
        when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
        """
        return pulumi.get(self, "pairwises")

    @property
    @pulumi.getter(name="privateWlan")
    def private_wlan(self) -> Optional[bool]:
        """
        when `multi_psk_only`==`true`, whether private wlan is enabled
        """
        return pulumi.get(self, "private_wlan")

    @property
    @pulumi.getter
    def psk(self) -> Optional[str]:
        """
        when `type`==`psk`, 8-64 characters, or 64 hex characters
        """
        return pulumi.get(self, "psk")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="wepAsSecondaryAuth")
    def wep_as_secondary_auth(self) -> Optional[bool]:
        """
        enable WEP as secondary auth
        """
        return pulumi.get(self, "wep_as_secondary_auth")


@pulumi.output_type
class WlanAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 secret: str,
                 keywrap_enabled: Optional[bool] = None,
                 keywrap_format: Optional[str] = None,
                 keywrap_kek: Optional[str] = None,
                 keywrap_mack: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: ip / hostname of RADIUS server
        :param str secret: secret of RADIUS server
        :param str keywrap_format: enum: `ascii`, `hex`
        :param int port: Auth port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "keywrap_enabled")

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_kek")

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[str]:
        return pulumi.get(self, "keywrap_mack")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Auth port of RADIUS server
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanBonjour(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVlanIds":
            suggest = "additional_vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanBonjour. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanBonjour.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanBonjour.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_vlan_ids: Sequence[str],
                 services: Mapping[str, 'outputs.WlanBonjourServices'],
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] additional_vlan_ids: additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        :param Mapping[str, 'WlanBonjourServicesArgs'] services: what services are allowed. 
               Property key is the service name
        :param bool enabled: whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        pulumi.set(__self__, "additional_vlan_ids", additional_vlan_ids)
        pulumi.set(__self__, "services", services)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="additionalVlanIds")
    def additional_vlan_ids(self) -> Sequence[str]:
        """
        additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
        """
        return pulumi.get(self, "additional_vlan_ids")

    @property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.WlanBonjourServices']:
        """
        what services are allowed. 
        Property key is the service name
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanBonjourServices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableLocal":
            suggest = "disable_local"
        elif key == "radiusGroups":
            suggest = "radius_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanBonjourServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanBonjourServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanBonjourServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_local: Optional[bool] = None,
                 radius_groups: Optional[Sequence[str]] = None,
                 scope: Optional[str] = None):
        """
        :param bool disable_local: whether to prevent wireless clients to discover bonjour devices on the same WLAN
        :param Sequence[str] radius_groups: optional, if the service is further restricted for certain RADIUS groups
        :param str scope: how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        if disable_local is not None:
            pulumi.set(__self__, "disable_local", disable_local)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="disableLocal")
    def disable_local(self) -> Optional[bool]:
        """
        whether to prevent wireless clients to discover bonjour devices on the same WLAN
        """
        return pulumi.get(self, "disable_local")

    @property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[Sequence[str]]:
        """
        optional, if the service is further restricted for certain RADIUS groups
        """
        return pulumi.get(self, "radius_groups")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class WlanCiscoCwa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHostnames":
            suggest = "allowed_hostnames"
        elif key == "allowedSubnets":
            suggest = "allowed_subnets"
        elif key == "blockedSubnets":
            suggest = "blocked_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanCiscoCwa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanCiscoCwa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanCiscoCwa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_hostnames: Optional[Sequence[str]] = None,
                 allowed_subnets: Optional[Sequence[str]] = None,
                 blocked_subnets: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] allowed_hostnames: list of hostnames without http(s):// (matched by substring)
        :param Sequence[str] allowed_subnets: list of CIDRs
        :param Sequence[str] blocked_subnets: list of blocked CIDRs
        """
        if allowed_hostnames is not None:
            pulumi.set(__self__, "allowed_hostnames", allowed_hostnames)
        if allowed_subnets is not None:
            pulumi.set(__self__, "allowed_subnets", allowed_subnets)
        if blocked_subnets is not None:
            pulumi.set(__self__, "blocked_subnets", blocked_subnets)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="allowedHostnames")
    def allowed_hostnames(self) -> Optional[Sequence[str]]:
        """
        list of hostnames without http(s):// (matched by substring)
        """
        return pulumi.get(self, "allowed_hostnames")

    @property
    @pulumi.getter(name="allowedSubnets")
    def allowed_subnets(self) -> Optional[Sequence[str]]:
        """
        list of CIDRs
        """
        return pulumi.get(self, "allowed_subnets")

    @property
    @pulumi.getter(name="blockedSubnets")
    def blocked_subnets(self) -> Optional[Sequence[str]]:
        """
        list of blocked CIDRs
        """
        return pulumi.get(self, "blocked_subnets")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanCoaServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableEventTimestampCheck":
            suggest = "disable_event_timestamp_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanCoaServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanCoaServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanCoaServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: str,
                 secret: str,
                 disable_event_timestamp_check: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 port: Optional[int] = None):
        """
        :param bool disable_event_timestamp_check: whether to disable Event-Timestamp Check
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "secret", secret)
        if disable_event_timestamp_check is not None:
            pulumi.set(__self__, "disable_event_timestamp_check", disable_event_timestamp_check)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def secret(self) -> str:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="disableEventTimestampCheck")
    def disable_event_timestamp_check(self) -> Optional[bool]:
        """
        whether to disable Event-Timestamp Check
        """
        return pulumi.get(self, "disable_event_timestamp_check")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanDnsServerRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "radiusGroups":
            suggest = "radius_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanDnsServerRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanDnsServerRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanDnsServerRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 radius_groups: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] radius_groups: map between radius_group and the desired DNS server (IPv4 only)
               Property key is the RADIUS group, property value is the desired DNS Server
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if radius_groups is not None:
            pulumi.set(__self__, "radius_groups", radius_groups)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="radiusGroups")
    def radius_groups(self) -> Optional[Mapping[str, str]]:
        """
        map between radius_group and the desired DNS server (IPv4 only)
        Property key is the RADIUS group, property value is the desired DNS Server
        """
        return pulumi.get(self, "radius_groups")


@pulumi.output_type
class WlanDynamicPsk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPsk":
            suggest = "default_psk"
        elif key == "defaultVlanId":
            suggest = "default_vlan_id"
        elif key == "forceLookup":
            suggest = "force_lookup"
        elif key == "vlanIds":
            suggest = "vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanDynamicPsk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanDynamicPsk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanDynamicPsk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_psk: Optional[str] = None,
                 default_vlan_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 force_lookup: Optional[bool] = None,
                 source: Optional[str] = None,
                 vlan_ids: Optional[Sequence[str]] = None):
        """
        :param str default_psk: default PSK to use if cloud WLC is not available, 8-63 characters
        :param bool force_lookup: when 11r is enabled, we'll try to use the cached PMK, this can be disabled
               `false` means auto
        :param str source: enum: `cloud_psks`, `radius`
        """
        if default_psk is not None:
            pulumi.set(__self__, "default_psk", default_psk)
        if default_vlan_id is not None:
            pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force_lookup is not None:
            pulumi.set(__self__, "force_lookup", force_lookup)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)

    @property
    @pulumi.getter(name="defaultPsk")
    def default_psk(self) -> Optional[str]:
        """
        default PSK to use if cloud WLC is not available, 8-63 characters
        """
        return pulumi.get(self, "default_psk")

    @property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> Optional[str]:
        return pulumi.get(self, "default_vlan_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="forceLookup")
    def force_lookup(self) -> Optional[bool]:
        """
        when 11r is enabled, we'll try to use the cached PMK, this can be disabled
        `false` means auto
        """
        return pulumi.get(self, "force_lookup")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        enum: `cloud_psks`, `radius`
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "vlan_ids")


@pulumi.output_type
class WlanDynamicVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultVlanIds":
            suggest = "default_vlan_ids"
        elif key == "localVlanIds":
            suggest = "local_vlan_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanDynamicVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanDynamicVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanDynamicVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_vlan_ids: Sequence[str],
                 enabled: Optional[bool] = None,
                 local_vlan_ids: Optional[Sequence[str]] = None,
                 type: Optional[str] = None,
                 vlans: Optional[Mapping[str, str]] = None):
        """
        :param Sequence[str] default_vlan_ids: Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        :param bool enabled: whether to enable dynamic vlan
        :param Sequence[str] local_vlan_ids: vlan_ids to be locally bridged
        :param str type: standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        :param Mapping[str, str] vlans: map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping
                 * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
                 * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        pulumi.set(__self__, "default_vlan_ids", default_vlan_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if local_vlan_ids is not None:
            pulumi.set(__self__, "local_vlan_ids", local_vlan_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="defaultVlanIds")
    def default_vlan_ids(self) -> Sequence[str]:
        """
        Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
        """
        return pulumi.get(self, "default_vlan_ids")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether to enable dynamic vlan
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="localVlanIds")
    def local_vlan_ids(self) -> Optional[Sequence[str]]:
        """
        vlan_ids to be locally bridged
        """
        return pulumi.get(self, "local_vlan_ids")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Mapping[str, str]]:
        """
        map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping
          * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\"\\"
          * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class WlanHotspot20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNames":
            suggest = "domain_names"
        elif key == "naiRealms":
            suggest = "nai_realms"
        elif key == "venueName":
            suggest = "venue_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanHotspot20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanHotspot20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanHotspot20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_names: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 nai_realms: Optional[Sequence[str]] = None,
                 operators: Optional[Sequence[str]] = None,
                 rcois: Optional[Sequence[str]] = None,
                 venue_name: Optional[str] = None):
        """
        :param bool enabled: whether to enable hotspot 2.0 config
        :param Sequence[str] operators: list of operators to support
        :param str venue_name: venue name, default is site name
        """
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if nai_realms is not None:
            pulumi.set(__self__, "nai_realms", nai_realms)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)
        if rcois is not None:
            pulumi.set(__self__, "rcois", rcois)
        if venue_name is not None:
            pulumi.set(__self__, "venue_name", venue_name)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether to enable hotspot 2.0 config
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="naiRealms")
    def nai_realms(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "nai_realms")

    @property
    @pulumi.getter
    def operators(self) -> Optional[Sequence[str]]:
        """
        list of operators to support
        """
        return pulumi.get(self, "operators")

    @property
    @pulumi.getter
    def rcois(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "rcois")

    @property
    @pulumi.getter(name="venueName")
    def venue_name(self) -> Optional[str]:
        """
        venue name, default is site name
        """
        return pulumi.get(self, "venue_name")


@pulumi.output_type
class WlanInjectDhcpOption82(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "circuitId":
            suggest = "circuit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanInjectDhcpOption82. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanInjectDhcpOption82.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanInjectDhcpOption82.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 circuit_id: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: whether to inject option 82 when forwarding DHCP packets
        """
        if circuit_id is not None:
            pulumi.set(__self__, "circuit_id", circuit_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="circuitId")
    def circuit_id(self) -> Optional[str]:
        return pulumi.get(self, "circuit_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether to inject option 82 when forwarding DHCP packets
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanMistNac(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: when enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed'
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        when enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed'
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class WlanPortal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonClientId":
            suggest = "amazon_client_id"
        elif key == "amazonClientSecret":
            suggest = "amazon_client_secret"
        elif key == "amazonEmailDomains":
            suggest = "amazon_email_domains"
        elif key == "amazonEnabled":
            suggest = "amazon_enabled"
        elif key == "amazonExpire":
            suggest = "amazon_expire"
        elif key == "azureClientId":
            suggest = "azure_client_id"
        elif key == "azureClientSecret":
            suggest = "azure_client_secret"
        elif key == "azureEnabled":
            suggest = "azure_enabled"
        elif key == "azureExpire":
            suggest = "azure_expire"
        elif key == "azureTenantId":
            suggest = "azure_tenant_id"
        elif key == "broadnetPassword":
            suggest = "broadnet_password"
        elif key == "broadnetSid":
            suggest = "broadnet_sid"
        elif key == "broadnetUserId":
            suggest = "broadnet_user_id"
        elif key == "bypassWhenCloudDown":
            suggest = "bypass_when_cloud_down"
        elif key == "clickatellApiKey":
            suggest = "clickatell_api_key"
        elif key == "crossSite":
            suggest = "cross_site"
        elif key == "emailEnabled":
            suggest = "email_enabled"
        elif key == "externalPortalUrl":
            suggest = "external_portal_url"
        elif key == "facebookClientId":
            suggest = "facebook_client_id"
        elif key == "facebookClientSecret":
            suggest = "facebook_client_secret"
        elif key == "facebookEmailDomains":
            suggest = "facebook_email_domains"
        elif key == "facebookEnabled":
            suggest = "facebook_enabled"
        elif key == "facebookExpire":
            suggest = "facebook_expire"
        elif key == "forwardUrl":
            suggest = "forward_url"
        elif key == "googleClientId":
            suggest = "google_client_id"
        elif key == "googleClientSecret":
            suggest = "google_client_secret"
        elif key == "googleEmailDomains":
            suggest = "google_email_domains"
        elif key == "googleEnabled":
            suggest = "google_enabled"
        elif key == "googleExpire":
            suggest = "google_expire"
        elif key == "gupshupPassword":
            suggest = "gupshup_password"
        elif key == "gupshupUserid":
            suggest = "gupshup_userid"
        elif key == "microsoftClientId":
            suggest = "microsoft_client_id"
        elif key == "microsoftClientSecret":
            suggest = "microsoft_client_secret"
        elif key == "microsoftEmailDomains":
            suggest = "microsoft_email_domains"
        elif key == "microsoftEnabled":
            suggest = "microsoft_enabled"
        elif key == "microsoftExpire":
            suggest = "microsoft_expire"
        elif key == "passphraseEnabled":
            suggest = "passphrase_enabled"
        elif key == "passphraseExpire":
            suggest = "passphrase_expire"
        elif key == "predefinedSponsorsEnabled":
            suggest = "predefined_sponsors_enabled"
        elif key == "predefinedSponsorsHideEmail":
            suggest = "predefined_sponsors_hide_email"
        elif key == "puzzelPassword":
            suggest = "puzzel_password"
        elif key == "puzzelServiceId":
            suggest = "puzzel_service_id"
        elif key == "puzzelUsername":
            suggest = "puzzel_username"
        elif key == "smsEnabled":
            suggest = "sms_enabled"
        elif key == "smsExpire":
            suggest = "sms_expire"
        elif key == "smsMessageFormat":
            suggest = "sms_message_format"
        elif key == "smsProvider":
            suggest = "sms_provider"
        elif key == "sponsorAutoApprove":
            suggest = "sponsor_auto_approve"
        elif key == "sponsorEmailDomains":
            suggest = "sponsor_email_domains"
        elif key == "sponsorEnabled":
            suggest = "sponsor_enabled"
        elif key == "sponsorExpire":
            suggest = "sponsor_expire"
        elif key == "sponsorLinkValidityDuration":
            suggest = "sponsor_link_validity_duration"
        elif key == "sponsorNotifyAll":
            suggest = "sponsor_notify_all"
        elif key == "sponsorStatusNotify":
            suggest = "sponsor_status_notify"
        elif key == "ssoDefaultRole":
            suggest = "sso_default_role"
        elif key == "ssoForcedRole":
            suggest = "sso_forced_role"
        elif key == "ssoIdpCert":
            suggest = "sso_idp_cert"
        elif key == "ssoIdpSignAlgo":
            suggest = "sso_idp_sign_algo"
        elif key == "ssoIdpSsoUrl":
            suggest = "sso_idp_sso_url"
        elif key == "ssoIssuer":
            suggest = "sso_issuer"
        elif key == "ssoNameidFormat":
            suggest = "sso_nameid_format"
        elif key == "telstraClientId":
            suggest = "telstra_client_id"
        elif key == "telstraClientSecret":
            suggest = "telstra_client_secret"
        elif key == "twilioAuthToken":
            suggest = "twilio_auth_token"
        elif key == "twilioPhoneNumber":
            suggest = "twilio_phone_number"
        elif key == "twilioSid":
            suggest = "twilio_sid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanPortal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanPortal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanPortal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_client_id: Optional[str] = None,
                 amazon_client_secret: Optional[str] = None,
                 amazon_email_domains: Optional[Sequence[str]] = None,
                 amazon_enabled: Optional[bool] = None,
                 amazon_expire: Optional[float] = None,
                 auth: Optional[str] = None,
                 azure_client_id: Optional[str] = None,
                 azure_client_secret: Optional[str] = None,
                 azure_enabled: Optional[bool] = None,
                 azure_expire: Optional[float] = None,
                 azure_tenant_id: Optional[str] = None,
                 broadnet_password: Optional[str] = None,
                 broadnet_sid: Optional[str] = None,
                 broadnet_user_id: Optional[str] = None,
                 bypass_when_cloud_down: Optional[bool] = None,
                 clickatell_api_key: Optional[str] = None,
                 cross_site: Optional[bool] = None,
                 email_enabled: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 expire: Optional[float] = None,
                 external_portal_url: Optional[str] = None,
                 facebook_client_id: Optional[str] = None,
                 facebook_client_secret: Optional[str] = None,
                 facebook_email_domains: Optional[Sequence[str]] = None,
                 facebook_enabled: Optional[bool] = None,
                 facebook_expire: Optional[float] = None,
                 forward: Optional[bool] = None,
                 forward_url: Optional[str] = None,
                 google_client_id: Optional[str] = None,
                 google_client_secret: Optional[str] = None,
                 google_email_domains: Optional[Sequence[str]] = None,
                 google_enabled: Optional[bool] = None,
                 google_expire: Optional[float] = None,
                 gupshup_password: Optional[str] = None,
                 gupshup_userid: Optional[str] = None,
                 microsoft_client_id: Optional[str] = None,
                 microsoft_client_secret: Optional[str] = None,
                 microsoft_email_domains: Optional[Sequence[str]] = None,
                 microsoft_enabled: Optional[bool] = None,
                 microsoft_expire: Optional[float] = None,
                 passphrase_enabled: Optional[bool] = None,
                 passphrase_expire: Optional[float] = None,
                 password: Optional[str] = None,
                 predefined_sponsors_enabled: Optional[bool] = None,
                 predefined_sponsors_hide_email: Optional[bool] = None,
                 privacy: Optional[bool] = None,
                 puzzel_password: Optional[str] = None,
                 puzzel_service_id: Optional[str] = None,
                 puzzel_username: Optional[str] = None,
                 sms_enabled: Optional[bool] = None,
                 sms_expire: Optional[float] = None,
                 sms_message_format: Optional[str] = None,
                 sms_provider: Optional[str] = None,
                 sponsor_auto_approve: Optional[bool] = None,
                 sponsor_email_domains: Optional[Sequence[str]] = None,
                 sponsor_enabled: Optional[bool] = None,
                 sponsor_expire: Optional[float] = None,
                 sponsor_link_validity_duration: Optional[str] = None,
                 sponsor_notify_all: Optional[bool] = None,
                 sponsor_status_notify: Optional[bool] = None,
                 sponsors: Optional[Mapping[str, str]] = None,
                 sso_default_role: Optional[str] = None,
                 sso_forced_role: Optional[str] = None,
                 sso_idp_cert: Optional[str] = None,
                 sso_idp_sign_algo: Optional[str] = None,
                 sso_idp_sso_url: Optional[str] = None,
                 sso_issuer: Optional[str] = None,
                 sso_nameid_format: Optional[str] = None,
                 telstra_client_id: Optional[str] = None,
                 telstra_client_secret: Optional[str] = None,
                 twilio_auth_token: Optional[str] = None,
                 twilio_phone_number: Optional[str] = None,
                 twilio_sid: Optional[str] = None):
        """
        :param str amazon_client_id: amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param str amazon_client_secret: amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.
        :param Sequence[str] amazon_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param bool amazon_enabled: whether amazon is enabled as a login method
        :param float amazon_expire: interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        :param str auth: authentication scheme. enum: `external`, `none`, `sso`
        :param str azure_client_id: Required if `azure_enabled`==`true`.
               Azure active directory app client id
        :param str azure_client_secret: Required if `azure_enabled`==`true`.
               Azure active directory app client secret
        :param bool azure_enabled: whether Azure Active Directory is enabled as a login method
        :param float azure_expire: interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        :param str azure_tenant_id: Required if `azure_enabled`==`true`.
               Azure active directory tenant id.
        :param str broadnet_password: when `sms_provider`==`broadnet`
        :param str broadnet_sid: when `sms_provider`==`broadnet`
        :param str broadnet_user_id: when `sms_provider`==`broadnet`
        :param bool bypass_when_cloud_down: whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        :param str clickatell_api_key: when `sms_provider`==`clickatell`
        :param bool cross_site: whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        :param bool email_enabled: whether email (access code verification) is enabled as a login method
        :param bool enabled: whether guest portal is enabled
        :param float expire: how long to remain authorized, in minutes
        :param str external_portal_url: external portal URL (e.g. https://host/url) where we can append our query parameters to
        :param str facebook_client_id: Required if `facebook_enabled`==`true`.
               Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param str facebook_client_secret: Required if `facebook_enabled`==`true`.
               Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.
        :param Sequence[str] facebook_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param bool facebook_enabled: whether facebook is enabled as a login method
        :param float facebook_expire: interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        :param bool forward: whether to forward the user to another URL after authorized
        :param str forward_url: the URL to forward the user to
        :param str google_client_id: Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        :param str google_client_secret: Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.
        :param Sequence[str] google_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param bool google_enabled: whether google is enabled as login method
        :param float google_expire: interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
        :param str gupshup_password: when `sms_provider`==`gupshup`
        :param str gupshup_userid: when `sms_provider`==`gupshup`
        :param str microsoft_client_id: microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        :param str microsoft_client_secret: microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.
        :param Sequence[str] microsoft_email_domains: Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        :param bool microsoft_enabled: whether microsoft 365 is enabled as a login method
        :param float microsoft_expire: interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        :param bool passphrase_enabled: whether password is enabled
        :param float passphrase_expire: interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        :param str password: passphrase
        :param bool predefined_sponsors_enabled: whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        :param bool predefined_sponsors_hide_email: whether to hide sponsor’s email from list of sponsors
        :param str puzzel_password: when `sms_provider`==`puzzel`
        :param str puzzel_service_id: when `sms_provider`==`puzzel`
        :param str puzzel_username: when `sms_provider`==`puzzel`
        :param bool sms_enabled: whether sms is enabled as a login method
        :param float sms_expire: interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        :param str sms_provider: enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        :param bool sponsor_auto_approve: whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        :param Sequence[str] sponsor_email_domains: list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        :param bool sponsor_enabled: whether sponsor is enabled
        :param float sponsor_expire: interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        :param str sponsor_link_validity_duration: how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
        :param bool sponsor_notify_all: whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        :param bool sponsor_status_notify: if enabled, guest will get email about sponsor's action (approve/deny)
        :param Mapping[str, str] sponsors: object of allowed sponsors email with name. Required if `sponsor_enabled`
                           is `true` and `sponsor_email_domains` is empty.
               
                           Property key is the sponsor email, Property value is the sponsor name
        :param str sso_default_role: default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        :param str sso_idp_cert: IDP Cert (used to verify the signed response)
        :param str sso_idp_sign_algo: signing algorithm for SAML Assertion
        :param str sso_idp_sso_url: IDP Single-Sign-On URL
        :param str sso_issuer: IDP issuer URL
        :param str sso_nameid_format: enum: `email`, `unspecified`
        :param str telstra_client_id: when `sms_provider`==`telstra`, Client ID provided by Telstra
        :param str telstra_client_secret: when `sms_provider`==`telstra`, Client secret provided by Telstra
        :param str twilio_auth_token: when `sms_provider`==`twilio`, Auth token account with twilio account
        :param str twilio_phone_number: when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        :param str twilio_sid: when `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        if amazon_client_id is not None:
            pulumi.set(__self__, "amazon_client_id", amazon_client_id)
        if amazon_client_secret is not None:
            pulumi.set(__self__, "amazon_client_secret", amazon_client_secret)
        if amazon_email_domains is not None:
            pulumi.set(__self__, "amazon_email_domains", amazon_email_domains)
        if amazon_enabled is not None:
            pulumi.set(__self__, "amazon_enabled", amazon_enabled)
        if amazon_expire is not None:
            pulumi.set(__self__, "amazon_expire", amazon_expire)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if azure_client_id is not None:
            pulumi.set(__self__, "azure_client_id", azure_client_id)
        if azure_client_secret is not None:
            pulumi.set(__self__, "azure_client_secret", azure_client_secret)
        if azure_enabled is not None:
            pulumi.set(__self__, "azure_enabled", azure_enabled)
        if azure_expire is not None:
            pulumi.set(__self__, "azure_expire", azure_expire)
        if azure_tenant_id is not None:
            pulumi.set(__self__, "azure_tenant_id", azure_tenant_id)
        if broadnet_password is not None:
            pulumi.set(__self__, "broadnet_password", broadnet_password)
        if broadnet_sid is not None:
            pulumi.set(__self__, "broadnet_sid", broadnet_sid)
        if broadnet_user_id is not None:
            pulumi.set(__self__, "broadnet_user_id", broadnet_user_id)
        if bypass_when_cloud_down is not None:
            pulumi.set(__self__, "bypass_when_cloud_down", bypass_when_cloud_down)
        if clickatell_api_key is not None:
            pulumi.set(__self__, "clickatell_api_key", clickatell_api_key)
        if cross_site is not None:
            pulumi.set(__self__, "cross_site", cross_site)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expire is not None:
            pulumi.set(__self__, "expire", expire)
        if external_portal_url is not None:
            pulumi.set(__self__, "external_portal_url", external_portal_url)
        if facebook_client_id is not None:
            pulumi.set(__self__, "facebook_client_id", facebook_client_id)
        if facebook_client_secret is not None:
            pulumi.set(__self__, "facebook_client_secret", facebook_client_secret)
        if facebook_email_domains is not None:
            pulumi.set(__self__, "facebook_email_domains", facebook_email_domains)
        if facebook_enabled is not None:
            pulumi.set(__self__, "facebook_enabled", facebook_enabled)
        if facebook_expire is not None:
            pulumi.set(__self__, "facebook_expire", facebook_expire)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if forward_url is not None:
            pulumi.set(__self__, "forward_url", forward_url)
        if google_client_id is not None:
            pulumi.set(__self__, "google_client_id", google_client_id)
        if google_client_secret is not None:
            pulumi.set(__self__, "google_client_secret", google_client_secret)
        if google_email_domains is not None:
            pulumi.set(__self__, "google_email_domains", google_email_domains)
        if google_enabled is not None:
            pulumi.set(__self__, "google_enabled", google_enabled)
        if google_expire is not None:
            pulumi.set(__self__, "google_expire", google_expire)
        if gupshup_password is not None:
            pulumi.set(__self__, "gupshup_password", gupshup_password)
        if gupshup_userid is not None:
            pulumi.set(__self__, "gupshup_userid", gupshup_userid)
        if microsoft_client_id is not None:
            pulumi.set(__self__, "microsoft_client_id", microsoft_client_id)
        if microsoft_client_secret is not None:
            pulumi.set(__self__, "microsoft_client_secret", microsoft_client_secret)
        if microsoft_email_domains is not None:
            pulumi.set(__self__, "microsoft_email_domains", microsoft_email_domains)
        if microsoft_enabled is not None:
            pulumi.set(__self__, "microsoft_enabled", microsoft_enabled)
        if microsoft_expire is not None:
            pulumi.set(__self__, "microsoft_expire", microsoft_expire)
        if passphrase_enabled is not None:
            pulumi.set(__self__, "passphrase_enabled", passphrase_enabled)
        if passphrase_expire is not None:
            pulumi.set(__self__, "passphrase_expire", passphrase_expire)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if predefined_sponsors_enabled is not None:
            pulumi.set(__self__, "predefined_sponsors_enabled", predefined_sponsors_enabled)
        if predefined_sponsors_hide_email is not None:
            pulumi.set(__self__, "predefined_sponsors_hide_email", predefined_sponsors_hide_email)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if puzzel_password is not None:
            pulumi.set(__self__, "puzzel_password", puzzel_password)
        if puzzel_service_id is not None:
            pulumi.set(__self__, "puzzel_service_id", puzzel_service_id)
        if puzzel_username is not None:
            pulumi.set(__self__, "puzzel_username", puzzel_username)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if sms_expire is not None:
            pulumi.set(__self__, "sms_expire", sms_expire)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_provider is not None:
            pulumi.set(__self__, "sms_provider", sms_provider)
        if sponsor_auto_approve is not None:
            pulumi.set(__self__, "sponsor_auto_approve", sponsor_auto_approve)
        if sponsor_email_domains is not None:
            pulumi.set(__self__, "sponsor_email_domains", sponsor_email_domains)
        if sponsor_enabled is not None:
            pulumi.set(__self__, "sponsor_enabled", sponsor_enabled)
        if sponsor_expire is not None:
            pulumi.set(__self__, "sponsor_expire", sponsor_expire)
        if sponsor_link_validity_duration is not None:
            pulumi.set(__self__, "sponsor_link_validity_duration", sponsor_link_validity_duration)
        if sponsor_notify_all is not None:
            pulumi.set(__self__, "sponsor_notify_all", sponsor_notify_all)
        if sponsor_status_notify is not None:
            pulumi.set(__self__, "sponsor_status_notify", sponsor_status_notify)
        if sponsors is not None:
            pulumi.set(__self__, "sponsors", sponsors)
        if sso_default_role is not None:
            pulumi.set(__self__, "sso_default_role", sso_default_role)
        if sso_forced_role is not None:
            pulumi.set(__self__, "sso_forced_role", sso_forced_role)
        if sso_idp_cert is not None:
            pulumi.set(__self__, "sso_idp_cert", sso_idp_cert)
        if sso_idp_sign_algo is not None:
            pulumi.set(__self__, "sso_idp_sign_algo", sso_idp_sign_algo)
        if sso_idp_sso_url is not None:
            pulumi.set(__self__, "sso_idp_sso_url", sso_idp_sso_url)
        if sso_issuer is not None:
            pulumi.set(__self__, "sso_issuer", sso_issuer)
        if sso_nameid_format is not None:
            pulumi.set(__self__, "sso_nameid_format", sso_nameid_format)
        if telstra_client_id is not None:
            pulumi.set(__self__, "telstra_client_id", telstra_client_id)
        if telstra_client_secret is not None:
            pulumi.set(__self__, "telstra_client_secret", telstra_client_secret)
        if twilio_auth_token is not None:
            pulumi.set(__self__, "twilio_auth_token", twilio_auth_token)
        if twilio_phone_number is not None:
            pulumi.set(__self__, "twilio_phone_number", twilio_phone_number)
        if twilio_sid is not None:
            pulumi.set(__self__, "twilio_sid", twilio_sid)

    @property
    @pulumi.getter(name="amazonClientId")
    def amazon_client_id(self) -> Optional[str]:
        """
        amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "amazon_client_id")

    @property
    @pulumi.getter(name="amazonClientSecret")
    def amazon_client_secret(self) -> Optional[str]:
        """
        amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "amazon_client_secret")

    @property
    @pulumi.getter(name="amazonEmailDomains")
    def amazon_email_domains(self) -> Optional[Sequence[str]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "amazon_email_domains")

    @property
    @pulumi.getter(name="amazonEnabled")
    def amazon_enabled(self) -> Optional[bool]:
        """
        whether amazon is enabled as a login method
        """
        return pulumi.get(self, "amazon_enabled")

    @property
    @pulumi.getter(name="amazonExpire")
    def amazon_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "amazon_expire")

    @property
    @pulumi.getter
    def auth(self) -> Optional[str]:
        """
        authentication scheme. enum: `external`, `none`, `sso`
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="azureClientId")
    def azure_client_id(self) -> Optional[str]:
        """
        Required if `azure_enabled`==`true`.
        Azure active directory app client id
        """
        return pulumi.get(self, "azure_client_id")

    @property
    @pulumi.getter(name="azureClientSecret")
    def azure_client_secret(self) -> Optional[str]:
        """
        Required if `azure_enabled`==`true`.
        Azure active directory app client secret
        """
        return pulumi.get(self, "azure_client_secret")

    @property
    @pulumi.getter(name="azureEnabled")
    def azure_enabled(self) -> Optional[bool]:
        """
        whether Azure Active Directory is enabled as a login method
        """
        return pulumi.get(self, "azure_enabled")

    @property
    @pulumi.getter(name="azureExpire")
    def azure_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "azure_expire")

    @property
    @pulumi.getter(name="azureTenantId")
    def azure_tenant_id(self) -> Optional[str]:
        """
        Required if `azure_enabled`==`true`.
        Azure active directory tenant id.
        """
        return pulumi.get(self, "azure_tenant_id")

    @property
    @pulumi.getter(name="broadnetPassword")
    def broadnet_password(self) -> Optional[str]:
        """
        when `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_password")

    @property
    @pulumi.getter(name="broadnetSid")
    def broadnet_sid(self) -> Optional[str]:
        """
        when `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_sid")

    @property
    @pulumi.getter(name="broadnetUserId")
    def broadnet_user_id(self) -> Optional[str]:
        """
        when `sms_provider`==`broadnet`
        """
        return pulumi.get(self, "broadnet_user_id")

    @property
    @pulumi.getter(name="bypassWhenCloudDown")
    def bypass_when_cloud_down(self) -> Optional[bool]:
        """
        whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        """
        return pulumi.get(self, "bypass_when_cloud_down")

    @property
    @pulumi.getter(name="clickatellApiKey")
    def clickatell_api_key(self) -> Optional[str]:
        """
        when `sms_provider`==`clickatell`
        """
        return pulumi.get(self, "clickatell_api_key")

    @property
    @pulumi.getter(name="crossSite")
    def cross_site(self) -> Optional[bool]:
        """
        whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
        """
        return pulumi.get(self, "cross_site")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[bool]:
        """
        whether email (access code verification) is enabled as a login method
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        whether guest portal is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expire(self) -> Optional[float]:
        """
        how long to remain authorized, in minutes
        """
        return pulumi.get(self, "expire")

    @property
    @pulumi.getter(name="externalPortalUrl")
    def external_portal_url(self) -> Optional[str]:
        """
        external portal URL (e.g. https://host/url) where we can append our query parameters to
        """
        return pulumi.get(self, "external_portal_url")

    @property
    @pulumi.getter(name="facebookClientId")
    def facebook_client_id(self) -> Optional[str]:
        """
        Required if `facebook_enabled`==`true`.
        Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "facebook_client_id")

    @property
    @pulumi.getter(name="facebookClientSecret")
    def facebook_client_secret(self) -> Optional[str]:
        """
        Required if `facebook_enabled`==`true`.
        Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "facebook_client_secret")

    @property
    @pulumi.getter(name="facebookEmailDomains")
    def facebook_email_domains(self) -> Optional[Sequence[str]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "facebook_email_domains")

    @property
    @pulumi.getter(name="facebookEnabled")
    def facebook_enabled(self) -> Optional[bool]:
        """
        whether facebook is enabled as a login method
        """
        return pulumi.get(self, "facebook_enabled")

    @property
    @pulumi.getter(name="facebookExpire")
    def facebook_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "facebook_expire")

    @property
    @pulumi.getter
    def forward(self) -> Optional[bool]:
        """
        whether to forward the user to another URL after authorized
        """
        return pulumi.get(self, "forward")

    @property
    @pulumi.getter(name="forwardUrl")
    def forward_url(self) -> Optional[str]:
        """
        the URL to forward the user to
        """
        return pulumi.get(self, "forward_url")

    @property
    @pulumi.getter(name="googleClientId")
    def google_client_id(self) -> Optional[str]:
        """
        Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "google_client_id")

    @property
    @pulumi.getter(name="googleClientSecret")
    def google_client_secret(self) -> Optional[str]:
        """
        Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "google_client_secret")

    @property
    @pulumi.getter(name="googleEmailDomains")
    def google_email_domains(self) -> Optional[Sequence[str]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "google_email_domains")

    @property
    @pulumi.getter(name="googleEnabled")
    def google_enabled(self) -> Optional[bool]:
        """
        whether google is enabled as login method
        """
        return pulumi.get(self, "google_enabled")

    @property
    @pulumi.getter(name="googleExpire")
    def google_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "google_expire")

    @property
    @pulumi.getter(name="gupshupPassword")
    def gupshup_password(self) -> Optional[str]:
        """
        when `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_password")

    @property
    @pulumi.getter(name="gupshupUserid")
    def gupshup_userid(self) -> Optional[str]:
        """
        when `sms_provider`==`gupshup`
        """
        return pulumi.get(self, "gupshup_userid")

    @property
    @pulumi.getter(name="microsoftClientId")
    def microsoft_client_id(self) -> Optional[str]:
        """
        microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        """
        return pulumi.get(self, "microsoft_client_id")

    @property
    @pulumi.getter(name="microsoftClientSecret")
    def microsoft_client_secret(self) -> Optional[str]:
        """
        microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.
        """
        return pulumi.get(self, "microsoft_client_secret")

    @property
    @pulumi.getter(name="microsoftEmailDomains")
    def microsoft_email_domains(self) -> Optional[Sequence[str]]:
        """
        Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        """
        return pulumi.get(self, "microsoft_email_domains")

    @property
    @pulumi.getter(name="microsoftEnabled")
    def microsoft_enabled(self) -> Optional[bool]:
        """
        whether microsoft 365 is enabled as a login method
        """
        return pulumi.get(self, "microsoft_enabled")

    @property
    @pulumi.getter(name="microsoftExpire")
    def microsoft_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "microsoft_expire")

    @property
    @pulumi.getter(name="passphraseEnabled")
    def passphrase_enabled(self) -> Optional[bool]:
        """
        whether password is enabled
        """
        return pulumi.get(self, "passphrase_enabled")

    @property
    @pulumi.getter(name="passphraseExpire")
    def passphrase_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
        """
        return pulumi.get(self, "passphrase_expire")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        passphrase
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="predefinedSponsorsEnabled")
    def predefined_sponsors_enabled(self) -> Optional[bool]:
        """
        whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
        """
        return pulumi.get(self, "predefined_sponsors_enabled")

    @property
    @pulumi.getter(name="predefinedSponsorsHideEmail")
    def predefined_sponsors_hide_email(self) -> Optional[bool]:
        """
        whether to hide sponsor’s email from list of sponsors
        """
        return pulumi.get(self, "predefined_sponsors_hide_email")

    @property
    @pulumi.getter
    def privacy(self) -> Optional[bool]:
        return pulumi.get(self, "privacy")

    @property
    @pulumi.getter(name="puzzelPassword")
    def puzzel_password(self) -> Optional[str]:
        """
        when `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_password")

    @property
    @pulumi.getter(name="puzzelServiceId")
    def puzzel_service_id(self) -> Optional[str]:
        """
        when `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_service_id")

    @property
    @pulumi.getter(name="puzzelUsername")
    def puzzel_username(self) -> Optional[str]:
        """
        when `sms_provider`==`puzzel`
        """
        return pulumi.get(self, "puzzel_username")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[bool]:
        """
        whether sms is enabled as a login method
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="smsExpire")
    def sms_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sms_expire")

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_message_format")

    @property
    @pulumi.getter(name="smsProvider")
    def sms_provider(self) -> Optional[str]:
        """
        enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
        """
        return pulumi.get(self, "sms_provider")

    @property
    @pulumi.getter(name="sponsorAutoApprove")
    def sponsor_auto_approve(self) -> Optional[bool]:
        """
        whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
        """
        return pulumi.get(self, "sponsor_auto_approve")

    @property
    @pulumi.getter(name="sponsorEmailDomains")
    def sponsor_email_domains(self) -> Optional[Sequence[str]]:
        """
        list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
        """
        return pulumi.get(self, "sponsor_email_domains")

    @property
    @pulumi.getter(name="sponsorEnabled")
    def sponsor_enabled(self) -> Optional[bool]:
        """
        whether sponsor is enabled
        """
        return pulumi.get(self, "sponsor_enabled")

    @property
    @pulumi.getter(name="sponsorExpire")
    def sponsor_expire(self) -> Optional[float]:
        """
        interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        """
        return pulumi.get(self, "sponsor_expire")

    @property
    @pulumi.getter(name="sponsorLinkValidityDuration")
    def sponsor_link_validity_duration(self) -> Optional[str]:
        """
        how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
        """
        return pulumi.get(self, "sponsor_link_validity_duration")

    @property
    @pulumi.getter(name="sponsorNotifyAll")
    def sponsor_notify_all(self) -> Optional[bool]:
        """
        whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        """
        return pulumi.get(self, "sponsor_notify_all")

    @property
    @pulumi.getter(name="sponsorStatusNotify")
    def sponsor_status_notify(self) -> Optional[bool]:
        """
        if enabled, guest will get email about sponsor's action (approve/deny)
        """
        return pulumi.get(self, "sponsor_status_notify")

    @property
    @pulumi.getter
    def sponsors(self) -> Optional[Mapping[str, str]]:
        """
        object of allowed sponsors email with name. Required if `sponsor_enabled`
                    is `true` and `sponsor_email_domains` is empty.

                    Property key is the sponsor email, Property value is the sponsor name
        """
        return pulumi.get(self, "sponsors")

    @property
    @pulumi.getter(name="ssoDefaultRole")
    def sso_default_role(self) -> Optional[str]:
        """
        default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        """
        return pulumi.get(self, "sso_default_role")

    @property
    @pulumi.getter(name="ssoForcedRole")
    def sso_forced_role(self) -> Optional[str]:
        return pulumi.get(self, "sso_forced_role")

    @property
    @pulumi.getter(name="ssoIdpCert")
    def sso_idp_cert(self) -> Optional[str]:
        """
        IDP Cert (used to verify the signed response)
        """
        return pulumi.get(self, "sso_idp_cert")

    @property
    @pulumi.getter(name="ssoIdpSignAlgo")
    def sso_idp_sign_algo(self) -> Optional[str]:
        """
        signing algorithm for SAML Assertion
        """
        return pulumi.get(self, "sso_idp_sign_algo")

    @property
    @pulumi.getter(name="ssoIdpSsoUrl")
    def sso_idp_sso_url(self) -> Optional[str]:
        """
        IDP Single-Sign-On URL
        """
        return pulumi.get(self, "sso_idp_sso_url")

    @property
    @pulumi.getter(name="ssoIssuer")
    def sso_issuer(self) -> Optional[str]:
        """
        IDP issuer URL
        """
        return pulumi.get(self, "sso_issuer")

    @property
    @pulumi.getter(name="ssoNameidFormat")
    def sso_nameid_format(self) -> Optional[str]:
        """
        enum: `email`, `unspecified`
        """
        return pulumi.get(self, "sso_nameid_format")

    @property
    @pulumi.getter(name="telstraClientId")
    def telstra_client_id(self) -> Optional[str]:
        """
        when `sms_provider`==`telstra`, Client ID provided by Telstra
        """
        return pulumi.get(self, "telstra_client_id")

    @property
    @pulumi.getter(name="telstraClientSecret")
    def telstra_client_secret(self) -> Optional[str]:
        """
        when `sms_provider`==`telstra`, Client secret provided by Telstra
        """
        return pulumi.get(self, "telstra_client_secret")

    @property
    @pulumi.getter(name="twilioAuthToken")
    def twilio_auth_token(self) -> Optional[str]:
        """
        when `sms_provider`==`twilio`, Auth token account with twilio account
        """
        return pulumi.get(self, "twilio_auth_token")

    @property
    @pulumi.getter(name="twilioPhoneNumber")
    def twilio_phone_number(self) -> Optional[str]:
        """
        when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
        """
        return pulumi.get(self, "twilio_phone_number")

    @property
    @pulumi.getter(name="twilioSid")
    def twilio_sid(self) -> Optional[str]:
        """
        when `sms_provider`==`twilio`, Account SID provided by Twilio
        """
        return pulumi.get(self, "twilio_sid")


@pulumi.output_type
class WlanPortalTemplatePortalTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessCodeAlternateEmail":
            suggest = "access_code_alternate_email"
        elif key == "authButtonAmazon":
            suggest = "auth_button_amazon"
        elif key == "authButtonAzure":
            suggest = "auth_button_azure"
        elif key == "authButtonEmail":
            suggest = "auth_button_email"
        elif key == "authButtonFacebook":
            suggest = "auth_button_facebook"
        elif key == "authButtonGoogle":
            suggest = "auth_button_google"
        elif key == "authButtonMicrosoft":
            suggest = "auth_button_microsoft"
        elif key == "authButtonPassphrase":
            suggest = "auth_button_passphrase"
        elif key == "authButtonSms":
            suggest = "auth_button_sms"
        elif key == "authButtonSponsor":
            suggest = "auth_button_sponsor"
        elif key == "authLabel":
            suggest = "auth_label"
        elif key == "backLink":
            suggest = "back_link"
        elif key == "colorDark":
            suggest = "color_dark"
        elif key == "colorLight":
            suggest = "color_light"
        elif key == "companyError":
            suggest = "company_error"
        elif key == "companyLabel":
            suggest = "company_label"
        elif key == "emailAccessDomainError":
            suggest = "email_access_domain_error"
        elif key == "emailCancel":
            suggest = "email_cancel"
        elif key == "emailCodeCancel":
            suggest = "email_code_cancel"
        elif key == "emailCodeError":
            suggest = "email_code_error"
        elif key == "emailCodeFieldLabel":
            suggest = "email_code_field_label"
        elif key == "emailCodeMessage":
            suggest = "email_code_message"
        elif key == "emailCodeSubmit":
            suggest = "email_code_submit"
        elif key == "emailCodeTitle":
            suggest = "email_code_title"
        elif key == "emailError":
            suggest = "email_error"
        elif key == "emailFieldLabel":
            suggest = "email_field_label"
        elif key == "emailLabel":
            suggest = "email_label"
        elif key == "emailMessage":
            suggest = "email_message"
        elif key == "emailSubmit":
            suggest = "email_submit"
        elif key == "emailTitle":
            suggest = "email_title"
        elif key == "multiAuth":
            suggest = "multi_auth"
        elif key == "nameError":
            suggest = "name_error"
        elif key == "nameLabel":
            suggest = "name_label"
        elif key == "optOutDefault":
            suggest = "opt_out_default"
        elif key == "optoutLabel":
            suggest = "optout_label"
        elif key == "pageTitle":
            suggest = "page_title"
        elif key == "passphraseCancel":
            suggest = "passphrase_cancel"
        elif key == "passphraseError":
            suggest = "passphrase_error"
        elif key == "passphraseLabel":
            suggest = "passphrase_label"
        elif key == "passphraseMessage":
            suggest = "passphrase_message"
        elif key == "passphraseSubmit":
            suggest = "passphrase_submit"
        elif key == "passphraseTitle":
            suggest = "passphrase_title"
        elif key == "poweredBy":
            suggest = "powered_by"
        elif key == "privacyPolicyAcceptLabel":
            suggest = "privacy_policy_accept_label"
        elif key == "privacyPolicyError":
            suggest = "privacy_policy_error"
        elif key == "privacyPolicyLink":
            suggest = "privacy_policy_link"
        elif key == "privacyPolicyText":
            suggest = "privacy_policy_text"
        elif key == "requiredFieldLabel":
            suggest = "required_field_label"
        elif key == "responsiveLayout":
            suggest = "responsive_layout"
        elif key == "signInLabel":
            suggest = "sign_in_label"
        elif key == "smsCarrierDefault":
            suggest = "sms_carrier_default"
        elif key == "smsCarrierError":
            suggest = "sms_carrier_error"
        elif key == "smsCarrierFieldLabel":
            suggest = "sms_carrier_field_label"
        elif key == "smsCodeCancel":
            suggest = "sms_code_cancel"
        elif key == "smsCodeError":
            suggest = "sms_code_error"
        elif key == "smsCodeFieldLabel":
            suggest = "sms_code_field_label"
        elif key == "smsCodeMessage":
            suggest = "sms_code_message"
        elif key == "smsCodeSubmit":
            suggest = "sms_code_submit"
        elif key == "smsCodeTitle":
            suggest = "sms_code_title"
        elif key == "smsCountryFieldLabel":
            suggest = "sms_country_field_label"
        elif key == "smsCountryFormat":
            suggest = "sms_country_format"
        elif key == "smsHaveAccessCode":
            suggest = "sms_have_access_code"
        elif key == "smsIsTwilio":
            suggest = "sms_is_twilio"
        elif key == "smsMessageFormat":
            suggest = "sms_message_format"
        elif key == "smsNumberCancel":
            suggest = "sms_number_cancel"
        elif key == "smsNumberError":
            suggest = "sms_number_error"
        elif key == "smsNumberFieldLabel":
            suggest = "sms_number_field_label"
        elif key == "smsNumberFormat":
            suggest = "sms_number_format"
        elif key == "smsNumberMessage":
            suggest = "sms_number_message"
        elif key == "smsNumberSubmit":
            suggest = "sms_number_submit"
        elif key == "smsNumberTitle":
            suggest = "sms_number_title"
        elif key == "smsUsernameFormat":
            suggest = "sms_username_format"
        elif key == "smsValidityDuration":
            suggest = "sms_validity_duration"
        elif key == "sponsorBackLink":
            suggest = "sponsor_back_link"
        elif key == "sponsorCancel":
            suggest = "sponsor_cancel"
        elif key == "sponsorEmail":
            suggest = "sponsor_email"
        elif key == "sponsorEmailError":
            suggest = "sponsor_email_error"
        elif key == "sponsorEmailTemplate":
            suggest = "sponsor_email_template"
        elif key == "sponsorInfoApproved":
            suggest = "sponsor_info_approved"
        elif key == "sponsorInfoDenied":
            suggest = "sponsor_info_denied"
        elif key == "sponsorInfoPending":
            suggest = "sponsor_info_pending"
        elif key == "sponsorName":
            suggest = "sponsor_name"
        elif key == "sponsorNameError":
            suggest = "sponsor_name_error"
        elif key == "sponsorNotePending":
            suggest = "sponsor_note_pending"
        elif key == "sponsorRequestAccess":
            suggest = "sponsor_request_access"
        elif key == "sponsorStatusApproved":
            suggest = "sponsor_status_approved"
        elif key == "sponsorStatusDenied":
            suggest = "sponsor_status_denied"
        elif key == "sponsorStatusPending":
            suggest = "sponsor_status_pending"
        elif key == "sponsorSubmit":
            suggest = "sponsor_submit"
        elif key == "sponsorsError":
            suggest = "sponsors_error"
        elif key == "sponsorsFieldLabel":
            suggest = "sponsors_field_label"
        elif key == "tosAcceptLabel":
            suggest = "tos_accept_label"
        elif key == "tosError":
            suggest = "tos_error"
        elif key == "tosLink":
            suggest = "tos_link"
        elif key == "tosText":
            suggest = "tos_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanPortalTemplatePortalTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanPortalTemplatePortalTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanPortalTemplatePortalTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_code_alternate_email: Optional[str] = None,
                 alignment: Optional[str] = None,
                 auth_button_amazon: Optional[str] = None,
                 auth_button_azure: Optional[str] = None,
                 auth_button_email: Optional[str] = None,
                 auth_button_facebook: Optional[str] = None,
                 auth_button_google: Optional[str] = None,
                 auth_button_microsoft: Optional[str] = None,
                 auth_button_passphrase: Optional[str] = None,
                 auth_button_sms: Optional[str] = None,
                 auth_button_sponsor: Optional[str] = None,
                 auth_label: Optional[str] = None,
                 back_link: Optional[str] = None,
                 color: Optional[str] = None,
                 color_dark: Optional[str] = None,
                 color_light: Optional[str] = None,
                 company: Optional[bool] = None,
                 company_error: Optional[str] = None,
                 company_label: Optional[str] = None,
                 email: Optional[bool] = None,
                 email_access_domain_error: Optional[str] = None,
                 email_cancel: Optional[str] = None,
                 email_code_cancel: Optional[str] = None,
                 email_code_error: Optional[str] = None,
                 email_code_field_label: Optional[str] = None,
                 email_code_message: Optional[str] = None,
                 email_code_submit: Optional[str] = None,
                 email_code_title: Optional[str] = None,
                 email_error: Optional[str] = None,
                 email_field_label: Optional[str] = None,
                 email_label: Optional[str] = None,
                 email_message: Optional[str] = None,
                 email_submit: Optional[str] = None,
                 email_title: Optional[str] = None,
                 field1: Optional[bool] = None,
                 field1error: Optional[str] = None,
                 field1label: Optional[str] = None,
                 field1required: Optional[bool] = None,
                 field2: Optional[bool] = None,
                 field2error: Optional[str] = None,
                 field2label: Optional[str] = None,
                 field2required: Optional[bool] = None,
                 field3: Optional[bool] = None,
                 field3error: Optional[str] = None,
                 field3label: Optional[str] = None,
                 field3required: Optional[bool] = None,
                 field4: Optional[bool] = None,
                 field4error: Optional[str] = None,
                 field4label: Optional[str] = None,
                 field4required: Optional[bool] = None,
                 locales: Optional[Mapping[str, 'outputs.WlanPortalTemplatePortalTemplateLocales']] = None,
                 logo: Optional[str] = None,
                 message: Optional[str] = None,
                 multi_auth: Optional[bool] = None,
                 name: Optional[bool] = None,
                 name_error: Optional[str] = None,
                 name_label: Optional[str] = None,
                 opt_out_default: Optional[bool] = None,
                 optout: Optional[bool] = None,
                 optout_label: Optional[str] = None,
                 page_title: Optional[str] = None,
                 passphrase_cancel: Optional[str] = None,
                 passphrase_error: Optional[str] = None,
                 passphrase_label: Optional[str] = None,
                 passphrase_message: Optional[str] = None,
                 passphrase_submit: Optional[str] = None,
                 passphrase_title: Optional[str] = None,
                 powered_by: Optional[bool] = None,
                 privacy: Optional[bool] = None,
                 privacy_policy_accept_label: Optional[str] = None,
                 privacy_policy_error: Optional[str] = None,
                 privacy_policy_link: Optional[str] = None,
                 privacy_policy_text: Optional[str] = None,
                 required_field_label: Optional[str] = None,
                 responsive_layout: Optional[bool] = None,
                 sign_in_label: Optional[str] = None,
                 sms_carrier_default: Optional[str] = None,
                 sms_carrier_error: Optional[str] = None,
                 sms_carrier_field_label: Optional[str] = None,
                 sms_code_cancel: Optional[str] = None,
                 sms_code_error: Optional[str] = None,
                 sms_code_field_label: Optional[str] = None,
                 sms_code_message: Optional[str] = None,
                 sms_code_submit: Optional[str] = None,
                 sms_code_title: Optional[str] = None,
                 sms_country_field_label: Optional[str] = None,
                 sms_country_format: Optional[str] = None,
                 sms_have_access_code: Optional[str] = None,
                 sms_is_twilio: Optional[bool] = None,
                 sms_message_format: Optional[str] = None,
                 sms_number_cancel: Optional[str] = None,
                 sms_number_error: Optional[str] = None,
                 sms_number_field_label: Optional[str] = None,
                 sms_number_format: Optional[str] = None,
                 sms_number_message: Optional[str] = None,
                 sms_number_submit: Optional[str] = None,
                 sms_number_title: Optional[str] = None,
                 sms_username_format: Optional[str] = None,
                 sms_validity_duration: Optional[int] = None,
                 sponsor_back_link: Optional[str] = None,
                 sponsor_cancel: Optional[str] = None,
                 sponsor_email: Optional[str] = None,
                 sponsor_email_error: Optional[str] = None,
                 sponsor_email_template: Optional[str] = None,
                 sponsor_info_approved: Optional[str] = None,
                 sponsor_info_denied: Optional[str] = None,
                 sponsor_info_pending: Optional[str] = None,
                 sponsor_name: Optional[str] = None,
                 sponsor_name_error: Optional[str] = None,
                 sponsor_note_pending: Optional[str] = None,
                 sponsor_request_access: Optional[str] = None,
                 sponsor_status_approved: Optional[str] = None,
                 sponsor_status_denied: Optional[str] = None,
                 sponsor_status_pending: Optional[str] = None,
                 sponsor_submit: Optional[str] = None,
                 sponsors_error: Optional[str] = None,
                 sponsors_field_label: Optional[str] = None,
                 tos: Optional[bool] = None,
                 tos_accept_label: Optional[str] = None,
                 tos_error: Optional[str] = None,
                 tos_link: Optional[str] = None,
                 tos_text: Optional[str] = None):
        """
        :param str alignment: defines alignment on portal. enum: `center`, `left`, `right`
        :param str auth_button_amazon: label for Amazon auth button
        :param str auth_button_azure: label for Azure auth button
        :param str auth_button_email: label for Email auth button
        :param str auth_button_facebook: label for Facebook auth button
        :param str auth_button_google: label for Google auth button
        :param str auth_button_microsoft: label for Microsoft auth button
        :param str auth_button_passphrase: label for passphrase auth button
        :param str auth_button_sms: label for SMS auth button
        :param str auth_button_sponsor: label for Sponsor auth button
        :param str back_link: label of the link to go back to /logon
        :param str color: Portal main color
        :param bool company: whether company field is required
        :param str company_error: error message when company not provided
        :param str company_label: label of company field
        :param bool email: whether email field is required
        :param str email_access_domain_error: error message when a user has valid social login but doesn't match specified email domains.
        :param str email_cancel: Label for cancel confirmation code submission using email auth
        :param str email_error: error message when email not provided
        :param str email_label: label of email field
        :param str email_submit: Label for confirmation code submit button using email auth
        :param str email_title: Title for the Email registration
        :param bool field1: whether to ask field1
        :param str field1error: error message when field1 not provided
        :param str field1label: label of field1
        :param bool field1required: whether field1 is required field
        :param bool field2: whether to ask field2
        :param str field2error: error message when field2 not provided
        :param str field2label: label of field2
        :param bool field2required: whether field2 is required field
        :param bool field3: whether to ask field3
        :param str field3error: error message when field3 not provided
        :param str field3label: label of field3
        :param bool field3required: whether field3 is required field
        :param bool field4: whether to ask field4
        :param str field4error: error message when field4 not provided
        :param str field4label: label of field4
        :param bool field4required: whether field4 is required field
        :param Mapping[str, 'WlanPortalTemplatePortalTemplateLocalesArgs'] locales: Can be used to localize the portal based on the User Agent. Allowed property key values are:
                 `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
                 `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
                 `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
                 `zh-Hans`, `zh-Hant`
        :param str logo: path to the background image file. File must be a `png` image`
        :param bool name: whether name field is required
        :param str name_error: error message when name not provided
        :param str name_label: label of name field
        :param bool opt_out_default: Default value for the `Do not store` checkbox
        :param bool optout: whether to display Do Not Store My Personal Information
        :param str optout_label: label for Do Not Store My Personal Information
        :param str passphrase_cancel: Label for the Passphrase cancel button
        :param str passphrase_error: error message when invalid passphrase is provided
        :param str passphrase_label: Passphrase
        :param str passphrase_submit: Label for the Passphrase submit button
        :param str passphrase_title: Title for passphrase details page
        :param bool powered_by: whether to show \\"Powered by Mist\\"
        :param bool privacy: wheter to require the Privacy Term acceptance
        :param str privacy_policy_accept_label: prefix of the label of the link to go to Privacy Policy
        :param str privacy_policy_error: error message when Privacy Policy not accepted
        :param str privacy_policy_link: label of the link to go to Privacy Policy
        :param str privacy_policy_text: text of the Privacy Policy
        :param str required_field_label: label to denote required field
        :param str sign_in_label: label of the button to /signin
        :param str sms_carrier_field_label: label for mobile carrier drop-down list
        :param str sms_code_cancel: Label for cancel confirmation code submission
        :param str sms_code_error: error message when confirmation code is invalid
        :param str sms_code_submit: Label for confirmation code submit button
        :param str sms_have_access_code: Label for checkbox to specify that the user has access code
        :param str sms_message_format: format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
        :param str sms_number_cancel: label for canceling mobile details for SMS auth
        :param str sms_number_field_label: label for field to provide mobile number
        :param str sms_number_submit: label for submit button for code generation
        :param str sms_number_title: Title for phone number details
        :param int sms_validity_duration: how long confirmation code should be considered valid (in minutes)
        :param str sponsor_email: label for Sponsor Email
        :param str sponsor_email_template: html template to replace/override default sponsor email template 
               Sponsor Email Template supports following template variables:
                 * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
                 * `deny_url`: Renders URL to reject the request
                 * `guest_email`: Renders Email ID of the guest
                 * `guest_name`: Renders Name of the guest
                 * `field1`: Renders value of the Custom Field 1
                 * `field2`: Renders value of the Custom Field 2
                 * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
                 * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        :param str sponsor_name: label for Sponsor Name
        :param str sponsor_request_access: submit button label request Wifi Access and notify sponsor about guest request
        :param str sponsor_status_approved: text to display if sponsor approves request
        :param str sponsor_status_denied: text to display when sponsor denies request
        :param str sponsor_status_pending: text to display if request is still pending
        :param str sponsor_submit: submit button label to notify sponsor about guest request
        :param str tos_accept_label: prefix of the label of the link to go to tos
        :param str tos_error: error message when tos not accepted
        :param str tos_link: label of the link to go to tos
        :param str tos_text: text of the Terms of Service
        """
        if access_code_alternate_email is not None:
            pulumi.set(__self__, "access_code_alternate_email", access_code_alternate_email)
        if alignment is not None:
            pulumi.set(__self__, "alignment", alignment)
        if auth_button_amazon is not None:
            pulumi.set(__self__, "auth_button_amazon", auth_button_amazon)
        if auth_button_azure is not None:
            pulumi.set(__self__, "auth_button_azure", auth_button_azure)
        if auth_button_email is not None:
            pulumi.set(__self__, "auth_button_email", auth_button_email)
        if auth_button_facebook is not None:
            pulumi.set(__self__, "auth_button_facebook", auth_button_facebook)
        if auth_button_google is not None:
            pulumi.set(__self__, "auth_button_google", auth_button_google)
        if auth_button_microsoft is not None:
            pulumi.set(__self__, "auth_button_microsoft", auth_button_microsoft)
        if auth_button_passphrase is not None:
            pulumi.set(__self__, "auth_button_passphrase", auth_button_passphrase)
        if auth_button_sms is not None:
            pulumi.set(__self__, "auth_button_sms", auth_button_sms)
        if auth_button_sponsor is not None:
            pulumi.set(__self__, "auth_button_sponsor", auth_button_sponsor)
        if auth_label is not None:
            pulumi.set(__self__, "auth_label", auth_label)
        if back_link is not None:
            pulumi.set(__self__, "back_link", back_link)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_dark is not None:
            pulumi.set(__self__, "color_dark", color_dark)
        if color_light is not None:
            pulumi.set(__self__, "color_light", color_light)
        if company is not None:
            pulumi.set(__self__, "company", company)
        if company_error is not None:
            pulumi.set(__self__, "company_error", company_error)
        if company_label is not None:
            pulumi.set(__self__, "company_label", company_label)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_access_domain_error is not None:
            pulumi.set(__self__, "email_access_domain_error", email_access_domain_error)
        if email_cancel is not None:
            pulumi.set(__self__, "email_cancel", email_cancel)
        if email_code_cancel is not None:
            pulumi.set(__self__, "email_code_cancel", email_code_cancel)
        if email_code_error is not None:
            pulumi.set(__self__, "email_code_error", email_code_error)
        if email_code_field_label is not None:
            pulumi.set(__self__, "email_code_field_label", email_code_field_label)
        if email_code_message is not None:
            pulumi.set(__self__, "email_code_message", email_code_message)
        if email_code_submit is not None:
            pulumi.set(__self__, "email_code_submit", email_code_submit)
        if email_code_title is not None:
            pulumi.set(__self__, "email_code_title", email_code_title)
        if email_error is not None:
            pulumi.set(__self__, "email_error", email_error)
        if email_field_label is not None:
            pulumi.set(__self__, "email_field_label", email_field_label)
        if email_label is not None:
            pulumi.set(__self__, "email_label", email_label)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_submit is not None:
            pulumi.set(__self__, "email_submit", email_submit)
        if email_title is not None:
            pulumi.set(__self__, "email_title", email_title)
        if field1 is not None:
            pulumi.set(__self__, "field1", field1)
        if field1error is not None:
            pulumi.set(__self__, "field1error", field1error)
        if field1label is not None:
            pulumi.set(__self__, "field1label", field1label)
        if field1required is not None:
            pulumi.set(__self__, "field1required", field1required)
        if field2 is not None:
            pulumi.set(__self__, "field2", field2)
        if field2error is not None:
            pulumi.set(__self__, "field2error", field2error)
        if field2label is not None:
            pulumi.set(__self__, "field2label", field2label)
        if field2required is not None:
            pulumi.set(__self__, "field2required", field2required)
        if field3 is not None:
            pulumi.set(__self__, "field3", field3)
        if field3error is not None:
            pulumi.set(__self__, "field3error", field3error)
        if field3label is not None:
            pulumi.set(__self__, "field3label", field3label)
        if field3required is not None:
            pulumi.set(__self__, "field3required", field3required)
        if field4 is not None:
            pulumi.set(__self__, "field4", field4)
        if field4error is not None:
            pulumi.set(__self__, "field4error", field4error)
        if field4label is not None:
            pulumi.set(__self__, "field4label", field4label)
        if field4required is not None:
            pulumi.set(__self__, "field4required", field4required)
        if locales is not None:
            pulumi.set(__self__, "locales", locales)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if multi_auth is not None:
            pulumi.set(__self__, "multi_auth", multi_auth)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_error is not None:
            pulumi.set(__self__, "name_error", name_error)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if opt_out_default is not None:
            pulumi.set(__self__, "opt_out_default", opt_out_default)
        if optout is not None:
            pulumi.set(__self__, "optout", optout)
        if optout_label is not None:
            pulumi.set(__self__, "optout_label", optout_label)
        if page_title is not None:
            pulumi.set(__self__, "page_title", page_title)
        if passphrase_cancel is not None:
            pulumi.set(__self__, "passphrase_cancel", passphrase_cancel)
        if passphrase_error is not None:
            pulumi.set(__self__, "passphrase_error", passphrase_error)
        if passphrase_label is not None:
            pulumi.set(__self__, "passphrase_label", passphrase_label)
        if passphrase_message is not None:
            pulumi.set(__self__, "passphrase_message", passphrase_message)
        if passphrase_submit is not None:
            pulumi.set(__self__, "passphrase_submit", passphrase_submit)
        if passphrase_title is not None:
            pulumi.set(__self__, "passphrase_title", passphrase_title)
        if powered_by is not None:
            pulumi.set(__self__, "powered_by", powered_by)
        if privacy is not None:
            pulumi.set(__self__, "privacy", privacy)
        if privacy_policy_accept_label is not None:
            pulumi.set(__self__, "privacy_policy_accept_label", privacy_policy_accept_label)
        if privacy_policy_error is not None:
            pulumi.set(__self__, "privacy_policy_error", privacy_policy_error)
        if privacy_policy_link is not None:
            pulumi.set(__self__, "privacy_policy_link", privacy_policy_link)
        if privacy_policy_text is not None:
            pulumi.set(__self__, "privacy_policy_text", privacy_policy_text)
        if required_field_label is not None:
            pulumi.set(__self__, "required_field_label", required_field_label)
        if responsive_layout is not None:
            pulumi.set(__self__, "responsive_layout", responsive_layout)
        if sign_in_label is not None:
            pulumi.set(__self__, "sign_in_label", sign_in_label)
        if sms_carrier_default is not None:
            pulumi.set(__self__, "sms_carrier_default", sms_carrier_default)
        if sms_carrier_error is not None:
            pulumi.set(__self__, "sms_carrier_error", sms_carrier_error)
        if sms_carrier_field_label is not None:
            pulumi.set(__self__, "sms_carrier_field_label", sms_carrier_field_label)
        if sms_code_cancel is not None:
            pulumi.set(__self__, "sms_code_cancel", sms_code_cancel)
        if sms_code_error is not None:
            pulumi.set(__self__, "sms_code_error", sms_code_error)
        if sms_code_field_label is not None:
            pulumi.set(__self__, "sms_code_field_label", sms_code_field_label)
        if sms_code_message is not None:
            pulumi.set(__self__, "sms_code_message", sms_code_message)
        if sms_code_submit is not None:
            pulumi.set(__self__, "sms_code_submit", sms_code_submit)
        if sms_code_title is not None:
            pulumi.set(__self__, "sms_code_title", sms_code_title)
        if sms_country_field_label is not None:
            pulumi.set(__self__, "sms_country_field_label", sms_country_field_label)
        if sms_country_format is not None:
            pulumi.set(__self__, "sms_country_format", sms_country_format)
        if sms_have_access_code is not None:
            pulumi.set(__self__, "sms_have_access_code", sms_have_access_code)
        if sms_is_twilio is not None:
            pulumi.set(__self__, "sms_is_twilio", sms_is_twilio)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_number_cancel is not None:
            pulumi.set(__self__, "sms_number_cancel", sms_number_cancel)
        if sms_number_error is not None:
            pulumi.set(__self__, "sms_number_error", sms_number_error)
        if sms_number_field_label is not None:
            pulumi.set(__self__, "sms_number_field_label", sms_number_field_label)
        if sms_number_format is not None:
            pulumi.set(__self__, "sms_number_format", sms_number_format)
        if sms_number_message is not None:
            pulumi.set(__self__, "sms_number_message", sms_number_message)
        if sms_number_submit is not None:
            pulumi.set(__self__, "sms_number_submit", sms_number_submit)
        if sms_number_title is not None:
            pulumi.set(__self__, "sms_number_title", sms_number_title)
        if sms_username_format is not None:
            pulumi.set(__self__, "sms_username_format", sms_username_format)
        if sms_validity_duration is not None:
            pulumi.set(__self__, "sms_validity_duration", sms_validity_duration)
        if sponsor_back_link is not None:
            pulumi.set(__self__, "sponsor_back_link", sponsor_back_link)
        if sponsor_cancel is not None:
            pulumi.set(__self__, "sponsor_cancel", sponsor_cancel)
        if sponsor_email is not None:
            pulumi.set(__self__, "sponsor_email", sponsor_email)
        if sponsor_email_error is not None:
            pulumi.set(__self__, "sponsor_email_error", sponsor_email_error)
        if sponsor_email_template is not None:
            pulumi.set(__self__, "sponsor_email_template", sponsor_email_template)
        if sponsor_info_approved is not None:
            pulumi.set(__self__, "sponsor_info_approved", sponsor_info_approved)
        if sponsor_info_denied is not None:
            pulumi.set(__self__, "sponsor_info_denied", sponsor_info_denied)
        if sponsor_info_pending is not None:
            pulumi.set(__self__, "sponsor_info_pending", sponsor_info_pending)
        if sponsor_name is not None:
            pulumi.set(__self__, "sponsor_name", sponsor_name)
        if sponsor_name_error is not None:
            pulumi.set(__self__, "sponsor_name_error", sponsor_name_error)
        if sponsor_note_pending is not None:
            pulumi.set(__self__, "sponsor_note_pending", sponsor_note_pending)
        if sponsor_request_access is not None:
            pulumi.set(__self__, "sponsor_request_access", sponsor_request_access)
        if sponsor_status_approved is not None:
            pulumi.set(__self__, "sponsor_status_approved", sponsor_status_approved)
        if sponsor_status_denied is not None:
            pulumi.set(__self__, "sponsor_status_denied", sponsor_status_denied)
        if sponsor_status_pending is not None:
            pulumi.set(__self__, "sponsor_status_pending", sponsor_status_pending)
        if sponsor_submit is not None:
            pulumi.set(__self__, "sponsor_submit", sponsor_submit)
        if sponsors_error is not None:
            pulumi.set(__self__, "sponsors_error", sponsors_error)
        if sponsors_field_label is not None:
            pulumi.set(__self__, "sponsors_field_label", sponsors_field_label)
        if tos is not None:
            pulumi.set(__self__, "tos", tos)
        if tos_accept_label is not None:
            pulumi.set(__self__, "tos_accept_label", tos_accept_label)
        if tos_error is not None:
            pulumi.set(__self__, "tos_error", tos_error)
        if tos_link is not None:
            pulumi.set(__self__, "tos_link", tos_link)
        if tos_text is not None:
            pulumi.set(__self__, "tos_text", tos_text)

    @property
    @pulumi.getter(name="accessCodeAlternateEmail")
    def access_code_alternate_email(self) -> Optional[str]:
        return pulumi.get(self, "access_code_alternate_email")

    @property
    @pulumi.getter
    def alignment(self) -> Optional[str]:
        """
        defines alignment on portal. enum: `center`, `left`, `right`
        """
        return pulumi.get(self, "alignment")

    @property
    @pulumi.getter(name="authButtonAmazon")
    def auth_button_amazon(self) -> Optional[str]:
        """
        label for Amazon auth button
        """
        return pulumi.get(self, "auth_button_amazon")

    @property
    @pulumi.getter(name="authButtonAzure")
    def auth_button_azure(self) -> Optional[str]:
        """
        label for Azure auth button
        """
        return pulumi.get(self, "auth_button_azure")

    @property
    @pulumi.getter(name="authButtonEmail")
    def auth_button_email(self) -> Optional[str]:
        """
        label for Email auth button
        """
        return pulumi.get(self, "auth_button_email")

    @property
    @pulumi.getter(name="authButtonFacebook")
    def auth_button_facebook(self) -> Optional[str]:
        """
        label for Facebook auth button
        """
        return pulumi.get(self, "auth_button_facebook")

    @property
    @pulumi.getter(name="authButtonGoogle")
    def auth_button_google(self) -> Optional[str]:
        """
        label for Google auth button
        """
        return pulumi.get(self, "auth_button_google")

    @property
    @pulumi.getter(name="authButtonMicrosoft")
    def auth_button_microsoft(self) -> Optional[str]:
        """
        label for Microsoft auth button
        """
        return pulumi.get(self, "auth_button_microsoft")

    @property
    @pulumi.getter(name="authButtonPassphrase")
    def auth_button_passphrase(self) -> Optional[str]:
        """
        label for passphrase auth button
        """
        return pulumi.get(self, "auth_button_passphrase")

    @property
    @pulumi.getter(name="authButtonSms")
    def auth_button_sms(self) -> Optional[str]:
        """
        label for SMS auth button
        """
        return pulumi.get(self, "auth_button_sms")

    @property
    @pulumi.getter(name="authButtonSponsor")
    def auth_button_sponsor(self) -> Optional[str]:
        """
        label for Sponsor auth button
        """
        return pulumi.get(self, "auth_button_sponsor")

    @property
    @pulumi.getter(name="authLabel")
    def auth_label(self) -> Optional[str]:
        return pulumi.get(self, "auth_label")

    @property
    @pulumi.getter(name="backLink")
    def back_link(self) -> Optional[str]:
        """
        label of the link to go back to /logon
        """
        return pulumi.get(self, "back_link")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Portal main color
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="colorDark")
    def color_dark(self) -> Optional[str]:
        return pulumi.get(self, "color_dark")

    @property
    @pulumi.getter(name="colorLight")
    def color_light(self) -> Optional[str]:
        return pulumi.get(self, "color_light")

    @property
    @pulumi.getter
    def company(self) -> Optional[bool]:
        """
        whether company field is required
        """
        return pulumi.get(self, "company")

    @property
    @pulumi.getter(name="companyError")
    def company_error(self) -> Optional[str]:
        """
        error message when company not provided
        """
        return pulumi.get(self, "company_error")

    @property
    @pulumi.getter(name="companyLabel")
    def company_label(self) -> Optional[str]:
        """
        label of company field
        """
        return pulumi.get(self, "company_label")

    @property
    @pulumi.getter
    def email(self) -> Optional[bool]:
        """
        whether email field is required
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailAccessDomainError")
    def email_access_domain_error(self) -> Optional[str]:
        """
        error message when a user has valid social login but doesn't match specified email domains.
        """
        return pulumi.get(self, "email_access_domain_error")

    @property
    @pulumi.getter(name="emailCancel")
    def email_cancel(self) -> Optional[str]:
        """
        Label for cancel confirmation code submission using email auth
        """
        return pulumi.get(self, "email_cancel")

    @property
    @pulumi.getter(name="emailCodeCancel")
    def email_code_cancel(self) -> Optional[str]:
        return pulumi.get(self, "email_code_cancel")

    @property
    @pulumi.getter(name="emailCodeError")
    def email_code_error(self) -> Optional[str]:
        return pulumi.get(self, "email_code_error")

    @property
    @pulumi.getter(name="emailCodeFieldLabel")
    def email_code_field_label(self) -> Optional[str]:
        return pulumi.get(self, "email_code_field_label")

    @property
    @pulumi.getter(name="emailCodeMessage")
    def email_code_message(self) -> Optional[str]:
        return pulumi.get(self, "email_code_message")

    @property
    @pulumi.getter(name="emailCodeSubmit")
    def email_code_submit(self) -> Optional[str]:
        return pulumi.get(self, "email_code_submit")

    @property
    @pulumi.getter(name="emailCodeTitle")
    def email_code_title(self) -> Optional[str]:
        return pulumi.get(self, "email_code_title")

    @property
    @pulumi.getter(name="emailError")
    def email_error(self) -> Optional[str]:
        """
        error message when email not provided
        """
        return pulumi.get(self, "email_error")

    @property
    @pulumi.getter(name="emailFieldLabel")
    def email_field_label(self) -> Optional[str]:
        return pulumi.get(self, "email_field_label")

    @property
    @pulumi.getter(name="emailLabel")
    def email_label(self) -> Optional[str]:
        """
        label of email field
        """
        return pulumi.get(self, "email_label")

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[str]:
        return pulumi.get(self, "email_message")

    @property
    @pulumi.getter(name="emailSubmit")
    def email_submit(self) -> Optional[str]:
        """
        Label for confirmation code submit button using email auth
        """
        return pulumi.get(self, "email_submit")

    @property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> Optional[str]:
        """
        Title for the Email registration
        """
        return pulumi.get(self, "email_title")

    @property
    @pulumi.getter
    def field1(self) -> Optional[bool]:
        """
        whether to ask field1
        """
        return pulumi.get(self, "field1")

    @property
    @pulumi.getter
    def field1error(self) -> Optional[str]:
        """
        error message when field1 not provided
        """
        return pulumi.get(self, "field1error")

    @property
    @pulumi.getter
    def field1label(self) -> Optional[str]:
        """
        label of field1
        """
        return pulumi.get(self, "field1label")

    @property
    @pulumi.getter
    def field1required(self) -> Optional[bool]:
        """
        whether field1 is required field
        """
        return pulumi.get(self, "field1required")

    @property
    @pulumi.getter
    def field2(self) -> Optional[bool]:
        """
        whether to ask field2
        """
        return pulumi.get(self, "field2")

    @property
    @pulumi.getter
    def field2error(self) -> Optional[str]:
        """
        error message when field2 not provided
        """
        return pulumi.get(self, "field2error")

    @property
    @pulumi.getter
    def field2label(self) -> Optional[str]:
        """
        label of field2
        """
        return pulumi.get(self, "field2label")

    @property
    @pulumi.getter
    def field2required(self) -> Optional[bool]:
        """
        whether field2 is required field
        """
        return pulumi.get(self, "field2required")

    @property
    @pulumi.getter
    def field3(self) -> Optional[bool]:
        """
        whether to ask field3
        """
        return pulumi.get(self, "field3")

    @property
    @pulumi.getter
    def field3error(self) -> Optional[str]:
        """
        error message when field3 not provided
        """
        return pulumi.get(self, "field3error")

    @property
    @pulumi.getter
    def field3label(self) -> Optional[str]:
        """
        label of field3
        """
        return pulumi.get(self, "field3label")

    @property
    @pulumi.getter
    def field3required(self) -> Optional[bool]:
        """
        whether field3 is required field
        """
        return pulumi.get(self, "field3required")

    @property
    @pulumi.getter
    def field4(self) -> Optional[bool]:
        """
        whether to ask field4
        """
        return pulumi.get(self, "field4")

    @property
    @pulumi.getter
    def field4error(self) -> Optional[str]:
        """
        error message when field4 not provided
        """
        return pulumi.get(self, "field4error")

    @property
    @pulumi.getter
    def field4label(self) -> Optional[str]:
        """
        label of field4
        """
        return pulumi.get(self, "field4label")

    @property
    @pulumi.getter
    def field4required(self) -> Optional[bool]:
        """
        whether field4 is required field
        """
        return pulumi.get(self, "field4required")

    @property
    @pulumi.getter
    def locales(self) -> Optional[Mapping[str, 'outputs.WlanPortalTemplatePortalTemplateLocales']]:
        """
        Can be used to localize the portal based on the User Agent. Allowed property key values are:
          `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
          `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
          `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
          `zh-Hans`, `zh-Hant`
        """
        return pulumi.get(self, "locales")

    @property
    @pulumi.getter
    def logo(self) -> Optional[str]:
        """
        path to the background image file. File must be a `png` image`
        """
        return pulumi.get(self, "logo")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="multiAuth")
    def multi_auth(self) -> Optional[bool]:
        return pulumi.get(self, "multi_auth")

    @property
    @pulumi.getter
    def name(self) -> Optional[bool]:
        """
        whether name field is required
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameError")
    def name_error(self) -> Optional[str]:
        """
        error message when name not provided
        """
        return pulumi.get(self, "name_error")

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[str]:
        """
        label of name field
        """
        return pulumi.get(self, "name_label")

    @property
    @pulumi.getter(name="optOutDefault")
    def opt_out_default(self) -> Optional[bool]:
        """
        Default value for the `Do not store` checkbox
        """
        return pulumi.get(self, "opt_out_default")

    @property
    @pulumi.getter
    def optout(self) -> Optional[bool]:
        """
        whether to display Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout")

    @property
    @pulumi.getter(name="optoutLabel")
    def optout_label(self) -> Optional[str]:
        """
        label for Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout_label")

    @property
    @pulumi.getter(name="pageTitle")
    def page_title(self) -> Optional[str]:
        return pulumi.get(self, "page_title")

    @property
    @pulumi.getter(name="passphraseCancel")
    def passphrase_cancel(self) -> Optional[str]:
        """
        Label for the Passphrase cancel button
        """
        return pulumi.get(self, "passphrase_cancel")

    @property
    @pulumi.getter(name="passphraseError")
    def passphrase_error(self) -> Optional[str]:
        """
        error message when invalid passphrase is provided
        """
        return pulumi.get(self, "passphrase_error")

    @property
    @pulumi.getter(name="passphraseLabel")
    def passphrase_label(self) -> Optional[str]:
        """
        Passphrase
        """
        return pulumi.get(self, "passphrase_label")

    @property
    @pulumi.getter(name="passphraseMessage")
    def passphrase_message(self) -> Optional[str]:
        return pulumi.get(self, "passphrase_message")

    @property
    @pulumi.getter(name="passphraseSubmit")
    def passphrase_submit(self) -> Optional[str]:
        """
        Label for the Passphrase submit button
        """
        return pulumi.get(self, "passphrase_submit")

    @property
    @pulumi.getter(name="passphraseTitle")
    def passphrase_title(self) -> Optional[str]:
        """
        Title for passphrase details page
        """
        return pulumi.get(self, "passphrase_title")

    @property
    @pulumi.getter(name="poweredBy")
    def powered_by(self) -> Optional[bool]:
        """
        whether to show \\"Powered by Mist\\"
        """
        return pulumi.get(self, "powered_by")

    @property
    @pulumi.getter
    def privacy(self) -> Optional[bool]:
        """
        wheter to require the Privacy Term acceptance
        """
        return pulumi.get(self, "privacy")

    @property
    @pulumi.getter(name="privacyPolicyAcceptLabel")
    def privacy_policy_accept_label(self) -> Optional[str]:
        """
        prefix of the label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_accept_label")

    @property
    @pulumi.getter(name="privacyPolicyError")
    def privacy_policy_error(self) -> Optional[str]:
        """
        error message when Privacy Policy not accepted
        """
        return pulumi.get(self, "privacy_policy_error")

    @property
    @pulumi.getter(name="privacyPolicyLink")
    def privacy_policy_link(self) -> Optional[str]:
        """
        label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_link")

    @property
    @pulumi.getter(name="privacyPolicyText")
    def privacy_policy_text(self) -> Optional[str]:
        """
        text of the Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_text")

    @property
    @pulumi.getter(name="requiredFieldLabel")
    def required_field_label(self) -> Optional[str]:
        """
        label to denote required field
        """
        return pulumi.get(self, "required_field_label")

    @property
    @pulumi.getter(name="responsiveLayout")
    def responsive_layout(self) -> Optional[bool]:
        return pulumi.get(self, "responsive_layout")

    @property
    @pulumi.getter(name="signInLabel")
    def sign_in_label(self) -> Optional[str]:
        """
        label of the button to /signin
        """
        return pulumi.get(self, "sign_in_label")

    @property
    @pulumi.getter(name="smsCarrierDefault")
    def sms_carrier_default(self) -> Optional[str]:
        return pulumi.get(self, "sms_carrier_default")

    @property
    @pulumi.getter(name="smsCarrierError")
    def sms_carrier_error(self) -> Optional[str]:
        return pulumi.get(self, "sms_carrier_error")

    @property
    @pulumi.getter(name="smsCarrierFieldLabel")
    def sms_carrier_field_label(self) -> Optional[str]:
        """
        label for mobile carrier drop-down list
        """
        return pulumi.get(self, "sms_carrier_field_label")

    @property
    @pulumi.getter(name="smsCodeCancel")
    def sms_code_cancel(self) -> Optional[str]:
        """
        Label for cancel confirmation code submission
        """
        return pulumi.get(self, "sms_code_cancel")

    @property
    @pulumi.getter(name="smsCodeError")
    def sms_code_error(self) -> Optional[str]:
        """
        error message when confirmation code is invalid
        """
        return pulumi.get(self, "sms_code_error")

    @property
    @pulumi.getter(name="smsCodeFieldLabel")
    def sms_code_field_label(self) -> Optional[str]:
        return pulumi.get(self, "sms_code_field_label")

    @property
    @pulumi.getter(name="smsCodeMessage")
    def sms_code_message(self) -> Optional[str]:
        return pulumi.get(self, "sms_code_message")

    @property
    @pulumi.getter(name="smsCodeSubmit")
    def sms_code_submit(self) -> Optional[str]:
        """
        Label for confirmation code submit button
        """
        return pulumi.get(self, "sms_code_submit")

    @property
    @pulumi.getter(name="smsCodeTitle")
    def sms_code_title(self) -> Optional[str]:
        return pulumi.get(self, "sms_code_title")

    @property
    @pulumi.getter(name="smsCountryFieldLabel")
    def sms_country_field_label(self) -> Optional[str]:
        return pulumi.get(self, "sms_country_field_label")

    @property
    @pulumi.getter(name="smsCountryFormat")
    def sms_country_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_country_format")

    @property
    @pulumi.getter(name="smsHaveAccessCode")
    def sms_have_access_code(self) -> Optional[str]:
        """
        Label for checkbox to specify that the user has access code
        """
        return pulumi.get(self, "sms_have_access_code")

    @property
    @pulumi.getter(name="smsIsTwilio")
    def sms_is_twilio(self) -> Optional[bool]:
        return pulumi.get(self, "sms_is_twilio")

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[str]:
        """
        format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
        """
        return pulumi.get(self, "sms_message_format")

    @property
    @pulumi.getter(name="smsNumberCancel")
    def sms_number_cancel(self) -> Optional[str]:
        """
        label for canceling mobile details for SMS auth
        """
        return pulumi.get(self, "sms_number_cancel")

    @property
    @pulumi.getter(name="smsNumberError")
    def sms_number_error(self) -> Optional[str]:
        return pulumi.get(self, "sms_number_error")

    @property
    @pulumi.getter(name="smsNumberFieldLabel")
    def sms_number_field_label(self) -> Optional[str]:
        """
        label for field to provide mobile number
        """
        return pulumi.get(self, "sms_number_field_label")

    @property
    @pulumi.getter(name="smsNumberFormat")
    def sms_number_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_number_format")

    @property
    @pulumi.getter(name="smsNumberMessage")
    def sms_number_message(self) -> Optional[str]:
        return pulumi.get(self, "sms_number_message")

    @property
    @pulumi.getter(name="smsNumberSubmit")
    def sms_number_submit(self) -> Optional[str]:
        """
        label for submit button for code generation
        """
        return pulumi.get(self, "sms_number_submit")

    @property
    @pulumi.getter(name="smsNumberTitle")
    def sms_number_title(self) -> Optional[str]:
        """
        Title for phone number details
        """
        return pulumi.get(self, "sms_number_title")

    @property
    @pulumi.getter(name="smsUsernameFormat")
    def sms_username_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_username_format")

    @property
    @pulumi.getter(name="smsValidityDuration")
    def sms_validity_duration(self) -> Optional[int]:
        """
        how long confirmation code should be considered valid (in minutes)
        """
        return pulumi.get(self, "sms_validity_duration")

    @property
    @pulumi.getter(name="sponsorBackLink")
    def sponsor_back_link(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_back_link")

    @property
    @pulumi.getter(name="sponsorCancel")
    def sponsor_cancel(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_cancel")

    @property
    @pulumi.getter(name="sponsorEmail")
    def sponsor_email(self) -> Optional[str]:
        """
        label for Sponsor Email
        """
        return pulumi.get(self, "sponsor_email")

    @property
    @pulumi.getter(name="sponsorEmailError")
    def sponsor_email_error(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_email_error")

    @property
    @pulumi.getter(name="sponsorEmailTemplate")
    def sponsor_email_template(self) -> Optional[str]:
        """
        html template to replace/override default sponsor email template 
        Sponsor Email Template supports following template variables:
          * `approve_url`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
          * `deny_url`: Renders URL to reject the request
          * `guest_email`: Renders Email ID of the guest
          * `guest_name`: Renders Name of the guest
          * `field1`: Renders value of the Custom Field 1
          * `field2`: Renders value of the Custom Field 2
          * `sponsor_link_validity_duration`: Renders validity time of the request (i.e. Approve/Deny URL)
          * `auth_expire_minutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
        """
        return pulumi.get(self, "sponsor_email_template")

    @property
    @pulumi.getter(name="sponsorInfoApproved")
    def sponsor_info_approved(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_info_approved")

    @property
    @pulumi.getter(name="sponsorInfoDenied")
    def sponsor_info_denied(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_info_denied")

    @property
    @pulumi.getter(name="sponsorInfoPending")
    def sponsor_info_pending(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_info_pending")

    @property
    @pulumi.getter(name="sponsorName")
    def sponsor_name(self) -> Optional[str]:
        """
        label for Sponsor Name
        """
        return pulumi.get(self, "sponsor_name")

    @property
    @pulumi.getter(name="sponsorNameError")
    def sponsor_name_error(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_name_error")

    @property
    @pulumi.getter(name="sponsorNotePending")
    def sponsor_note_pending(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_note_pending")

    @property
    @pulumi.getter(name="sponsorRequestAccess")
    def sponsor_request_access(self) -> Optional[str]:
        """
        submit button label request Wifi Access and notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_request_access")

    @property
    @pulumi.getter(name="sponsorStatusApproved")
    def sponsor_status_approved(self) -> Optional[str]:
        """
        text to display if sponsor approves request
        """
        return pulumi.get(self, "sponsor_status_approved")

    @property
    @pulumi.getter(name="sponsorStatusDenied")
    def sponsor_status_denied(self) -> Optional[str]:
        """
        text to display when sponsor denies request
        """
        return pulumi.get(self, "sponsor_status_denied")

    @property
    @pulumi.getter(name="sponsorStatusPending")
    def sponsor_status_pending(self) -> Optional[str]:
        """
        text to display if request is still pending
        """
        return pulumi.get(self, "sponsor_status_pending")

    @property
    @pulumi.getter(name="sponsorSubmit")
    def sponsor_submit(self) -> Optional[str]:
        """
        submit button label to notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_submit")

    @property
    @pulumi.getter(name="sponsorsError")
    def sponsors_error(self) -> Optional[str]:
        return pulumi.get(self, "sponsors_error")

    @property
    @pulumi.getter(name="sponsorsFieldLabel")
    def sponsors_field_label(self) -> Optional[str]:
        return pulumi.get(self, "sponsors_field_label")

    @property
    @pulumi.getter
    def tos(self) -> Optional[bool]:
        return pulumi.get(self, "tos")

    @property
    @pulumi.getter(name="tosAcceptLabel")
    def tos_accept_label(self) -> Optional[str]:
        """
        prefix of the label of the link to go to tos
        """
        return pulumi.get(self, "tos_accept_label")

    @property
    @pulumi.getter(name="tosError")
    def tos_error(self) -> Optional[str]:
        """
        error message when tos not accepted
        """
        return pulumi.get(self, "tos_error")

    @property
    @pulumi.getter(name="tosLink")
    def tos_link(self) -> Optional[str]:
        """
        label of the link to go to tos
        """
        return pulumi.get(self, "tos_link")

    @property
    @pulumi.getter(name="tosText")
    def tos_text(self) -> Optional[str]:
        """
        text of the Terms of Service
        """
        return pulumi.get(self, "tos_text")


@pulumi.output_type
class WlanPortalTemplatePortalTemplateLocales(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authButtonAmazon":
            suggest = "auth_button_amazon"
        elif key == "authButtonAzure":
            suggest = "auth_button_azure"
        elif key == "authButtonEmail":
            suggest = "auth_button_email"
        elif key == "authButtonFacebook":
            suggest = "auth_button_facebook"
        elif key == "authButtonGoogle":
            suggest = "auth_button_google"
        elif key == "authButtonMicrosoft":
            suggest = "auth_button_microsoft"
        elif key == "authButtonPassphrase":
            suggest = "auth_button_passphrase"
        elif key == "authButtonSms":
            suggest = "auth_button_sms"
        elif key == "authButtonSponsor":
            suggest = "auth_button_sponsor"
        elif key == "authLabel":
            suggest = "auth_label"
        elif key == "backLink":
            suggest = "back_link"
        elif key == "companyError":
            suggest = "company_error"
        elif key == "companyLabel":
            suggest = "company_label"
        elif key == "emailAccessDomainError":
            suggest = "email_access_domain_error"
        elif key == "emailCancel":
            suggest = "email_cancel"
        elif key == "emailCodeCancel":
            suggest = "email_code_cancel"
        elif key == "emailCodeError":
            suggest = "email_code_error"
        elif key == "emailCodeFieldLabel":
            suggest = "email_code_field_label"
        elif key == "emailCodeMessage":
            suggest = "email_code_message"
        elif key == "emailCodeSubmit":
            suggest = "email_code_submit"
        elif key == "emailCodeTitle":
            suggest = "email_code_title"
        elif key == "emailError":
            suggest = "email_error"
        elif key == "emailFieldLabel":
            suggest = "email_field_label"
        elif key == "emailLabel":
            suggest = "email_label"
        elif key == "emailMessage":
            suggest = "email_message"
        elif key == "emailSubmit":
            suggest = "email_submit"
        elif key == "emailTitle":
            suggest = "email_title"
        elif key == "nameError":
            suggest = "name_error"
        elif key == "nameLabel":
            suggest = "name_label"
        elif key == "optoutLabel":
            suggest = "optout_label"
        elif key == "pageTitle":
            suggest = "page_title"
        elif key == "passphraseCancel":
            suggest = "passphrase_cancel"
        elif key == "passphraseError":
            suggest = "passphrase_error"
        elif key == "passphraseLabel":
            suggest = "passphrase_label"
        elif key == "passphraseMessage":
            suggest = "passphrase_message"
        elif key == "passphraseSubmit":
            suggest = "passphrase_submit"
        elif key == "passphraseTitle":
            suggest = "passphrase_title"
        elif key == "privacyPolicyAcceptLabel":
            suggest = "privacy_policy_accept_label"
        elif key == "privacyPolicyError":
            suggest = "privacy_policy_error"
        elif key == "privacyPolicyLink":
            suggest = "privacy_policy_link"
        elif key == "privacyPolicyText":
            suggest = "privacy_policy_text"
        elif key == "requiredFieldLabel":
            suggest = "required_field_label"
        elif key == "signInLabel":
            suggest = "sign_in_label"
        elif key == "smsCarrierDefault":
            suggest = "sms_carrier_default"
        elif key == "smsCarrierError":
            suggest = "sms_carrier_error"
        elif key == "smsCarrierFieldLabel":
            suggest = "sms_carrier_field_label"
        elif key == "smsCodeCancel":
            suggest = "sms_code_cancel"
        elif key == "smsCodeError":
            suggest = "sms_code_error"
        elif key == "smsCodeFieldLabel":
            suggest = "sms_code_field_label"
        elif key == "smsCodeMessage":
            suggest = "sms_code_message"
        elif key == "smsCodeSubmit":
            suggest = "sms_code_submit"
        elif key == "smsCodeTitle":
            suggest = "sms_code_title"
        elif key == "smsCountryFieldLabel":
            suggest = "sms_country_field_label"
        elif key == "smsCountryFormat":
            suggest = "sms_country_format"
        elif key == "smsHaveAccessCode":
            suggest = "sms_have_access_code"
        elif key == "smsMessageFormat":
            suggest = "sms_message_format"
        elif key == "smsNumberCancel":
            suggest = "sms_number_cancel"
        elif key == "smsNumberError":
            suggest = "sms_number_error"
        elif key == "smsNumberFieldLabel":
            suggest = "sms_number_field_label"
        elif key == "smsNumberFormat":
            suggest = "sms_number_format"
        elif key == "smsNumberMessage":
            suggest = "sms_number_message"
        elif key == "smsNumberSubmit":
            suggest = "sms_number_submit"
        elif key == "smsNumberTitle":
            suggest = "sms_number_title"
        elif key == "smsUsernameFormat":
            suggest = "sms_username_format"
        elif key == "sponsorBackLink":
            suggest = "sponsor_back_link"
        elif key == "sponsorCancel":
            suggest = "sponsor_cancel"
        elif key == "sponsorEmail":
            suggest = "sponsor_email"
        elif key == "sponsorEmailError":
            suggest = "sponsor_email_error"
        elif key == "sponsorInfoApproved":
            suggest = "sponsor_info_approved"
        elif key == "sponsorInfoDenied":
            suggest = "sponsor_info_denied"
        elif key == "sponsorInfoPending":
            suggest = "sponsor_info_pending"
        elif key == "sponsorName":
            suggest = "sponsor_name"
        elif key == "sponsorNameError":
            suggest = "sponsor_name_error"
        elif key == "sponsorNotePending":
            suggest = "sponsor_note_pending"
        elif key == "sponsorRequestAccess":
            suggest = "sponsor_request_access"
        elif key == "sponsorStatusApproved":
            suggest = "sponsor_status_approved"
        elif key == "sponsorStatusDenied":
            suggest = "sponsor_status_denied"
        elif key == "sponsorStatusPending":
            suggest = "sponsor_status_pending"
        elif key == "sponsorSubmit":
            suggest = "sponsor_submit"
        elif key == "sponsorsError":
            suggest = "sponsors_error"
        elif key == "sponsorsFieldLabel":
            suggest = "sponsors_field_label"
        elif key == "tosAcceptLabel":
            suggest = "tos_accept_label"
        elif key == "tosError":
            suggest = "tos_error"
        elif key == "tosLink":
            suggest = "tos_link"
        elif key == "tosText":
            suggest = "tos_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanPortalTemplatePortalTemplateLocales. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanPortalTemplatePortalTemplateLocales.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanPortalTemplatePortalTemplateLocales.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_button_amazon: Optional[str] = None,
                 auth_button_azure: Optional[str] = None,
                 auth_button_email: Optional[str] = None,
                 auth_button_facebook: Optional[str] = None,
                 auth_button_google: Optional[str] = None,
                 auth_button_microsoft: Optional[str] = None,
                 auth_button_passphrase: Optional[str] = None,
                 auth_button_sms: Optional[str] = None,
                 auth_button_sponsor: Optional[str] = None,
                 auth_label: Optional[str] = None,
                 back_link: Optional[str] = None,
                 company_error: Optional[str] = None,
                 company_label: Optional[str] = None,
                 email_access_domain_error: Optional[str] = None,
                 email_cancel: Optional[str] = None,
                 email_code_cancel: Optional[str] = None,
                 email_code_error: Optional[str] = None,
                 email_code_field_label: Optional[str] = None,
                 email_code_message: Optional[str] = None,
                 email_code_submit: Optional[str] = None,
                 email_code_title: Optional[str] = None,
                 email_error: Optional[str] = None,
                 email_field_label: Optional[str] = None,
                 email_label: Optional[str] = None,
                 email_message: Optional[str] = None,
                 email_submit: Optional[str] = None,
                 email_title: Optional[str] = None,
                 field1error: Optional[str] = None,
                 field1label: Optional[str] = None,
                 field2error: Optional[str] = None,
                 field2label: Optional[str] = None,
                 field3error: Optional[str] = None,
                 field3label: Optional[str] = None,
                 field4error: Optional[str] = None,
                 field4label: Optional[str] = None,
                 message: Optional[str] = None,
                 name_error: Optional[str] = None,
                 name_label: Optional[str] = None,
                 optout_label: Optional[str] = None,
                 page_title: Optional[str] = None,
                 passphrase_cancel: Optional[str] = None,
                 passphrase_error: Optional[str] = None,
                 passphrase_label: Optional[str] = None,
                 passphrase_message: Optional[str] = None,
                 passphrase_submit: Optional[str] = None,
                 passphrase_title: Optional[str] = None,
                 privacy_policy_accept_label: Optional[str] = None,
                 privacy_policy_error: Optional[str] = None,
                 privacy_policy_link: Optional[str] = None,
                 privacy_policy_text: Optional[str] = None,
                 required_field_label: Optional[str] = None,
                 sign_in_label: Optional[str] = None,
                 sms_carrier_default: Optional[str] = None,
                 sms_carrier_error: Optional[str] = None,
                 sms_carrier_field_label: Optional[str] = None,
                 sms_code_cancel: Optional[str] = None,
                 sms_code_error: Optional[str] = None,
                 sms_code_field_label: Optional[str] = None,
                 sms_code_message: Optional[str] = None,
                 sms_code_submit: Optional[str] = None,
                 sms_code_title: Optional[str] = None,
                 sms_country_field_label: Optional[str] = None,
                 sms_country_format: Optional[str] = None,
                 sms_have_access_code: Optional[str] = None,
                 sms_message_format: Optional[str] = None,
                 sms_number_cancel: Optional[str] = None,
                 sms_number_error: Optional[str] = None,
                 sms_number_field_label: Optional[str] = None,
                 sms_number_format: Optional[str] = None,
                 sms_number_message: Optional[str] = None,
                 sms_number_submit: Optional[str] = None,
                 sms_number_title: Optional[str] = None,
                 sms_username_format: Optional[str] = None,
                 sponsor_back_link: Optional[str] = None,
                 sponsor_cancel: Optional[str] = None,
                 sponsor_email: Optional[str] = None,
                 sponsor_email_error: Optional[str] = None,
                 sponsor_info_approved: Optional[str] = None,
                 sponsor_info_denied: Optional[str] = None,
                 sponsor_info_pending: Optional[str] = None,
                 sponsor_name: Optional[str] = None,
                 sponsor_name_error: Optional[str] = None,
                 sponsor_note_pending: Optional[str] = None,
                 sponsor_request_access: Optional[str] = None,
                 sponsor_status_approved: Optional[str] = None,
                 sponsor_status_denied: Optional[str] = None,
                 sponsor_status_pending: Optional[str] = None,
                 sponsor_submit: Optional[str] = None,
                 sponsors_error: Optional[str] = None,
                 sponsors_field_label: Optional[str] = None,
                 tos_accept_label: Optional[str] = None,
                 tos_error: Optional[str] = None,
                 tos_link: Optional[str] = None,
                 tos_text: Optional[str] = None):
        """
        :param str auth_button_amazon: label for Amazon auth button
        :param str auth_button_azure: label for Azure auth button
        :param str auth_button_email: label for Email auth button
        :param str auth_button_facebook: label for Facebook auth button
        :param str auth_button_google: label for Google auth button
        :param str auth_button_microsoft: label for Microsoft auth button
        :param str auth_button_passphrase: label for passphrase auth button
        :param str auth_button_sms: label for SMS auth button
        :param str auth_button_sponsor: label for Sponsor auth button
        :param str back_link: label of the link to go back to /logon
        :param str company_error: error message when company not provided
        :param str company_label: label of company field
        :param str email_access_domain_error: error message when a user has valid social login but doesn't match specified email domains.
        :param str email_cancel: Label for cancel confirmation code submission using email auth
        :param str email_error: error message when email not provided
        :param str email_label: label of email field
        :param str email_submit: Label for confirmation code submit button using email auth
        :param str email_title: Title for the Email registration
        :param str field1error: error message when field1 not provided
        :param str field1label: label of field1
        :param str field2error: error message when field2 not provided
        :param str field2label: label of field2
        :param str field3error: error message when field3 not provided
        :param str field3label: label of field3
        :param str field4error: error message when field4 not provided
        :param str field4label: label of field4
        :param str name_error: error message when name not provided
        :param str name_label: label of name field
        :param str optout_label: label for Do Not Store My Personal Information
        :param str passphrase_cancel: Label for the Passphrase cancel button
        :param str passphrase_error: error message when invalid passphrase is provided
        :param str passphrase_label: Passphrase
        :param str passphrase_submit: Label for the Passphrase submit button
        :param str passphrase_title: Title for passphrase details page
        :param str privacy_policy_accept_label: prefix of the label of the link to go to Privacy Policy
        :param str privacy_policy_error: error message when Privacy Policy not accepted
        :param str privacy_policy_link: label of the link to go to Privacy Policy
        :param str privacy_policy_text: text of the Privacy Policy
        :param str required_field_label: label to denote required field
        :param str sign_in_label: label of the button to /signin
        :param str sms_carrier_field_label: label for mobile carrier drop-down list
        :param str sms_code_cancel: Label for cancel confirmation code submission
        :param str sms_code_error: error message when confirmation code is invalid
        :param str sms_code_submit: Label for confirmation code submit button
        :param str sms_have_access_code: Label for checkbox to specify that the user has access code
        :param str sms_message_format: format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
        :param str sms_number_cancel: label for canceling mobile details for SMS auth
        :param str sms_number_field_label: label for field to provide mobile number
        :param str sms_number_submit: label for submit button for code generation
        :param str sms_number_title: Title for phone number details
        :param str sponsor_email: label for Sponsor Email
        :param str sponsor_name: label for Sponsor Name
        :param str sponsor_request_access: submit button label request Wifi Access and notify sponsor about guest request
        :param str sponsor_status_approved: text to display if sponsor approves request
        :param str sponsor_status_denied: text to display when sponsor denies request
        :param str sponsor_status_pending: text to display if request is still pending
        :param str sponsor_submit: submit button label to notify sponsor about guest request
        :param str tos_accept_label: prefix of the label of the link to go to tos
        :param str tos_error: error message when tos not accepted
        :param str tos_link: label of the link to go to tos
        :param str tos_text: text of the Terms of Service
        """
        if auth_button_amazon is not None:
            pulumi.set(__self__, "auth_button_amazon", auth_button_amazon)
        if auth_button_azure is not None:
            pulumi.set(__self__, "auth_button_azure", auth_button_azure)
        if auth_button_email is not None:
            pulumi.set(__self__, "auth_button_email", auth_button_email)
        if auth_button_facebook is not None:
            pulumi.set(__self__, "auth_button_facebook", auth_button_facebook)
        if auth_button_google is not None:
            pulumi.set(__self__, "auth_button_google", auth_button_google)
        if auth_button_microsoft is not None:
            pulumi.set(__self__, "auth_button_microsoft", auth_button_microsoft)
        if auth_button_passphrase is not None:
            pulumi.set(__self__, "auth_button_passphrase", auth_button_passphrase)
        if auth_button_sms is not None:
            pulumi.set(__self__, "auth_button_sms", auth_button_sms)
        if auth_button_sponsor is not None:
            pulumi.set(__self__, "auth_button_sponsor", auth_button_sponsor)
        if auth_label is not None:
            pulumi.set(__self__, "auth_label", auth_label)
        if back_link is not None:
            pulumi.set(__self__, "back_link", back_link)
        if company_error is not None:
            pulumi.set(__self__, "company_error", company_error)
        if company_label is not None:
            pulumi.set(__self__, "company_label", company_label)
        if email_access_domain_error is not None:
            pulumi.set(__self__, "email_access_domain_error", email_access_domain_error)
        if email_cancel is not None:
            pulumi.set(__self__, "email_cancel", email_cancel)
        if email_code_cancel is not None:
            pulumi.set(__self__, "email_code_cancel", email_code_cancel)
        if email_code_error is not None:
            pulumi.set(__self__, "email_code_error", email_code_error)
        if email_code_field_label is not None:
            pulumi.set(__self__, "email_code_field_label", email_code_field_label)
        if email_code_message is not None:
            pulumi.set(__self__, "email_code_message", email_code_message)
        if email_code_submit is not None:
            pulumi.set(__self__, "email_code_submit", email_code_submit)
        if email_code_title is not None:
            pulumi.set(__self__, "email_code_title", email_code_title)
        if email_error is not None:
            pulumi.set(__self__, "email_error", email_error)
        if email_field_label is not None:
            pulumi.set(__self__, "email_field_label", email_field_label)
        if email_label is not None:
            pulumi.set(__self__, "email_label", email_label)
        if email_message is not None:
            pulumi.set(__self__, "email_message", email_message)
        if email_submit is not None:
            pulumi.set(__self__, "email_submit", email_submit)
        if email_title is not None:
            pulumi.set(__self__, "email_title", email_title)
        if field1error is not None:
            pulumi.set(__self__, "field1error", field1error)
        if field1label is not None:
            pulumi.set(__self__, "field1label", field1label)
        if field2error is not None:
            pulumi.set(__self__, "field2error", field2error)
        if field2label is not None:
            pulumi.set(__self__, "field2label", field2label)
        if field3error is not None:
            pulumi.set(__self__, "field3error", field3error)
        if field3label is not None:
            pulumi.set(__self__, "field3label", field3label)
        if field4error is not None:
            pulumi.set(__self__, "field4error", field4error)
        if field4label is not None:
            pulumi.set(__self__, "field4label", field4label)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if name_error is not None:
            pulumi.set(__self__, "name_error", name_error)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if optout_label is not None:
            pulumi.set(__self__, "optout_label", optout_label)
        if page_title is not None:
            pulumi.set(__self__, "page_title", page_title)
        if passphrase_cancel is not None:
            pulumi.set(__self__, "passphrase_cancel", passphrase_cancel)
        if passphrase_error is not None:
            pulumi.set(__self__, "passphrase_error", passphrase_error)
        if passphrase_label is not None:
            pulumi.set(__self__, "passphrase_label", passphrase_label)
        if passphrase_message is not None:
            pulumi.set(__self__, "passphrase_message", passphrase_message)
        if passphrase_submit is not None:
            pulumi.set(__self__, "passphrase_submit", passphrase_submit)
        if passphrase_title is not None:
            pulumi.set(__self__, "passphrase_title", passphrase_title)
        if privacy_policy_accept_label is not None:
            pulumi.set(__self__, "privacy_policy_accept_label", privacy_policy_accept_label)
        if privacy_policy_error is not None:
            pulumi.set(__self__, "privacy_policy_error", privacy_policy_error)
        if privacy_policy_link is not None:
            pulumi.set(__self__, "privacy_policy_link", privacy_policy_link)
        if privacy_policy_text is not None:
            pulumi.set(__self__, "privacy_policy_text", privacy_policy_text)
        if required_field_label is not None:
            pulumi.set(__self__, "required_field_label", required_field_label)
        if sign_in_label is not None:
            pulumi.set(__self__, "sign_in_label", sign_in_label)
        if sms_carrier_default is not None:
            pulumi.set(__self__, "sms_carrier_default", sms_carrier_default)
        if sms_carrier_error is not None:
            pulumi.set(__self__, "sms_carrier_error", sms_carrier_error)
        if sms_carrier_field_label is not None:
            pulumi.set(__self__, "sms_carrier_field_label", sms_carrier_field_label)
        if sms_code_cancel is not None:
            pulumi.set(__self__, "sms_code_cancel", sms_code_cancel)
        if sms_code_error is not None:
            pulumi.set(__self__, "sms_code_error", sms_code_error)
        if sms_code_field_label is not None:
            pulumi.set(__self__, "sms_code_field_label", sms_code_field_label)
        if sms_code_message is not None:
            pulumi.set(__self__, "sms_code_message", sms_code_message)
        if sms_code_submit is not None:
            pulumi.set(__self__, "sms_code_submit", sms_code_submit)
        if sms_code_title is not None:
            pulumi.set(__self__, "sms_code_title", sms_code_title)
        if sms_country_field_label is not None:
            pulumi.set(__self__, "sms_country_field_label", sms_country_field_label)
        if sms_country_format is not None:
            pulumi.set(__self__, "sms_country_format", sms_country_format)
        if sms_have_access_code is not None:
            pulumi.set(__self__, "sms_have_access_code", sms_have_access_code)
        if sms_message_format is not None:
            pulumi.set(__self__, "sms_message_format", sms_message_format)
        if sms_number_cancel is not None:
            pulumi.set(__self__, "sms_number_cancel", sms_number_cancel)
        if sms_number_error is not None:
            pulumi.set(__self__, "sms_number_error", sms_number_error)
        if sms_number_field_label is not None:
            pulumi.set(__self__, "sms_number_field_label", sms_number_field_label)
        if sms_number_format is not None:
            pulumi.set(__self__, "sms_number_format", sms_number_format)
        if sms_number_message is not None:
            pulumi.set(__self__, "sms_number_message", sms_number_message)
        if sms_number_submit is not None:
            pulumi.set(__self__, "sms_number_submit", sms_number_submit)
        if sms_number_title is not None:
            pulumi.set(__self__, "sms_number_title", sms_number_title)
        if sms_username_format is not None:
            pulumi.set(__self__, "sms_username_format", sms_username_format)
        if sponsor_back_link is not None:
            pulumi.set(__self__, "sponsor_back_link", sponsor_back_link)
        if sponsor_cancel is not None:
            pulumi.set(__self__, "sponsor_cancel", sponsor_cancel)
        if sponsor_email is not None:
            pulumi.set(__self__, "sponsor_email", sponsor_email)
        if sponsor_email_error is not None:
            pulumi.set(__self__, "sponsor_email_error", sponsor_email_error)
        if sponsor_info_approved is not None:
            pulumi.set(__self__, "sponsor_info_approved", sponsor_info_approved)
        if sponsor_info_denied is not None:
            pulumi.set(__self__, "sponsor_info_denied", sponsor_info_denied)
        if sponsor_info_pending is not None:
            pulumi.set(__self__, "sponsor_info_pending", sponsor_info_pending)
        if sponsor_name is not None:
            pulumi.set(__self__, "sponsor_name", sponsor_name)
        if sponsor_name_error is not None:
            pulumi.set(__self__, "sponsor_name_error", sponsor_name_error)
        if sponsor_note_pending is not None:
            pulumi.set(__self__, "sponsor_note_pending", sponsor_note_pending)
        if sponsor_request_access is not None:
            pulumi.set(__self__, "sponsor_request_access", sponsor_request_access)
        if sponsor_status_approved is not None:
            pulumi.set(__self__, "sponsor_status_approved", sponsor_status_approved)
        if sponsor_status_denied is not None:
            pulumi.set(__self__, "sponsor_status_denied", sponsor_status_denied)
        if sponsor_status_pending is not None:
            pulumi.set(__self__, "sponsor_status_pending", sponsor_status_pending)
        if sponsor_submit is not None:
            pulumi.set(__self__, "sponsor_submit", sponsor_submit)
        if sponsors_error is not None:
            pulumi.set(__self__, "sponsors_error", sponsors_error)
        if sponsors_field_label is not None:
            pulumi.set(__self__, "sponsors_field_label", sponsors_field_label)
        if tos_accept_label is not None:
            pulumi.set(__self__, "tos_accept_label", tos_accept_label)
        if tos_error is not None:
            pulumi.set(__self__, "tos_error", tos_error)
        if tos_link is not None:
            pulumi.set(__self__, "tos_link", tos_link)
        if tos_text is not None:
            pulumi.set(__self__, "tos_text", tos_text)

    @property
    @pulumi.getter(name="authButtonAmazon")
    def auth_button_amazon(self) -> Optional[str]:
        """
        label for Amazon auth button
        """
        return pulumi.get(self, "auth_button_amazon")

    @property
    @pulumi.getter(name="authButtonAzure")
    def auth_button_azure(self) -> Optional[str]:
        """
        label for Azure auth button
        """
        return pulumi.get(self, "auth_button_azure")

    @property
    @pulumi.getter(name="authButtonEmail")
    def auth_button_email(self) -> Optional[str]:
        """
        label for Email auth button
        """
        return pulumi.get(self, "auth_button_email")

    @property
    @pulumi.getter(name="authButtonFacebook")
    def auth_button_facebook(self) -> Optional[str]:
        """
        label for Facebook auth button
        """
        return pulumi.get(self, "auth_button_facebook")

    @property
    @pulumi.getter(name="authButtonGoogle")
    def auth_button_google(self) -> Optional[str]:
        """
        label for Google auth button
        """
        return pulumi.get(self, "auth_button_google")

    @property
    @pulumi.getter(name="authButtonMicrosoft")
    def auth_button_microsoft(self) -> Optional[str]:
        """
        label for Microsoft auth button
        """
        return pulumi.get(self, "auth_button_microsoft")

    @property
    @pulumi.getter(name="authButtonPassphrase")
    def auth_button_passphrase(self) -> Optional[str]:
        """
        label for passphrase auth button
        """
        return pulumi.get(self, "auth_button_passphrase")

    @property
    @pulumi.getter(name="authButtonSms")
    def auth_button_sms(self) -> Optional[str]:
        """
        label for SMS auth button
        """
        return pulumi.get(self, "auth_button_sms")

    @property
    @pulumi.getter(name="authButtonSponsor")
    def auth_button_sponsor(self) -> Optional[str]:
        """
        label for Sponsor auth button
        """
        return pulumi.get(self, "auth_button_sponsor")

    @property
    @pulumi.getter(name="authLabel")
    def auth_label(self) -> Optional[str]:
        return pulumi.get(self, "auth_label")

    @property
    @pulumi.getter(name="backLink")
    def back_link(self) -> Optional[str]:
        """
        label of the link to go back to /logon
        """
        return pulumi.get(self, "back_link")

    @property
    @pulumi.getter(name="companyError")
    def company_error(self) -> Optional[str]:
        """
        error message when company not provided
        """
        return pulumi.get(self, "company_error")

    @property
    @pulumi.getter(name="companyLabel")
    def company_label(self) -> Optional[str]:
        """
        label of company field
        """
        return pulumi.get(self, "company_label")

    @property
    @pulumi.getter(name="emailAccessDomainError")
    def email_access_domain_error(self) -> Optional[str]:
        """
        error message when a user has valid social login but doesn't match specified email domains.
        """
        return pulumi.get(self, "email_access_domain_error")

    @property
    @pulumi.getter(name="emailCancel")
    def email_cancel(self) -> Optional[str]:
        """
        Label for cancel confirmation code submission using email auth
        """
        return pulumi.get(self, "email_cancel")

    @property
    @pulumi.getter(name="emailCodeCancel")
    def email_code_cancel(self) -> Optional[str]:
        return pulumi.get(self, "email_code_cancel")

    @property
    @pulumi.getter(name="emailCodeError")
    def email_code_error(self) -> Optional[str]:
        return pulumi.get(self, "email_code_error")

    @property
    @pulumi.getter(name="emailCodeFieldLabel")
    def email_code_field_label(self) -> Optional[str]:
        return pulumi.get(self, "email_code_field_label")

    @property
    @pulumi.getter(name="emailCodeMessage")
    def email_code_message(self) -> Optional[str]:
        return pulumi.get(self, "email_code_message")

    @property
    @pulumi.getter(name="emailCodeSubmit")
    def email_code_submit(self) -> Optional[str]:
        return pulumi.get(self, "email_code_submit")

    @property
    @pulumi.getter(name="emailCodeTitle")
    def email_code_title(self) -> Optional[str]:
        return pulumi.get(self, "email_code_title")

    @property
    @pulumi.getter(name="emailError")
    def email_error(self) -> Optional[str]:
        """
        error message when email not provided
        """
        return pulumi.get(self, "email_error")

    @property
    @pulumi.getter(name="emailFieldLabel")
    def email_field_label(self) -> Optional[str]:
        return pulumi.get(self, "email_field_label")

    @property
    @pulumi.getter(name="emailLabel")
    def email_label(self) -> Optional[str]:
        """
        label of email field
        """
        return pulumi.get(self, "email_label")

    @property
    @pulumi.getter(name="emailMessage")
    def email_message(self) -> Optional[str]:
        return pulumi.get(self, "email_message")

    @property
    @pulumi.getter(name="emailSubmit")
    def email_submit(self) -> Optional[str]:
        """
        Label for confirmation code submit button using email auth
        """
        return pulumi.get(self, "email_submit")

    @property
    @pulumi.getter(name="emailTitle")
    def email_title(self) -> Optional[str]:
        """
        Title for the Email registration
        """
        return pulumi.get(self, "email_title")

    @property
    @pulumi.getter
    def field1error(self) -> Optional[str]:
        """
        error message when field1 not provided
        """
        return pulumi.get(self, "field1error")

    @property
    @pulumi.getter
    def field1label(self) -> Optional[str]:
        """
        label of field1
        """
        return pulumi.get(self, "field1label")

    @property
    @pulumi.getter
    def field2error(self) -> Optional[str]:
        """
        error message when field2 not provided
        """
        return pulumi.get(self, "field2error")

    @property
    @pulumi.getter
    def field2label(self) -> Optional[str]:
        """
        label of field2
        """
        return pulumi.get(self, "field2label")

    @property
    @pulumi.getter
    def field3error(self) -> Optional[str]:
        """
        error message when field3 not provided
        """
        return pulumi.get(self, "field3error")

    @property
    @pulumi.getter
    def field3label(self) -> Optional[str]:
        """
        label of field3
        """
        return pulumi.get(self, "field3label")

    @property
    @pulumi.getter
    def field4error(self) -> Optional[str]:
        """
        error message when field4 not provided
        """
        return pulumi.get(self, "field4error")

    @property
    @pulumi.getter
    def field4label(self) -> Optional[str]:
        """
        label of field4
        """
        return pulumi.get(self, "field4label")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="nameError")
    def name_error(self) -> Optional[str]:
        """
        error message when name not provided
        """
        return pulumi.get(self, "name_error")

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[str]:
        """
        label of name field
        """
        return pulumi.get(self, "name_label")

    @property
    @pulumi.getter(name="optoutLabel")
    def optout_label(self) -> Optional[str]:
        """
        label for Do Not Store My Personal Information
        """
        return pulumi.get(self, "optout_label")

    @property
    @pulumi.getter(name="pageTitle")
    def page_title(self) -> Optional[str]:
        return pulumi.get(self, "page_title")

    @property
    @pulumi.getter(name="passphraseCancel")
    def passphrase_cancel(self) -> Optional[str]:
        """
        Label for the Passphrase cancel button
        """
        return pulumi.get(self, "passphrase_cancel")

    @property
    @pulumi.getter(name="passphraseError")
    def passphrase_error(self) -> Optional[str]:
        """
        error message when invalid passphrase is provided
        """
        return pulumi.get(self, "passphrase_error")

    @property
    @pulumi.getter(name="passphraseLabel")
    def passphrase_label(self) -> Optional[str]:
        """
        Passphrase
        """
        return pulumi.get(self, "passphrase_label")

    @property
    @pulumi.getter(name="passphraseMessage")
    def passphrase_message(self) -> Optional[str]:
        return pulumi.get(self, "passphrase_message")

    @property
    @pulumi.getter(name="passphraseSubmit")
    def passphrase_submit(self) -> Optional[str]:
        """
        Label for the Passphrase submit button
        """
        return pulumi.get(self, "passphrase_submit")

    @property
    @pulumi.getter(name="passphraseTitle")
    def passphrase_title(self) -> Optional[str]:
        """
        Title for passphrase details page
        """
        return pulumi.get(self, "passphrase_title")

    @property
    @pulumi.getter(name="privacyPolicyAcceptLabel")
    def privacy_policy_accept_label(self) -> Optional[str]:
        """
        prefix of the label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_accept_label")

    @property
    @pulumi.getter(name="privacyPolicyError")
    def privacy_policy_error(self) -> Optional[str]:
        """
        error message when Privacy Policy not accepted
        """
        return pulumi.get(self, "privacy_policy_error")

    @property
    @pulumi.getter(name="privacyPolicyLink")
    def privacy_policy_link(self) -> Optional[str]:
        """
        label of the link to go to Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_link")

    @property
    @pulumi.getter(name="privacyPolicyText")
    def privacy_policy_text(self) -> Optional[str]:
        """
        text of the Privacy Policy
        """
        return pulumi.get(self, "privacy_policy_text")

    @property
    @pulumi.getter(name="requiredFieldLabel")
    def required_field_label(self) -> Optional[str]:
        """
        label to denote required field
        """
        return pulumi.get(self, "required_field_label")

    @property
    @pulumi.getter(name="signInLabel")
    def sign_in_label(self) -> Optional[str]:
        """
        label of the button to /signin
        """
        return pulumi.get(self, "sign_in_label")

    @property
    @pulumi.getter(name="smsCarrierDefault")
    def sms_carrier_default(self) -> Optional[str]:
        return pulumi.get(self, "sms_carrier_default")

    @property
    @pulumi.getter(name="smsCarrierError")
    def sms_carrier_error(self) -> Optional[str]:
        return pulumi.get(self, "sms_carrier_error")

    @property
    @pulumi.getter(name="smsCarrierFieldLabel")
    def sms_carrier_field_label(self) -> Optional[str]:
        """
        label for mobile carrier drop-down list
        """
        return pulumi.get(self, "sms_carrier_field_label")

    @property
    @pulumi.getter(name="smsCodeCancel")
    def sms_code_cancel(self) -> Optional[str]:
        """
        Label for cancel confirmation code submission
        """
        return pulumi.get(self, "sms_code_cancel")

    @property
    @pulumi.getter(name="smsCodeError")
    def sms_code_error(self) -> Optional[str]:
        """
        error message when confirmation code is invalid
        """
        return pulumi.get(self, "sms_code_error")

    @property
    @pulumi.getter(name="smsCodeFieldLabel")
    def sms_code_field_label(self) -> Optional[str]:
        return pulumi.get(self, "sms_code_field_label")

    @property
    @pulumi.getter(name="smsCodeMessage")
    def sms_code_message(self) -> Optional[str]:
        return pulumi.get(self, "sms_code_message")

    @property
    @pulumi.getter(name="smsCodeSubmit")
    def sms_code_submit(self) -> Optional[str]:
        """
        Label for confirmation code submit button
        """
        return pulumi.get(self, "sms_code_submit")

    @property
    @pulumi.getter(name="smsCodeTitle")
    def sms_code_title(self) -> Optional[str]:
        return pulumi.get(self, "sms_code_title")

    @property
    @pulumi.getter(name="smsCountryFieldLabel")
    def sms_country_field_label(self) -> Optional[str]:
        return pulumi.get(self, "sms_country_field_label")

    @property
    @pulumi.getter(name="smsCountryFormat")
    def sms_country_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_country_format")

    @property
    @pulumi.getter(name="smsHaveAccessCode")
    def sms_have_access_code(self) -> Optional[str]:
        """
        Label for checkbox to specify that the user has access code
        """
        return pulumi.get(self, "sms_have_access_code")

    @property
    @pulumi.getter(name="smsMessageFormat")
    def sms_message_format(self) -> Optional[str]:
        """
        format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
        """
        return pulumi.get(self, "sms_message_format")

    @property
    @pulumi.getter(name="smsNumberCancel")
    def sms_number_cancel(self) -> Optional[str]:
        """
        label for canceling mobile details for SMS auth
        """
        return pulumi.get(self, "sms_number_cancel")

    @property
    @pulumi.getter(name="smsNumberError")
    def sms_number_error(self) -> Optional[str]:
        return pulumi.get(self, "sms_number_error")

    @property
    @pulumi.getter(name="smsNumberFieldLabel")
    def sms_number_field_label(self) -> Optional[str]:
        """
        label for field to provide mobile number
        """
        return pulumi.get(self, "sms_number_field_label")

    @property
    @pulumi.getter(name="smsNumberFormat")
    def sms_number_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_number_format")

    @property
    @pulumi.getter(name="smsNumberMessage")
    def sms_number_message(self) -> Optional[str]:
        return pulumi.get(self, "sms_number_message")

    @property
    @pulumi.getter(name="smsNumberSubmit")
    def sms_number_submit(self) -> Optional[str]:
        """
        label for submit button for code generation
        """
        return pulumi.get(self, "sms_number_submit")

    @property
    @pulumi.getter(name="smsNumberTitle")
    def sms_number_title(self) -> Optional[str]:
        """
        Title for phone number details
        """
        return pulumi.get(self, "sms_number_title")

    @property
    @pulumi.getter(name="smsUsernameFormat")
    def sms_username_format(self) -> Optional[str]:
        return pulumi.get(self, "sms_username_format")

    @property
    @pulumi.getter(name="sponsorBackLink")
    def sponsor_back_link(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_back_link")

    @property
    @pulumi.getter(name="sponsorCancel")
    def sponsor_cancel(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_cancel")

    @property
    @pulumi.getter(name="sponsorEmail")
    def sponsor_email(self) -> Optional[str]:
        """
        label for Sponsor Email
        """
        return pulumi.get(self, "sponsor_email")

    @property
    @pulumi.getter(name="sponsorEmailError")
    def sponsor_email_error(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_email_error")

    @property
    @pulumi.getter(name="sponsorInfoApproved")
    def sponsor_info_approved(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_info_approved")

    @property
    @pulumi.getter(name="sponsorInfoDenied")
    def sponsor_info_denied(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_info_denied")

    @property
    @pulumi.getter(name="sponsorInfoPending")
    def sponsor_info_pending(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_info_pending")

    @property
    @pulumi.getter(name="sponsorName")
    def sponsor_name(self) -> Optional[str]:
        """
        label for Sponsor Name
        """
        return pulumi.get(self, "sponsor_name")

    @property
    @pulumi.getter(name="sponsorNameError")
    def sponsor_name_error(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_name_error")

    @property
    @pulumi.getter(name="sponsorNotePending")
    def sponsor_note_pending(self) -> Optional[str]:
        return pulumi.get(self, "sponsor_note_pending")

    @property
    @pulumi.getter(name="sponsorRequestAccess")
    def sponsor_request_access(self) -> Optional[str]:
        """
        submit button label request Wifi Access and notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_request_access")

    @property
    @pulumi.getter(name="sponsorStatusApproved")
    def sponsor_status_approved(self) -> Optional[str]:
        """
        text to display if sponsor approves request
        """
        return pulumi.get(self, "sponsor_status_approved")

    @property
    @pulumi.getter(name="sponsorStatusDenied")
    def sponsor_status_denied(self) -> Optional[str]:
        """
        text to display when sponsor denies request
        """
        return pulumi.get(self, "sponsor_status_denied")

    @property
    @pulumi.getter(name="sponsorStatusPending")
    def sponsor_status_pending(self) -> Optional[str]:
        """
        text to display if request is still pending
        """
        return pulumi.get(self, "sponsor_status_pending")

    @property
    @pulumi.getter(name="sponsorSubmit")
    def sponsor_submit(self) -> Optional[str]:
        """
        submit button label to notify sponsor about guest request
        """
        return pulumi.get(self, "sponsor_submit")

    @property
    @pulumi.getter(name="sponsorsError")
    def sponsors_error(self) -> Optional[str]:
        return pulumi.get(self, "sponsors_error")

    @property
    @pulumi.getter(name="sponsorsFieldLabel")
    def sponsors_field_label(self) -> Optional[str]:
        return pulumi.get(self, "sponsors_field_label")

    @property
    @pulumi.getter(name="tosAcceptLabel")
    def tos_accept_label(self) -> Optional[str]:
        """
        prefix of the label of the link to go to tos
        """
        return pulumi.get(self, "tos_accept_label")

    @property
    @pulumi.getter(name="tosError")
    def tos_error(self) -> Optional[str]:
        """
        error message when tos not accepted
        """
        return pulumi.get(self, "tos_error")

    @property
    @pulumi.getter(name="tosLink")
    def tos_link(self) -> Optional[str]:
        """
        label of the link to go to tos
        """
        return pulumi.get(self, "tos_link")

    @property
    @pulumi.getter(name="tosText")
    def tos_text(self) -> Optional[str]:
        """
        text of the Terms of Service
        """
        return pulumi.get(self, "tos_text")


@pulumi.output_type
class WlanQos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanQos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanQos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanQos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_: Optional[str] = None,
                 overwrite: Optional[bool] = None):
        """
        :param str class_: enum: `background`, `best_effort`, `video`, `voice`
        :param bool overwrite: whether to overwrite QoS
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        enum: `background`, `best_effort`, `video`, `voice`
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def overwrite(self) -> Optional[bool]:
        """
        whether to overwrite QoS
        """
        return pulumi.get(self, "overwrite")


@pulumi.output_type
class WlanRadsec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "mxclusterIds":
            suggest = "mxcluster_ids"
        elif key == "proxyHosts":
            suggest = "proxy_hosts"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "useMxedge":
            suggest = "use_mxedge"
        elif key == "useSiteMxedge":
            suggest = "use_site_mxedge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WlanRadsec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WlanRadsec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WlanRadsec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coa_enabled: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 idle_timeout: Optional[int] = None,
                 mxcluster_ids: Optional[Sequence[str]] = None,
                 proxy_hosts: Optional[Sequence[str]] = None,
                 server_name: Optional[str] = None,
                 servers: Optional[Sequence['outputs.WlanRadsecServer']] = None,
                 use_mxedge: Optional[bool] = None,
                 use_site_mxedge: Optional[bool] = None):
        """
        :param Sequence[str] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
               Org mxedge(s) identified by mxcluster_ids
        :param Sequence[str] proxy_hosts: default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
               when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
        :param str server_name: name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param Sequence['WlanRadsecServerArgs'] servers: List of Radsec Servers. Only if not Mist Edge.
        :param bool use_mxedge: use mxedge(s) as radsecproxy
        :param bool use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if mxcluster_ids is not None:
            pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        if proxy_hosts is not None:
            pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if use_mxedge is not None:
            pulumi.set(__self__, "use_mxedge", use_mxedge)
        if use_site_mxedge is not None:
            pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "coa_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[int]:
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Optional[Sequence[str]]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
        Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Optional[Sequence[str]]:
        """
        default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
        when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
        """
        return pulumi.get(self, "proxy_hosts")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.WlanRadsecServer']]:
        """
        List of Radsec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> Optional[bool]:
        """
        use mxedge(s) as radsecproxy
        """
        return pulumi.get(self, "use_mxedge")

    @property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> Optional[bool]:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")


@pulumi.output_type
class WlanRadsecServer(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WlanSchedule(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 hours: Optional['outputs.WlanScheduleHours'] = None):
        """
        :param 'WlanScheduleHoursArgs' hours: hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
               
               **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def hours(self) -> Optional['outputs.WlanScheduleHours']:
        """
        hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 

        **Note**: If the dow is not defined then it\\u2019\\ s treated as 00:00-23:59.
        """
        return pulumi.get(self, "hours")


@pulumi.output_type
class WlanScheduleHours(dict):
    def __init__(__self__, *,
                 fri: Optional[str] = None,
                 mon: Optional[str] = None,
                 sat: Optional[str] = None,
                 sun: Optional[str] = None,
                 thu: Optional[str] = None,
                 tue: Optional[str] = None,
                 wed: Optional[str] = None):
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[str]:
        return pulumi.get(self, "fri")

    @property
    @pulumi.getter
    def mon(self) -> Optional[str]:
        return pulumi.get(self, "mon")

    @property
    @pulumi.getter
    def sat(self) -> Optional[str]:
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def sun(self) -> Optional[str]:
        return pulumi.get(self, "sun")

    @property
    @pulumi.getter
    def thu(self) -> Optional[str]:
        return pulumi.get(self, "thu")

    @property
    @pulumi.getter
    def tue(self) -> Optional[str]:
        return pulumi.get(self, "tue")

    @property
    @pulumi.getter
    def wed(self) -> Optional[str]:
        return pulumi.get(self, "wed")


@pulumi.output_type
class WxtagSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WxtagSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WxtagSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WxtagSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnets: Sequence[str],
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param Sequence[str] subnets: matched destination subnets and/or IP Addresses
        :param str port_range: matched destination port, "0" means any
        :param str protocol: tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        pulumi.set(__self__, "subnets", subnets)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        """
        matched destination subnets and/or IP Addresses
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        matched destination port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class BaseLatlng(dict):
    def __init__(__self__, *,
                 lat: float,
                 lng: float):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @property
    @pulumi.getter
    def lat(self) -> float:
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lng(self) -> float:
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetPsksSitePskResult(dict):
    def __init__(__self__, *,
                 admin_sso_id: str,
                 created_time: float,
                 email: str,
                 expire_time: int,
                 expiry_notification_time: int,
                 id: str,
                 mac: str,
                 modified_time: float,
                 name: str,
                 note: str,
                 notify_expiry: bool,
                 notify_on_create_or_edit: bool,
                 old_passphrase: str,
                 org_id: str,
                 passphrase: str,
                 role: str,
                 site_id: str,
                 ssid: str,
                 usage: str,
                 vlan_id: str):
        """
        :param str admin_sso_id: sso id for psk created from psk portal
        :param str email: email to send psk expiring notifications to
        :param int expire_time: Expire time for this PSK key (epoch time in seconds). Default `null` (as no expiration)
        :param int expiry_notification_time: Number of days before psk is expired. Used as to when to start sending reminder notification when the psk is about to expire
        :param str mac: if `usage`==`single`, the mac that this PSK ties to, empty if `auto-binding`
        :param bool notify_expiry: If set to true, reminder notification will be sent when psk is about to expire
        :param bool notify_on_create_or_edit: If set to true, notification will be sent when psk is created or edited
        :param str old_passphrase: previous passphrase of the PSK if it has been rotated
        :param str passphrase: passphrase of the PSK (8-63 character or 64 in hex)
        :param str ssid: SSID this PSK should be applicable to
        :param str usage: enum: `macs`, `multi`, `single`
        """
        pulumi.set(__self__, "admin_sso_id", admin_sso_id)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "expiry_notification_time", expiry_notification_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "note", note)
        pulumi.set(__self__, "notify_expiry", notify_expiry)
        pulumi.set(__self__, "notify_on_create_or_edit", notify_on_create_or_edit)
        pulumi.set(__self__, "old_passphrase", old_passphrase)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "ssid", ssid)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="adminSsoId")
    def admin_sso_id(self) -> str:
        """
        sso id for psk created from psk portal
        """
        return pulumi.get(self, "admin_sso_id")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> float:
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        email to send psk expiring notifications to
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> int:
        """
        Expire time for this PSK key (epoch time in seconds). Default `null` (as no expiration)
        """
        return pulumi.get(self, "expire_time")

    @property
    @pulumi.getter(name="expiryNotificationTime")
    def expiry_notification_time(self) -> int:
        """
        Number of days before psk is expired. Used as to when to start sending reminder notification when the psk is about to expire
        """
        return pulumi.get(self, "expiry_notification_time")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        if `usage`==`single`, the mac that this PSK ties to, empty if `auto-binding`
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> float:
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def note(self) -> str:
        return pulumi.get(self, "note")

    @property
    @pulumi.getter(name="notifyExpiry")
    def notify_expiry(self) -> bool:
        """
        If set to true, reminder notification will be sent when psk is about to expire
        """
        return pulumi.get(self, "notify_expiry")

    @property
    @pulumi.getter(name="notifyOnCreateOrEdit")
    def notify_on_create_or_edit(self) -> bool:
        """
        If set to true, notification will be sent when psk is created or edited
        """
        return pulumi.get(self, "notify_on_create_or_edit")

    @property
    @pulumi.getter(name="oldPassphrase")
    def old_passphrase(self) -> str:
        """
        previous passphrase of the PSK if it has been rotated
        """
        return pulumi.get(self, "old_passphrase")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def passphrase(self) -> str:
        """
        passphrase of the PSK (8-63 character or 64 in hex)
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter
    def role(self) -> str:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter
    def ssid(self) -> str:
        """
        SSID this PSK should be applicable to
        """
        return pulumi.get(self, "ssid")

    @property
    @pulumi.getter
    def usage(self) -> str:
        """
        enum: `macs`, `multi`, `single`
        """
        return pulumi.get(self, "usage")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetWebhooksSiteWebhookResult(dict):
    def __init__(__self__, *,
                 created_time: float,
                 enabled: bool,
                 headers: Mapping[str, str],
                 id: str,
                 modified_time: float,
                 name: str,
                 oauth2_client_id: str,
                 oauth2_client_secret: str,
                 oauth2_grant_type: str,
                 oauth2_password: str,
                 oauth2_scopes: Sequence[str],
                 oauth2_token_url: str,
                 oauth2_username: str,
                 org_id: str,
                 secret: str,
                 site_id: str,
                 splunk_token: str,
                 topics: Sequence[str],
                 type: str,
                 url: str,
                 verify_cert: bool):
        """
        :param bool enabled: whether webhook is enabled
        :param Mapping[str, str] headers: if `type`=`http-post`, additional custom HTTP headers to add
               the headers name and value must be string, total bytes of headers name and value must be less than 1000
        :param str name: name of the webhook
        :param str oauth2_client_id: required when `oauth2_grant_type`==`client_credentials`
        :param str oauth2_client_secret: required when `oauth2_grant_type`==`client_credentials`
        :param str oauth2_grant_type: required when `type`==`oauth2`. enum: `client_credentials`, `password`
        :param str oauth2_password: required when `oauth2_grant_type`==`password`
        :param Sequence[str] oauth2_scopes: required when `type`==`oauth2`, if provided, will be used in the token request
        :param str oauth2_token_url: required when `type`==`oauth2`
        :param str oauth2_username: required when `oauth2_grant_type`==`password`
        :param str secret: only if `type`=`http-post`
        :param str splunk_token: required if `type`=`splunk`
               If splunk_token is not defined for a type Splunk webhook, it will not send, regardless if the webhook receiver is configured to accept it.'
        :param Sequence[str] topics: N.B. For org webhooks, only device_events/alarms/audits/client-join/client-sessions/nac-sessions/nac_events topics are supported.
        :param str type: enum: `aws-sns`, `google-pubsub`, `http-post`, `oauth2`, `splunk`
        :param bool verify_cert: when url uses HTTPS, whether to verify the certificate
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oauth2_client_id", oauth2_client_id)
        pulumi.set(__self__, "oauth2_client_secret", oauth2_client_secret)
        pulumi.set(__self__, "oauth2_grant_type", oauth2_grant_type)
        pulumi.set(__self__, "oauth2_password", oauth2_password)
        pulumi.set(__self__, "oauth2_scopes", oauth2_scopes)
        pulumi.set(__self__, "oauth2_token_url", oauth2_token_url)
        pulumi.set(__self__, "oauth2_username", oauth2_username)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "splunk_token", splunk_token)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "verify_cert", verify_cert)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> float:
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        whether webhook is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        """
        if `type`=`http-post`, additional custom HTTP headers to add
        the headers name and value must be string, total bytes of headers name and value must be less than 1000
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> float:
        return pulumi.get(self, "modified_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of the webhook
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="oauth2ClientId")
    def oauth2_client_id(self) -> str:
        """
        required when `oauth2_grant_type`==`client_credentials`
        """
        return pulumi.get(self, "oauth2_client_id")

    @property
    @pulumi.getter(name="oauth2ClientSecret")
    def oauth2_client_secret(self) -> str:
        """
        required when `oauth2_grant_type`==`client_credentials`
        """
        return pulumi.get(self, "oauth2_client_secret")

    @property
    @pulumi.getter(name="oauth2GrantType")
    def oauth2_grant_type(self) -> str:
        """
        required when `type`==`oauth2`. enum: `client_credentials`, `password`
        """
        return pulumi.get(self, "oauth2_grant_type")

    @property
    @pulumi.getter(name="oauth2Password")
    def oauth2_password(self) -> str:
        """
        required when `oauth2_grant_type`==`password`
        """
        return pulumi.get(self, "oauth2_password")

    @property
    @pulumi.getter(name="oauth2Scopes")
    def oauth2_scopes(self) -> Sequence[str]:
        """
        required when `type`==`oauth2`, if provided, will be used in the token request
        """
        return pulumi.get(self, "oauth2_scopes")

    @property
    @pulumi.getter(name="oauth2TokenUrl")
    def oauth2_token_url(self) -> str:
        """
        required when `type`==`oauth2`
        """
        return pulumi.get(self, "oauth2_token_url")

    @property
    @pulumi.getter(name="oauth2Username")
    def oauth2_username(self) -> str:
        """
        required when `oauth2_grant_type`==`password`
        """
        return pulumi.get(self, "oauth2_username")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        only if `type`=`http-post`
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="splunkToken")
    def splunk_token(self) -> str:
        """
        required if `type`=`splunk`
        If splunk_token is not defined for a type Splunk webhook, it will not send, regardless if the webhook receiver is configured to accept it.'
        """
        return pulumi.get(self, "splunk_token")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[str]:
        """
        N.B. For org webhooks, only device_events/alarms/audits/client-join/client-sessions/nac-sessions/nac_events topics are supported.
        """
        return pulumi.get(self, "topics")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        enum: `aws-sns`, `google-pubsub`, `http-post`, `oauth2`, `splunk`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> bool:
        """
        when url uses HTTPS, whether to verify the certificate
        """
        return pulumi.get(self, "verify_cert")


