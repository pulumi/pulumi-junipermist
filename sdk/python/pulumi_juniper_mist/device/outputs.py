# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ApAeroscout',
    'ApAirista',
    'ApBleConfig',
    'ApCentrak',
    'ApClientBridge',
    'ApClientBridgeAuth',
    'ApEslConfig',
    'ApIpConfig',
    'ApLacpConfig',
    'ApLed',
    'ApMesh',
    'ApPortConfig',
    'ApPortConfigDynamicVlan',
    'ApPortConfigMistNac',
    'ApPortConfigRadiusConfig',
    'ApPortConfigRadiusConfigAcctServer',
    'ApPortConfigRadiusConfigAuthServer',
    'ApPortConfigRadsec',
    'ApPortConfigRadsecServer',
    'ApPwrConfig',
    'ApRadioConfig',
    'ApRadioConfigBand24',
    'ApRadioConfigBand5',
    'ApRadioConfigBand5On24Radio',
    'ApRadioConfigBand6',
    'ApUplinkPortConfig',
    'ApUsbConfig',
    'GatewayBgpConfig',
    'GatewayBgpConfigNeighbors',
    'GatewayClusterNode',
    'GatewayDhcpdConfig',
    'GatewayDhcpdConfigConfig',
    'GatewayDhcpdConfigConfigFixedBindings',
    'GatewayDhcpdConfigConfigOptions',
    'GatewayDhcpdConfigConfigVendorEncapsulated',
    'GatewayExtraRoutes6',
    'GatewayExtraRoutes',
    'GatewayIdpProfiles',
    'GatewayIdpProfilesOverwrite',
    'GatewayIdpProfilesOverwriteMatching',
    'GatewayIpConfigs',
    'GatewayNetwork',
    'GatewayNetworkInternalAccess',
    'GatewayNetworkInternetAccess',
    'GatewayNetworkInternetAccessDestinationNat',
    'GatewayNetworkInternetAccessStaticNat',
    'GatewayNetworkMulticast',
    'GatewayNetworkMulticastGroups',
    'GatewayNetworkTenants',
    'GatewayNetworkVpnAccess',
    'GatewayNetworkVpnAccessDestinationNat',
    'GatewayNetworkVpnAccessSourceNat',
    'GatewayNetworkVpnAccessStaticNat',
    'GatewayOobIpConfig',
    'GatewayOobIpConfigNode1',
    'GatewayPathPreferences',
    'GatewayPathPreferencesPath',
    'GatewayPortConfig',
    'GatewayPortConfigIpConfig',
    'GatewayPortConfigTrafficShaping',
    'GatewayPortConfigVpnPaths',
    'GatewayPortConfigVpnPathsTrafficShaping',
    'GatewayPortConfigWanExtraRoutes6',
    'GatewayPortConfigWanExtraRoutes',
    'GatewayPortConfigWanProbeOverride',
    'GatewayPortConfigWanSourceNat',
    'GatewayPortMirroring',
    'GatewayPortMirroringPortMirror',
    'GatewayRoutingPolicies',
    'GatewayRoutingPoliciesTerm',
    'GatewayRoutingPoliciesTermActions',
    'GatewayRoutingPoliciesTermMatching',
    'GatewayRoutingPoliciesTermMatchingRouteExists',
    'GatewayRoutingPoliciesTermMatchingVpnPathSla',
    'GatewayServicePolicy',
    'GatewayServicePolicyAntivirus',
    'GatewayServicePolicyAppqoe',
    'GatewayServicePolicyEwf',
    'GatewayServicePolicyIdp',
    'GatewayServicePolicySslProxy',
    'GatewayTunnelConfigs',
    'GatewayTunnelConfigsAutoProvision',
    'GatewayTunnelConfigsAutoProvisionLatlng',
    'GatewayTunnelConfigsAutoProvisionPrimary',
    'GatewayTunnelConfigsAutoProvisionSecondary',
    'GatewayTunnelConfigsIkeProposal',
    'GatewayTunnelConfigsIpsecProposal',
    'GatewayTunnelConfigsPrimary',
    'GatewayTunnelConfigsProbe',
    'GatewayTunnelConfigsSecondary',
    'GatewayTunnelProviderOptions',
    'GatewayTunnelProviderOptionsJse',
    'GatewayTunnelProviderOptionsPrisma',
    'GatewayTunnelProviderOptionsZscaler',
    'GatewayTunnelProviderOptionsZscalerSubLocation',
    'GatewayVrfConfig',
    'GatewayVrfInstances',
    'SwitchAclPolicy',
    'SwitchAclPolicyAction',
    'SwitchAclTags',
    'SwitchAclTagsSpec',
    'SwitchDhcpSnooping',
    'SwitchDhcpdConfig',
    'SwitchDhcpdConfigConfig',
    'SwitchDhcpdConfigConfigFixedBindings',
    'SwitchDhcpdConfigConfigOptions',
    'SwitchDhcpdConfigConfigVendorEncapsulated',
    'SwitchExtraRoutes6',
    'SwitchExtraRoutes6NextQualified',
    'SwitchExtraRoutes',
    'SwitchExtraRoutesNextQualified',
    'SwitchIpConfig',
    'SwitchLocalPortConfig',
    'SwitchLocalPortConfigStormControl',
    'SwitchMistNac',
    'SwitchNetworks',
    'SwitchOobIpConfig',
    'SwitchOspfAreas',
    'SwitchOspfAreasNetworks',
    'SwitchOspfConfig',
    'SwitchOspfConfigAreas',
    'SwitchOtherIpConfigs',
    'SwitchPortConfig',
    'SwitchPortConfigOverwrite',
    'SwitchPortMirroring',
    'SwitchPortUsages',
    'SwitchPortUsagesRule',
    'SwitchPortUsagesStormControl',
    'SwitchRadiusConfig',
    'SwitchRadiusConfigAcctServer',
    'SwitchRadiusConfigAuthServer',
    'SwitchRemoteSyslog',
    'SwitchRemoteSyslogArchive',
    'SwitchRemoteSyslogConsole',
    'SwitchRemoteSyslogConsoleContent',
    'SwitchRemoteSyslogFile',
    'SwitchRemoteSyslogFileArchive',
    'SwitchRemoteSyslogFileContent',
    'SwitchRemoteSyslogServer',
    'SwitchRemoteSyslogServerContent',
    'SwitchRemoteSyslogUser',
    'SwitchRemoteSyslogUserContent',
    'SwitchSnmpConfig',
    'SwitchSnmpConfigClientList',
    'SwitchSnmpConfigTrapGroup',
    'SwitchSnmpConfigV2cConfig',
    'SwitchSnmpConfigV3Config',
    'SwitchSnmpConfigV3ConfigNotify',
    'SwitchSnmpConfigV3ConfigNotifyFilter',
    'SwitchSnmpConfigV3ConfigNotifyFilterContent',
    'SwitchSnmpConfigV3ConfigTargetAddress',
    'SwitchSnmpConfigV3ConfigTargetParameter',
    'SwitchSnmpConfigV3ConfigUsm',
    'SwitchSnmpConfigV3ConfigUsmUser',
    'SwitchSnmpConfigV3ConfigVacm',
    'SwitchSnmpConfigV3ConfigVacmAccess',
    'SwitchSnmpConfigV3ConfigVacmAccessPrefixList',
    'SwitchSnmpConfigV3ConfigVacmSecurityToGroup',
    'SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent',
    'SwitchSnmpConfigView',
    'SwitchStpConfig',
    'SwitchSwitchMgmt',
    'SwitchSwitchMgmtLocalAccounts',
    'SwitchSwitchMgmtProtectRe',
    'SwitchSwitchMgmtProtectReCustom',
    'SwitchSwitchMgmtTacacs',
    'SwitchSwitchMgmtTacacsAcctServer',
    'SwitchSwitchMgmtTacacsTacplusServer',
    'SwitchVirtualChassis',
    'SwitchVirtualChassisMember',
    'SwitchVrfConfig',
    'SwitchVrfInstances',
    'SwitchVrfInstancesExtraRoutes6',
    'SwitchVrfInstancesExtraRoutes',
    'SwitchVrrpConfig',
    'SwitchVrrpConfigGroups',
    'BaseLatlng',
    'GetApStatsDeviceApStatResult',
    'GetApStatsDeviceApStatAutoPlacementResult',
    'GetApStatsDeviceApStatAutoPlacementInfoResult',
    'GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurfaceResult',
    'GetApStatsDeviceApStatAutoUpgradeStatResult',
    'GetApStatsDeviceApStatBleStatResult',
    'GetApStatsDeviceApStatEnvStatResult',
    'GetApStatsDeviceApStatEslStatResult',
    'GetApStatsDeviceApStatFwupdateResult',
    'GetApStatsDeviceApStatGpsResult',
    'GetApStatsDeviceApStatIotStatResult',
    'GetApStatsDeviceApStatIpConfigResult',
    'GetApStatsDeviceApStatIpStatResult',
    'GetApStatsDeviceApStatL2tpStatResult',
    'GetApStatsDeviceApStatL2tpStatSessionResult',
    'GetApStatsDeviceApStatLastTroubleResult',
    'GetApStatsDeviceApStatLedResult',
    'GetApStatsDeviceApStatLldpStatResult',
    'GetApStatsDeviceApStatMeshDownlinksResult',
    'GetApStatsDeviceApStatMeshUplinkResult',
    'GetApStatsDeviceApStatPortStatResult',
    'GetApStatsDeviceApStatRadioStatResult',
    'GetApStatsDeviceApStatRadioStatBand24Result',
    'GetApStatsDeviceApStatRadioStatBand5Result',
    'GetApStatsDeviceApStatRadioStatBand6Result',
    'GetApStatsDeviceApStatSwitchRedundancyResult',
    'GetApStatsDeviceApStatUsbStatResult',
    'GetGatewayStatsDeviceGatewayStatResult',
    'GetGatewayStatsDeviceGatewayStatApRedundancyResult',
    'GetGatewayStatsDeviceGatewayStatApRedundancyModulesResult',
    'GetGatewayStatsDeviceGatewayStatArpTableStatsResult',
    'GetGatewayStatsDeviceGatewayStatBgpPeerResult',
    'GetGatewayStatsDeviceGatewayStatClusterConfigResult',
    'GetGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfoResult',
    'GetGatewayStatsDeviceGatewayStatClusterConfigEthernetConnectionResult',
    'GetGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfoResult',
    'GetGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformationResult',
    'GetGatewayStatsDeviceGatewayStatClusterStatResult',
    'GetGatewayStatsDeviceGatewayStatCpu2StatResult',
    'GetGatewayStatsDeviceGatewayStatCpuStatResult',
    'GetGatewayStatsDeviceGatewayStatDhcpd2StatResult',
    'GetGatewayStatsDeviceGatewayStatDhcpdStatResult',
    'GetGatewayStatsDeviceGatewayStatFwupdateResult',
    'GetGatewayStatsDeviceGatewayStatIf2StatResult',
    'GetGatewayStatsDeviceGatewayStatIf2StatServpInfoResult',
    'GetGatewayStatsDeviceGatewayStatIfStatResult',
    'GetGatewayStatsDeviceGatewayStatIfStatServpInfoResult',
    'GetGatewayStatsDeviceGatewayStatIp2StatResult',
    'GetGatewayStatsDeviceGatewayStatIpStatResult',
    'GetGatewayStatsDeviceGatewayStatMemory2StatResult',
    'GetGatewayStatsDeviceGatewayStatMemoryStatResult',
    'GetGatewayStatsDeviceGatewayStatModule2StatResult',
    'GetGatewayStatsDeviceGatewayStatModule2StatFanResult',
    'GetGatewayStatsDeviceGatewayStatModule2StatPoeResult',
    'GetGatewayStatsDeviceGatewayStatModule2StatPsusResult',
    'GetGatewayStatsDeviceGatewayStatModule2StatTemperatureResult',
    'GetGatewayStatsDeviceGatewayStatModule2StatVcLinkResult',
    'GetGatewayStatsDeviceGatewayStatModuleStatResult',
    'GetGatewayStatsDeviceGatewayStatModuleStatFanResult',
    'GetGatewayStatsDeviceGatewayStatModuleStatPoeResult',
    'GetGatewayStatsDeviceGatewayStatModuleStatPsusResult',
    'GetGatewayStatsDeviceGatewayStatModuleStatTemperatureResult',
    'GetGatewayStatsDeviceGatewayStatModuleStatVcLinkResult',
    'GetGatewayStatsDeviceGatewayStatPortResult',
    'GetGatewayStatsDeviceGatewayStatRouteSummaryStatsResult',
    'GetGatewayStatsDeviceGatewayStatService2StatResult',
    'GetGatewayStatsDeviceGatewayStatServiceStatResult',
    'GetGatewayStatsDeviceGatewayStatServiceStatusResult',
    'GetGatewayStatsDeviceGatewayStatSpu2StatResult',
    'GetGatewayStatsDeviceGatewayStatSpuStatResult',
    'GetGatewayStatsDeviceGatewayStatTunnelResult',
    'GetGatewayStatsDeviceGatewayStatVpnPeerResult',
    'GetSwitchStatsDeviceSwitchStatResult',
    'GetSwitchStatsDeviceSwitchStatApRedundancyResult',
    'GetSwitchStatsDeviceSwitchStatApRedundancyModulesResult',
    'GetSwitchStatsDeviceSwitchStatArpTableStatsResult',
    'GetSwitchStatsDeviceSwitchStatClientResult',
    'GetSwitchStatsDeviceSwitchStatClientsStatsResult',
    'GetSwitchStatsDeviceSwitchStatClientsStatsTotalResult',
    'GetSwitchStatsDeviceSwitchStatCpuStatResult',
    'GetSwitchStatsDeviceSwitchStatDhcpdStatResult',
    'GetSwitchStatsDeviceSwitchStatFwupdateResult',
    'GetSwitchStatsDeviceSwitchStatIfStatResult',
    'GetSwitchStatsDeviceSwitchStatIfStatServpInfoResult',
    'GetSwitchStatsDeviceSwitchStatIpStatResult',
    'GetSwitchStatsDeviceSwitchStatLastTroubleResult',
    'GetSwitchStatsDeviceSwitchStatMacTableStatsResult',
    'GetSwitchStatsDeviceSwitchStatMemoryStatResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatCpuStatResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatErrorResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatFanResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatPicResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatPicPortGroupResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatPoeResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatPsusResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatTemperatureResult',
    'GetSwitchStatsDeviceSwitchStatModuleStatVcLinkResult',
    'GetSwitchStatsDeviceSwitchStatPortResult',
    'GetSwitchStatsDeviceSwitchStatRouteSummaryStatsResult',
    'GetSwitchStatsDeviceSwitchStatServiceStatResult',
    'GetSwitchStatsDeviceSwitchStatVcSetupInfoResult',
    'GetVersionsDeviceVersionResult',
]

@pulumi.output_type
class ApAeroscout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locateConnected":
            suggest = "locate_connected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApAeroscout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApAeroscout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApAeroscout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 locate_connected: Optional[_builtins.bool] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Whether to enable aeroscout config
        :param _builtins.str host: Required if enabled, aeroscout server host
        :param _builtins.bool locate_connected: Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if locate_connected is not None:
            pulumi.set(__self__, "locate_connected", locate_connected)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable aeroscout config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Required if enabled, aeroscout server host
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="locateConnected")
    def locate_connected(self) -> Optional[_builtins.bool]:
        """
        Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        return pulumi.get(self, "locate_connected")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ApAirista(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Whether to enable Airista config
        :param _builtins.str host: Required if enabled, Airista server host
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Airista config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Required if enabled, Airista server host
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ApBleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beaconEnabled":
            suggest = "beacon_enabled"
        elif key == "beaconRate":
            suggest = "beacon_rate"
        elif key == "beaconRateMode":
            suggest = "beacon_rate_mode"
        elif key == "beamDisableds":
            suggest = "beam_disableds"
        elif key == "customBlePacketEnabled":
            suggest = "custom_ble_packet_enabled"
        elif key == "customBlePacketFrame":
            suggest = "custom_ble_packet_frame"
        elif key == "customBlePacketFreqMsec":
            suggest = "custom_ble_packet_freq_msec"
        elif key == "eddystoneUidAdvPower":
            suggest = "eddystone_uid_adv_power"
        elif key == "eddystoneUidBeams":
            suggest = "eddystone_uid_beams"
        elif key == "eddystoneUidEnabled":
            suggest = "eddystone_uid_enabled"
        elif key == "eddystoneUidFreqMsec":
            suggest = "eddystone_uid_freq_msec"
        elif key == "eddystoneUidInstance":
            suggest = "eddystone_uid_instance"
        elif key == "eddystoneUidNamespace":
            suggest = "eddystone_uid_namespace"
        elif key == "eddystoneUrlAdvPower":
            suggest = "eddystone_url_adv_power"
        elif key == "eddystoneUrlBeams":
            suggest = "eddystone_url_beams"
        elif key == "eddystoneUrlEnabled":
            suggest = "eddystone_url_enabled"
        elif key == "eddystoneUrlFreqMsec":
            suggest = "eddystone_url_freq_msec"
        elif key == "eddystoneUrlUrl":
            suggest = "eddystone_url_url"
        elif key == "ibeaconAdvPower":
            suggest = "ibeacon_adv_power"
        elif key == "ibeaconBeams":
            suggest = "ibeacon_beams"
        elif key == "ibeaconEnabled":
            suggest = "ibeacon_enabled"
        elif key == "ibeaconFreqMsec":
            suggest = "ibeacon_freq_msec"
        elif key == "ibeaconMajor":
            suggest = "ibeacon_major"
        elif key == "ibeaconMinor":
            suggest = "ibeacon_minor"
        elif key == "ibeaconUuid":
            suggest = "ibeacon_uuid"
        elif key == "powerMode":
            suggest = "power_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApBleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApBleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApBleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 beacon_enabled: Optional[_builtins.bool] = None,
                 beacon_rate: Optional[_builtins.int] = None,
                 beacon_rate_mode: Optional[_builtins.str] = None,
                 beam_disableds: Optional[Sequence[_builtins.int]] = None,
                 custom_ble_packet_enabled: Optional[_builtins.bool] = None,
                 custom_ble_packet_frame: Optional[_builtins.str] = None,
                 custom_ble_packet_freq_msec: Optional[_builtins.int] = None,
                 eddystone_uid_adv_power: Optional[_builtins.int] = None,
                 eddystone_uid_beams: Optional[_builtins.str] = None,
                 eddystone_uid_enabled: Optional[_builtins.bool] = None,
                 eddystone_uid_freq_msec: Optional[_builtins.int] = None,
                 eddystone_uid_instance: Optional[_builtins.str] = None,
                 eddystone_uid_namespace: Optional[_builtins.str] = None,
                 eddystone_url_adv_power: Optional[_builtins.int] = None,
                 eddystone_url_beams: Optional[_builtins.str] = None,
                 eddystone_url_enabled: Optional[_builtins.bool] = None,
                 eddystone_url_freq_msec: Optional[_builtins.int] = None,
                 eddystone_url_url: Optional[_builtins.str] = None,
                 ibeacon_adv_power: Optional[_builtins.int] = None,
                 ibeacon_beams: Optional[_builtins.str] = None,
                 ibeacon_enabled: Optional[_builtins.bool] = None,
                 ibeacon_freq_msec: Optional[_builtins.int] = None,
                 ibeacon_major: Optional[_builtins.int] = None,
                 ibeacon_minor: Optional[_builtins.int] = None,
                 ibeacon_uuid: Optional[_builtins.str] = None,
                 power: Optional[_builtins.int] = None,
                 power_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.bool beacon_enabled: Whether Mist beacons is enabled
        :param _builtins.int beacon_rate: Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        :param _builtins.str beacon_rate_mode: enum: `custom`, `default`
        :param Sequence[_builtins.int] beam_disableds: List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        :param _builtins.bool custom_ble_packet_enabled: Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        :param _builtins.str custom_ble_packet_frame: The custom frame to be sent out in this beacon. The frame must be a hexstring
        :param _builtins.int custom_ble_packet_freq_msec: Frequency (msec) of data emitted by custom ble beacon
        :param _builtins.int eddystone_uid_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param _builtins.bool eddystone_uid_enabled: Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        :param _builtins.int eddystone_uid_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param _builtins.str eddystone_uid_instance: Eddystone-UID instance for the device
        :param _builtins.str eddystone_uid_namespace: Eddystone-UID namespace
        :param _builtins.int eddystone_url_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param _builtins.bool eddystone_url_enabled: Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        :param _builtins.int eddystone_url_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param _builtins.str eddystone_url_url: URL pointed by Eddystone-URL beacon
        :param _builtins.int ibeacon_adv_power: Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param _builtins.bool ibeacon_enabled: Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        :param _builtins.int ibeacon_freq_msec: Frequency (msec) of data emit for iBeacon
        :param _builtins.int ibeacon_major: Major number for iBeacon
        :param _builtins.int ibeacon_minor: Minor number for iBeacon
        :param _builtins.str ibeacon_uuid: Optional, if not specified, the same UUID as the beacon will be used
        :param _builtins.int power: Required if `power_mode`==`custom`; else use `power_mode` as default
        :param _builtins.str power_mode: enum: `custom`, `default`
        """
        if beacon_enabled is not None:
            pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        if beacon_rate is not None:
            pulumi.set(__self__, "beacon_rate", beacon_rate)
        if beacon_rate_mode is not None:
            pulumi.set(__self__, "beacon_rate_mode", beacon_rate_mode)
        if beam_disableds is not None:
            pulumi.set(__self__, "beam_disableds", beam_disableds)
        if custom_ble_packet_enabled is not None:
            pulumi.set(__self__, "custom_ble_packet_enabled", custom_ble_packet_enabled)
        if custom_ble_packet_frame is not None:
            pulumi.set(__self__, "custom_ble_packet_frame", custom_ble_packet_frame)
        if custom_ble_packet_freq_msec is not None:
            pulumi.set(__self__, "custom_ble_packet_freq_msec", custom_ble_packet_freq_msec)
        if eddystone_uid_adv_power is not None:
            pulumi.set(__self__, "eddystone_uid_adv_power", eddystone_uid_adv_power)
        if eddystone_uid_beams is not None:
            pulumi.set(__self__, "eddystone_uid_beams", eddystone_uid_beams)
        if eddystone_uid_enabled is not None:
            pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        if eddystone_uid_freq_msec is not None:
            pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        if eddystone_uid_instance is not None:
            pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        if eddystone_uid_namespace is not None:
            pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        if eddystone_url_adv_power is not None:
            pulumi.set(__self__, "eddystone_url_adv_power", eddystone_url_adv_power)
        if eddystone_url_beams is not None:
            pulumi.set(__self__, "eddystone_url_beams", eddystone_url_beams)
        if eddystone_url_enabled is not None:
            pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        if eddystone_url_freq_msec is not None:
            pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        if eddystone_url_url is not None:
            pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        if ibeacon_adv_power is not None:
            pulumi.set(__self__, "ibeacon_adv_power", ibeacon_adv_power)
        if ibeacon_beams is not None:
            pulumi.set(__self__, "ibeacon_beams", ibeacon_beams)
        if ibeacon_enabled is not None:
            pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        if ibeacon_freq_msec is not None:
            pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        if ibeacon_major is not None:
            pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        if ibeacon_minor is not None:
            pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        if ibeacon_uuid is not None:
            pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)

    @_builtins.property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether Mist beacons is enabled
        """
        return pulumi.get(self, "beacon_enabled")

    @_builtins.property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> Optional[_builtins.int]:
        """
        Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        return pulumi.get(self, "beacon_rate")

    @_builtins.property
    @pulumi.getter(name="beaconRateMode")
    def beacon_rate_mode(self) -> Optional[_builtins.str]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "beacon_rate_mode")

    @_builtins.property
    @pulumi.getter(name="beamDisableds")
    def beam_disableds(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        return pulumi.get(self, "beam_disableds")

    @_builtins.property
    @pulumi.getter(name="customBlePacketEnabled")
    def custom_ble_packet_enabled(self) -> Optional[_builtins.bool]:
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        return pulumi.get(self, "custom_ble_packet_enabled")

    @_builtins.property
    @pulumi.getter(name="customBlePacketFrame")
    def custom_ble_packet_frame(self) -> Optional[_builtins.str]:
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        return pulumi.get(self, "custom_ble_packet_frame")

    @_builtins.property
    @pulumi.getter(name="customBlePacketFreqMsec")
    def custom_ble_packet_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        return pulumi.get(self, "custom_ble_packet_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidAdvPower")
    def eddystone_uid_adv_power(self) -> Optional[_builtins.int]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_uid_adv_power")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidBeams")
    def eddystone_uid_beams(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "eddystone_uid_beams")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> Optional[_builtins.bool]:
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        return pulumi.get(self, "eddystone_uid_enabled")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> Optional[_builtins.str]:
        """
        Eddystone-UID instance for the device
        """
        return pulumi.get(self, "eddystone_uid_instance")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> Optional[_builtins.str]:
        """
        Eddystone-UID namespace
        """
        return pulumi.get(self, "eddystone_uid_namespace")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlAdvPower")
    def eddystone_url_adv_power(self) -> Optional[_builtins.int]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_url_adv_power")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlBeams")
    def eddystone_url_beams(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "eddystone_url_beams")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> Optional[_builtins.bool]:
        """
        Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        return pulumi.get(self, "eddystone_url_enabled")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> Optional[_builtins.str]:
        """
        URL pointed by Eddystone-URL beacon
        """
        return pulumi.get(self, "eddystone_url_url")

    @_builtins.property
    @pulumi.getter(name="ibeaconAdvPower")
    def ibeacon_adv_power(self) -> Optional[_builtins.int]:
        """
        Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "ibeacon_adv_power")

    @_builtins.property
    @pulumi.getter(name="ibeaconBeams")
    def ibeacon_beams(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ibeacon_beams")

    @_builtins.property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> Optional[_builtins.bool]:
        """
        Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        return pulumi.get(self, "ibeacon_enabled")

    @_builtins.property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> Optional[_builtins.int]:
        """
        Frequency (msec) of data emit for iBeacon
        """
        return pulumi.get(self, "ibeacon_freq_msec")

    @_builtins.property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> Optional[_builtins.int]:
        """
        Major number for iBeacon
        """
        return pulumi.get(self, "ibeacon_major")

    @_builtins.property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> Optional[_builtins.int]:
        """
        Minor number for iBeacon
        """
        return pulumi.get(self, "ibeacon_minor")

    @_builtins.property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> Optional[_builtins.str]:
        """
        Optional, if not specified, the same UUID as the beacon will be used
        """
        return pulumi.get(self, "ibeacon_uuid")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        Required if `power_mode`==`custom`; else use `power_mode` as default
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[_builtins.str]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "power_mode")


@pulumi.output_type
class ApCentrak(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApClientBridge(dict):
    def __init__(__self__, *,
                 auth: Optional['outputs.ApClientBridgeAuth'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 ssid: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: When acted as client bridge:
                 * only 5G radio can be used
                 * will not serve as AP on any radios
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.ApClientBridgeAuth']:
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When acted as client bridge:
          * only 5G radio can be used
          * will not serve as AP on any radios
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def ssid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssid")


@pulumi.output_type
class ApClientBridgeAuth(dict):
    def __init__(__self__, *,
                 psk: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
        """
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "psk")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApEslConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCert":
            suggest = "verify_cert"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApEslConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApEslConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApEslConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cacert: Optional[_builtins.str] = None,
                 channel: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 verify_cert: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str cacert: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.int channel: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.bool enabled: usb_config is ignored if esl_config enabled
        :param _builtins.str host: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.int port: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.str type: note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        :param _builtins.bool verify_cert: Only if `type`==`imagotag` or `type`==`native`
        :param _builtins.int vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "cacert")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        usb_config is ignored if esl_config enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "verify_cert")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class ApIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.int] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] dns: If `type`==`static`
        :param Sequence[_builtins.str] dns_suffixes: Required if `type`==`static`
        :param _builtins.str gateway: Required if `type`==`static`
        :param _builtins.str ip: Required if `type`==`static`
        :param _builtins.str netmask: Required if `type`==`static`
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        :param _builtins.int vlan_id: Management VLAN id, default is 1 (untagged)
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Management VLAN id, default is 1 (untagged)
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class ApLacpConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApLed(dict):
    def __init__(__self__, *,
                 brightness: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None):
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "brightness")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApMesh(dict):
    def __init__(__self__, *,
                 bands: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 group: Optional[_builtins.int] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] bands: List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        :param _builtins.bool enabled: Whether mesh is enabled on this AP
        :param _builtins.int group: Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        :param _builtins.str role: enum: `base`, `remote`
        """
        if bands is not None:
            pulumi.set(__self__, "bands", bands)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def bands(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`
        """
        return pulumi.get(self, "bands")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether mesh is enabled on this AP
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.int]:
        """
        Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        enum: `base`, `remote`
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ApPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicVlan":
            suggest = "dynamic_vlan"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "macAuthPreferred":
            suggest = "mac_auth_preferred"
        elif key == "macAuthProtocol":
            suggest = "mac_auth_protocol"
        elif key == "mistNac":
            suggest = "mist_nac"
        elif key == "mxTunnelId":
            suggest = "mx_tunnel_id"
        elif key == "mxtunnelName":
            suggest = "mxtunnel_name"
        elif key == "portAuth":
            suggest = "port_auth"
        elif key == "portVlanId":
            suggest = "port_vlan_id"
        elif key == "radiusConfig":
            suggest = "radius_config"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vlanIds":
            suggest = "vlan_ids"
        elif key == "wxtunnelId":
            suggest = "wxtunnel_id"
        elif key == "wxtunnelRemoteId":
            suggest = "wxtunnel_remote_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 dynamic_vlan: Optional['outputs.ApPortConfigDynamicVlan'] = None,
                 enable_mac_auth: Optional[_builtins.bool] = None,
                 forwarding: Optional[_builtins.str] = None,
                 mac_auth_preferred: Optional[_builtins.bool] = None,
                 mac_auth_protocol: Optional[_builtins.str] = None,
                 mist_nac: Optional['outputs.ApPortConfigMistNac'] = None,
                 mx_tunnel_id: Optional[_builtins.str] = None,
                 mxtunnel_name: Optional[_builtins.str] = None,
                 port_auth: Optional[_builtins.str] = None,
                 port_vlan_id: Optional[_builtins.int] = None,
                 radius_config: Optional['outputs.ApPortConfigRadiusConfig'] = None,
                 radsec: Optional['outputs.ApPortConfigRadsec'] = None,
                 vlan_id: Optional[_builtins.int] = None,
                 vlan_ids: Optional[Sequence[_builtins.int]] = None,
                 wxtunnel_id: Optional[_builtins.str] = None,
                 wxtunnel_remote_id: Optional[_builtins.str] = None):
        """
        :param 'ApPortConfigDynamicVlanArgs' dynamic_vlan: Optional dynamic vlan
        :param _builtins.str forwarding: enum: 
                 * `all`: local breakout, All VLANs
                 * `limited`: local breakout, only the VLANs configured in `port_vlan_id` and `vlan_ids`
                 * `mxtunnel`: central breakout to an Org Mist Edge (requires `mxtunnel_id`)
                 * `site_mxedge`: central breakout to a Site Mist Edge (requires `mxtunnel_name`)
                 * `wxtunnel`': central breakout to an Org WxTunnel (requires `wxtunnel_id`)
        :param _builtins.bool mac_auth_preferred: When `true`, we'll do dot1x then mac_auth. enable this to prefer mac_auth
        :param _builtins.str mac_auth_protocol: if `enable_mac_auth`==`true`, allows user to select an authentication protocol. enum: `eap-md5`, `eap-peap`, `pap`
        :param _builtins.str mx_tunnel_id: If `forwarding`==`mxtunnel`, vlan_ids comes from mxtunnel
        :param _builtins.str mxtunnel_name: If `forwarding`==`site_mxedge`, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        :param _builtins.str port_auth: When doing port auth. enum: `dot1x`, `none`
        :param _builtins.int port_vlan_id: If `forwarding`==`limited`
        :param 'ApPortConfigRadiusConfigArgs' radius_config: Junos Radius config
        :param 'ApPortConfigRadsecArgs' radsec: RadSec settings
        :param _builtins.int vlan_id: Optional to specify the vlan id for a tunnel if forwarding is for `wxtunnel`, `mxtunnel` or `site_mxedge`.
                 * if vlan_id is not specified then it will use first one in vlan_ids[] of the mxtunnel.
                 * if forwarding == site_mxedge, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        :param Sequence[_builtins.int] vlan_ids: If `forwarding`==`limited`
        :param _builtins.str wxtunnel_id: If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        :param _builtins.str wxtunnel_remote_id: If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dynamic_vlan is not None:
            pulumi.set(__self__, "dynamic_vlan", dynamic_vlan)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if forwarding is not None:
            pulumi.set(__self__, "forwarding", forwarding)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mist_nac is not None:
            pulumi.set(__self__, "mist_nac", mist_nac)
        if mx_tunnel_id is not None:
            pulumi.set(__self__, "mx_tunnel_id", mx_tunnel_id)
        if mxtunnel_name is not None:
            pulumi.set(__self__, "mxtunnel_name", mxtunnel_name)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_vlan_id is not None:
            pulumi.set(__self__, "port_vlan_id", port_vlan_id)
        if radius_config is not None:
            pulumi.set(__self__, "radius_config", radius_config)
        if radsec is not None:
            pulumi.set(__self__, "radsec", radsec)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_ids is not None:
            pulumi.set(__self__, "vlan_ids", vlan_ids)
        if wxtunnel_id is not None:
            pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)
        if wxtunnel_remote_id is not None:
            pulumi.set(__self__, "wxtunnel_remote_id", wxtunnel_remote_id)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="dynamicVlan")
    def dynamic_vlan(self) -> Optional['outputs.ApPortConfigDynamicVlan']:
        """
        Optional dynamic vlan
        """
        return pulumi.get(self, "dynamic_vlan")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter
    def forwarding(self) -> Optional[_builtins.str]:
        """
        enum: 
          * `all`: local breakout, All VLANs
          * `limited`: local breakout, only the VLANs configured in `port_vlan_id` and `vlan_ids`
          * `mxtunnel`: central breakout to an Org Mist Edge (requires `mxtunnel_id`)
          * `site_mxedge`: central breakout to a Site Mist Edge (requires `mxtunnel_name`)
          * `wxtunnel`': central breakout to an Org WxTunnel (requires `wxtunnel_id`)
        """
        return pulumi.get(self, "forwarding")

    @_builtins.property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[_builtins.bool]:
        """
        When `true`, we'll do dot1x then mac_auth. enable this to prefer mac_auth
        """
        return pulumi.get(self, "mac_auth_preferred")

    @_builtins.property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[_builtins.str]:
        """
        if `enable_mac_auth`==`true`, allows user to select an authentication protocol. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @_builtins.property
    @pulumi.getter(name="mistNac")
    def mist_nac(self) -> Optional['outputs.ApPortConfigMistNac']:
        return pulumi.get(self, "mist_nac")

    @_builtins.property
    @pulumi.getter(name="mxTunnelId")
    def mx_tunnel_id(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`mxtunnel`, vlan_ids comes from mxtunnel
        """
        return pulumi.get(self, "mx_tunnel_id")

    @_builtins.property
    @pulumi.getter(name="mxtunnelName")
    def mxtunnel_name(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`site_mxedge`, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        """
        return pulumi.get(self, "mxtunnel_name")

    @_builtins.property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[_builtins.str]:
        """
        When doing port auth. enum: `dot1x`, `none`
        """
        return pulumi.get(self, "port_auth")

    @_builtins.property
    @pulumi.getter(name="portVlanId")
    def port_vlan_id(self) -> Optional[_builtins.int]:
        """
        If `forwarding`==`limited`
        """
        return pulumi.get(self, "port_vlan_id")

    @_builtins.property
    @pulumi.getter(name="radiusConfig")
    def radius_config(self) -> Optional['outputs.ApPortConfigRadiusConfig']:
        """
        Junos Radius config
        """
        return pulumi.get(self, "radius_config")

    @_builtins.property
    @pulumi.getter
    def radsec(self) -> Optional['outputs.ApPortConfigRadsec']:
        """
        RadSec settings
        """
        return pulumi.get(self, "radsec")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Optional to specify the vlan id for a tunnel if forwarding is for `wxtunnel`, `mxtunnel` or `site_mxedge`.
          * if vlan_id is not specified then it will use first one in vlan_ids[] of the mxtunnel.
          * if forwarding == site_mxedge, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)
        """
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vlanIds")
    def vlan_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        If `forwarding`==`limited`
        """
        return pulumi.get(self, "vlan_ids")

    @_builtins.property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        """
        return pulumi.get(self, "wxtunnel_id")

    @_builtins.property
    @pulumi.getter(name="wxtunnelRemoteId")
    def wxtunnel_remote_id(self) -> Optional[_builtins.str]:
        """
        If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session
        """
        return pulumi.get(self, "wxtunnel_remote_id")


@pulumi.output_type
class ApPortConfigDynamicVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultVlanId":
            suggest = "default_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfigDynamicVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfigDynamicVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfigDynamicVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_vlan_id: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None,
                 vlans: Optional[Mapping[str, _builtins.str]] = None):
        if default_vlan_id is not None:
            pulumi.set(__self__, "default_vlan_id", default_vlan_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @_builtins.property
    @pulumi.getter(name="defaultVlanId")
    def default_vlan_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "default_vlan_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vlans(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "vlans")


@pulumi.output_type
class ApPortConfigMistNac(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "fastDot1xTimers":
            suggest = "fast_dot1x_timers"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfigMistNac. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfigMistNac.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfigMistNac.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fast_dot1x_timers: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled.
        :param _builtins.int auth_servers_retries: Radius auth session retries. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "retries" are set to value of `auth_servers_timeout`. "max-requests" is also set when setting `auth_servers_retries` is set to default value to 3.
        :param _builtins.int auth_servers_timeout: Radius auth session timeout. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "quite-period" and "transmit-period" are set to half the value of `auth_servers_timeout`. "supplicant-timeout" is also set when setting `auth_servers_timeout` is set to default value of 10.
        :param _builtins.bool coa_enabled: Allows a RADIUS server to dynamically modify the authorization status of a user session.
        :param _builtins.int coa_port: the communication port used for Change of Authorization (CoA) messages
        :param _builtins.bool enabled: When enabled:
                 * `auth_servers` is ignored
                 * `acct_servers` is ignored
                 * `auth_servers_*` are ignored
                 * `coa_servers` is ignored
                 * `radsec` is ignored
                 * `coa_enabled` is assumed
        :param _builtins.bool fast_dot1x_timers: If set to true, sets default fast-timers with values calculated from `auth_servers_timeout` and `auth_server_retries`.
        :param _builtins.str network: Which network the mist nac server resides in
        :param _builtins.str source_ip: In case there is a static IP for this network, we can specify it using source ip
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled.
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        Radius auth session retries. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "retries" are set to value of `auth_servers_timeout`. "max-requests" is also set when setting `auth_servers_retries` is set to default value to 3.
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        Radius auth session timeout. Following fast timers are set if `fast_dot1x_timers` knob is enabled. "quite-period" and "transmit-period" are set to half the value of `auth_servers_timeout`. "supplicant-timeout" is also set when setting `auth_servers_timeout` is set to default value of 10.
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        """
        Allows a RADIUS server to dynamically modify the authorization status of a user session.
        """
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.int]:
        """
        the communication port used for Change of Authorization (CoA) messages
        """
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When enabled:
          * `auth_servers` is ignored
          * `acct_servers` is ignored
          * `auth_servers_*` are ignored
          * `coa_servers` is ignored
          * `radsec` is ignored
          * `coa_enabled` is assumed
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[_builtins.bool]:
        """
        If set to true, sets default fast-timers with values calculated from `auth_servers_timeout` and `auth_server_retries`.
        """
        return pulumi.get(self, "fast_dot1x_timers")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Which network the mist nac server resides in
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        In case there is a static IP for this network, we can specify it using source ip
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class ApPortConfigRadiusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "acctServers":
            suggest = "acct_servers"
        elif key == "authServers":
            suggest = "auth_servers"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfigRadiusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfigRadiusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfigRadiusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 acct_servers: Optional[Sequence['outputs.ApPortConfigRadiusConfigAcctServer']] = None,
                 auth_servers: Optional[Sequence['outputs.ApPortConfigRadiusConfigAuthServer']] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.int] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param _builtins.int auth_servers_retries: radius auth session retries
        :param _builtins.int auth_servers_timeout: radius auth session timeout
        :param _builtins.str network: use `network`or `source_ip`, which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param _builtins.str source_ip: use `network`or `source_ip`
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.ApPortConfigRadiusConfigAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[Sequence['outputs.ApPortConfigRadiusConfigAuthServer']]:
        return pulumi.get(self, "auth_servers")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        use `network`or `source_ip`, which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class ApPortConfigRadiusConfigAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfigRadiusConfigAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfigRadiusConfigAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfigRadiusConfigAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ApPortConfigRadiusConfigAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"
        elif key == "requireMessageAuthenticator":
            suggest = "require_message_authenticator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfigRadiusConfigAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfigRadiusConfigAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfigRadiusConfigAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 require_message_authenticator: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.bool require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[_builtins.bool]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")


@pulumi.output_type
class ApPortConfigRadsec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "mxclusterIds":
            suggest = "mxcluster_ids"
        elif key == "proxyHosts":
            suggest = "proxy_hosts"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "useMxedge":
            suggest = "use_mxedge"
        elif key == "useSiteMxedge":
            suggest = "use_site_mxedge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPortConfigRadsec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPortConfigRadsec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPortConfigRadsec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coa_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idle_timeout: Optional[_builtins.str] = None,
                 mxcluster_ids: Optional[Sequence[_builtins.str]] = None,
                 proxy_hosts: Optional[Sequence[_builtins.str]] = None,
                 server_name: Optional[_builtins.str] = None,
                 servers: Optional[Sequence['outputs.ApPortConfigRadsecServer']] = None,
                 use_mxedge: Optional[_builtins.bool] = None,
                 use_site_mxedge: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] mxcluster_ids: To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        :param Sequence[_builtins.str] proxy_hosts: Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        :param _builtins.str server_name: Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        :param Sequence['ApPortConfigRadsecServerArgs'] servers: List of RadSec Servers. Only if not Mist Edge.
        :param _builtins.bool use_mxedge: use mxedge(s) as RadSec Proxy
        :param _builtins.bool use_site_mxedge: To use Site mxedges when this WLAN does not use mxtunnel
        """
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if mxcluster_ids is not None:
            pulumi.set(__self__, "mxcluster_ids", mxcluster_ids)
        if proxy_hosts is not None:
            pulumi.set(__self__, "proxy_hosts", proxy_hosts)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if use_mxedge is not None:
            pulumi.set(__self__, "use_mxedge", use_mxedge)
        if use_site_mxedge is not None:
            pulumi.set(__self__, "use_site_mxedge", use_site_mxedge)

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="mxclusterIds")
    def mxcluster_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids
        """
        return pulumi.get(self, "mxcluster_ids")

    @_builtins.property
    @pulumi.getter(name="proxyHosts")
    def proxy_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`
        """
        return pulumi.get(self, "proxy_hosts")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.ApPortConfigRadsecServer']]:
        """
        List of RadSec Servers. Only if not Mist Edge.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="useMxedge")
    def use_mxedge(self) -> Optional[_builtins.bool]:
        """
        use mxedge(s) as RadSec Proxy
        """
        return pulumi.get(self, "use_mxedge")

    @_builtins.property
    @pulumi.getter(name="useSiteMxedge")
    def use_site_mxedge(self) -> Optional[_builtins.bool]:
        """
        To use Site mxedges when this WLAN does not use mxtunnel
        """
        return pulumi.get(self, "use_site_mxedge")


@pulumi.output_type
class ApPortConfigRadsecServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class ApPwrConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferUsbOverWifi":
            suggest = "prefer_usb_over_wifi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApPwrConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApPwrConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApPwrConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base: Optional[_builtins.int] = None,
                 prefer_usb_over_wifi: Optional[_builtins.bool] = None):
        """
        :param _builtins.int base: Additional power to request during negotiating with PSE over PoE, in mW
        :param _builtins.bool prefer_usb_over_wifi: Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
        if base is not None:
            pulumi.set(__self__, "base", base)
        if prefer_usb_over_wifi is not None:
            pulumi.set(__self__, "prefer_usb_over_wifi", prefer_usb_over_wifi)

    @_builtins.property
    @pulumi.getter
    def base(self) -> Optional[_builtins.int]:
        """
        Additional power to request during negotiating with PSE over PoE, in mW
        """
        return pulumi.get(self, "base")

    @_builtins.property
    @pulumi.getter(name="preferUsbOverWifi")
    def prefer_usb_over_wifi(self) -> Optional[_builtins.bool]:
        """
        Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)
        """
        return pulumi.get(self, "prefer_usb_over_wifi")


@pulumi.output_type
class ApRadioConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain24":
            suggest = "ant_gain24"
        elif key == "antGain5":
            suggest = "ant_gain5"
        elif key == "antGain6":
            suggest = "ant_gain6"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "band24Usage":
            suggest = "band24_usage"
        elif key == "band5On24Radio":
            suggest = "band5_on24_radio"
        elif key == "fullAutomaticRrm":
            suggest = "full_automatic_rrm"
        elif key == "indoorUse":
            suggest = "indoor_use"
        elif key == "scanningEnabled":
            suggest = "scanning_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApRadioConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApRadioConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApRadioConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain24: Optional[_builtins.int] = None,
                 ant_gain5: Optional[_builtins.int] = None,
                 ant_gain6: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 band24: Optional['outputs.ApRadioConfigBand24'] = None,
                 band24_usage: Optional[_builtins.str] = None,
                 band5: Optional['outputs.ApRadioConfigBand5'] = None,
                 band5_on24_radio: Optional['outputs.ApRadioConfigBand5On24Radio'] = None,
                 band6: Optional['outputs.ApRadioConfigBand6'] = None,
                 full_automatic_rrm: Optional[_builtins.bool] = None,
                 indoor_use: Optional[_builtins.bool] = None,
                 scanning_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int ant_gain24: Antenna gain for 2.4G - for models with external antenna only
        :param _builtins.int ant_gain5: Antenna gain for 5G - for models with external antenna only
        :param _builtins.int ant_gain6: Antenna gain for 6G - for models with external antenna only
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param 'ApRadioConfigBand24Args' band24: Radio Band AP settings
        :param _builtins.str band24_usage: enum: `24`, `5`, `6`, `auto`
        :param 'ApRadioConfigBand5Args' band5: Radio Band AP settings
        :param 'ApRadioConfigBand5On24RadioArgs' band5_on24_radio: Radio Band AP settings
        :param 'ApRadioConfigBand6Args' band6: Radio Band AP settings
        :param _builtins.bool full_automatic_rrm: Let RRM control everything, only the `channels` and `ant_gain` will be honored (i.e. disabled/bandwidth/power/band_24_usage are all controlled by RRM)
        :param _builtins.bool indoor_use: To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        :param _builtins.bool scanning_enabled: Whether scanning radio is enabled
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain24 is not None:
            pulumi.set(__self__, "ant_gain24", ant_gain24)
        if ant_gain5 is not None:
            pulumi.set(__self__, "ant_gain5", ant_gain5)
        if ant_gain6 is not None:
            pulumi.set(__self__, "ant_gain6", ant_gain6)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if band24 is not None:
            pulumi.set(__self__, "band24", band24)
        if band24_usage is not None:
            pulumi.set(__self__, "band24_usage", band24_usage)
        if band5 is not None:
            pulumi.set(__self__, "band5", band5)
        if band5_on24_radio is not None:
            pulumi.set(__self__, "band5_on24_radio", band5_on24_radio)
        if band6 is not None:
            pulumi.set(__self__, "band6", band6)
        if full_automatic_rrm is not None:
            pulumi.set(__self__, "full_automatic_rrm", full_automatic_rrm)
        if indoor_use is not None:
            pulumi.set(__self__, "indoor_use", indoor_use)
        if scanning_enabled is not None:
            pulumi.set(__self__, "scanning_enabled", scanning_enabled)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain24")
    def ant_gain24(self) -> Optional[_builtins.int]:
        """
        Antenna gain for 2.4G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain24")

    @_builtins.property
    @pulumi.getter(name="antGain5")
    def ant_gain5(self) -> Optional[_builtins.int]:
        """
        Antenna gain for 5G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain5")

    @_builtins.property
    @pulumi.getter(name="antGain6")
    def ant_gain6(self) -> Optional[_builtins.int]:
        """
        Antenna gain for 6G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain6")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def band24(self) -> Optional['outputs.ApRadioConfigBand24']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band24")

    @_builtins.property
    @pulumi.getter(name="band24Usage")
    def band24_usage(self) -> Optional[_builtins.str]:
        """
        enum: `24`, `5`, `6`, `auto`
        """
        return pulumi.get(self, "band24_usage")

    @_builtins.property
    @pulumi.getter
    def band5(self) -> Optional['outputs.ApRadioConfigBand5']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5")

    @_builtins.property
    @pulumi.getter(name="band5On24Radio")
    def band5_on24_radio(self) -> Optional['outputs.ApRadioConfigBand5On24Radio']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5_on24_radio")

    @_builtins.property
    @pulumi.getter
    def band6(self) -> Optional['outputs.ApRadioConfigBand6']:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band6")

    @_builtins.property
    @pulumi.getter(name="fullAutomaticRrm")
    def full_automatic_rrm(self) -> Optional[_builtins.bool]:
        """
        Let RRM control everything, only the `channels` and `ant_gain` will be honored (i.e. disabled/bandwidth/power/band_24_usage are all controlled by RRM)
        """
        return pulumi.get(self, "full_automatic_rrm")

    @_builtins.property
    @pulumi.getter(name="indoorUse")
    def indoor_use(self) -> Optional[_builtins.bool]:
        """
        To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        """
        return pulumi.get(self, "indoor_use")

    @_builtins.property
    @pulumi.getter(name="scanningEnabled")
    def scanning_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether scanning radio is enabled
        """
        return pulumi.get(self, "scanning_enabled")


@pulumi.output_type
class ApRadioConfigBand24(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApRadioConfigBand24. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApRadioConfigBand24.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApRadioConfigBand24.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class ApRadioConfigBand5(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApRadioConfigBand5. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApRadioConfigBand5.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApRadioConfigBand5.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class ApRadioConfigBand5On24Radio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApRadioConfigBand5On24Radio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApRadioConfigBand5On24Radio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApRadioConfigBand5On24Radio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")


@pulumi.output_type
class ApRadioConfigBand6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRrmDisable":
            suggest = "allow_rrm_disable"
        elif key == "antGain":
            suggest = "ant_gain"
        elif key == "antennaMode":
            suggest = "antenna_mode"
        elif key == "powerMax":
            suggest = "power_max"
        elif key == "powerMin":
            suggest = "power_min"
        elif key == "standardPower":
            suggest = "standard_power"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApRadioConfigBand6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApRadioConfigBand6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApRadioConfigBand6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_rrm_disable: Optional[_builtins.bool] = None,
                 ant_gain: Optional[_builtins.int] = None,
                 antenna_mode: Optional[_builtins.str] = None,
                 bandwidth: Optional[_builtins.int] = None,
                 channel: Optional[_builtins.int] = None,
                 channels: Optional[Sequence[_builtins.int]] = None,
                 disabled: Optional[_builtins.bool] = None,
                 power: Optional[_builtins.int] = None,
                 power_max: Optional[_builtins.int] = None,
                 power_min: Optional[_builtins.int] = None,
                 preamble: Optional[_builtins.str] = None,
                 standard_power: Optional[_builtins.bool] = None):
        """
        :param _builtins.str antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param _builtins.int bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param _builtins.int channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param Sequence[_builtins.int] channels: For RFTemplates. List of channels, null or empty array means auto
        :param _builtins.bool disabled: Whether to disable the radio
        :param _builtins.int power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        :param _builtins.int power_max: When power=0, max tx power to use, HW-specific values will be used if not set
        :param _builtins.int power_min: When power=0, min tx power to use, HW-specific values will be used if not set
        :param _builtins.str preamble: enum: `auto`, `long`, `short`
        :param _builtins.bool standard_power: For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @_builtins.property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_rrm_disable")

    @_builtins.property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ant_gain")

    @_builtins.property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[_builtins.str]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[_builtins.int]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def power(self) -> Optional[_builtins.int]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / 
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[_builtins.int]:
        """
        When power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @_builtins.property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[_builtins.int]:
        """
        When power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @_builtins.property
    @pulumi.getter
    def preamble(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @_builtins.property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[_builtins.bool]:
        """
        For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")


@pulumi.output_type
class ApUplinkPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepWlansUpIfDown":
            suggest = "keep_wlans_up_if_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApUplinkPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApUplinkPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApUplinkPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dot1x: Optional[_builtins.bool] = None,
                 keep_wlans_up_if_down: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool dot1x: Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param _builtins.bool keep_wlans_up_if_down: By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @_builtins.property
    @pulumi.getter
    def dot1x(self) -> Optional[_builtins.bool]:
        """
        Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @_builtins.property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[_builtins.bool]:
        """
        By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")


@pulumi.output_type
class ApUsbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCert":
            suggest = "verify_cert"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApUsbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApUsbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApUsbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cacert: Optional[_builtins.str] = None,
                 channel: Optional[_builtins.int] = None,
                 enabled: Optional[_builtins.bool] = None,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 verify_cert: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str cacert: Only if `type`==`imagotag`
        :param _builtins.int channel: Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        :param _builtins.bool enabled: Whether to enable any usb config
        :param _builtins.str host: Only if `type`==`imagotag`
        :param _builtins.int port: Only if `type`==`imagotag`
        :param _builtins.str type: usb config type. enum: `hanshow`, `imagotag`, `solum`
        :param _builtins.bool verify_cert: Only if `type`==`imagotag`, whether to turn on SSL verification
        :param _builtins.int vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "cacert")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable any usb config
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`imagotag`
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        usb config type. enum: `hanshow`, `imagotag`, `solum`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`imagotag`, whether to turn on SSL verification
        """
        return pulumi.get(self, "verify_cert")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.int]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GatewayBgpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authKey":
            suggest = "auth_key"
        elif key == "bfdMinimumInterval":
            suggest = "bfd_minimum_interval"
        elif key == "bfdMultiplier":
            suggest = "bfd_multiplier"
        elif key == "disableBfd":
            suggest = "disable_bfd"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "extendedV4Nexthop":
            suggest = "extended_v4_nexthop"
        elif key == "gracefulRestartTime":
            suggest = "graceful_restart_time"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "import":
            suggest = "import_"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "localAs":
            suggest = "local_as"
        elif key == "neighborAs":
            suggest = "neighbor_as"
        elif key == "noPrivateAs":
            suggest = "no_private_as"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "tunnelName":
            suggest = "tunnel_name"
        elif key == "vpnName":
            suggest = "vpn_name"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayBgpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayBgpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayBgpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 auth_key: Optional[_builtins.str] = None,
                 bfd_minimum_interval: Optional[_builtins.int] = None,
                 bfd_multiplier: Optional[_builtins.int] = None,
                 disable_bfd: Optional[_builtins.bool] = None,
                 export: Optional[_builtins.str] = None,
                 export_policy: Optional[_builtins.str] = None,
                 extended_v4_nexthop: Optional[_builtins.bool] = None,
                 graceful_restart_time: Optional[_builtins.int] = None,
                 hold_time: Optional[_builtins.int] = None,
                 import_: Optional[_builtins.str] = None,
                 import_policy: Optional[_builtins.str] = None,
                 local_as: Optional[_builtins.str] = None,
                 neighbor_as: Optional[_builtins.str] = None,
                 neighbors: Optional[Mapping[str, 'outputs.GatewayBgpConfigNeighbors']] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 no_private_as: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 tunnel_name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vpn_name: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str via: enum: `lan`, `tunnel`, `vpn`, `wan`
        :param _builtins.str auth_key: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`
        :param _builtins.int bfd_minimum_interval: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_multiplier is configured alone. Default:
                 * 1000 if `type`==`external`
                 * 350 `type`==`internal`
        :param _builtins.int bfd_multiplier: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_minimum_interval_is_configured alone
        :param _builtins.bool disable_bfd: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BFD provides faster path failure detection and is enabled by default
        :param _builtins.str export_policy: Default export policies if no per-neighbor policies defined
        :param _builtins.bool extended_v4_nexthop: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        :param _builtins.int graceful_restart_time: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. `0` means disable
        :param _builtins.int hold_time: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default is 90.
        :param _builtins.str import_policy: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default import policies if no per-neighbor policies defined
        :param _builtins.str local_as: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BGPLocal AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param _builtins.str neighbor_as: Neighbor AS. If `type`==`internal`, must be equal to `local_as`. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param Mapping[str, 'GatewayBgpConfigNeighborsArgs'] neighbors: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If per-neighbor as is desired. Property key is the neighbor address
        :param Sequence[_builtins.str] networks: Optional if `via`==`lan`. List of networks where we expect BGP neighbor to connect to/from
        :param _builtins.bool no_private_as: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If true, we will not advertise private ASNs (AS 64512-65534) to this neighbor
        :param _builtins.bool no_readvertise_to_overlay: Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, we'll re-advertise all learned BGP routers toward overlay
        :param _builtins.str tunnel_name: Optional if `via`==`tunnel`
        :param _builtins.str type: Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. enum: `external`, `internal`
        :param _builtins.str vpn_name: Optional if `via`==`vpn`
        :param _builtins.str wan_name: Optional if `via`==`wan`
        """
        pulumi.set(__self__, "via", via)
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if bfd_multiplier is not None:
            pulumi.set(__self__, "bfd_multiplier", bfd_multiplier)
        if disable_bfd is not None:
            pulumi.set(__self__, "disable_bfd", disable_bfd)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if extended_v4_nexthop is not None:
            pulumi.set(__self__, "extended_v4_nexthop", extended_v4_nexthop)
        if graceful_restart_time is not None:
            pulumi.set(__self__, "graceful_restart_time", graceful_restart_time)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if no_private_as is not None:
            pulumi.set(__self__, "no_private_as", no_private_as)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if tunnel_name is not None:
            pulumi.set(__self__, "tunnel_name", tunnel_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpn_name is not None:
            pulumi.set(__self__, "vpn_name", vpn_name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`
        """
        return pulumi.get(self, "auth_key")

    @_builtins.property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        return pulumi.get(self, "bfd_minimum_interval")

    @_builtins.property
    @pulumi.getter(name="bfdMultiplier")
    def bfd_multiplier(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`, when bfd_minimum_interval_is_configured alone
        """
        return pulumi.get(self, "bfd_multiplier")

    @_builtins.property
    @pulumi.getter(name="disableBfd")
    def disable_bfd(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BFD provides faster path failure detection and is enabled by default
        """
        return pulumi.get(self, "disable_bfd")

    @_builtins.property
    @pulumi.getter
    def export(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        """
        Default export policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="extendedV4Nexthop")
    def extended_v4_nexthop(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        return pulumi.get(self, "extended_v4_nexthop")

    @_builtins.property
    @pulumi.getter(name="gracefulRestartTime")
    def graceful_restart_time(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. `0` means disable
        """
        return pulumi.get(self, "graceful_restart_time")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.int]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default is 90.
        """
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. Default import policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[_builtins.str]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. BGPLocal AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "local_as")

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[_builtins.str]:
        """
        Neighbor AS. If `type`==`internal`, must be equal to `local_as`. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter
    def neighbors(self) -> Optional[Mapping[str, 'outputs.GatewayBgpConfigNeighbors']]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If per-neighbor as is desired. Property key is the neighbor address
        """
        return pulumi.get(self, "neighbors")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional if `via`==`lan`. List of networks where we expect BGP neighbor to connect to/from
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="noPrivateAs")
    def no_private_as(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. If true, we will not advertise private ASNs (AS 64512-65534) to this neighbor
        """
        return pulumi.get(self, "no_private_as")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        Optional if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. By default, we'll re-advertise all learned BGP routers toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`tunnel`
        """
        return pulumi.get(self, "tunnel_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Required if `via`==`lan`, `via`==`tunnel` or `via`==`wan`. enum: `external`, `internal`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpnName")
    def vpn_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`vpn`
        """
        return pulumi.get(self, "vpn_name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        Optional if `via`==`wan`
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewayBgpConfigNeighbors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "neighborAs":
            suggest = "neighbor_as"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "holdTime":
            suggest = "hold_time"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "multihopTtl":
            suggest = "multihop_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayBgpConfigNeighbors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayBgpConfigNeighbors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayBgpConfigNeighbors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 neighbor_as: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 export_policy: Optional[_builtins.str] = None,
                 hold_time: Optional[_builtins.int] = None,
                 import_policy: Optional[_builtins.str] = None,
                 multihop_ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str neighbor_as: Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        :param _builtins.bool disabled: If true, the BGP session to this neighbor will be administratively disabled/shutdown
        :param _builtins.int multihop_ttl: Assuming BGP neighbor is directly connected
        """
        pulumi.set(__self__, "neighbor_as", neighbor_as)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if multihop_ttl is not None:
            pulumi.set(__self__, "multihop_ttl", multihop_ttl)

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> _builtins.str:
        """
        Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)
        """
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hold_time")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="multihopTtl")
    def multihop_ttl(self) -> Optional[_builtins.int]:
        """
        Assuming BGP neighbor is directly connected
        """
        return pulumi.get(self, "multihop_ttl")


@pulumi.output_type
class GatewayClusterNode(dict):
    def __init__(__self__, *,
                 mac: _builtins.str):
        """
        :param _builtins.str mac: Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        pulumi.set(__self__, "mac", mac)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "mac")


@pulumi.output_type
class GatewayDhcpdConfig(dict):
    def __init__(__self__, *,
                 config: Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfig']] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, 'GatewayDhcpdConfigConfigArgs'] config: Property key is the network name
        :param _builtins.bool enabled: If set to `false`, disable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfig']]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to `false`, disable the DHCP server
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewayDhcpdConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"
        elif key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "fixedBindings":
            suggest = "fixed_bindings"
        elif key == "ip6End":
            suggest = "ip6_end"
        elif key == "ip6Start":
            suggest = "ip6_start"
        elif key == "ipEnd":
            suggest = "ip_end"
        elif key == "ipStart":
            suggest = "ip_start"
        elif key == "leaseTime":
            suggest = "lease_time"
        elif key == "serverIdOverride":
            suggest = "server_id_override"
        elif key == "vendorEncapsulated":
            suggest = "vendor_encapsulated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayDhcpdConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayDhcpdConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayDhcpdConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 fixed_bindings: Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfigFixedBindings']] = None,
                 gateway: Optional[_builtins.str] = None,
                 ip6_end: Optional[_builtins.str] = None,
                 ip6_start: Optional[_builtins.str] = None,
                 ip_end: Optional[_builtins.str] = None,
                 ip_start: Optional[_builtins.str] = None,
                 lease_time: Optional[_builtins.int] = None,
                 options: Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfigOptions']] = None,
                 server_id_override: Optional[_builtins.bool] = None,
                 servers: Optional[Sequence[_builtins.str]] = None,
                 serversv6s: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None,
                 vendor_encapsulated: Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfigVendorEncapsulated']] = None):
        """
        :param Sequence[_builtins.str] dns_servers: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param Sequence[_builtins.str] dns_suffixes: If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param Mapping[str, 'GatewayDhcpdConfigConfigFixedBindingsArgs'] fixed_bindings: If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        :param _builtins.str gateway: If `type`==`local` - optional, `ip` will be used if not provided
        :param _builtins.str ip6_end: If `type6`==`local`
        :param _builtins.str ip6_start: If `type6`==`local`
        :param _builtins.str ip_end: If `type`==`local`
        :param _builtins.str ip_start: If `type`==`local`
        :param _builtins.int lease_time: In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param Mapping[str, 'GatewayDhcpdConfigConfigOptionsArgs'] options: If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        :param _builtins.bool server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param Sequence[_builtins.str] servers: If `type`==`relay`
        :param Sequence[_builtins.str] serversv6s: If `type6`==`relay`
        :param _builtins.str type: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param _builtins.str type6: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param Mapping[str, 'GatewayDhcpdConfigConfigVendorEncapsulatedArgs'] vendor_encapsulated: If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip6_end is not None:
            pulumi.set(__self__, "ip6_end", ip6_end)
        if ip6_start is not None:
            pulumi.set(__self__, "ip6_start", ip6_start)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if serversv6s is not None:
            pulumi.set(__self__, "serversv6s", serversv6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapsulated is not None:
            pulumi.set(__self__, "vendor_encapsulated", vendor_encapsulated)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    @_utilities.deprecated("""Configuring `dns_suffix` is deprecated and will not be supported in the future, please configure Code 15 or Code 119 in Server `options` instead""")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfigFixedBindings']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`local` - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter(name="ip6End")
    def ip6_end(self) -> Optional[_builtins.str]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip6_end")

    @_builtins.property
    @pulumi.getter(name="ip6Start")
    def ip6_start(self) -> Optional[_builtins.str]:
        """
        If `type6`==`local`
        """
        return pulumi.get(self, "ip6_start")

    @_builtins.property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[_builtins.str]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_end")

    @_builtins.property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[_builtins.str]:
        """
        If `type`==`local`
        """
        return pulumi.get(self, "ip_start")

    @_builtins.property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[_builtins.int]:
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfigOptions']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[_builtins.bool]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def serversv6s(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type6`==`relay`
        """
        return pulumi.get(self, "serversv6s")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vendorEncapsulated")
    def vendor_encapsulated(self) -> Optional[Mapping[str, 'outputs.GatewayDhcpdConfigConfigVendorEncapsulated']]:
        """
        If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code
        """
        return pulumi.get(self, "vendor_encapsulated")


@pulumi.output_type
class GatewayDhcpdConfigConfigFixedBindings(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewayDhcpdConfigConfigOptions(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewayDhcpdConfigConfigVendorEncapsulated(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GatewayExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewayExtraRoutes(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewayIdpProfiles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseProfile":
            suggest = "base_profile"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayIdpProfiles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayIdpProfiles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayIdpProfiles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_profile: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 org_id: Optional[_builtins.str] = None,
                 overwrites: Optional[Sequence['outputs.GatewayIdpProfilesOverwrite']] = None):
        """
        :param _builtins.str base_profile: enum: `critical`, `standard`, `strict`
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        """
        if base_profile is not None:
            pulumi.set(__self__, "base_profile", base_profile)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)

    @_builtins.property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def overwrites(self) -> Optional[Sequence['outputs.GatewayIdpProfilesOverwrite']]:
        return pulumi.get(self, "overwrites")


@pulumi.output_type
class GatewayIdpProfilesOverwrite(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 matching: Optional['outputs.GatewayIdpProfilesOverwriteMatching'] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: enum:
                 * alert (default)
                 * drop: silently dropping packets
                 * close: notify client/server to close connection
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        enum:
          * alert (default)
          * drop: silently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.GatewayIdpProfilesOverwriteMatching']:
        return pulumi.get(self, "matching")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewayIdpProfilesOverwriteMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackNames":
            suggest = "attack_names"
        elif key == "dstSubnets":
            suggest = "dst_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayIdpProfilesOverwriteMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayIdpProfilesOverwriteMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayIdpProfilesOverwriteMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attack_names: Optional[Sequence[_builtins.str]] = None,
                 dst_subnets: Optional[Sequence[_builtins.str]] = None,
                 severities: Optional[Sequence[_builtins.str]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @_builtins.property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "attack_names")

    @_builtins.property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dst_subnets")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "severities")


@pulumi.output_type
class GatewayIpConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryIps":
            suggest = "secondary_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayIpConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayIpConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayIpConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 secondary_ips: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] secondary_ips: Optional list of secondary IPs in CIDR format
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if secondary_ips is not None:
            pulumi.set(__self__, "secondary_ips", secondary_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter(name="secondaryIps")
    def secondary_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional list of secondary IPs in CIDR format
        """
        return pulumi.get(self, "secondary_ips")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class GatewayNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disallowMistServices":
            suggest = "disallow_mist_services"
        elif key == "internalAccess":
            suggest = "internal_access"
        elif key == "internetAccess":
            suggest = "internet_access"
        elif key == "routedForNetworks":
            suggest = "routed_for_networks"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vpnAccess":
            suggest = "vpn_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 subnet: _builtins.str,
                 disallow_mist_services: Optional[_builtins.bool] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 internal_access: Optional['outputs.GatewayNetworkInternalAccess'] = None,
                 internet_access: Optional['outputs.GatewayNetworkInternetAccess'] = None,
                 isolation: Optional[_builtins.bool] = None,
                 multicast: Optional['outputs.GatewayNetworkMulticast'] = None,
                 routed_for_networks: Optional[Sequence[_builtins.str]] = None,
                 subnet6: Optional[_builtins.str] = None,
                 tenants: Optional[Mapping[str, 'outputs.GatewayNetworkTenants']] = None,
                 vlan_id: Optional[_builtins.str] = None,
                 vpn_access: Optional[Mapping[str, 'outputs.GatewayNetworkVpnAccess']] = None):
        """
        :param _builtins.bool disallow_mist_services: Whether to disallow Mist Devices in the network
        :param 'GatewayNetworkInternetAccessArgs' internet_access: Whether this network has direct internet access
        :param _builtins.bool isolation: Whether to allow clients in the network to talk to each other
        :param 'GatewayNetworkMulticastArgs' multicast: Whether to enable multicast support (only PIM-sparse mode is supported)
        :param Sequence[_builtins.str] routed_for_networks: For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param Mapping[str, 'GatewayNetworkTenantsArgs'] tenants: Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        :param Mapping[str, 'GatewayNetworkVpnAccessArgs'] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        if disallow_mist_services is not None:
            pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if internal_access is not None:
            pulumi.set(__self__, "internal_access", internal_access)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if routed_for_networks is not None:
            pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_access is not None:
            pulumi.set(__self__, "vpn_access", vpn_access)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> Optional[_builtins.bool]:
        """
        Whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> Optional['outputs.GatewayNetworkInternalAccess']:
        return pulumi.get(self, "internal_access")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional['outputs.GatewayNetworkInternetAccess']:
        """
        Whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[_builtins.bool]:
        """
        Whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter
    def multicast(self) -> Optional['outputs.GatewayNetworkMulticast']:
        """
        Whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @_builtins.property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @_builtins.property
    @pulumi.getter
    def subnet6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet6")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkTenants']]:
        """
        Property key must be the user/tenant name (i.e. "printer-1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "tenants")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkVpnAccess']]:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")


@pulumi.output_type
class GatewayNetworkInternalAccess(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewayNetworkInternetAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createSimpleServicePolicy":
            suggest = "create_simple_service_policy"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "staticNat":
            suggest = "static_nat"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkInternetAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkInternetAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkInternetAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_simple_service_policy: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.GatewayNetworkInternetAccessDestinationNat']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 restricted: Optional[_builtins.bool] = None,
                 static_nat: Optional[Mapping[str, 'outputs.GatewayNetworkInternetAccessStaticNat']] = None):
        """
        :param Mapping[str, 'GatewayNetworkInternetAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.bool restricted: By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param Mapping[str, 'GatewayNetworkInternetAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @_builtins.property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_simple_service_policy")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkInternetAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def restricted(self) -> Optional[_builtins.bool]:
        """
        By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkInternetAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")


@pulumi.output_type
class GatewayNetworkInternetAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkInternetAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkInternetAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkInternetAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str port: The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be a Port (i.e. "443") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewayNetworkInternetAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkInternetAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkInternetAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkInternetAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str wan_name: SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewayNetworkMulticast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableIgmp":
            suggest = "disable_igmp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkMulticast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkMulticast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkMulticast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_igmp: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 groups: Optional[Mapping[str, 'outputs.GatewayNetworkMulticastGroups']] = None):
        """
        :param _builtins.bool disable_igmp: If the network will only be the source of the multicast traffic, IGMP can be disabled
        :param Mapping[str, 'GatewayNetworkMulticastGroupsArgs'] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[_builtins.bool]:
        """
        If the network will only be the source of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkMulticastGroups']]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class GatewayNetworkMulticastGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rpIp":
            suggest = "rp_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkMulticastGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkMulticastGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkMulticastGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rp_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @_builtins.property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[_builtins.str]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")


@pulumi.output_type
class GatewayNetworkTenants(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[_builtins.str]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "addresses")


@pulumi.output_type
class GatewayNetworkVpnAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedSubnet":
            suggest = "advertised_subnet"
        elif key == "allowPing":
            suggest = "allow_ping"
        elif key == "destinationNat":
            suggest = "destination_nat"
        elif key == "natPool":
            suggest = "nat_pool"
        elif key == "noReadvertiseToLanBgp":
            suggest = "no_readvertise_to_lan_bgp"
        elif key == "noReadvertiseToLanOspf":
            suggest = "no_readvertise_to_lan_ospf"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"
        elif key == "otherVrfs":
            suggest = "other_vrfs"
        elif key == "sourceNat":
            suggest = "source_nat"
        elif key == "staticNat":
            suggest = "static_nat"
        elif key == "summarizedSubnet":
            suggest = "summarized_subnet"
        elif key == "summarizedSubnetToLanBgp":
            suggest = "summarized_subnet_to_lan_bgp"
        elif key == "summarizedSubnetToLanOspf":
            suggest = "summarized_subnet_to_lan_ospf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkVpnAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkVpnAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkVpnAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_subnet: Optional[_builtins.str] = None,
                 allow_ping: Optional[_builtins.bool] = None,
                 destination_nat: Optional[Mapping[str, 'outputs.GatewayNetworkVpnAccessDestinationNat']] = None,
                 nat_pool: Optional[_builtins.str] = None,
                 no_readvertise_to_lan_bgp: Optional[_builtins.bool] = None,
                 no_readvertise_to_lan_ospf: Optional[_builtins.bool] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 other_vrfs: Optional[Sequence[_builtins.str]] = None,
                 routed: Optional[_builtins.bool] = None,
                 source_nat: Optional['outputs.GatewayNetworkVpnAccessSourceNat'] = None,
                 static_nat: Optional[Mapping[str, 'outputs.GatewayNetworkVpnAccessStaticNat']] = None,
                 summarized_subnet: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_bgp: Optional[_builtins.str] = None,
                 summarized_subnet_to_lan_ospf: Optional[_builtins.str] = None):
        """
        :param _builtins.str advertised_subnet: If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param _builtins.bool allow_ping: Whether to allow ping from vpn into this routed network
        :param Mapping[str, 'GatewayNetworkVpnAccessDestinationNatArgs'] destination_nat: Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        :param _builtins.str nat_pool: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param _builtins.bool no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.bool no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param _builtins.bool no_readvertise_to_overlay: toward overlay, how HUB should deal with routes it received from Spokes
        :param Sequence[_builtins.str] other_vrfs: By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        :param _builtins.bool routed: Whether this network is routable
        :param 'GatewayNetworkVpnAccessSourceNatArgs' source_nat: If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param Mapping[str, 'GatewayNetworkVpnAccessStaticNatArgs'] static_nat: Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str summarized_subnet: toward overlay, how HUB should deal with routes it received from Spokes
        :param _builtins.str summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param _builtins.str summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @_builtins.property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[_builtins.str]:
        """
        If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @_builtins.property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[_builtins.bool]:
        """
        Whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @_builtins.property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkVpnAccessDestinationNat']]:
        """
        Property key can be an External IP (i.e. "63.16.0.3"), an External IP:Port (i.e. "63.16.0.3:443"), an External Port (i.e. ":443"), an External CIDR (i.e. "63.16.0.0/30"), an External CIDR:Port (i.e. "63.16.0.0/30:443") or a Variable (i.e. "{{myvar}}"). At least one of the `internal_ip` or `port` must be defined
        """
        return pulumi.get(self, "destination_nat")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[_builtins.bool]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @_builtins.property
    @pulumi.getter
    def routed(self) -> Optional[_builtins.bool]:
        """
        Whether this network is routable
        """
        return pulumi.get(self, "routed")

    @_builtins.property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional['outputs.GatewayNetworkVpnAccessSourceNat']:
        """
        If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @_builtins.property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[Mapping[str, 'outputs.GatewayNetworkVpnAccessStaticNat']]:
        """
        Property key may be an External IP Address (i.e. "63.16.0.3"), a CIDR (i.e. "63.16.0.12/20") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "static_nat")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[_builtins.str]:
        """
        toward overlay, how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[_builtins.str]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @_builtins.property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[_builtins.str]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")


@pulumi.output_type
class GatewayNetworkVpnAccessDestinationNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkVpnAccessDestinationNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkVpnAccessDestinationNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkVpnAccessDestinationNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str internal_ip: The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        The Destination NAT destination IP Address. Must be an IP (i.e. "192.168.70.30") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class GatewayNetworkVpnAccessSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIp":
            suggest = "external_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkVpnAccessSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkVpnAccessSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkVpnAccessSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_ip: Optional[_builtins.str] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @_builtins.property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_ip")


@pulumi.output_type
class GatewayNetworkVpnAccessStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayNetworkVpnAccessStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayNetworkVpnAccessStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayNetworkVpnAccessStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_ip: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str internal_ip: The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        The Static NAT destination IP Address. Must be an IP Address (i.e. "192.168.70.3") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewayOobIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayOobIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayOobIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayOobIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 node1: Optional['outputs.GatewayOobIpConfigNode1'] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: If `type`==`static`
        :param _builtins.str ip: If `type`==`static`
        :param _builtins.str netmask: If `type`==`static`
        :param 'GatewayOobIpConfigNode1Args' node1: For HA Cluster, node1 can have different IP Config
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if node1 is not None:
            pulumi.set(__self__, "node1", node1)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def node1(self) -> Optional['outputs.GatewayOobIpConfigNode1']:
        """
        For HA Cluster, node1 can have different IP Config
        """
        return pulumi.get(self, "node1")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GatewayOobIpConfigNode1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayOobIpConfigNode1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayOobIpConfigNode1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayOobIpConfigNode1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None,
                 vlan_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: If `type`==`static`
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GatewayPathPreferences(dict):
    def __init__(__self__, *,
                 paths: Optional[Sequence['outputs.GatewayPathPreferencesPath']] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.str strategy: enum: `ecmp`, `ordered`, `weighted`
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence['outputs.GatewayPathPreferencesPath']]:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GatewayPathPreferencesPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayIp":
            suggest = "gateway_ip"
        elif key == "internetAccess":
            suggest = "internet_access"
        elif key == "targetIps":
            suggest = "target_ips"
        elif key == "wanName":
            suggest = "wan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPathPreferencesPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPathPreferencesPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPathPreferencesPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 cost: Optional[_builtins.int] = None,
                 disabled: Optional[_builtins.bool] = None,
                 gateway_ip: Optional[_builtins.str] = None,
                 internet_access: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 target_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `local`, `tunnel`, `vpn`, `wan`
        :param _builtins.bool disabled: For SSR Only. `true`, if this specific path is undesired
        :param _builtins.str gateway_ip: Only if `type`==`local`, if a different gateway is desired
        :param _builtins.bool internet_access: Only if `type`==`vpn`, if this vpn path can be used for internet
        :param _builtins.str name: Required when 
                 * `type`==`vpn`: the name of the VPN Path to use 
                 * `type`==`wan`: the name of the WAN interface to use
        :param Sequence[_builtins.str] networks: Required when `type`==`local`
        :param Sequence[_builtins.str] target_ips: If `type`==`local`, if destination IP is to be replaced
        :param _builtins.str wan_name: Optional if `type`==`vpn`
        """
        pulumi.set(__self__, "type", type)
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def cost(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cost")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[_builtins.str]:
        """
        Only if `type`==`local`, if a different gateway is desired
        """
        return pulumi.get(self, "gateway_ip")

    @_builtins.property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[_builtins.bool]:
        """
        Only if `type`==`vpn`, if this vpn path can be used for internet
        """
        return pulumi.get(self, "internet_access")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `type`==`local`
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`local`, if destination IP is to be replaced
        """
        return pulumi.get(self, "target_ips")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[_builtins.str]:
        """
        Optional if `type`==`vpn`
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GatewayPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeDisableLacp":
            suggest = "ae_disable_lacp"
        elif key == "aeIdx":
            suggest = "ae_idx"
        elif key == "aeLacpForceUp":
            suggest = "ae_lacp_force_up"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dslType":
            suggest = "dsl_type"
        elif key == "dslVci":
            suggest = "dsl_vci"
        elif key == "dslVpi":
            suggest = "dsl_vpi"
        elif key == "ipConfig":
            suggest = "ip_config"
        elif key == "lteApn":
            suggest = "lte_apn"
        elif key == "lteAuth":
            suggest = "lte_auth"
        elif key == "lteBackup":
            suggest = "lte_backup"
        elif key == "ltePassword":
            suggest = "lte_password"
        elif key == "lteUsername":
            suggest = "lte_username"
        elif key == "outerVlanId":
            suggest = "outer_vlan_id"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "preserveDscp":
            suggest = "preserve_dscp"
        elif key == "redundantGroup":
            suggest = "redundant_group"
        elif key == "rethIdx":
            suggest = "reth_idx"
        elif key == "rethNode":
            suggest = "reth_node"
        elif key == "rethNodes":
            suggest = "reth_nodes"
        elif key == "ssrNoVirtualMac":
            suggest = "ssr_no_virtual_mac"
        elif key == "svrPortRange":
            suggest = "svr_port_range"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vpnPaths":
            suggest = "vpn_paths"
        elif key == "wanArpPolicer":
            suggest = "wan_arp_policer"
        elif key == "wanDisableSpeedtest":
            suggest = "wan_disable_speedtest"
        elif key == "wanExtIp":
            suggest = "wan_ext_ip"
        elif key == "wanExtraRoutes":
            suggest = "wan_extra_routes"
        elif key == "wanExtraRoutes6":
            suggest = "wan_extra_routes6"
        elif key == "wanNetworks":
            suggest = "wan_networks"
        elif key == "wanProbeOverride":
            suggest = "wan_probe_override"
        elif key == "wanSourceNat":
            suggest = "wan_source_nat"
        elif key == "wanType":
            suggest = "wan_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: _builtins.str,
                 ae_disable_lacp: Optional[_builtins.bool] = None,
                 ae_idx: Optional[_builtins.str] = None,
                 ae_lacp_force_up: Optional[_builtins.bool] = None,
                 aggregated: Optional[_builtins.bool] = None,
                 critical: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 dsl_type: Optional[_builtins.str] = None,
                 dsl_vci: Optional[_builtins.int] = None,
                 dsl_vpi: Optional[_builtins.int] = None,
                 duplex: Optional[_builtins.str] = None,
                 ip_config: Optional['outputs.GatewayPortConfigIpConfig'] = None,
                 lte_apn: Optional[_builtins.str] = None,
                 lte_auth: Optional[_builtins.str] = None,
                 lte_backup: Optional[_builtins.bool] = None,
                 lte_password: Optional[_builtins.str] = None,
                 lte_username: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 outer_vlan_id: Optional[_builtins.int] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_network: Optional[_builtins.str] = None,
                 preserve_dscp: Optional[_builtins.bool] = None,
                 redundant: Optional[_builtins.bool] = None,
                 redundant_group: Optional[_builtins.int] = None,
                 reth_idx: Optional[_builtins.str] = None,
                 reth_node: Optional[_builtins.str] = None,
                 reth_nodes: Optional[Sequence[_builtins.str]] = None,
                 speed: Optional[_builtins.str] = None,
                 ssr_no_virtual_mac: Optional[_builtins.bool] = None,
                 svr_port_range: Optional[_builtins.str] = None,
                 traffic_shaping: Optional['outputs.GatewayPortConfigTrafficShaping'] = None,
                 vlan_id: Optional[_builtins.str] = None,
                 vpn_paths: Optional[Mapping[str, 'outputs.GatewayPortConfigVpnPaths']] = None,
                 wan_arp_policer: Optional[_builtins.str] = None,
                 wan_disable_speedtest: Optional[_builtins.bool] = None,
                 wan_ext_ip: Optional[_builtins.str] = None,
                 wan_extra_routes: Optional[Mapping[str, 'outputs.GatewayPortConfigWanExtraRoutes']] = None,
                 wan_extra_routes6: Optional[Mapping[str, 'outputs.GatewayPortConfigWanExtraRoutes6']] = None,
                 wan_networks: Optional[Sequence[_builtins.str]] = None,
                 wan_probe_override: Optional['outputs.GatewayPortConfigWanProbeOverride'] = None,
                 wan_source_nat: Optional['outputs.GatewayPortConfigWanSourceNat'] = None,
                 wan_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        :param _builtins.bool ae_disable_lacp: If `aggregated`==`true`. To disable LCP support for the AE interface
        :param _builtins.str ae_idx: If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        :param _builtins.bool ae_lacp_force_up: For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        :param _builtins.bool critical: To generate port up/down alarm, set it to true
        :param _builtins.str description: Interface Description. Can be a variable (i.e. "{{myvar}}")
        :param _builtins.bool disabled: Port admin up (true) / down (false)
        :param _builtins.str dsl_type: if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        :param _builtins.int dsl_vci: If `wan_type`==`dsl`, 16 bit int
        :param _builtins.int dsl_vpi: If `wan_type`==`dsl`, 8 bit int
        :param _builtins.str duplex: enum: `auto`, `full`, `half`
        :param 'GatewayPortConfigIpConfigArgs' ip_config: Junos IP Config
        :param _builtins.str lte_apn: If `wan_type`==`lte`
        :param _builtins.str lte_auth: if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        :param _builtins.str lte_password: If `wan_type`==`lte`
        :param _builtins.str lte_username: If `wan_type`==`lte`
        :param _builtins.str name: Name that we'll use to derive config
        :param Sequence[_builtins.str] networks: if `usage`==`lan`, name of the `org.Network` resource
        :param _builtins.int outer_vlan_id: For Q-in-Q
        :param _builtins.str port_network: Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        :param _builtins.bool preserve_dscp: Whether to preserve dscp when sending traffic over VPN (SSR-only)
        :param _builtins.bool redundant: If HA mode
        :param _builtins.int redundant_group: If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        :param _builtins.str reth_idx: For SRX only and if HA Mode
        :param _builtins.str reth_node: If HA mode
        :param Sequence[_builtins.str] reth_nodes: SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        :param _builtins.bool ssr_no_virtual_mac: When SSR is running as VM, this is required on certain hosting platforms
        :param _builtins.str svr_port_range: For SSR only
        :param Mapping[str, 'GatewayPortConfigVpnPathsArgs'] vpn_paths: Property key is the VPN name
        :param _builtins.str wan_arp_policer: Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        :param _builtins.bool wan_disable_speedtest: If `wan_type`==`wan`, disable speedtest
        :param _builtins.str wan_ext_ip: Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        :param Mapping[str, 'GatewayPortConfigWanExtraRoutesArgs'] wan_extra_routes: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        :param Mapping[str, 'GatewayPortConfigWanExtraRoutes6Args'] wan_extra_routes6: Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        :param Sequence[_builtins.str] wan_networks: Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        :param 'GatewayPortConfigWanProbeOverrideArgs' wan_probe_override: Only if `usage`==`wan`
        :param 'GatewayPortConfigWanSourceNatArgs' wan_source_nat: Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        :param _builtins.str wan_type: Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_force_up is not None:
            pulumi.set(__self__, "ae_lacp_force_up", ae_lacp_force_up)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dsl_type is not None:
            pulumi.set(__self__, "dsl_type", dsl_type)
        if dsl_vci is not None:
            pulumi.set(__self__, "dsl_vci", dsl_vci)
        if dsl_vpi is not None:
            pulumi.set(__self__, "dsl_vpi", dsl_vpi)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if lte_apn is not None:
            pulumi.set(__self__, "lte_apn", lte_apn)
        if lte_auth is not None:
            pulumi.set(__self__, "lte_auth", lte_auth)
        if lte_backup is not None:
            pulumi.set(__self__, "lte_backup", lte_backup)
        if lte_password is not None:
            pulumi.set(__self__, "lte_password", lte_password)
        if lte_username is not None:
            pulumi.set(__self__, "lte_username", lte_username)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if outer_vlan_id is not None:
            pulumi.set(__self__, "outer_vlan_id", outer_vlan_id)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if preserve_dscp is not None:
            pulumi.set(__self__, "preserve_dscp", preserve_dscp)
        if redundant is not None:
            pulumi.set(__self__, "redundant", redundant)
        if redundant_group is not None:
            pulumi.set(__self__, "redundant_group", redundant_group)
        if reth_idx is not None:
            pulumi.set(__self__, "reth_idx", reth_idx)
        if reth_node is not None:
            pulumi.set(__self__, "reth_node", reth_node)
        if reth_nodes is not None:
            pulumi.set(__self__, "reth_nodes", reth_nodes)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssr_no_virtual_mac is not None:
            pulumi.set(__self__, "ssr_no_virtual_mac", ssr_no_virtual_mac)
        if svr_port_range is not None:
            pulumi.set(__self__, "svr_port_range", svr_port_range)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)
        if wan_arp_policer is not None:
            pulumi.set(__self__, "wan_arp_policer", wan_arp_policer)
        if wan_disable_speedtest is not None:
            pulumi.set(__self__, "wan_disable_speedtest", wan_disable_speedtest)
        if wan_ext_ip is not None:
            pulumi.set(__self__, "wan_ext_ip", wan_ext_ip)
        if wan_extra_routes is not None:
            pulumi.set(__self__, "wan_extra_routes", wan_extra_routes)
        if wan_extra_routes6 is not None:
            pulumi.set(__self__, "wan_extra_routes6", wan_extra_routes6)
        if wan_networks is not None:
            pulumi.set(__self__, "wan_networks", wan_networks)
        if wan_probe_override is not None:
            pulumi.set(__self__, "wan_probe_override", wan_probe_override)
        if wan_source_nat is not None:
            pulumi.set(__self__, "wan_source_nat", wan_source_nat)
        if wan_type is not None:
            pulumi.set(__self__, "wan_type", wan_type)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[_builtins.bool]:
        """
        If `aggregated`==`true`. To disable LCP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @_builtins.property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[_builtins.str]:
        """
        If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        return pulumi.get(self, "ae_idx")

    @_builtins.property
    @pulumi.getter(name="aeLacpForceUp")
    def ae_lacp_force_up(self) -> Optional[_builtins.bool]:
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        return pulumi.get(self, "ae_lacp_force_up")

    @_builtins.property
    @pulumi.getter
    def aggregated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aggregated")

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[_builtins.bool]:
        """
        To generate port up/down alarm, set it to true
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Interface Description. Can be a variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Port admin up (true) / down (false)
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="dslType")
    def dsl_type(self) -> Optional[_builtins.str]:
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        return pulumi.get(self, "dsl_type")

    @_builtins.property
    @pulumi.getter(name="dslVci")
    def dsl_vci(self) -> Optional[_builtins.int]:
        """
        If `wan_type`==`dsl`, 16 bit int
        """
        return pulumi.get(self, "dsl_vci")

    @_builtins.property
    @pulumi.getter(name="dslVpi")
    def dsl_vpi(self) -> Optional[_builtins.int]:
        """
        If `wan_type`==`dsl`, 8 bit int
        """
        return pulumi.get(self, "dsl_vpi")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional['outputs.GatewayPortConfigIpConfig']:
        """
        Junos IP Config
        """
        return pulumi.get(self, "ip_config")

    @_builtins.property
    @pulumi.getter(name="lteApn")
    def lte_apn(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_apn")

    @_builtins.property
    @pulumi.getter(name="lteAuth")
    def lte_auth(self) -> Optional[_builtins.str]:
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "lte_auth")

    @_builtins.property
    @pulumi.getter(name="lteBackup")
    def lte_backup(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "lte_backup")

    @_builtins.property
    @pulumi.getter(name="ltePassword")
    def lte_password(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_password")

    @_builtins.property
    @pulumi.getter(name="lteUsername")
    def lte_username(self) -> Optional[_builtins.str]:
        """
        If `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_username")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name that we'll use to derive config
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        if `usage`==`lan`, name of the `org.Network` resource
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="outerVlanId")
    def outer_vlan_id(self) -> Optional[_builtins.int]:
        """
        For Q-in-Q
        """
        return pulumi.get(self, "outer_vlan_id")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter(name="preserveDscp")
    def preserve_dscp(self) -> Optional[_builtins.bool]:
        """
        Whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        return pulumi.get(self, "preserve_dscp")

    @_builtins.property
    @pulumi.getter
    def redundant(self) -> Optional[_builtins.bool]:
        """
        If HA mode
        """
        return pulumi.get(self, "redundant")

    @_builtins.property
    @pulumi.getter(name="redundantGroup")
    def redundant_group(self) -> Optional[_builtins.int]:
        """
        If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX
        """
        return pulumi.get(self, "redundant_group")

    @_builtins.property
    @pulumi.getter(name="rethIdx")
    def reth_idx(self) -> Optional[_builtins.str]:
        """
        For SRX only and if HA Mode
        """
        return pulumi.get(self, "reth_idx")

    @_builtins.property
    @pulumi.getter(name="rethNode")
    def reth_node(self) -> Optional[_builtins.str]:
        """
        If HA mode
        """
        return pulumi.get(self, "reth_node")

    @_builtins.property
    @pulumi.getter(name="rethNodes")
    def reth_nodes(self) -> Optional[Sequence[_builtins.str]]:
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        return pulumi.get(self, "reth_nodes")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="ssrNoVirtualMac")
    def ssr_no_virtual_mac(self) -> Optional[_builtins.bool]:
        """
        When SSR is running as VM, this is required on certain hosting platforms
        """
        return pulumi.get(self, "ssr_no_virtual_mac")

    @_builtins.property
    @pulumi.getter(name="svrPortRange")
    def svr_port_range(self) -> Optional[_builtins.str]:
        """
        For SSR only
        """
        return pulumi.get(self, "svr_port_range")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.GatewayPortConfigTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[Mapping[str, 'outputs.GatewayPortConfigVpnPaths']]:
        """
        Property key is the VPN name
        """
        return pulumi.get(self, "vpn_paths")

    @_builtins.property
    @pulumi.getter(name="wanArpPolicer")
    def wan_arp_policer(self) -> Optional[_builtins.str]:
        """
        Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        return pulumi.get(self, "wan_arp_policer")

    @_builtins.property
    @pulumi.getter(name="wanDisableSpeedtest")
    def wan_disable_speedtest(self) -> Optional[_builtins.bool]:
        """
        If `wan_type`==`wan`, disable speedtest
        """
        return pulumi.get(self, "wan_disable_speedtest")

    @_builtins.property
    @pulumi.getter(name="wanExtIp")
    def wan_ext_ip(self) -> Optional[_builtins.str]:
        """
        Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP
        """
        return pulumi.get(self, "wan_ext_ip")

    @_builtins.property
    @pulumi.getter(name="wanExtraRoutes")
    def wan_extra_routes(self) -> Optional[Mapping[str, 'outputs.GatewayPortConfigWanExtraRoutes']]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "100.100.100.0/24")
        """
        return pulumi.get(self, "wan_extra_routes")

    @_builtins.property
    @pulumi.getter(name="wanExtraRoutes6")
    def wan_extra_routes6(self) -> Optional[Mapping[str, 'outputs.GatewayPortConfigWanExtraRoutes6']]:
        """
        Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        return pulumi.get(self, "wan_extra_routes6")

    @_builtins.property
    @pulumi.getter(name="wanNetworks")
    def wan_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined
        """
        return pulumi.get(self, "wan_networks")

    @_builtins.property
    @pulumi.getter(name="wanProbeOverride")
    def wan_probe_override(self) -> Optional['outputs.GatewayPortConfigWanProbeOverride']:
        """
        Only if `usage`==`wan`
        """
        return pulumi.get(self, "wan_probe_override")

    @_builtins.property
    @pulumi.getter(name="wanSourceNat")
    def wan_source_nat(self) -> Optional['outputs.GatewayPortConfigWanSourceNat']:
        """
        Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        return pulumi.get(self, "wan_source_nat")

    @_builtins.property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> Optional[_builtins.str]:
        """
        Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        return pulumi.get(self, "wan_type")


@pulumi.output_type
class GatewayPortConfigIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "poserPassword":
            suggest = "poser_password"
        elif key == "pppoeAuth":
            suggest = "pppoe_auth"
        elif key == "pppoeUsername":
            suggest = "pppoe_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfigIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfigIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfigIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 poser_password: Optional[_builtins.str] = None,
                 pppoe_auth: Optional[_builtins.str] = None,
                 pppoe_username: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dns: Except for out-of_band interface (vme/em0/fxp0)
        :param Sequence[_builtins.str] dns_suffixes: Except for out-of_band interface (vme/em0/fxp0)
        :param _builtins.str gateway: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str gateway6: Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IPv6 Address (i.e. "2001:db8::1") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str ip: Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str ip6: Interface IPv6 Address (i.e. "2001:db8::123") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str netmask6: Used only if `subnet` is not specified in `networks`. Interface IPv6 Netmask (i.e. "/64") or a Variable (i.e. "{{myvar}}")
        :param _builtins.str network: Optional, the network to be used for mgmt
        :param _builtins.str poser_password: If `type`==`pppoe`
        :param _builtins.str pppoe_auth: if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        :param _builtins.str pppoe_username: If `type`==`pppoe`
        :param _builtins.str type: enum: `dhcp`, `pppoe`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if poser_password is not None:
            pulumi.set(__self__, "poser_password", poser_password)
        if pppoe_auth is not None:
            pulumi.set(__self__, "pppoe_auth", pppoe_auth)
        if pppoe_username is not None:
            pulumi.set(__self__, "pppoe_username", pppoe_username)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. "192.168.1.1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        """
        Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IPv6 Address (i.e. "2001:db8::1") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Interface IP Address (i.e. "192.168.1.8") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        """
        Interface IPv6 Address (i.e. "2001:db8::123") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. "/24") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`. Interface IPv6 Netmask (i.e. "/64") or a Variable (i.e. "{{myvar}}")
        """
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="poserPassword")
    def poser_password(self) -> Optional[_builtins.str]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "poser_password")

    @_builtins.property
    @pulumi.getter(name="pppoeAuth")
    def pppoe_auth(self) -> Optional[_builtins.str]:
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "pppoe_auth")

    @_builtins.property
    @pulumi.getter(name="pppoeUsername")
    def pppoe_username(self) -> Optional[_builtins.str]:
        """
        If `type`==`pppoe`
        """
        return pulumi.get(self, "pppoe_username")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `pppoe`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class GatewayPortConfigTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfigTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfigTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfigTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param _builtins.int max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class GatewayPortConfigVpnPaths(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bfdProfile":
            suggest = "bfd_profile"
        elif key == "bfdUseTunnelMode":
            suggest = "bfd_use_tunnel_mode"
        elif key == "trafficShaping":
            suggest = "traffic_shaping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfigVpnPaths. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfigVpnPaths.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfigVpnPaths.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bfd_profile: Optional[_builtins.str] = None,
                 bfd_use_tunnel_mode: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None,
                 role: Optional[_builtins.str] = None,
                 traffic_shaping: Optional['outputs.GatewayPortConfigVpnPathsTrafficShaping'] = None):
        """
        :param _builtins.str bfd_profile: Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        :param _builtins.bool bfd_use_tunnel_mode: Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        :param _builtins.int preference: Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        :param _builtins.str role: If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @_builtins.property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[_builtins.str]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @_builtins.property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[_builtins.bool]:
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        return pulumi.get(self, "preference")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional['outputs.GatewayPortConfigVpnPathsTrafficShaping']:
        return pulumi.get(self, "traffic_shaping")


@pulumi.output_type
class GatewayPortConfigVpnPathsTrafficShaping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classPercentages":
            suggest = "class_percentages"
        elif key == "maxTxKbps":
            suggest = "max_tx_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfigVpnPathsTrafficShaping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfigVpnPathsTrafficShaping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfigVpnPathsTrafficShaping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_percentages: Optional[Sequence[_builtins.int]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 max_tx_kbps: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] class_percentages: percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        :param _builtins.int max_tx_kbps: Interface Transmit Cap in kbps
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_tx_kbps is not None:
            pulumi.set(__self__, "max_tx_kbps", max_tx_kbps)

    @_builtins.property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[Sequence[_builtins.int]]:
        """
        percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxTxKbps")
    def max_tx_kbps(self) -> Optional[_builtins.int]:
        """
        Interface Transmit Cap in kbps
        """
        return pulumi.get(self, "max_tx_kbps")


@pulumi.output_type
class GatewayPortConfigWanExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewayPortConfigWanExtraRoutes(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "via")


@pulumi.output_type
class GatewayPortConfigWanProbeOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeProfile":
            suggest = "probe_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfigWanProbeOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfigWanProbeOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfigWanProbeOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip6s: Optional[Sequence[_builtins.str]] = None,
                 ips: Optional[Sequence[_builtins.str]] = None,
                 probe_profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str probe_profile: enum: `broadband`, `lte`
        """
        if ip6s is not None:
            pulumi.set(__self__, "ip6s", ip6s)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if probe_profile is not None:
            pulumi.set(__self__, "probe_profile", probe_profile)

    @_builtins.property
    @pulumi.getter
    def ip6s(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip6s")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="probeProfile")
    def probe_profile(self) -> Optional[_builtins.str]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "probe_profile")


@pulumi.output_type
class GatewayPortConfigWanSourceNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "natPool":
            suggest = "nat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortConfigWanSourceNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortConfigWanSourceNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortConfigWanSourceNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 nat_pool: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Or to disable the source-nat
        :param _builtins.str nat_pool: If alternative nat_pool is desired
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Or to disable the source-nat
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[_builtins.str]:
        """
        If alternative nat_pool is desired
        """
        return pulumi.get(self, "nat_pool")


@pulumi.output_type
class GatewayPortMirroring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portMirror":
            suggest = "port_mirror"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortMirroring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortMirroring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortMirroring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_mirror: Optional['outputs.GatewayPortMirroringPortMirror'] = None):
        if port_mirror is not None:
            pulumi.set(__self__, "port_mirror", port_mirror)

    @_builtins.property
    @pulumi.getter(name="portMirror")
    def port_mirror(self) -> Optional['outputs.GatewayPortMirroringPortMirror']:
        return pulumi.get(self, "port_mirror")


@pulumi.output_type
class GatewayPortMirroringPortMirror(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "familyType":
            suggest = "family_type"
        elif key == "ingressPortIds":
            suggest = "ingress_port_ids"
        elif key == "outputPortId":
            suggest = "output_port_id"
        elif key == "runLength":
            suggest = "run_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPortMirroringPortMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPortMirroringPortMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPortMirroringPortMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 family_type: Optional[_builtins.str] = None,
                 ingress_port_ids: Optional[Sequence[_builtins.str]] = None,
                 output_port_id: Optional[_builtins.str] = None,
                 rate: Optional[_builtins.int] = None,
                 run_length: Optional[_builtins.int] = None):
        if family_type is not None:
            pulumi.set(__self__, "family_type", family_type)
        if ingress_port_ids is not None:
            pulumi.set(__self__, "ingress_port_ids", ingress_port_ids)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if run_length is not None:
            pulumi.set(__self__, "run_length", run_length)

    @_builtins.property
    @pulumi.getter(name="familyType")
    def family_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "family_type")

    @_builtins.property
    @pulumi.getter(name="ingressPortIds")
    def ingress_port_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ingress_port_ids")

    @_builtins.property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "output_port_id")

    @_builtins.property
    @pulumi.getter
    def rate(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "rate")

    @_builtins.property
    @pulumi.getter(name="runLength")
    def run_length(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "run_length")


@pulumi.output_type
class GatewayRoutingPolicies(dict):
    def __init__(__self__, *,
                 terms: Optional[Sequence['outputs.GatewayRoutingPoliciesTerm']] = None):
        """
        :param Sequence['GatewayRoutingPoliciesTermArgs'] terms: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @_builtins.property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GatewayRoutingPoliciesTerm']]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "terms")


@pulumi.output_type
class GatewayRoutingPoliciesTerm(dict):
    def __init__(__self__, *,
                 actions: Optional['outputs.GatewayRoutingPoliciesTermActions'] = None,
                 matching: Optional['outputs.GatewayRoutingPoliciesTermMatching'] = None):
        """
        :param 'GatewayRoutingPoliciesTermActionsArgs' actions: When used as import policy
        :param 'GatewayRoutingPoliciesTermMatchingArgs' matching: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GatewayRoutingPoliciesTermActions']:
        """
        When used as import policy
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def matching(self) -> Optional['outputs.GatewayRoutingPoliciesTermMatching']:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "matching")


@pulumi.output_type
class GatewayRoutingPoliciesTermActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addCommunities":
            suggest = "add_communities"
        elif key == "addTargetVrfs":
            suggest = "add_target_vrfs"
        elif key == "excludeAsPaths":
            suggest = "exclude_as_paths"
        elif key == "excludeCommunities":
            suggest = "exclude_communities"
        elif key == "exportCommunities":
            suggest = "export_communities"
        elif key == "localPreference":
            suggest = "local_preference"
        elif key == "prependAsPaths":
            suggest = "prepend_as_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRoutingPoliciesTermActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRoutingPoliciesTermActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRoutingPoliciesTermActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accept: Optional[_builtins.bool] = None,
                 add_communities: Optional[Sequence[_builtins.str]] = None,
                 add_target_vrfs: Optional[Sequence[_builtins.str]] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 exclude_as_paths: Optional[Sequence[_builtins.str]] = None,
                 exclude_communities: Optional[Sequence[_builtins.str]] = None,
                 export_communities: Optional[Sequence[_builtins.str]] = None,
                 local_preference: Optional[_builtins.str] = None,
                 prepend_as_paths: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] add_target_vrfs: For SSR, hub decides how VRF routes are leaked on spoke
        :param Sequence[_builtins.str] communities: When used as export policy, optional
        :param Sequence[_builtins.str] exclude_as_paths: When used as export policy, optional. To exclude certain AS
        :param Sequence[_builtins.str] export_communities: When used as export policy, optional
        :param _builtins.str local_preference: Optional, for an import policy, local_preference can be changed
        :param Sequence[_builtins.str] prepend_as_paths: When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if add_communities is not None:
            pulumi.set(__self__, "add_communities", add_communities)
        if add_target_vrfs is not None:
            pulumi.set(__self__, "add_target_vrfs", add_target_vrfs)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if exclude_as_paths is not None:
            pulumi.set(__self__, "exclude_as_paths", exclude_as_paths)
        if exclude_communities is not None:
            pulumi.set(__self__, "exclude_communities", exclude_communities)
        if export_communities is not None:
            pulumi.set(__self__, "export_communities", export_communities)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if prepend_as_paths is not None:
            pulumi.set(__self__, "prepend_as_paths", prepend_as_paths)

    @_builtins.property
    @pulumi.getter
    def accept(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "accept")

    @_builtins.property
    @pulumi.getter(name="addCommunities")
    def add_communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "add_communities")

    @_builtins.property
    @pulumi.getter(name="addTargetVrfs")
    def add_target_vrfs(self) -> Optional[Sequence[_builtins.str]]:
        """
        For SSR, hub decides how VRF routes are leaked on spoke
        """
        return pulumi.get(self, "add_target_vrfs")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter(name="excludeAsPaths")
    def exclude_as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional. To exclude certain AS
        """
        return pulumi.get(self, "exclude_as_paths")

    @_builtins.property
    @pulumi.getter(name="excludeCommunities")
    def exclude_communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_communities")

    @_builtins.property
    @pulumi.getter(name="exportCommunities")
    def export_communities(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional
        """
        return pulumi.get(self, "export_communities")

    @_builtins.property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[_builtins.str]:
        """
        Optional, for an import policy, local_preference can be changed
        """
        return pulumi.get(self, "local_preference")

    @_builtins.property
    @pulumi.getter(name="prependAsPaths")
    def prepend_as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        When used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        return pulumi.get(self, "prepend_as_paths")


@pulumi.output_type
class GatewayRoutingPoliciesTermMatching(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asPaths":
            suggest = "as_paths"
        elif key == "routeExists":
            suggest = "route_exists"
        elif key == "vpnNeighborMacs":
            suggest = "vpn_neighbor_macs"
        elif key == "vpnPathSla":
            suggest = "vpn_path_sla"
        elif key == "vpnPaths":
            suggest = "vpn_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRoutingPoliciesTermMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRoutingPoliciesTermMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRoutingPoliciesTermMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 as_paths: Optional[Sequence[_builtins.str]] = None,
                 communities: Optional[Sequence[_builtins.str]] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 prefixes: Optional[Sequence[_builtins.str]] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 route_exists: Optional['outputs.GatewayRoutingPoliciesTermMatchingRouteExists'] = None,
                 vpn_neighbor_macs: Optional[Sequence[_builtins.str]] = None,
                 vpn_path_sla: Optional['outputs.GatewayRoutingPoliciesTermMatchingVpnPathSla'] = None,
                 vpn_paths: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] as_paths: takes regular expression
        :param Sequence[_builtins.str] prefixes: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        :param Sequence[_builtins.str] protocols: `direct`, `bgp`, `osp`, `static`, `aggregate`...
        :param Sequence[_builtins.str] vpn_neighbor_macs: overlay-facing criteria (used for bgp_config where via=vpn)
        :param Sequence[_builtins.str] vpn_paths: overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_exists is not None:
            pulumi.set(__self__, "route_exists", route_exists)
        if vpn_neighbor_macs is not None:
            pulumi.set(__self__, "vpn_neighbor_macs", vpn_neighbor_macs)
        if vpn_path_sla is not None:
            pulumi.set(__self__, "vpn_path_sla", vpn_path_sla)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)

    @_builtins.property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        takes regular expression
        """
        return pulumi.get(self, "as_paths")

    @_builtins.property
    @pulumi.getter
    def communities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "communities")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "prefixes")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        `direct`, `bgp`, `osp`, `static`, `aggregate`...
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeExists")
    def route_exists(self) -> Optional['outputs.GatewayRoutingPoliciesTermMatchingRouteExists']:
        return pulumi.get(self, "route_exists")

    @_builtins.property
    @pulumi.getter(name="vpnNeighborMacs")
    def vpn_neighbor_macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        return pulumi.get(self, "vpn_neighbor_macs")

    @_builtins.property
    @pulumi.getter(name="vpnPathSla")
    def vpn_path_sla(self) -> Optional['outputs.GatewayRoutingPoliciesTermMatchingVpnPathSla']:
        return pulumi.get(self, "vpn_path_sla")

    @_builtins.property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn). ordered-
        """
        return pulumi.get(self, "vpn_paths")


@pulumi.output_type
class GatewayRoutingPoliciesTermMatchingRouteExists(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vrfName":
            suggest = "vrf_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRoutingPoliciesTermMatchingRouteExists. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRoutingPoliciesTermMatchingRouteExists.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRoutingPoliciesTermMatchingRouteExists.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route: Optional[_builtins.str] = None,
                 vrf_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str vrf_name: Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        if route is not None:
            pulumi.set(__self__, "route", route)
        if vrf_name is not None:
            pulumi.set(__self__, "vrf_name", vrf_name)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> Optional[_builtins.str]:
        """
        Name of the vrf instance, it can also be the name of the VPN or wan if they
        """
        return pulumi.get(self, "vrf_name")


@pulumi.output_type
class GatewayRoutingPoliciesTermMatchingVpnPathSla(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxJitter":
            suggest = "max_jitter"
        elif key == "maxLatency":
            suggest = "max_latency"
        elif key == "maxLoss":
            suggest = "max_loss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRoutingPoliciesTermMatchingVpnPathSla. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRoutingPoliciesTermMatchingVpnPathSla.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRoutingPoliciesTermMatchingVpnPathSla.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_jitter: Optional[_builtins.int] = None,
                 max_latency: Optional[_builtins.int] = None,
                 max_loss: Optional[_builtins.int] = None):
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)

    @_builtins.property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_jitter")

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_latency")

    @_builtins.property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_loss")


@pulumi.output_type
class GatewayServicePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localRouting":
            suggest = "local_routing"
        elif key == "pathPreference":
            suggest = "path_preference"
        elif key == "servicepolicyId":
            suggest = "servicepolicy_id"
        elif key == "sslProxy":
            suggest = "ssl_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayServicePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayServicePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayServicePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 antivirus: Optional['outputs.GatewayServicePolicyAntivirus'] = None,
                 appqoe: Optional['outputs.GatewayServicePolicyAppqoe'] = None,
                 ewfs: Optional[Sequence['outputs.GatewayServicePolicyEwf']] = None,
                 idp: Optional['outputs.GatewayServicePolicyIdp'] = None,
                 local_routing: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path_preference: Optional[_builtins.str] = None,
                 servicepolicy_id: Optional[_builtins.str] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 ssl_proxy: Optional['outputs.GatewayServicePolicySslProxy'] = None,
                 tenants: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str action: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        :param 'GatewayServicePolicyAntivirusArgs' antivirus: For SRX-only
        :param 'GatewayServicePolicyAppqoeArgs' appqoe: For SRX Only
        :param _builtins.bool local_routing: access within the same VRF
        :param _builtins.str name: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        :param _builtins.str path_preference: By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        :param _builtins.str servicepolicy_id: Used to link servicepolicy defined at org level and overwrite some attributes
        :param Sequence[_builtins.str] services: Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        :param 'GatewayServicePolicySslProxyArgs' ssl_proxy: For SRX-only
        :param Sequence[_builtins.str] tenants: Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if appqoe is not None:
            pulumi.set(__self__, "appqoe", appqoe)
        if ewfs is not None:
            pulumi.set(__self__, "ewfs", ewfs)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if local_routing is not None:
            pulumi.set(__self__, "local_routing", local_routing)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_preference is not None:
            pulumi.set(__self__, "path_preference", path_preference)
        if servicepolicy_id is not None:
            pulumi.set(__self__, "servicepolicy_id", servicepolicy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssl_proxy is not None:
            pulumi.set(__self__, "ssl_proxy", ssl_proxy)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional['outputs.GatewayServicePolicyAntivirus']:
        """
        For SRX-only
        """
        return pulumi.get(self, "antivirus")

    @_builtins.property
    @pulumi.getter
    def appqoe(self) -> Optional['outputs.GatewayServicePolicyAppqoe']:
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @_builtins.property
    @pulumi.getter
    def ewfs(self) -> Optional[Sequence['outputs.GatewayServicePolicyEwf']]:
        return pulumi.get(self, "ewfs")

    @_builtins.property
    @pulumi.getter
    def idp(self) -> Optional['outputs.GatewayServicePolicyIdp']:
        return pulumi.get(self, "idp")

    @_builtins.property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> Optional[_builtins.bool]:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> Optional[_builtins.str]:
        """
        By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @_builtins.property
    @pulumi.getter(name="servicepolicyId")
    def servicepolicy_id(self) -> Optional[_builtins.str]:
        """
        Used to link servicepolicy defined at org level and overwrite some attributes
        """
        return pulumi.get(self, "servicepolicy_id")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Destinations
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sslProxy")
    def ssl_proxy(self) -> Optional['outputs.GatewayServicePolicySslProxy']:
        """
        For SRX-only
        """
        return pulumi.get(self, "ssl_proxy")

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        return pulumi.get(self, "tenants")


@pulumi.output_type
class GatewayServicePolicyAntivirus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avprofileId":
            suggest = "avprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayServicePolicyAntivirus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayServicePolicyAntivirus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayServicePolicyAntivirus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avprofile_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str avprofile_id: org-level AV Profile can be used, this takes precedence over 'profile'
        :param _builtins.str profile: Default / noftp / httponly / or keys from av_profiles
        """
        if avprofile_id is not None:
            pulumi.set(__self__, "avprofile_id", avprofile_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="avprofileId")
    def avprofile_id(self) -> Optional[_builtins.str]:
        """
        org-level AV Profile can be used, this takes precedence over 'profile'
        """
        return pulumi.get(self, "avprofile_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        Default / noftp / httponly / or keys from av_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GatewayServicePolicyAppqoe(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewayServicePolicyEwf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "blockMessage":
            suggest = "block_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayServicePolicyEwf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayServicePolicyEwf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayServicePolicyEwf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 block_message: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "block_message")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GatewayServicePolicyIdp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnly":
            suggest = "alert_only"
        elif key == "idpprofileId":
            suggest = "idpprofile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayServicePolicyIdp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayServicePolicyIdp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayServicePolicyIdp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_only: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 idpprofile_id: Optional[_builtins.str] = None,
                 profile: Optional[_builtins.str] = None):
        """
        :param _builtins.str idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param _builtins.str profile: enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @_builtins.property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_only")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[_builtins.str]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @_builtins.property
    @pulumi.getter
    def profile(self) -> Optional[_builtins.str]:
        """
        enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class GatewayServicePolicySslProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ciphersCategory":
            suggest = "ciphers_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayServicePolicySslProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayServicePolicySslProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayServicePolicySslProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ciphers_category: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ciphers_category: enum: `medium`, `strong`, `weak`
        """
        if ciphers_category is not None:
            pulumi.set(__self__, "ciphers_category", ciphers_category)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="ciphersCategory")
    def ciphers_category(self) -> Optional[_builtins.str]:
        """
        enum: `medium`, `strong`, `weak`
        """
        return pulumi.get(self, "ciphers_category")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewayTunnelConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoProvision":
            suggest = "auto_provision"
        elif key == "ikeLifetime":
            suggest = "ike_lifetime"
        elif key == "ikeMode":
            suggest = "ike_mode"
        elif key == "ikeProposals":
            suggest = "ike_proposals"
        elif key == "ipsecLifetime":
            suggest = "ipsec_lifetime"
        elif key == "ipsecProposals":
            suggest = "ipsec_proposals"
        elif key == "localId":
            suggest = "local_id"
        elif key == "localSubnets":
            suggest = "local_subnets"
        elif key == "remoteSubnets":
            suggest = "remote_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_provision: Optional['outputs.GatewayTunnelConfigsAutoProvision'] = None,
                 ike_lifetime: Optional[_builtins.int] = None,
                 ike_mode: Optional[_builtins.str] = None,
                 ike_proposals: Optional[Sequence['outputs.GatewayTunnelConfigsIkeProposal']] = None,
                 ipsec_lifetime: Optional[_builtins.int] = None,
                 ipsec_proposals: Optional[Sequence['outputs.GatewayTunnelConfigsIpsecProposal']] = None,
                 local_id: Optional[_builtins.str] = None,
                 local_subnets: Optional[Sequence[_builtins.str]] = None,
                 mode: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 primary: Optional['outputs.GatewayTunnelConfigsPrimary'] = None,
                 probe: Optional['outputs.GatewayTunnelConfigsProbe'] = None,
                 protocol: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 psk: Optional[_builtins.str] = None,
                 remote_subnets: Optional[Sequence[_builtins.str]] = None,
                 secondary: Optional['outputs.GatewayTunnelConfigsSecondary'] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param 'GatewayTunnelConfigsAutoProvisionArgs' auto_provision: Auto Provisioning configuration for the tunne. This takes precedence over the `primary` and `secondary` nodes.
        :param _builtins.int ike_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param _builtins.str ike_mode: Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        :param Sequence['GatewayTunnelConfigsIkeProposalArgs'] ike_proposals: If `provider`==`custom-ipsec`
        :param _builtins.int ipsec_lifetime: Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        :param Sequence['GatewayTunnelConfigsIpsecProposalArgs'] ipsec_proposals: Only if  `provider`==`custom-ipsec`
        :param _builtins.str local_id: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param Sequence[_builtins.str] local_subnets: List of Local protected subnet for policy-based IPSec negotiation
        :param _builtins.str mode: Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        :param Sequence[_builtins.str] networks: If `provider`==`custom-ipsec` or `provider`==`prisma-ipsec`, networks reachable via this tunnel
        :param 'GatewayTunnelConfigsPrimaryArgs' primary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param 'GatewayTunnelConfigsProbeArgs' probe: Only if `provider`==`custom-ipsec`
        :param _builtins.str protocol: Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        :param _builtins.str provider: Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `prisma-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        :param _builtins.str psk: Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param Sequence[_builtins.str] remote_subnets: List of Remote protected subnet for policy-based IPSec negotiation
        :param 'GatewayTunnelConfigsSecondaryArgs' secondary: Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        :param _builtins.str version: Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        if auto_provision is not None:
            pulumi.set(__self__, "auto_provision", auto_provision)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_mode is not None:
            pulumi.set(__self__, "ike_mode", ike_mode)
        if ike_proposals is not None:
            pulumi.set(__self__, "ike_proposals", ike_proposals)
        if ipsec_lifetime is not None:
            pulumi.set(__self__, "ipsec_lifetime", ipsec_lifetime)
        if ipsec_proposals is not None:
            pulumi.set(__self__, "ipsec_proposals", ipsec_proposals)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if local_subnets is not None:
            pulumi.set(__self__, "local_subnets", local_subnets)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if probe is not None:
            pulumi.set(__self__, "probe", probe)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if remote_subnets is not None:
            pulumi.set(__self__, "remote_subnets", remote_subnets)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> Optional['outputs.GatewayTunnelConfigsAutoProvision']:
        """
        Auto Provisioning configuration for the tunne. This takes precedence over the `primary` and `secondary` nodes.
        """
        return pulumi.get(self, "auto_provision")

    @_builtins.property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[_builtins.int]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ike_lifetime")

    @_builtins.property
    @pulumi.getter(name="ikeMode")
    def ike_mode(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`
        """
        return pulumi.get(self, "ike_mode")

    @_builtins.property
    @pulumi.getter(name="ikeProposals")
    def ike_proposals(self) -> Optional[Sequence['outputs.GatewayTunnelConfigsIkeProposal']]:
        """
        If `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ike_proposals")

    @_builtins.property
    @pulumi.getter(name="ipsecLifetime")
    def ipsec_lifetime(self) -> Optional[_builtins.int]:
        """
        Only if `provider`==`custom-ipsec`. Must be between 180 and 86400
        """
        return pulumi.get(self, "ipsec_lifetime")

    @_builtins.property
    @pulumi.getter(name="ipsecProposals")
    def ipsec_proposals(self) -> Optional[Sequence['outputs.GatewayTunnelConfigsIpsecProposal']]:
        """
        Only if  `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "ipsec_proposals")

    @_builtins.property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "local_id")

    @_builtins.property
    @pulumi.getter(name="localSubnets")
    def local_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Local protected subnet for policy-based IPSec negotiation
        """
        return pulumi.get(self, "local_subnets")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `provider`==`custom-ipsec` or `provider`==`prisma-ipsec`, networks reachable via this tunnel
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.GatewayTunnelConfigsPrimary']:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def probe(self) -> Optional['outputs.GatewayTunnelConfigsProbe']:
        """
        Only if `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "probe")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `custom-gre`, `jse-ipsec`, `prisma-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def psk(self) -> Optional[_builtins.str]:
        """
        Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "psk")

    @_builtins.property
    @pulumi.getter(name="remoteSubnets")
    def remote_subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Remote protected subnet for policy-based IPSec negotiation
        """
        return pulumi.get(self, "remote_subnets")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.GatewayTunnelConfigsSecondary']:
        """
        Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GatewayTunnelConfigsAutoProvision(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConnection":
            suggest = "service_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsAutoProvision. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsAutoProvision.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsAutoProvision.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider: _builtins.str,
                 enabled: Optional[_builtins.bool] = None,
                 latlng: Optional['outputs.GatewayTunnelConfigsAutoProvisionLatlng'] = None,
                 primary: Optional['outputs.GatewayTunnelConfigsAutoProvisionPrimary'] = None,
                 region: Optional[_builtins.str] = None,
                 secondary: Optional['outputs.GatewayTunnelConfigsAutoProvisionSecondary'] = None,
                 service_connection: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider: enum: `jse-ipsec`, `zscaler-ipsec`
        :param _builtins.bool enabled: Enable auto provisioning for the tunnel. If enabled, the `primary` and `secondary` nodes will be ignored.
        :param 'GatewayTunnelConfigsAutoProvisionLatlngArgs' latlng: API override for POP selection
        :param _builtins.str region: API override for POP selection in the case user wants to override the auto discovery of remote network location and force the tunnel to use the specified peer location.
        :param _builtins.str service_connection: if `provider`==`prisma-ipsec`. By default, we'll use the location of the site to determine the optimal Remote Network location, optionally, service_connection can be considered, then we'll also consider this along with the site location. Define service_connection if the traffic is to be routed to a specific service connection. This field takes a service connection name that is configured in the Prisma cloud, Prisma Access Setup > Service Connections.
        """
        pulumi.set(__self__, "provider", provider)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if latlng is not None:
            pulumi.set(__self__, "latlng", latlng)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if service_connection is not None:
            pulumi.set(__self__, "service_connection", service_connection)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        enum: `jse-ipsec`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable auto provisioning for the tunnel. If enabled, the `primary` and `secondary` nodes will be ignored.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def latlng(self) -> Optional['outputs.GatewayTunnelConfigsAutoProvisionLatlng']:
        """
        API override for POP selection
        """
        return pulumi.get(self, "latlng")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional['outputs.GatewayTunnelConfigsAutoProvisionPrimary']:
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        API override for POP selection in the case user wants to override the auto discovery of remote network location and force the tunnel to use the specified peer location.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def secondary(self) -> Optional['outputs.GatewayTunnelConfigsAutoProvisionSecondary']:
        return pulumi.get(self, "secondary")

    @_builtins.property
    @pulumi.getter(name="serviceConnection")
    def service_connection(self) -> Optional[_builtins.str]:
        """
        if `provider`==`prisma-ipsec`. By default, we'll use the location of the site to determine the optimal Remote Network location, optionally, service_connection can be considered, then we'll also consider this along with the site location. Define service_connection if the traffic is to be routed to a specific service connection. This field takes a service connection name that is configured in the Prisma cloud, Prisma Access Setup > Service Connections.
        """
        return pulumi.get(self, "service_connection")


@pulumi.output_type
class GatewayTunnelConfigsAutoProvisionLatlng(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        return pulumi.get(self, "lng")


@pulumi.output_type
class GatewayTunnelConfigsAutoProvisionPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIps":
            suggest = "probe_ips"
        elif key == "wanNames":
            suggest = "wan_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsAutoProvisionPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsAutoProvisionPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsAutoProvisionPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")


@pulumi.output_type
class GatewayTunnelConfigsAutoProvisionSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIps":
            suggest = "probe_ips"
        elif key == "wanNames":
            suggest = "wan_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsAutoProvisionSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsAutoProvisionSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsAutoProvisionSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 wan_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] wan_names: Optional, only needed if `vars_only`==`false`
        """
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")


@pulumi.output_type
class GatewayTunnelConfigsIkeProposal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authAlgo":
            suggest = "auth_algo"
        elif key == "dhGroup":
            suggest = "dh_group"
        elif key == "encAlgo":
            suggest = "enc_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsIkeProposal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsIkeProposal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsIkeProposal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_algo: Optional[_builtins.str] = None,
                 dh_group: Optional[_builtins.str] = None,
                 enc_algo: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_algo: enum: `md5`, `sha1`, `sha2`
        :param _builtins.str dh_group: enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param _builtins.str enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[_builtins.str]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[_builtins.str]:
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @_builtins.property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[_builtins.str]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")


@pulumi.output_type
class GatewayTunnelConfigsIpsecProposal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authAlgo":
            suggest = "auth_algo"
        elif key == "dhGroup":
            suggest = "dh_group"
        elif key == "encAlgo":
            suggest = "enc_algo"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsIpsecProposal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsIpsecProposal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsIpsecProposal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_algo: Optional[_builtins.str] = None,
                 dh_group: Optional[_builtins.str] = None,
                 enc_algo: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_algo: enum: `md5`, `sha1`, `sha2`
        :param _builtins.str dh_group: Only if `provider`==`custom-ipsec`. enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param _builtins.str enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[_builtins.str]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[_builtins.str]:
        """
        Only if `provider`==`custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @_builtins.property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[_builtins.str]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")


@pulumi.output_type
class GatewayTunnelConfigsPrimary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanNames":
            suggest = "wan_names"
        elif key == "internalIps":
            suggest = "internal_ips"
        elif key == "probeIps":
            suggest = "probe_ips"
        elif key == "remoteIds":
            suggest = "remote_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsPrimary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsPrimary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsPrimary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 wan_names: Sequence[_builtins.str],
                 internal_ips: Optional[Sequence[_builtins.str]] = None,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 remote_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param Sequence[_builtins.str] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "wan_names")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")


@pulumi.output_type
class GatewayTunnelConfigsProbe(dict):
    def __init__(__self__, *,
                 interval: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int interval: How often to trigger the probe
        :param _builtins.int threshold: Number of consecutive misses before declaring the tunnel down
        :param _builtins.int timeout: Time within which to complete the connectivity check
        :param _builtins.str type: enum: `http`, `icmp`
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        How often to trigger the probe
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive misses before declaring the tunnel down
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Time within which to complete the connectivity check
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayTunnelConfigsSecondary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wanNames":
            suggest = "wan_names"
        elif key == "internalIps":
            suggest = "internal_ips"
        elif key == "probeIps":
            suggest = "probe_ips"
        elif key == "remoteIds":
            suggest = "remote_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelConfigsSecondary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelConfigsSecondary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelConfigsSecondary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 wan_names: Sequence[_builtins.str],
                 internal_ips: Optional[Sequence[_builtins.str]] = None,
                 probe_ips: Optional[Sequence[_builtins.str]] = None,
                 remote_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] internal_ips: Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        :param Sequence[_builtins.str] remote_ids: Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "wan_names", wan_names)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "wan_names")

    @_builtins.property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @_builtins.property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "probe_ips")

    @_builtins.property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")


@pulumi.output_type
class GatewayTunnelProviderOptions(dict):
    def __init__(__self__, *,
                 jse: Optional['outputs.GatewayTunnelProviderOptionsJse'] = None,
                 prisma: Optional['outputs.GatewayTunnelProviderOptionsPrisma'] = None,
                 zscaler: Optional['outputs.GatewayTunnelProviderOptionsZscaler'] = None):
        """
        :param 'GatewayTunnelProviderOptionsJseArgs' jse: For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        :param 'GatewayTunnelProviderOptionsZscalerArgs' zscaler: For zscaler-ipsec and zscaler-gre
        """
        if jse is not None:
            pulumi.set(__self__, "jse", jse)
        if prisma is not None:
            pulumi.set(__self__, "prisma", prisma)
        if zscaler is not None:
            pulumi.set(__self__, "zscaler", zscaler)

    @_builtins.property
    @pulumi.getter
    def jse(self) -> Optional['outputs.GatewayTunnelProviderOptionsJse']:
        """
        For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        return pulumi.get(self, "jse")

    @_builtins.property
    @pulumi.getter
    def prisma(self) -> Optional['outputs.GatewayTunnelProviderOptionsPrisma']:
        return pulumi.get(self, "prisma")

    @_builtins.property
    @pulumi.getter
    def zscaler(self) -> Optional['outputs.GatewayTunnelProviderOptionsZscaler']:
        """
        For zscaler-ipsec and zscaler-gre
        """
        return pulumi.get(self, "zscaler")


@pulumi.output_type
class GatewayTunnelProviderOptionsJse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numUsers":
            suggest = "num_users"
        elif key == "orgName":
            suggest = "org_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelProviderOptionsJse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelProviderOptionsJse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelProviderOptionsJse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_users: Optional[_builtins.int] = None,
                 org_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str org_name: JSE Organization name
        """
        if num_users is not None:
            pulumi.set(__self__, "num_users", num_users)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)

    @_builtins.property
    @pulumi.getter(name="numUsers")
    def num_users(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_users")

    @_builtins.property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[_builtins.str]:
        """
        JSE Organization name
        """
        return pulumi.get(self, "org_name")


@pulumi.output_type
class GatewayTunnelProviderOptionsPrisma(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountName":
            suggest = "service_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelProviderOptionsPrisma. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelProviderOptionsPrisma.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelProviderOptionsPrisma.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_name: For prisma-ipsec, service account name to used for tunnel auto provisioning
        """
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)

    @_builtins.property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[_builtins.str]:
        """
        For prisma-ipsec, service account name to used for tunnel auto provisioning
        """
        return pulumi.get(self, "service_account_name")


@pulumi.output_type
class GatewayTunnelProviderOptionsZscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aupBlockInternetUntilAccepted":
            suggest = "aup_block_internet_until_accepted"
        elif key == "aupEnabled":
            suggest = "aup_enabled"
        elif key == "aupForceSslInspection":
            suggest = "aup_force_ssl_inspection"
        elif key == "aupTimeoutInDays":
            suggest = "aup_timeout_in_days"
        elif key == "authRequired":
            suggest = "auth_required"
        elif key == "cautionEnabled":
            suggest = "caution_enabled"
        elif key == "dnBandwidth":
            suggest = "dn_bandwidth"
        elif key == "idleTimeInMinutes":
            suggest = "idle_time_in_minutes"
        elif key == "ofwEnabled":
            suggest = "ofw_enabled"
        elif key == "subLocations":
            suggest = "sub_locations"
        elif key == "surrogateIp":
            suggest = "surrogate_ip"
        elif key == "surrogateIpEnforcedForKnownBrowsers":
            suggest = "surrogate_ip_enforced_for_known_browsers"
        elif key == "surrogateRefreshTimeInMinutes":
            suggest = "surrogate_refresh_time_in_minutes"
        elif key == "upBandwidth":
            suggest = "up_bandwidth"
        elif key == "xffForwardEnabled":
            suggest = "xff_forward_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelProviderOptionsZscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelProviderOptionsZscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelProviderOptionsZscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[_builtins.bool] = None,
                 aup_enabled: Optional[_builtins.bool] = None,
                 aup_force_ssl_inspection: Optional[_builtins.bool] = None,
                 aup_timeout_in_days: Optional[_builtins.int] = None,
                 auth_required: Optional[_builtins.bool] = None,
                 caution_enabled: Optional[_builtins.bool] = None,
                 dn_bandwidth: Optional[_builtins.float] = None,
                 idle_time_in_minutes: Optional[_builtins.int] = None,
                 ofw_enabled: Optional[_builtins.bool] = None,
                 sub_locations: Optional[Sequence['outputs.GatewayTunnelProviderOptionsZscalerSubLocation']] = None,
                 surrogate_ip: Optional[_builtins.bool] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[_builtins.bool] = None,
                 surrogate_refresh_time_in_minutes: Optional[_builtins.int] = None,
                 up_bandwidth: Optional[_builtins.float] = None,
                 xff_forward_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param _builtins.bool aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param _builtins.int aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param _builtins.bool auth_required: Enable this option to enforce user authentication
        :param _builtins.bool caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param _builtins.float dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.int idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param _builtins.bool ofw_enabled: If `true`, enable the firewall control option
        :param Sequence['GatewayTunnelProviderOptionsZscalerSubLocationArgs'] sub_locations: `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        :param _builtins.bool surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param _builtins.bool surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param _builtins.int surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param _builtins.float up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.bool xff_forward_enabled: Location uses proxy chaining to forward traffic
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if sub_locations is not None:
            pulumi.set(__self__, "sub_locations", sub_locations)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)
        if xff_forward_enabled is not None:
            pulumi.set(__self__, "xff_forward_enabled", xff_forward_enabled)

    @_builtins.property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @_builtins.property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @_builtins.property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[_builtins.bool]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @_builtins.property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[_builtins.int]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @_builtins.property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[_builtins.bool]:
        """
        Enable this option to enforce user authentication
        """
        return pulumi.get(self, "auth_required")

    @_builtins.property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @_builtins.property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @_builtins.property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @_builtins.property
    @pulumi.getter(name="subLocations")
    def sub_locations(self) -> Optional[Sequence['outputs.GatewayTunnelProviderOptionsZscalerSubLocation']]:
        """
        `sub-locations` can be used for specific uses cases to define different configuration based on the user network
        """
        return pulumi.get(self, "sub_locations")

    @_builtins.property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @_builtins.property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @_builtins.property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")

    @_builtins.property
    @pulumi.getter(name="xffForwardEnabled")
    def xff_forward_enabled(self) -> Optional[_builtins.bool]:
        """
        Location uses proxy chaining to forward traffic
        """
        return pulumi.get(self, "xff_forward_enabled")


@pulumi.output_type
class GatewayTunnelProviderOptionsZscalerSubLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aupBlockInternetUntilAccepted":
            suggest = "aup_block_internet_until_accepted"
        elif key == "aupEnabled":
            suggest = "aup_enabled"
        elif key == "aupForceSslInspection":
            suggest = "aup_force_ssl_inspection"
        elif key == "aupTimeoutInDays":
            suggest = "aup_timeout_in_days"
        elif key == "authRequired":
            suggest = "auth_required"
        elif key == "cautionEnabled":
            suggest = "caution_enabled"
        elif key == "dnBandwidth":
            suggest = "dn_bandwidth"
        elif key == "idleTimeInMinutes":
            suggest = "idle_time_in_minutes"
        elif key == "ofwEnabled":
            suggest = "ofw_enabled"
        elif key == "surrogateIp":
            suggest = "surrogate_ip"
        elif key == "surrogateIpEnforcedForKnownBrowsers":
            suggest = "surrogate_ip_enforced_for_known_browsers"
        elif key == "surrogateRefreshTimeInMinutes":
            suggest = "surrogate_refresh_time_in_minutes"
        elif key == "upBandwidth":
            suggest = "up_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTunnelProviderOptionsZscalerSubLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTunnelProviderOptionsZscalerSubLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTunnelProviderOptionsZscalerSubLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aup_block_internet_until_accepted: Optional[_builtins.bool] = None,
                 aup_enabled: Optional[_builtins.bool] = None,
                 aup_force_ssl_inspection: Optional[_builtins.bool] = None,
                 aup_timeout_in_days: Optional[_builtins.int] = None,
                 auth_required: Optional[_builtins.bool] = None,
                 caution_enabled: Optional[_builtins.bool] = None,
                 dn_bandwidth: Optional[_builtins.float] = None,
                 idle_time_in_minutes: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 ofw_enabled: Optional[_builtins.bool] = None,
                 surrogate_ip: Optional[_builtins.bool] = None,
                 surrogate_ip_enforced_for_known_browsers: Optional[_builtins.bool] = None,
                 surrogate_refresh_time_in_minutes: Optional[_builtins.int] = None,
                 up_bandwidth: Optional[_builtins.float] = None):
        """
        :param _builtins.bool aup_enabled: Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        :param _builtins.bool aup_force_ssl_inspection: Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param _builtins.int aup_timeout_in_days: Required if `aup_enabled`==`true`. Days before AUP is requested again
        :param _builtins.bool auth_required: Enable this option to authenticate users
        :param _builtins.bool caution_enabled: Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        :param _builtins.float dn_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        :param _builtins.int idle_time_in_minutes: Required if `surrogate_IP`==`true`, idle Time to Disassociation
        :param _builtins.str name: Network name
        :param _builtins.bool ofw_enabled: If `true`, enable the firewall control option
        :param _builtins.bool surrogate_ip: Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        :param _builtins.bool surrogate_ip_enforced_for_known_browsers: Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        :param _builtins.int surrogate_refresh_time_in_minutes: Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        :param _builtins.float up_bandwidth: Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        if aup_block_internet_until_accepted is not None:
            pulumi.set(__self__, "aup_block_internet_until_accepted", aup_block_internet_until_accepted)
        if aup_enabled is not None:
            pulumi.set(__self__, "aup_enabled", aup_enabled)
        if aup_force_ssl_inspection is not None:
            pulumi.set(__self__, "aup_force_ssl_inspection", aup_force_ssl_inspection)
        if aup_timeout_in_days is not None:
            pulumi.set(__self__, "aup_timeout_in_days", aup_timeout_in_days)
        if auth_required is not None:
            pulumi.set(__self__, "auth_required", auth_required)
        if caution_enabled is not None:
            pulumi.set(__self__, "caution_enabled", caution_enabled)
        if dn_bandwidth is not None:
            pulumi.set(__self__, "dn_bandwidth", dn_bandwidth)
        if idle_time_in_minutes is not None:
            pulumi.set(__self__, "idle_time_in_minutes", idle_time_in_minutes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ofw_enabled is not None:
            pulumi.set(__self__, "ofw_enabled", ofw_enabled)
        if surrogate_ip is not None:
            pulumi.set(__self__, "surrogate_ip", surrogate_ip)
        if surrogate_ip_enforced_for_known_browsers is not None:
            pulumi.set(__self__, "surrogate_ip_enforced_for_known_browsers", surrogate_ip_enforced_for_known_browsers)
        if surrogate_refresh_time_in_minutes is not None:
            pulumi.set(__self__, "surrogate_refresh_time_in_minutes", surrogate_refresh_time_in_minutes)
        if up_bandwidth is not None:
            pulumi.set(__self__, "up_bandwidth", up_bandwidth)

    @_builtins.property
    @pulumi.getter(name="aupBlockInternetUntilAccepted")
    def aup_block_internet_until_accepted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aup_block_internet_until_accepted")

    @_builtins.property
    @pulumi.getter(name="aupEnabled")
    def aup_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "aup_enabled")

    @_builtins.property
    @pulumi.getter(name="aupForceSslInspection")
    def aup_force_ssl_inspection(self) -> Optional[_builtins.bool]:
        """
        Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_force_ssl_inspection")

    @_builtins.property
    @pulumi.getter(name="aupTimeoutInDays")
    def aup_timeout_in_days(self) -> Optional[_builtins.int]:
        """
        Required if `aup_enabled`==`true`. Days before AUP is requested again
        """
        return pulumi.get(self, "aup_timeout_in_days")

    @_builtins.property
    @pulumi.getter(name="authRequired")
    def auth_required(self) -> Optional[_builtins.bool]:
        """
        Enable this option to authenticate users
        """
        return pulumi.get(self, "auth_required")

    @_builtins.property
    @pulumi.getter(name="cautionEnabled")
    def caution_enabled(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "caution_enabled")

    @_builtins.property
    @pulumi.getter(name="dnBandwidth")
    def dn_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "dn_bandwidth")

    @_builtins.property
    @pulumi.getter(name="idleTimeInMinutes")
    def idle_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP`==`true`, idle Time to Disassociation
        """
        return pulumi.get(self, "idle_time_in_minutes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ofwEnabled")
    def ofw_enabled(self) -> Optional[_builtins.bool]:
        """
        If `true`, enable the firewall control option
        """
        return pulumi.get(self, "ofw_enabled")

    @_builtins.property
    @pulumi.getter(name="surrogateIp")
    def surrogate_ip(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies
        """
        return pulumi.get(self, "surrogate_ip")

    @_builtins.property
    @pulumi.getter(name="surrogateIpEnforcedForKnownBrowsers")
    def surrogate_ip_enforced_for_known_browsers(self) -> Optional[_builtins.bool]:
        """
        Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers
        """
        return pulumi.get(self, "surrogate_ip_enforced_for_known_browsers")

    @_builtins.property
    @pulumi.getter(name="surrogateRefreshTimeInMinutes")
    def surrogate_refresh_time_in_minutes(self) -> Optional[_builtins.int]:
        """
        Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy
        """
        return pulumi.get(self, "surrogate_refresh_time_in_minutes")

    @_builtins.property
    @pulumi.getter(name="upBandwidth")
    def up_bandwidth(self) -> Optional[_builtins.float]:
        """
        Download bandwidth cap of the link, in Mbps. Disabled if not set
        """
        return pulumi.get(self, "up_bandwidth")


@pulumi.output_type
class GatewayVrfConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GatewayVrfInstances(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[_builtins.str]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class SwitchAclPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "srcTags":
            suggest = "src_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAclPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAclPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAclPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.SwitchAclPolicyAction']] = None,
                 name: Optional[_builtins.str] = None,
                 src_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['SwitchAclPolicyActionArgs'] actions: ACL Policy Actions:
                 - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
                 - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        :param Sequence[_builtins.str] src_tags: ACL Policy Source Tags:
                 - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
                 - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_tags is not None:
            pulumi.set(__self__, "src_tags", src_tags)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.SwitchAclPolicyAction']]:
        """
        ACL Policy Actions:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="srcTags")
    def src_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        ACL Policy Source Tags:
          - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
          - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "src_tags")


@pulumi.output_type
class SwitchAclPolicyAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dstTag":
            suggest = "dst_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAclPolicyAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAclPolicyAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAclPolicyAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dst_tag: _builtins.str,
                 action: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: enum: `allow`, `deny`
        """
        pulumi.set(__self__, "dst_tag", dst_tag)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter(name="dstTag")
    def dst_tag(self) -> _builtins.str:
        return pulumi.get(self, "dst_tag")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class SwitchAclTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "etherTypes":
            suggest = "ether_types"
        elif key == "gbpTag":
            suggest = "gbp_tag"
        elif key == "portUsage":
            suggest = "port_usage"
        elif key == "radiusGroup":
            suggest = "radius_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAclTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAclTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAclTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 ether_types: Optional[Sequence[_builtins.str]] = None,
                 gbp_tag: Optional[_builtins.int] = None,
                 macs: Optional[Sequence[_builtins.str]] = None,
                 network: Optional[_builtins.str] = None,
                 port_usage: Optional[_builtins.str] = None,
                 radius_group: Optional[_builtins.str] = None,
                 specs: Optional[Sequence['outputs.SwitchAclTagsSpec']] = None,
                 subnets: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: enum: 
                 * `any`: matching anything not identified
                 * `dynamic_gbp`: from the gbp_tag received from RADIUS
                 * `gbp_resource`: can only be used in `dst_tags`
                 * `mac`
                 * `network`
                 * `port_usage`
                 * `radius_group`
                 * `resource`: can only be used in `dst_tags`
                 * `static_gbp`: applying gbp tag against matching conditions
                 * `subnet`'
        :param Sequence[_builtins.str] ether_types: Can only be used under dst tags.
        :param _builtins.int gbp_tag: Required if
                 - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
                 - `type`==`gbp_resource`
                 - `type`==`static_gbp` (applying gbp tag against matching conditions)
        :param Sequence[_builtins.str] macs: Required if 
               - `type`==`mac`
               - `type`==`static_gbp` if from matching mac
        :param _builtins.str network: If:
                 * `type`==`mac` (optional. default is `any`)
                 * `type`==`subnet` (optional. default is `any`)
                 * `type`==`network`
                 * `type`==`resource` (optional. default is `any`)
                 * `type`==`static_gbp` if from matching network (vlan)
        :param _builtins.str port_usage: Required if `type`==`port_usage`
        :param _builtins.str radius_group: Required if:
                 * `type`==`radius_group`
                 * `type`==`static_gbp`
               if from matching radius_group
        :param Sequence['SwitchAclTagsSpecArgs'] specs: If `type`==`resource`, `type`==`radius_group`, `type`==`port_usage` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        :param Sequence[_builtins.str] subnets: If 
               - `type`==`subnet` 
               - `type`==`resource` (optional. default is `any`)
               - `type`==`static_gbp` if from matching subnet
        """
        pulumi.set(__self__, "type", type)
        if ether_types is not None:
            pulumi.set(__self__, "ether_types", ether_types)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if macs is not None:
            pulumi.set(__self__, "macs", macs)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port_usage is not None:
            pulumi.set(__self__, "port_usage", port_usage)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: 
          * `any`: matching anything not identified
          * `dynamic_gbp`: from the gbp_tag received from RADIUS
          * `gbp_resource`: can only be used in `dst_tags`
          * `mac`
          * `network`
          * `port_usage`
          * `radius_group`
          * `resource`: can only be used in `dst_tags`
          * `static_gbp`: applying gbp tag against matching conditions
          * `subnet`'
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="etherTypes")
    def ether_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Can only be used under dst tags.
        """
        return pulumi.get(self, "ether_types")

    @_builtins.property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[_builtins.int]:
        """
        Required if
          - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
          - `type`==`gbp_resource`
          - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        return pulumi.get(self, "gbp_tag")

    @_builtins.property
    @pulumi.getter
    def macs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        return pulumi.get(self, "macs")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        If:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`port_usage`
        """
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[_builtins.str]:
        """
        Required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        return pulumi.get(self, "radius_group")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Optional[Sequence['outputs.SwitchAclTagsSpec']]:
        """
        If `type`==`resource`, `type`==`radius_group`, `type`==`port_usage` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        If 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class SwitchAclTagsSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchAclTagsSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchAclTagsSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchAclTagsSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_range: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_range: Matched dst port, "0" means any
        :param _builtins.str protocol: `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        Matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        `tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class SwitchDhcpSnooping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "enableArpSpoofCheck":
            suggest = "enable_arp_spoof_check"
        elif key == "enableIpSourceGuard":
            suggest = "enable_ip_source_guard"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchDhcpSnooping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchDhcpSnooping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchDhcpSnooping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_networks: Optional[_builtins.bool] = None,
                 enable_arp_spoof_check: Optional[_builtins.bool] = None,
                 enable_ip_source_guard: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 networks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enable_arp_spoof_check: Enable for dynamic ARP inspection check
        :param _builtins.bool enable_ip_source_guard: Enable for check for forging source IP address
        :param Sequence[_builtins.str] networks: If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_ip_source_guard is not None:
            pulumi.set(__self__, "enable_ip_source_guard", enable_ip_source_guard)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all_networks")

    @_builtins.property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[_builtins.bool]:
        """
        Enable for dynamic ARP inspection check
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @_builtins.property
    @pulumi.getter(name="enableIpSourceGuard")
    def enable_ip_source_guard(self) -> Optional[_builtins.bool]:
        """
        Enable for check for forging source IP address
        """
        return pulumi.get(self, "enable_ip_source_guard")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class SwitchDhcpdConfig(dict):
    def __init__(__self__, *,
                 config: Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfig']] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, 'SwitchDhcpdConfigConfigArgs'] config: Property key is the network name
        :param _builtins.bool enabled: If set to `true`, enable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfig']]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to `true`, enable the DHCP server
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SwitchDhcpdConfigConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"
        elif key == "dnsSuffixes":
            suggest = "dns_suffixes"
        elif key == "fixedBindings":
            suggest = "fixed_bindings"
        elif key == "ipEnd":
            suggest = "ip_end"
        elif key == "ipEnd6":
            suggest = "ip_end6"
        elif key == "ipStart":
            suggest = "ip_start"
        elif key == "ipStart6":
            suggest = "ip_start6"
        elif key == "leaseTime":
            suggest = "lease_time"
        elif key == "serverIdOverride":
            suggest = "server_id_override"
        elif key == "vendorEncapsulated":
            suggest = "vendor_encapsulated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchDhcpdConfigConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchDhcpdConfigConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchDhcpdConfigConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 fixed_bindings: Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfigFixedBindings']] = None,
                 gateway: Optional[_builtins.str] = None,
                 ip_end: Optional[_builtins.str] = None,
                 ip_end6: Optional[_builtins.str] = None,
                 ip_start: Optional[_builtins.str] = None,
                 ip_start6: Optional[_builtins.str] = None,
                 lease_time: Optional[_builtins.int] = None,
                 options: Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfigOptions']] = None,
                 server_id_override: Optional[_builtins.bool] = None,
                 servers: Optional[Sequence[_builtins.str]] = None,
                 servers6s: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None,
                 vendor_encapsulated: Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfigVendorEncapsulated']] = None):
        """
        :param Sequence[_builtins.str] dns_servers: If `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        :param Sequence[_builtins.str] dns_suffixes: If `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        :param Mapping[str, 'SwitchDhcpdConfigConfigFixedBindingsArgs'] fixed_bindings: If `type`==`server` or `type6`==`server`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        :param _builtins.str gateway: If `type`==`server`  - optional, `ip` will be used if not provided
        :param _builtins.str ip_end: If `type`==`server`
        :param _builtins.str ip_end6: If `type6`==`server`
        :param _builtins.str ip_start: If `type`==`server`
        :param _builtins.str ip_start6: If `type6`==`server`
        :param _builtins.int lease_time: In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param Mapping[str, 'SwitchDhcpdConfigConfigOptionsArgs'] options: If `type`==`server` or `type6`==`server`. Property key is the DHCP option number
        :param _builtins.bool server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param Sequence[_builtins.str] servers: If `type`==`relay`
        :param Sequence[_builtins.str] servers6s: If `type6`==`relay`
        :param _builtins.str type: enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        :param _builtins.str type6: enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        :param Mapping[str, 'SwitchDhcpdConfigConfigVendorEncapsulatedArgs'] vendor_encapsulated: If `type`==`server` or `type6`==`server`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code'
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_end6 is not None:
            pulumi.set(__self__, "ip_end6", ip_end6)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if ip_start6 is not None:
            pulumi.set(__self__, "ip_start6", ip_start6)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if servers6s is not None:
            pulumi.set(__self__, "servers6s", servers6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapsulated is not None:
            pulumi.set(__self__, "vendor_encapsulated", vendor_encapsulated)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfigFixedBindings']]:
        """
        If `type`==`server` or `type6`==`server`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        If `type`==`server`  - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[_builtins.str]:
        """
        If `type`==`server`
        """
        return pulumi.get(self, "ip_end")

    @_builtins.property
    @pulumi.getter(name="ipEnd6")
    def ip_end6(self) -> Optional[_builtins.str]:
        """
        If `type6`==`server`
        """
        return pulumi.get(self, "ip_end6")

    @_builtins.property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[_builtins.str]:
        """
        If `type`==`server`
        """
        return pulumi.get(self, "ip_start")

    @_builtins.property
    @pulumi.getter(name="ipStart6")
    def ip_start6(self) -> Optional[_builtins.str]:
        """
        If `type6`==`server`
        """
        return pulumi.get(self, "ip_start6")

    @_builtins.property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[_builtins.int]:
        """
        In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfigOptions']]:
        """
        If `type`==`server` or `type6`==`server`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[_builtins.bool]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def servers6s(self) -> Optional[Sequence[_builtins.str]]:
        """
        If `type6`==`relay`
        """
        return pulumi.get(self, "servers6s")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vendorEncapsulated")
    def vendor_encapsulated(self) -> Optional[Mapping[str, 'outputs.SwitchDhcpdConfigConfigVendorEncapsulated']]:
        """
        If `type`==`server` or `type6`==`server`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code'
        """
        return pulumi.get(self, "vendor_encapsulated")


@pulumi.output_type
class SwitchDhcpdConfigConfigFixedBindings(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwitchDhcpdConfigConfigOptions(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SwitchDhcpdConfigConfigVendorEncapsulated(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SwitchExtraRoutes6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextQualified":
            suggest = "next_qualified"
        elif key == "noResolve":
            suggest = "no_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchExtraRoutes6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchExtraRoutes6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchExtraRoutes6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 discard: Optional[_builtins.bool] = None,
                 metric: Optional[_builtins.int] = None,
                 next_qualified: Optional[Mapping[str, 'outputs.SwitchExtraRoutes6NextQualified']] = None,
                 no_resolve: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None):
        """
        :param _builtins.str via: Next-hop IP Address
        :param _builtins.bool discard: This takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        Next-hop IP Address
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.bool]:
        """
        This takes precedence
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[Mapping[str, 'outputs.SwitchExtraRoutes6NextQualified']]:
        return pulumi.get(self, "next_qualified")

    @_builtins.property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_resolve")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class SwitchExtraRoutes6NextQualified(dict):
    def __init__(__self__, *,
                 metric: Optional[_builtins.int] = None,
                 preference: Optional[_builtins.int] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class SwitchExtraRoutes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextQualified":
            suggest = "next_qualified"
        elif key == "noResolve":
            suggest = "no_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchExtraRoutes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchExtraRoutes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchExtraRoutes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 via: _builtins.str,
                 discard: Optional[_builtins.bool] = None,
                 metric: Optional[_builtins.int] = None,
                 next_qualified: Optional[Mapping[str, 'outputs.SwitchExtraRoutesNextQualified']] = None,
                 no_resolve: Optional[_builtins.bool] = None,
                 preference: Optional[_builtins.int] = None):
        """
        :param _builtins.str via: Next-hop IP Address
        :param _builtins.bool discard: This takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        Next-hop IP Address
        """
        return pulumi.get(self, "via")

    @_builtins.property
    @pulumi.getter
    def discard(self) -> Optional[_builtins.bool]:
        """
        This takes precedence
        """
        return pulumi.get(self, "discard")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[Mapping[str, 'outputs.SwitchExtraRoutesNextQualified']]:
        return pulumi.get(self, "next_qualified")

    @_builtins.property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_resolve")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class SwitchExtraRoutesNextQualified(dict):
    def __init__(__self__, *,
                 metric: Optional[_builtins.int] = None,
                 preference: Optional[_builtins.int] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "preference")


@pulumi.output_type
class SwitchIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffixes":
            suggest = "dns_suffixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns: Optional[Sequence[_builtins.str]] = None,
                 dns_suffixes: Optional[Sequence[_builtins.str]] = None,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dns: Required when `type`==`static`
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`
        :param _builtins.str network: Network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
        :param _builtins.str type: enum: `dhcp`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required when `type`==`static`
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwitchLocalPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "allowDhcpd":
            suggest = "allow_dhcpd"
        elif key == "allowMultipleSupplicants":
            suggest = "allow_multiple_supplicants"
        elif key == "bypassAuthWhenServerDown":
            suggest = "bypass_auth_when_server_down"
        elif key == "bypassAuthWhenServerDownForUnknownClient":
            suggest = "bypass_auth_when_server_down_for_unknown_client"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicVlanNetworks":
            suggest = "dynamic_vlan_networks"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "enableQos":
            suggest = "enable_qos"
        elif key == "guestNetwork":
            suggest = "guest_network"
        elif key == "interSwitchLink":
            suggest = "inter_switch_link"
        elif key == "macAuthOnly":
            suggest = "mac_auth_only"
        elif key == "macAuthPreferred":
            suggest = "mac_auth_preferred"
        elif key == "macAuthProtocol":
            suggest = "mac_auth_protocol"
        elif key == "macLimit":
            suggest = "mac_limit"
        elif key == "persistMac":
            suggest = "persist_mac"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portAuth":
            suggest = "port_auth"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "reauthInterval":
            suggest = "reauth_interval"
        elif key == "serverFailNetwork":
            suggest = "server_fail_network"
        elif key == "serverRejectNetwork":
            suggest = "server_reject_network"
        elif key == "stormControl":
            suggest = "storm_control"
        elif key == "stpEdge":
            suggest = "stp_edge"
        elif key == "stpNoRootPort":
            suggest = "stp_no_root_port"
        elif key == "stpP2p":
            suggest = "stp_p2p"
        elif key == "useVstp":
            suggest = "use_vstp"
        elif key == "voipNetwork":
            suggest = "voip_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchLocalPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchLocalPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchLocalPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: _builtins.str,
                 all_networks: Optional[_builtins.bool] = None,
                 allow_dhcpd: Optional[_builtins.bool] = None,
                 allow_multiple_supplicants: Optional[_builtins.bool] = None,
                 bypass_auth_when_server_down: Optional[_builtins.bool] = None,
                 bypass_auth_when_server_down_for_unknown_client: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 duplex: Optional[_builtins.str] = None,
                 dynamic_vlan_networks: Optional[Sequence[_builtins.str]] = None,
                 enable_mac_auth: Optional[_builtins.bool] = None,
                 enable_qos: Optional[_builtins.bool] = None,
                 guest_network: Optional[_builtins.str] = None,
                 inter_switch_link: Optional[_builtins.bool] = None,
                 mac_auth_only: Optional[_builtins.bool] = None,
                 mac_auth_preferred: Optional[_builtins.bool] = None,
                 mac_auth_protocol: Optional[_builtins.str] = None,
                 mac_limit: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.int] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 note: Optional[_builtins.str] = None,
                 persist_mac: Optional[_builtins.bool] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_auth: Optional[_builtins.str] = None,
                 port_network: Optional[_builtins.str] = None,
                 reauth_interval: Optional[_builtins.str] = None,
                 server_fail_network: Optional[_builtins.str] = None,
                 server_reject_network: Optional[_builtins.str] = None,
                 speed: Optional[_builtins.str] = None,
                 storm_control: Optional['outputs.SwitchLocalPortConfigStormControl'] = None,
                 stp_edge: Optional[_builtins.bool] = None,
                 stp_no_root_port: Optional[_builtins.bool] = None,
                 stp_p2p: Optional[_builtins.bool] = None,
                 use_vstp: Optional[_builtins.bool] = None,
                 voip_network: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: Port usage name.
        :param _builtins.bool all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param _builtins.bool allow_dhcpd: If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        :param _builtins.bool bypass_auth_when_server_down: Only if `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param _builtins.bool bypass_auth_when_server_down_for_unknown_client: Only if `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param _builtins.bool disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param _builtins.bool disabled: Whether the port is disabled
        :param _builtins.str duplex: link connection mode. enum: `auto`, `full`, `half`
        :param Sequence[_builtins.str] dynamic_vlan_networks: Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param _builtins.bool enable_mac_auth: Only if `port_auth`==`dot1x` whether to enable MAC Auth
        :param _builtins.str guest_network: Only if `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param _builtins.bool inter_switch_link: inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param _builtins.bool mac_auth_only: Only if `enable_mac_auth`==`true`
        :param _builtins.bool mac_auth_preferred: Only if `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        :param _builtins.str mac_auth_protocol: Only if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param _builtins.int mac_limit: Max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        :param _builtins.str mode: enum: `access`, `inet`, `trunk`
        :param _builtins.int mtu: Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        :param Sequence[_builtins.str] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param _builtins.str note: Additional note for the port config override
        :param _builtins.bool persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param _builtins.bool poe_disabled: Whether PoE capabilities are disabled for a port
        :param _builtins.str port_auth: if dot1x is desired, set to dot1x. enum: `dot1x`
        :param _builtins.str port_network: Native network/vlan for untagged traffic
        :param _builtins.str reauth_interval: Only `port_auth`=`dot1x`, reauthentication interval range between 10 and 65535 (default: 3600)
        :param _builtins.str server_fail_network: Only if `port_auth`==`dot1x` sets server fail fallback vlan
        :param _builtins.str server_reject_network: Only if `port_auth`==`dot1x` when radius server reject / fails
        :param _builtins.str speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        :param 'SwitchLocalPortConfigStormControlArgs' storm_control: Switch storm control
        :param _builtins.bool stp_edge: When enabled, the port is not expected to receive BPDU frames
        :param _builtins.bool use_vstp: If this is connected to a vstp network
        :param _builtins.str voip_network: Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        pulumi.set(__self__, "usage", usage)
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unknown_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unknown_client", bypass_auth_when_server_down_for_unknown_client)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if note is not None:
            pulumi.set(__self__, "note", note)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if server_fail_network is not None:
            pulumi.set(__self__, "server_fail_network", server_fail_network)
        if server_reject_network is not None:
            pulumi.set(__self__, "server_reject_network", server_reject_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if stp_no_root_port is not None:
            pulumi.set(__self__, "stp_no_root_port", stp_no_root_port)
        if stp_p2p is not None:
            pulumi.set(__self__, "stp_p2p", stp_p2p)
        if use_vstp is not None:
            pulumi.set(__self__, "use_vstp", use_vstp)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        Port usage name.
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @_builtins.property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[_builtins.bool]:
        """
        If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @_builtins.property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_multiple_supplicants")

    @_builtins.property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[_builtins.bool]:
        """
        Only if `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @_builtins.property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnknownClient")
    def bypass_auth_when_server_down_for_unknown_client(self) -> Optional[_builtins.bool]:
        """
        Only if `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unknown_client")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[_builtins.bool]:
        """
        Only if `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_qos")

    @_builtins.property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[_builtins.str]:
        """
        Only if `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @_builtins.property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[_builtins.bool]:
        """
        inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @_builtins.property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[_builtins.bool]:
        """
        Only if `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @_builtins.property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[_builtins.bool]:
        """
        Only if `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        return pulumi.get(self, "mac_auth_preferred")

    @_builtins.property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[_builtins.str]:
        """
        Only if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @_builtins.property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[_builtins.int]:
        """
        Max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        """
        return pulumi.get(self, "mac_limit")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        enum: `access`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        """
        Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def note(self) -> Optional[_builtins.str]:
        """
        Additional note for the port config override
        """
        return pulumi.get(self, "note")

    @_builtins.property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        """
        Whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[_builtins.str]:
        """
        if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[_builtins.str]:
        """
        Only `port_auth`=`dot1x`, reauthentication interval range between 10 and 65535 (default: 3600)
        """
        return pulumi.get(self, "reauth_interval")

    @_builtins.property
    @pulumi.getter(name="serverFailNetwork")
    def server_fail_network(self) -> Optional[_builtins.str]:
        """
        Only if `port_auth`==`dot1x` sets server fail fallback vlan
        """
        return pulumi.get(self, "server_fail_network")

    @_builtins.property
    @pulumi.getter(name="serverRejectNetwork")
    def server_reject_network(self) -> Optional[_builtins.str]:
        """
        Only if `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "server_reject_network")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional['outputs.SwitchLocalPortConfigStormControl']:
        """
        Switch storm control
        """
        return pulumi.get(self, "storm_control")

    @_builtins.property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[_builtins.bool]:
        """
        When enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @_builtins.property
    @pulumi.getter(name="stpNoRootPort")
    def stp_no_root_port(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stp_no_root_port")

    @_builtins.property
    @pulumi.getter(name="stpP2p")
    def stp_p2p(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stp_p2p")

    @_builtins.property
    @pulumi.getter(name="useVstp")
    def use_vstp(self) -> Optional[_builtins.bool]:
        """
        If this is connected to a vstp network
        """
        return pulumi.get(self, "use_vstp")

    @_builtins.property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[_builtins.str]:
        """
        Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")


@pulumi.output_type
class SwitchLocalPortConfigStormControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePort":
            suggest = "disable_port"
        elif key == "noBroadcast":
            suggest = "no_broadcast"
        elif key == "noMulticast":
            suggest = "no_multicast"
        elif key == "noRegisteredMulticast":
            suggest = "no_registered_multicast"
        elif key == "noUnknownUnicast":
            suggest = "no_unknown_unicast"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchLocalPortConfigStormControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchLocalPortConfigStormControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchLocalPortConfigStormControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_port: Optional[_builtins.bool] = None,
                 no_broadcast: Optional[_builtins.bool] = None,
                 no_multicast: Optional[_builtins.bool] = None,
                 no_registered_multicast: Optional[_builtins.bool] = None,
                 no_unknown_unicast: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disable_port: Whether to disable the port when storm control is triggered
        :param _builtins.bool no_broadcast: Whether to disable storm control on broadcast traffic
        :param _builtins.bool no_multicast: Whether to disable storm control on multicast traffic
        :param _builtins.bool no_registered_multicast: Whether to disable storm control on registered multicast traffic
        :param _builtins.bool no_unknown_unicast: Whether to disable storm control on unknown unicast traffic
        :param _builtins.int percentage: Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if disable_port is not None:
            pulumi.set(__self__, "disable_port", disable_port)
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="disablePort")
    def disable_port(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the port when storm control is triggered
        """
        return pulumi.get(self, "disable_port")

    @_builtins.property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @_builtins.property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @_builtins.property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @_builtins.property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class SwitchMistNac(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network")


@pulumi.output_type
class SwitchNetworks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"
        elif key == "isolationVlanId":
            suggest = "isolation_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchNetworks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchNetworks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchNetworks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_id: _builtins.str,
                 gateway: Optional[_builtins.str] = None,
                 gateway6: Optional[_builtins.str] = None,
                 isolation: Optional[_builtins.bool] = None,
                 isolation_vlan_id: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None,
                 subnet6: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway: Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        :param _builtins.str gateway6: Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        :param _builtins.bool isolation: whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set. See also `inter_isolation_network_link` and `community_vlan_id` in port_usage
        :param _builtins.str subnet: Optional for pure switching, required when L3 / routing features are used
        :param _builtins.str subnet6: Optional for pure switching, required when L3 / routing features are used
        """
        pulumi.set(__self__, "vlan_id", vlan_id)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if isolation_vlan_id is not None:
            pulumi.set(__self__, "isolation_vlan_id", isolation_vlan_id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.str:
        return pulumi.get(self, "vlan_id")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        """
        Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> Optional[_builtins.str]:
        """
        Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
        """
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def isolation(self) -> Optional[_builtins.bool]:
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set. See also `inter_isolation_network_link` and `community_vlan_id` in port_usage
        """
        return pulumi.get(self, "isolation")

    @_builtins.property
    @pulumi.getter(name="isolationVlanId")
    def isolation_vlan_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "isolation_vlan_id")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def subnet6(self) -> Optional[_builtins.str]:
        """
        Optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet6")


@pulumi.output_type
class SwitchOobIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useMgmtVrf":
            suggest = "use_mgmt_vrf"
        elif key == "useMgmtVrfForHostOut":
            suggest = "use_mgmt_vrf_for_host_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchOobIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchOobIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchOobIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 use_mgmt_vrf: Optional[_builtins.bool] = None,
                 use_mgmt_vrf_for_host_out: Optional[_builtins.bool] = None):
        """
        :param _builtins.str netmask: Used only if `subnet` is not specified in `networks`
        :param _builtins.str network: Optional, the network to be used for mgmt
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.bool use_mgmt_vrf: If supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param _builtins.bool use_mgmt_vrf_for_host_out: For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[_builtins.bool]:
        """
        If supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @_builtins.property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[_builtins.bool]:
        """
        For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")


@pulumi.output_type
class SwitchOspfAreas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeLoopback":
            suggest = "include_loopback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchOspfAreas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchOspfAreas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchOspfAreas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 networks: Mapping[str, 'outputs.SwitchOspfAreasNetworks'],
                 include_loopback: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: OSPF type. enum: `default`, `nssa`, `stub`
        """
        pulumi.set(__self__, "networks", networks)
        if include_loopback is not None:
            pulumi.set(__self__, "include_loopback", include_loopback)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Mapping[str, 'outputs.SwitchOspfAreasNetworks']:
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="includeLoopback")
    def include_loopback(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_loopback")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        OSPF type. enum: `default`, `nssa`, `stub`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwitchOspfAreasNetworks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authKeys":
            suggest = "auth_keys"
        elif key == "authPassword":
            suggest = "auth_password"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "bfdMinimumInterval":
            suggest = "bfd_minimum_interval"
        elif key == "deadInterval":
            suggest = "dead_interval"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "helloInterval":
            suggest = "hello_interval"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "noReadvertiseToOverlay":
            suggest = "no_readvertise_to_overlay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchOspfAreasNetworks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchOspfAreasNetworks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchOspfAreasNetworks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_keys: Optional[Mapping[str, _builtins.str]] = None,
                 auth_password: Optional[_builtins.str] = None,
                 auth_type: Optional[_builtins.str] = None,
                 bfd_minimum_interval: Optional[_builtins.int] = None,
                 dead_interval: Optional[_builtins.int] = None,
                 export_policy: Optional[_builtins.str] = None,
                 hello_interval: Optional[_builtins.int] = None,
                 import_policy: Optional[_builtins.str] = None,
                 interface_type: Optional[_builtins.str] = None,
                 metric: Optional[_builtins.int] = None,
                 no_readvertise_to_overlay: Optional[_builtins.bool] = None,
                 passive: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] auth_keys: Required if `auth_type`==`md5`. Property key is the key number
        :param _builtins.str auth_password: Required if `auth_type`==`password`, the password, max length is 8
        :param _builtins.str auth_type: auth type. enum: `md5`, `none`, `password`
        :param _builtins.str interface_type: interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        :param _builtins.bool no_readvertise_to_overlay: By default, we'll re-advertise all learned OSPF routes toward overlay
        :param _builtins.bool passive: Whether to send OSPF-Hello
        """
        if auth_keys is not None:
            pulumi.set(__self__, "auth_keys", auth_keys)
        if auth_password is not None:
            pulumi.set(__self__, "auth_password", auth_password)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if dead_interval is not None:
            pulumi.set(__self__, "dead_interval", dead_interval)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)

    @_builtins.property
    @pulumi.getter(name="authKeys")
    def auth_keys(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Required if `auth_type`==`md5`. Property key is the key number
        """
        return pulumi.get(self, "auth_keys")

    @_builtins.property
    @pulumi.getter(name="authPassword")
    def auth_password(self) -> Optional[_builtins.str]:
        """
        Required if `auth_type`==`password`, the password, max length is 8
        """
        return pulumi.get(self, "auth_password")

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[_builtins.str]:
        """
        auth type. enum: `md5`, `none`, `password`
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "bfd_minimum_interval")

    @_builtins.property
    @pulumi.getter(name="deadInterval")
    def dead_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "dead_interval")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hello_interval")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[_builtins.str]:
        """
        interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        """
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[_builtins.bool]:
        """
        By default, we'll re-advertise all learned OSPF routes toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @_builtins.property
    @pulumi.getter
    def passive(self) -> Optional[_builtins.bool]:
        """
        Whether to send OSPF-Hello
        """
        return pulumi.get(self, "passive")


@pulumi.output_type
class SwitchOspfConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportPolicy":
            suggest = "export_policy"
        elif key == "importPolicy":
            suggest = "import_policy"
        elif key == "referenceBandwidth":
            suggest = "reference_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchOspfConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchOspfConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchOspfConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 areas: Optional[Mapping[str, 'outputs.SwitchOspfConfigAreas']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 export_policy: Optional[_builtins.str] = None,
                 import_policy: Optional[_builtins.str] = None,
                 reference_bandwidth: Optional[_builtins.str] = None):
        """
        :param Mapping[str, 'SwitchOspfConfigAreasArgs'] areas: Property key is the area name. Defines the OSPF areas configured on the switch.
        :param _builtins.bool enabled: Enable OSPF on the switch
        :param _builtins.str export_policy: optional, for basic scenario, `import_policy` can be specified and can be applied to all networks in all areas if not explicitly specified
        :param _builtins.str import_policy: optional, for basic scenario, `import_policy` can be specified and can be applied to all networks in all areas if not explicitly specified
        """
        if areas is not None:
            pulumi.set(__self__, "areas", areas)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if reference_bandwidth is not None:
            pulumi.set(__self__, "reference_bandwidth", reference_bandwidth)

    @_builtins.property
    @pulumi.getter
    def areas(self) -> Optional[Mapping[str, 'outputs.SwitchOspfConfigAreas']]:
        """
        Property key is the area name. Defines the OSPF areas configured on the switch.
        """
        return pulumi.get(self, "areas")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable OSPF on the switch
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[_builtins.str]:
        """
        optional, for basic scenario, `import_policy` can be specified and can be applied to all networks in all areas if not explicitly specified
        """
        return pulumi.get(self, "export_policy")

    @_builtins.property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[_builtins.str]:
        """
        optional, for basic scenario, `import_policy` can be specified and can be applied to all networks in all areas if not explicitly specified
        """
        return pulumi.get(self, "import_policy")

    @_builtins.property
    @pulumi.getter(name="referenceBandwidth")
    def reference_bandwidth(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "reference_bandwidth")


@pulumi.output_type
class SwitchOspfConfigAreas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noSummary":
            suggest = "no_summary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchOspfConfigAreas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchOspfConfigAreas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchOspfConfigAreas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_summary: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool no_summary: Disable OSPF summary routes for this area
        """
        if no_summary is not None:
            pulumi.set(__self__, "no_summary", no_summary)

    @_builtins.property
    @pulumi.getter(name="noSummary")
    def no_summary(self) -> Optional[_builtins.bool]:
        """
        Disable OSPF summary routes for this area
        """
        return pulumi.get(self, "no_summary")


@pulumi.output_type
class SwitchOtherIpConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evpnAnycast":
            suggest = "evpn_anycast"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchOtherIpConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchOtherIpConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchOtherIpConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evpn_anycast: Optional[_builtins.bool] = None,
                 ip: Optional[_builtins.str] = None,
                 ip6: Optional[_builtins.str] = None,
                 netmask: Optional[_builtins.str] = None,
                 netmask6: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 type6: Optional[_builtins.str] = None):
        """
        :param _builtins.bool evpn_anycast: For EVPN, if anycast is desired
        :param _builtins.str ip: Required if `type`==`static`
        :param _builtins.str ip6: Required if `type6`==`static`
        :param _builtins.str netmask: Optional, `subnet` from `network` definition will be used if defined
        :param _builtins.str netmask6: Optional, `subnet` from `network` definition will be used if defined
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if evpn_anycast is not None:
            pulumi.set(__self__, "evpn_anycast", evpn_anycast)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @_builtins.property
    @pulumi.getter(name="evpnAnycast")
    def evpn_anycast(self) -> Optional[_builtins.bool]:
        """
        For EVPN, if anycast is desired
        """
        return pulumi.get(self, "evpn_anycast")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> Optional[_builtins.str]:
        """
        Required if `type6`==`static`
        """
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> Optional[_builtins.str]:
        """
        Optional, `subnet` from `network` definition will be used if defined
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> Optional[_builtins.str]:
        """
        Optional, `subnet` from `network` definition will be used if defined
        """
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> Optional[_builtins.str]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")


@pulumi.output_type
class SwitchPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeDisableLacp":
            suggest = "ae_disable_lacp"
        elif key == "aeIdx":
            suggest = "ae_idx"
        elif key == "aeLacpSlow":
            suggest = "ae_lacp_slow"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicUsage":
            suggest = "dynamic_usage"
        elif key == "noLocalOverwrite":
            suggest = "no_local_overwrite"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portNetwork":
            suggest = "port_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage: _builtins.str,
                 ae_disable_lacp: Optional[_builtins.bool] = None,
                 ae_idx: Optional[_builtins.int] = None,
                 ae_lacp_slow: Optional[_builtins.bool] = None,
                 aggregated: Optional[_builtins.bool] = None,
                 critical: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 duplex: Optional[_builtins.str] = None,
                 dynamic_usage: Optional[_builtins.str] = None,
                 esilag: Optional[_builtins.bool] = None,
                 mtu: Optional[_builtins.int] = None,
                 no_local_overwrite: Optional[_builtins.bool] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_network: Optional[_builtins.str] = None,
                 speed: Optional[_builtins.str] = None):
        """
        :param _builtins.str usage: Port usage name. For Q-in-Q, use `vlan_tunnel`. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param _builtins.bool ae_disable_lacp: To disable LACP support for the AE interface
        :param _builtins.int ae_idx: Users could force to use the designated AE name
        :param _builtins.bool ae_lacp_slow: To use fast timeout
        :param _builtins.bool critical: To generate port up/down alarm
        :param _builtins.bool disable_autoneg: If `speed` and `duplex` are specified, whether to disable autonegotiation
        :param _builtins.str duplex: enum: `auto`, `full`, `half`
        :param _builtins.str dynamic_usage: Enable dynamic usage for this port. Set to `dynamic` to enable.
        :param _builtins.int mtu: Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param _builtins.bool no_local_overwrite: Prevent helpdesk to override the port config
        :param _builtins.str port_network: Required if `usage`==`vlan_tunnel`. Q-in-Q tunneling using All-in-one bundling. This also enables standard L2PT for interfaces that are not encapsulation tunnel interfaces and uses MAC rewrite operation. [View more information](https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/q-in-q.html#id-understanding-qinq-tunneling-and-vlan-translation)
        :param _builtins.str speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_slow is not None:
            pulumi.set(__self__, "ae_lacp_slow", ae_lacp_slow)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_usage is not None:
            pulumi.set(__self__, "dynamic_usage", dynamic_usage)
        if esilag is not None:
            pulumi.set(__self__, "esilag", esilag)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if no_local_overwrite is not None:
            pulumi.set(__self__, "no_local_overwrite", no_local_overwrite)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        """
        Port usage name. For Q-in-Q, use `vlan_tunnel`. If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[_builtins.bool]:
        """
        To disable LACP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @_builtins.property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[_builtins.int]:
        """
        Users could force to use the designated AE name
        """
        return pulumi.get(self, "ae_idx")

    @_builtins.property
    @pulumi.getter(name="aeLacpSlow")
    def ae_lacp_slow(self) -> Optional[_builtins.bool]:
        """
        To use fast timeout
        """
        return pulumi.get(self, "ae_lacp_slow")

    @_builtins.property
    @pulumi.getter
    def aggregated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "aggregated")

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[_builtins.bool]:
        """
        To generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        """
        If `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="dynamicUsage")
    def dynamic_usage(self) -> Optional[_builtins.str]:
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        return pulumi.get(self, "dynamic_usage")

    @_builtins.property
    @pulumi.getter
    def esilag(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "esilag")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        """
        Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter(name="noLocalOverwrite")
    def no_local_overwrite(self) -> Optional[_builtins.bool]:
        """
        Prevent helpdesk to override the port config
        """
        return pulumi.get(self, "no_local_overwrite")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Required if `usage`==`vlan_tunnel`. Q-in-Q tunneling using All-in-one bundling. This also enables standard L2PT for interfaces that are not encapsulation tunnel interfaces and uses MAC rewrite operation. [View more information](https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/q-in-q.html#id-understanding-qinq-tunneling-and-vlan-translation)
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class SwitchPortConfigOverwrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macLimit":
            suggest = "mac_limit"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portNetwork":
            suggest = "port_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortConfigOverwrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortConfigOverwrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortConfigOverwrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 duplex: Optional[_builtins.str] = None,
                 mac_limit: Optional[_builtins.str] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_network: Optional[_builtins.str] = None,
                 speed: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Whether the port is disabled
        :param _builtins.str duplex: Link connection mode. enum: `auto`, `full`, `half`
        :param _builtins.bool poe_disabled: Whether PoE capabilities are disabled for a port
        :param _builtins.str port_network: Native network/vlan for untagged traffic
        :param _builtins.str speed: Port Speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        Link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mac_limit")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        """
        Whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        Port Speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")


@pulumi.output_type
class SwitchPortMirroring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputNetworksIngresses":
            suggest = "input_networks_ingresses"
        elif key == "inputPortIdsEgresses":
            suggest = "input_port_ids_egresses"
        elif key == "inputPortIdsIngresses":
            suggest = "input_port_ids_ingresses"
        elif key == "outputIpAddress":
            suggest = "output_ip_address"
        elif key == "outputNetwork":
            suggest = "output_network"
        elif key == "outputPortId":
            suggest = "output_port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortMirroring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortMirroring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortMirroring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_networks_ingresses: Optional[Sequence[_builtins.str]] = None,
                 input_port_ids_egresses: Optional[Sequence[_builtins.str]] = None,
                 input_port_ids_ingresses: Optional[Sequence[_builtins.str]] = None,
                 output_ip_address: Optional[_builtins.str] = None,
                 output_network: Optional[_builtins.str] = None,
                 output_port_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] input_networks_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[_builtins.str] input_port_ids_egresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param Sequence[_builtins.str] input_port_ids_ingresses: At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param _builtins.str output_ip_address: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        :param _builtins.str output_network: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        :param _builtins.str output_port_id: Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_ip_address is not None:
            pulumi.set(__self__, "output_ip_address", output_ip_address)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @_builtins.property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @_builtins.property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @_builtins.property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @_builtins.property
    @pulumi.getter(name="outputIpAddress")
    def output_ip_address(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_ip_address")

    @_builtins.property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @_builtins.property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[_builtins.str]:
        """
        Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")


@pulumi.output_type
class SwitchPortUsages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNetworks":
            suggest = "all_networks"
        elif key == "allowDhcpd":
            suggest = "allow_dhcpd"
        elif key == "allowMultipleSupplicants":
            suggest = "allow_multiple_supplicants"
        elif key == "bypassAuthWhenServerDown":
            suggest = "bypass_auth_when_server_down"
        elif key == "bypassAuthWhenServerDownForUnknownClient":
            suggest = "bypass_auth_when_server_down_for_unknown_client"
        elif key == "communityVlanId":
            suggest = "community_vlan_id"
        elif key == "disableAutoneg":
            suggest = "disable_autoneg"
        elif key == "dynamicVlanNetworks":
            suggest = "dynamic_vlan_networks"
        elif key == "enableMacAuth":
            suggest = "enable_mac_auth"
        elif key == "enableQos":
            suggest = "enable_qos"
        elif key == "guestNetwork":
            suggest = "guest_network"
        elif key == "interIsolationNetworkLink":
            suggest = "inter_isolation_network_link"
        elif key == "interSwitchLink":
            suggest = "inter_switch_link"
        elif key == "macAuthOnly":
            suggest = "mac_auth_only"
        elif key == "macAuthPreferred":
            suggest = "mac_auth_preferred"
        elif key == "macAuthProtocol":
            suggest = "mac_auth_protocol"
        elif key == "macLimit":
            suggest = "mac_limit"
        elif key == "persistMac":
            suggest = "persist_mac"
        elif key == "poeDisabled":
            suggest = "poe_disabled"
        elif key == "portAuth":
            suggest = "port_auth"
        elif key == "portNetwork":
            suggest = "port_network"
        elif key == "reauthInterval":
            suggest = "reauth_interval"
        elif key == "resetDefaultWhen":
            suggest = "reset_default_when"
        elif key == "serverFailNetwork":
            suggest = "server_fail_network"
        elif key == "serverRejectNetwork":
            suggest = "server_reject_network"
        elif key == "stormControl":
            suggest = "storm_control"
        elif key == "stpEdge":
            suggest = "stp_edge"
        elif key == "stpNoRootPort":
            suggest = "stp_no_root_port"
        elif key == "stpP2p":
            suggest = "stp_p2p"
        elif key == "useVstp":
            suggest = "use_vstp"
        elif key == "voipNetwork":
            suggest = "voip_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortUsages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortUsages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortUsages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_networks: Optional[_builtins.bool] = None,
                 allow_dhcpd: Optional[_builtins.bool] = None,
                 allow_multiple_supplicants: Optional[_builtins.bool] = None,
                 bypass_auth_when_server_down: Optional[_builtins.bool] = None,
                 bypass_auth_when_server_down_for_unknown_client: Optional[_builtins.bool] = None,
                 community_vlan_id: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 disable_autoneg: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 duplex: Optional[_builtins.str] = None,
                 dynamic_vlan_networks: Optional[Sequence[_builtins.str]] = None,
                 enable_mac_auth: Optional[_builtins.bool] = None,
                 enable_qos: Optional[_builtins.bool] = None,
                 guest_network: Optional[_builtins.str] = None,
                 inter_isolation_network_link: Optional[_builtins.bool] = None,
                 inter_switch_link: Optional[_builtins.bool] = None,
                 mac_auth_only: Optional[_builtins.bool] = None,
                 mac_auth_preferred: Optional[_builtins.bool] = None,
                 mac_auth_protocol: Optional[_builtins.str] = None,
                 mac_limit: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 mtu: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 persist_mac: Optional[_builtins.bool] = None,
                 poe_disabled: Optional[_builtins.bool] = None,
                 port_auth: Optional[_builtins.str] = None,
                 port_network: Optional[_builtins.str] = None,
                 reauth_interval: Optional[_builtins.str] = None,
                 reset_default_when: Optional[_builtins.str] = None,
                 rules: Optional[Sequence['outputs.SwitchPortUsagesRule']] = None,
                 server_fail_network: Optional[_builtins.str] = None,
                 server_reject_network: Optional[_builtins.str] = None,
                 speed: Optional[_builtins.str] = None,
                 storm_control: Optional['outputs.SwitchPortUsagesStormControl'] = None,
                 stp_edge: Optional[_builtins.bool] = None,
                 stp_no_root_port: Optional[_builtins.bool] = None,
                 stp_p2p: Optional[_builtins.bool] = None,
                 use_vstp: Optional[_builtins.bool] = None,
                 voip_network: Optional[_builtins.str] = None):
        """
        :param _builtins.bool all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param _builtins.bool allow_dhcpd: Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        :param _builtins.bool allow_multiple_supplicants: Only if `mode`!=`dynamic`
        :param _builtins.bool bypass_auth_when_server_down: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param _builtins.bool bypass_auth_when_server_down_for_unknown_client: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param _builtins.int community_vlan_id: Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
        :param _builtins.str description: Only if `mode`!=`dynamic`
        :param _builtins.bool disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param _builtins.bool disabled: Only if `mode`!=`dynamic` whether the port is disabled
        :param _builtins.str duplex: Only if `mode`!=`dynamic`, link connection mode. enum: `auto`, `full`, `half`
        :param Sequence[_builtins.str] dynamic_vlan_networks: Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param _builtins.bool enable_mac_auth: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        :param _builtins.bool enable_qos: Only if `mode`!=`dynamic`
        :param _builtins.str guest_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param _builtins.bool inter_isolation_network_link: `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        :param _builtins.bool inter_switch_link: Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param _builtins.bool mac_auth_only: Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        :param _builtins.bool mac_auth_preferred: Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        :param _builtins.str mac_auth_protocol: Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param _builtins.str mac_limit: Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        :param _builtins.str mode: `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        :param _builtins.str mtu: Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        :param Sequence[_builtins.str] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param _builtins.bool persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param _builtins.bool poe_disabled: Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        :param _builtins.str port_auth: Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        :param _builtins.str port_network: Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        :param _builtins.str reauth_interval: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        :param _builtins.str reset_default_when: Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        :param Sequence['SwitchPortUsagesRuleArgs'] rules: Only if `mode`==`dynamic`
        :param _builtins.str server_fail_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        :param _builtins.str server_reject_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        :param _builtins.str speed: Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        :param 'SwitchPortUsagesStormControlArgs' storm_control: Switch storm control. Only if `mode`!=`dynamic`
        :param _builtins.bool stp_edge: Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        :param _builtins.bool use_vstp: If this is connected to a vstp network
        :param _builtins.str voip_network: Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unknown_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unknown_client", bypass_auth_when_server_down_for_unknown_client)
        if community_vlan_id is not None:
            pulumi.set(__self__, "community_vlan_id", community_vlan_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_isolation_network_link is not None:
            pulumi.set(__self__, "inter_isolation_network_link", inter_isolation_network_link)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if reset_default_when is not None:
            pulumi.set(__self__, "reset_default_when", reset_default_when)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if server_fail_network is not None:
            pulumi.set(__self__, "server_fail_network", server_fail_network)
        if server_reject_network is not None:
            pulumi.set(__self__, "server_reject_network", server_reject_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if stp_no_root_port is not None:
            pulumi.set(__self__, "stp_no_root_port", stp_no_root_port)
        if stp_p2p is not None:
            pulumi.set(__self__, "stp_p2p", stp_p2p)
        if use_vstp is not None:
            pulumi.set(__self__, "use_vstp", use_vstp)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @_builtins.property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @_builtins.property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system's default setting which depends on whether the port is an access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @_builtins.property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "allow_multiple_supplicants")

    @_builtins.property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @_builtins.property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnknownClient")
    def bypass_auth_when_server_down_for_unknown_client(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unknown_client")

    @_builtins.property
    @pulumi.getter(name="communityVlanId")
    def community_vlan_id(self) -> Optional[_builtins.int]:
        """
        Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
        """
        return pulumi.get(self, "community_vlan_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def duplex(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic`, link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @_builtins.property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @_builtins.property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @_builtins.property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "enable_qos")

    @_builtins.property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @_builtins.property
    @pulumi.getter(name="interIsolationNetworkLink")
    def inter_isolation_network_link(self) -> Optional[_builtins.bool]:
        """
        `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_isolation_network_link")

    @_builtins.property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @_builtins.property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @_builtins.property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        return pulumi.get(self, "mac_auth_preferred")

    @_builtins.property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @_builtins.property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
        """
        return pulumi.get(self, "mac_limit")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @_builtins.property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @_builtins.property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
        """
        return pulumi.get(self, "reauth_interval")

    @_builtins.property
    @pulumi.getter(name="resetDefaultWhen")
    def reset_default_when(self) -> Optional[_builtins.str]:
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        return pulumi.get(self, "reset_default_when")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.SwitchPortUsagesRule']]:
        """
        Only if `mode`==`dynamic`
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="serverFailNetwork")
    def server_fail_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        return pulumi.get(self, "server_fail_network")

    @_builtins.property
    @pulumi.getter(name="serverRejectNetwork")
    def server_reject_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "server_reject_network")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
        """
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional['outputs.SwitchPortUsagesStormControl']:
        """
        Switch storm control. Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "storm_control")

    @_builtins.property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[_builtins.bool]:
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @_builtins.property
    @pulumi.getter(name="stpNoRootPort")
    def stp_no_root_port(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stp_no_root_port")

    @_builtins.property
    @pulumi.getter(name="stpP2p")
    def stp_p2p(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "stp_p2p")

    @_builtins.property
    @pulumi.getter(name="useVstp")
    def use_vstp(self) -> Optional[_builtins.bool]:
        """
        If this is connected to a vstp network
        """
        return pulumi.get(self, "use_vstp")

    @_builtins.property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[_builtins.str]:
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")


@pulumi.output_type
class SwitchPortUsagesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "equalsAnies":
            suggest = "equals_anies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortUsagesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortUsagesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortUsagesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 src: _builtins.str,
                 equals: Optional[_builtins.str] = None,
                 equals_anies: Optional[Sequence[_builtins.str]] = None,
                 expression: Optional[_builtins.str] = None,
                 usage: Optional[_builtins.str] = None):
        """
        :param _builtins.str src: enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        :param Sequence[_builtins.str] equals_anies: Use `equals_any` to match any item in a list
        :param _builtins.str expression: "[0:3]":"abcdef" > "abc"
               "split(.)[1]": "a.b.c" > "b"
               "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        :param _builtins.str usage: `port_usage` name
        """
        pulumi.set(__self__, "src", src)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if equals_anies is not None:
            pulumi.set(__self__, "equals_anies", equals_anies)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @_builtins.property
    @pulumi.getter
    def src(self) -> _builtins.str:
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        return pulumi.get(self, "src")

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "equals")

    @_builtins.property
    @pulumi.getter(name="equalsAnies")
    def equals_anies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Use `equals_any` to match any item in a list
        """
        return pulumi.get(self, "equals_anies")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[_builtins.str]:
        """
        `port_usage` name
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class SwitchPortUsagesStormControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePort":
            suggest = "disable_port"
        elif key == "noBroadcast":
            suggest = "no_broadcast"
        elif key == "noMulticast":
            suggest = "no_multicast"
        elif key == "noRegisteredMulticast":
            suggest = "no_registered_multicast"
        elif key == "noUnknownUnicast":
            suggest = "no_unknown_unicast"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchPortUsagesStormControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchPortUsagesStormControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchPortUsagesStormControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_port: Optional[_builtins.bool] = None,
                 no_broadcast: Optional[_builtins.bool] = None,
                 no_multicast: Optional[_builtins.bool] = None,
                 no_registered_multicast: Optional[_builtins.bool] = None,
                 no_unknown_unicast: Optional[_builtins.bool] = None,
                 percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disable_port: Whether to disable the port when storm control is triggered
        :param _builtins.bool no_broadcast: Whether to disable storm control on broadcast traffic
        :param _builtins.bool no_multicast: Whether to disable storm control on multicast traffic
        :param _builtins.bool no_registered_multicast: Whether to disable storm control on registered multicast traffic
        :param _builtins.bool no_unknown_unicast: Whether to disable storm control on unknown unicast traffic
        :param _builtins.int percentage: Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if disable_port is not None:
            pulumi.set(__self__, "disable_port", disable_port)
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @_builtins.property
    @pulumi.getter(name="disablePort")
    def disable_port(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the port when storm control is triggered
        """
        return pulumi.get(self, "disable_port")

    @_builtins.property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @_builtins.property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @_builtins.property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @_builtins.property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[_builtins.bool]:
        """
        Whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> Optional[_builtins.int]:
        """
        Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class SwitchRadiusConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctImmediateUpdate":
            suggest = "acct_immediate_update"
        elif key == "acctInterimInterval":
            suggest = "acct_interim_interval"
        elif key == "acctServers":
            suggest = "acct_servers"
        elif key == "authServerSelection":
            suggest = "auth_server_selection"
        elif key == "authServers":
            suggest = "auth_servers"
        elif key == "authServersRetries":
            suggest = "auth_servers_retries"
        elif key == "authServersTimeout":
            suggest = "auth_servers_timeout"
        elif key == "coaEnabled":
            suggest = "coa_enabled"
        elif key == "coaPort":
            suggest = "coa_port"
        elif key == "fastDot1xTimers":
            suggest = "fast_dot1x_timers"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRadiusConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRadiusConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRadiusConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_immediate_update: Optional[_builtins.bool] = None,
                 acct_interim_interval: Optional[_builtins.int] = None,
                 acct_servers: Optional[Sequence['outputs.SwitchRadiusConfigAcctServer']] = None,
                 auth_server_selection: Optional[_builtins.str] = None,
                 auth_servers: Optional[Sequence['outputs.SwitchRadiusConfigAuthServer']] = None,
                 auth_servers_retries: Optional[_builtins.int] = None,
                 auth_servers_timeout: Optional[_builtins.int] = None,
                 coa_enabled: Optional[_builtins.bool] = None,
                 coa_port: Optional[_builtins.str] = None,
                 fast_dot1x_timers: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int acct_interim_interval: How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param _builtins.str auth_server_selection: enum: `ordered`, `unordered`
        :param _builtins.int auth_servers_retries: Radius auth session retries
        :param _builtins.int auth_servers_timeout: Radius auth session timeout
        :param _builtins.str network: Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param _builtins.str source_ip: Use `network`or `source_ip`
        """
        if acct_immediate_update is not None:
            pulumi.set(__self__, "acct_immediate_update", acct_immediate_update)
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_server_selection is not None:
            pulumi.set(__self__, "auth_server_selection", auth_server_selection)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if coa_enabled is not None:
            pulumi.set(__self__, "coa_enabled", coa_enabled)
        if coa_port is not None:
            pulumi.set(__self__, "coa_port", coa_port)
        if fast_dot1x_timers is not None:
            pulumi.set(__self__, "fast_dot1x_timers", fast_dot1x_timers)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="acctImmediateUpdate")
    def acct_immediate_update(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "acct_immediate_update")

    @_builtins.property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[_builtins.int]:
        """
        How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.SwitchRadiusConfigAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter(name="authServerSelection")
    def auth_server_selection(self) -> Optional[_builtins.str]:
        """
        enum: `ordered`, `unordered`
        """
        return pulumi.get(self, "auth_server_selection")

    @_builtins.property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[Sequence['outputs.SwitchRadiusConfigAuthServer']]:
        return pulumi.get(self, "auth_servers")

    @_builtins.property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[_builtins.int]:
        """
        Radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @_builtins.property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[_builtins.int]:
        """
        Radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @_builtins.property
    @pulumi.getter(name="coaEnabled")
    def coa_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "coa_enabled")

    @_builtins.property
    @pulumi.getter(name="coaPort")
    def coa_port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "coa_port")

    @_builtins.property
    @pulumi.getter(name="fastDot1xTimers")
    def fast_dot1x_timers(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fast_dot1x_timers")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.str]:
        """
        Use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwitchRadiusConfigAcctServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRadiusConfigAcctServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRadiusConfigAcctServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRadiusConfigAcctServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")


@pulumi.output_type
class SwitchRadiusConfigAuthServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keywrapEnabled":
            suggest = "keywrap_enabled"
        elif key == "keywrapFormat":
            suggest = "keywrap_format"
        elif key == "keywrapKek":
            suggest = "keywrap_kek"
        elif key == "keywrapMack":
            suggest = "keywrap_mack"
        elif key == "requireMessageAuthenticator":
            suggest = "require_message_authenticator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRadiusConfigAuthServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRadiusConfigAuthServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRadiusConfigAuthServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 secret: _builtins.str,
                 keywrap_enabled: Optional[_builtins.bool] = None,
                 keywrap_format: Optional[_builtins.str] = None,
                 keywrap_kek: Optional[_builtins.str] = None,
                 keywrap_mack: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 require_message_authenticator: Optional[_builtins.bool] = None):
        """
        :param _builtins.str host: IP/ hostname of RADIUS server
        :param _builtins.str secret: Secret of RADIUS server
        :param _builtins.str keywrap_format: enum: `ascii`, `hex`
        :param _builtins.bool require_message_authenticator: Whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        IP/ hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "keywrap_enabled")

    @_builtins.property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[_builtins.str]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @_builtins.property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_kek")

    @_builtins.property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keywrap_mack")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[_builtins.bool]:
        """
        Whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")


@pulumi.output_type
class SwitchRemoteSyslog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sendToAllServers":
            suggest = "send_to_all_servers"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRemoteSyslog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRemoteSyslog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRemoteSyslog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional['outputs.SwitchRemoteSyslogArchive'] = None,
                 cacerts: Optional[Sequence[_builtins.str]] = None,
                 console: Optional['outputs.SwitchRemoteSyslogConsole'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 files: Optional[Sequence['outputs.SwitchRemoteSyslogFile']] = None,
                 network: Optional[_builtins.str] = None,
                 send_to_all_servers: Optional[_builtins.bool] = None,
                 servers: Optional[Sequence['outputs.SwitchRemoteSyslogServer']] = None,
                 time_format: Optional[_builtins.str] = None,
                 users: Optional[Sequence['outputs.SwitchRemoteSyslogUser']] = None):
        """
        :param _builtins.str network: If source_address is configured, will use the vlan firstly otherwise use source_ip
        :param _builtins.str time_format: enum: `millisecond`, `year`, `year millisecond`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if cacerts is not None:
            pulumi.set(__self__, "cacerts", cacerts)
        if console is not None:
            pulumi.set(__self__, "console", console)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if send_to_all_servers is not None:
            pulumi.set(__self__, "send_to_all_servers", send_to_all_servers)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional['outputs.SwitchRemoteSyslogArchive']:
        return pulumi.get(self, "archive")

    @_builtins.property
    @pulumi.getter
    def cacerts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cacerts")

    @_builtins.property
    @pulumi.getter
    def console(self) -> Optional['outputs.SwitchRemoteSyslogConsole']:
        return pulumi.get(self, "console")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogFile']]:
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="sendToAllServers")
    def send_to_all_servers(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "send_to_all_servers")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogServer']]:
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class SwitchRemoteSyslogArchive(dict):
    def __init__(__self__, *,
                 files: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "size")


@pulumi.output_type
class SwitchRemoteSyslogConsole(dict):
    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.SwitchRemoteSyslogConsoleContent']] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogConsoleContent']]:
        return pulumi.get(self, "contents")


@pulumi.output_type
class SwitchRemoteSyslogConsoleContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class SwitchRemoteSyslogFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableTls":
            suggest = "enable_tls"
        elif key == "explicitPriority":
            suggest = "explicit_priority"
        elif key == "structuredData":
            suggest = "structured_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRemoteSyslogFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRemoteSyslogFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRemoteSyslogFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional['outputs.SwitchRemoteSyslogFileArchive'] = None,
                 contents: Optional[Sequence['outputs.SwitchRemoteSyslogFileContent']] = None,
                 enable_tls: Optional[_builtins.bool] = None,
                 explicit_priority: Optional[_builtins.bool] = None,
                 file: Optional[_builtins.str] = None,
                 match: Optional[_builtins.str] = None,
                 structured_data: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_tls: Only if `protocol`==`tcp`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if enable_tls is not None:
            pulumi.set(__self__, "enable_tls", enable_tls)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional['outputs.SwitchRemoteSyslogFileArchive']:
        return pulumi.get(self, "archive")

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogFileContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="enableTls")
    def enable_tls(self) -> Optional[_builtins.bool]:
        """
        Only if `protocol`==`tcp`
        """
        return pulumi.get(self, "enable_tls")

    @_builtins.property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "explicit_priority")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "structured_data")


@pulumi.output_type
class SwitchRemoteSyslogFileArchive(dict):
    def __init__(__self__, *,
                 files: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "size")


@pulumi.output_type
class SwitchRemoteSyslogFileContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class SwitchRemoteSyslogServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "explicitPriority":
            suggest = "explicit_priority"
        elif key == "routingInstance":
            suggest = "routing_instance"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "structuredData":
            suggest = "structured_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchRemoteSyslogServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchRemoteSyslogServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchRemoteSyslogServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.SwitchRemoteSyslogServerContent']] = None,
                 explicit_priority: Optional[_builtins.bool] = None,
                 facility: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 match: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 routing_instance: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 source_address: Optional[_builtins.str] = None,
                 structured_data: Optional[_builtins.bool] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str protocol: enum: `tcp`, `udp`
        :param _builtins.str server_name: Name of the server
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        :param _builtins.str source_address: If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routing_instance is not None:
            pulumi.set(__self__, "routing_instance", routing_instance)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogServerContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "explicit_priority")

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        enum: `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="routingInstance")
    def routing_instance(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "routing_instance")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Name of the server
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        """
        If source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "structured_data")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class SwitchRemoteSyslogServerContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class SwitchRemoteSyslogUser(dict):
    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.SwitchRemoteSyslogUserContent']] = None,
                 match: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.SwitchRemoteSyslogUserContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class SwitchRemoteSyslogUserContent(dict):
    def __init__(__self__, *,
                 facility: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None):
        """
        :param _builtins.str facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param _builtins.str severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def facility(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class SwitchSnmpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientLists":
            suggest = "client_lists"
        elif key == "engineId":
            suggest = "engine_id"
        elif key == "engineIdType":
            suggest = "engine_id_type"
        elif key == "trapGroups":
            suggest = "trap_groups"
        elif key == "v2cConfigs":
            suggest = "v2c_configs"
        elif key == "v3Config":
            suggest = "v3_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_lists: Optional[Sequence['outputs.SwitchSnmpConfigClientList']] = None,
                 contact: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 engine_id: Optional[_builtins.str] = None,
                 engine_id_type: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 trap_groups: Optional[Sequence['outputs.SwitchSnmpConfigTrapGroup']] = None,
                 v2c_configs: Optional[Sequence['outputs.SwitchSnmpConfigV2cConfig']] = None,
                 v3_config: Optional['outputs.SwitchSnmpConfigV3Config'] = None,
                 views: Optional[Sequence['outputs.SwitchSnmpConfigView']] = None):
        """
        :param _builtins.str engine_id_type: enum: `local`, `use_mac_address`
        """
        if client_lists is not None:
            pulumi.set(__self__, "client_lists", client_lists)
        if contact is not None:
            pulumi.set(__self__, "contact", contact)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if engine_id_type is not None:
            pulumi.set(__self__, "engine_id_type", engine_id_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if trap_groups is not None:
            pulumi.set(__self__, "trap_groups", trap_groups)
        if v2c_configs is not None:
            pulumi.set(__self__, "v2c_configs", v2c_configs)
        if v3_config is not None:
            pulumi.set(__self__, "v3_config", v3_config)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter(name="clientLists")
    def client_lists(self) -> Optional[Sequence['outputs.SwitchSnmpConfigClientList']]:
        return pulumi.get(self, "client_lists")

    @_builtins.property
    @pulumi.getter
    def contact(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "contact")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "engine_id")

    @_builtins.property
    @pulumi.getter(name="engineIdType")
    def engine_id_type(self) -> Optional[_builtins.str]:
        """
        enum: `local`, `use_mac_address`
        """
        return pulumi.get(self, "engine_id_type")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="trapGroups")
    def trap_groups(self) -> Optional[Sequence['outputs.SwitchSnmpConfigTrapGroup']]:
        return pulumi.get(self, "trap_groups")

    @_builtins.property
    @pulumi.getter(name="v2cConfigs")
    def v2c_configs(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV2cConfig']]:
        return pulumi.get(self, "v2c_configs")

    @_builtins.property
    @pulumi.getter(name="v3Config")
    def v3_config(self) -> Optional['outputs.SwitchSnmpConfigV3Config']:
        return pulumi.get(self, "v3_config")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.SwitchSnmpConfigView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class SwitchSnmpConfigClientList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientListName":
            suggest = "client_list_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigClientList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigClientList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigClientList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_list_name: Optional[_builtins.str] = None,
                 clients: Optional[Sequence[_builtins.str]] = None):
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_list_name")

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "clients")


@pulumi.output_type
class SwitchSnmpConfigTrapGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigTrapGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigTrapGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigTrapGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Optional[Sequence[_builtins.str]] = None,
                 group_name: Optional[_builtins.str] = None,
                 targets: Optional[Sequence[_builtins.str]] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str group_name: Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        :param _builtins.str version: enum: `all`, `v1`, `v2`
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "targets")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        enum: `all`, `v1`, `v2`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SwitchSnmpConfigV2cConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientListName":
            suggest = "client_list_name"
        elif key == "communityName":
            suggest = "community_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV2cConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV2cConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV2cConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization: Optional[_builtins.str] = None,
                 client_list_name: Optional[_builtins.str] = None,
                 community_name: Optional[_builtins.str] = None,
                 view: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_list_name: Client_list_name here should refer to client_list above
        :param _builtins.str view: View name here should be defined in views above
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[_builtins.str]:
        """
        Client_list_name here should refer to client_list above
        """
        return pulumi.get(self, "client_list_name")

    @_builtins.property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "community_name")

    @_builtins.property
    @pulumi.getter
    def view(self) -> Optional[_builtins.str]:
        """
        View name here should be defined in views above
        """
        return pulumi.get(self, "view")


@pulumi.output_type
class SwitchSnmpConfigV3Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyFilters":
            suggest = "notify_filters"
        elif key == "targetAddresses":
            suggest = "target_addresses"
        elif key == "targetParameters":
            suggest = "target_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notifies: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigNotify']] = None,
                 notify_filters: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigNotifyFilter']] = None,
                 target_addresses: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigTargetAddress']] = None,
                 target_parameters: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigTargetParameter']] = None,
                 usms: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigUsm']] = None,
                 vacm: Optional['outputs.SwitchSnmpConfigV3ConfigVacm'] = None):
        if notifies is not None:
            pulumi.set(__self__, "notifies", notifies)
        if notify_filters is not None:
            pulumi.set(__self__, "notify_filters", notify_filters)
        if target_addresses is not None:
            pulumi.set(__self__, "target_addresses", target_addresses)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)
        if usms is not None:
            pulumi.set(__self__, "usms", usms)
        if vacm is not None:
            pulumi.set(__self__, "vacm", vacm)

    @_builtins.property
    @pulumi.getter
    def notifies(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigNotify']]:
        return pulumi.get(self, "notifies")

    @_builtins.property
    @pulumi.getter(name="notifyFilters")
    def notify_filters(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigNotifyFilter']]:
        return pulumi.get(self, "notify_filters")

    @_builtins.property
    @pulumi.getter(name="targetAddresses")
    def target_addresses(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigTargetAddress']]:
        return pulumi.get(self, "target_addresses")

    @_builtins.property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigTargetParameter']]:
        return pulumi.get(self, "target_parameters")

    @_builtins.property
    @pulumi.getter
    def usms(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigUsm']]:
        return pulumi.get(self, "usms")

    @_builtins.property
    @pulumi.getter
    def vacm(self) -> Optional['outputs.SwitchSnmpConfigV3ConfigVacm']:
        return pulumi.get(self, "vacm")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigNotify(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 tag: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str type: enum: `inform`, `trap`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `inform`, `trap`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigNotifyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profileName":
            suggest = "profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigNotifyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigNotifyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigNotifyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigNotifyFilterContent']] = None,
                 profile_name: Optional[_builtins.str] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigNotifyFilterContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profile_name")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigNotifyFilterContent(dict):
    def __init__(__self__, *,
                 oid: _builtins.str,
                 include: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "oid", oid)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @_builtins.property
    @pulumi.getter
    def oid(self) -> _builtins.str:
        return pulumi.get(self, "oid")

    @_builtins.property
    @pulumi.getter
    def include(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigTargetAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressMask":
            suggest = "address_mask"
        elif key == "targetAddressName":
            suggest = "target_address_name"
        elif key == "tagList":
            suggest = "tag_list"
        elif key == "targetParameters":
            suggest = "target_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigTargetAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigTargetAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigTargetAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 address_mask: _builtins.str,
                 target_address_name: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 tag_list: Optional[_builtins.str] = None,
                 target_parameters: Optional[_builtins.str] = None):
        """
        :param _builtins.str tag_list: Refer to notify tag, can be multiple with blank
        :param _builtins.str target_parameters: Refer to notify target parameters name
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "address_mask", address_mask)
        pulumi.set(__self__, "target_address_name", target_address_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressMask")
    def address_mask(self) -> _builtins.str:
        return pulumi.get(self, "address_mask")

    @_builtins.property
    @pulumi.getter(name="targetAddressName")
    def target_address_name(self) -> _builtins.str:
        return pulumi.get(self, "target_address_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[_builtins.str]:
        """
        Refer to notify tag, can be multiple with blank
        """
        return pulumi.get(self, "tag_list")

    @_builtins.property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[_builtins.str]:
        """
        Refer to notify target parameters name
        """
        return pulumi.get(self, "target_parameters")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigTargetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageProcessingModel":
            suggest = "message_processing_model"
        elif key == "notifyFilter":
            suggest = "notify_filter"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "securityModel":
            suggest = "security_model"
        elif key == "securityName":
            suggest = "security_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigTargetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigTargetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigTargetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_processing_model: _builtins.str,
                 name: _builtins.str,
                 notify_filter: Optional[_builtins.str] = None,
                 security_level: Optional[_builtins.str] = None,
                 security_model: Optional[_builtins.str] = None,
                 security_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str message_processing_model: enum: `v1`, `v2c`, `v3`
        :param _builtins.str notify_filter: Refer to profile-name in notify_filter
        :param _builtins.str security_level: enum: `authentication`, `none`, `privacy`
        :param _builtins.str security_model: enum: `usm`, `v1`, `v2c`
        :param _builtins.str security_name: Refer to security_name in usm
        """
        pulumi.set(__self__, "message_processing_model", message_processing_model)
        pulumi.set(__self__, "name", name)
        if notify_filter is not None:
            pulumi.set(__self__, "notify_filter", notify_filter)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @_builtins.property
    @pulumi.getter(name="messageProcessingModel")
    def message_processing_model(self) -> _builtins.str:
        """
        enum: `v1`, `v2c`, `v3`
        """
        return pulumi.get(self, "message_processing_model")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notifyFilter")
    def notify_filter(self) -> Optional[_builtins.str]:
        """
        Refer to profile-name in notify_filter
        """
        return pulumi.get(self, "notify_filter")

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[_builtins.str]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @_builtins.property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[_builtins.str]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @_builtins.property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[_builtins.str]:
        """
        Refer to security_name in usm
        """
        return pulumi.get(self, "security_name")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigUsm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engineType":
            suggest = "engine_type"
        elif key == "remoteEngineId":
            suggest = "remote_engine_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigUsm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigUsm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigUsm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine_type: _builtins.str,
                 remote_engine_id: Optional[_builtins.str] = None,
                 users: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigUsmUser']] = None):
        """
        :param _builtins.str engine_type: enum: `local_engine`, `remote_engine`
        :param _builtins.str remote_engine_id: Required only if `engine_type`==`remote_engine`
        """
        pulumi.set(__self__, "engine_type", engine_type)
        if remote_engine_id is not None:
            pulumi.set(__self__, "remote_engine_id", remote_engine_id)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> _builtins.str:
        """
        enum: `local_engine`, `remote_engine`
        """
        return pulumi.get(self, "engine_type")

    @_builtins.property
    @pulumi.getter(name="remoteEngineId")
    def remote_engine_id(self) -> Optional[_builtins.str]:
        """
        Required only if `engine_type`==`remote_engine`
        """
        return pulumi.get(self, "remote_engine_id")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigUsmUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigUsmUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationPassword":
            suggest = "authentication_password"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "encryptionPassword":
            suggest = "encryption_password"
        elif key == "encryptionType":
            suggest = "encryption_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigUsmUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigUsmUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigUsmUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_password: Optional[_builtins.str] = None,
                 authentication_type: Optional[_builtins.str] = None,
                 encryption_password: Optional[_builtins.str] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str authentication_password: Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        :param _builtins.str authentication_type: sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        :param _builtins.str encryption_password: Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        :param _builtins.str encryption_type: enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        if authentication_password is not None:
            pulumi.set(__self__, "authentication_password", authentication_password)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="authenticationPassword")
    def authentication_password(self) -> Optional[_builtins.str]:
        """
        Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        return pulumi.get(self, "authentication_password")

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[_builtins.str]:
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`
        """
        return pulumi.get(self, "authentication_type")

    @_builtins.property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[_builtins.str]:
        """
        Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        return pulumi.get(self, "encryption_password")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigVacm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityToGroup":
            suggest = "security_to_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigVacm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigVacm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigVacm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accesses: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigVacmAccess']] = None,
                 security_to_group: Optional['outputs.SwitchSnmpConfigV3ConfigVacmSecurityToGroup'] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if security_to_group is not None:
            pulumi.set(__self__, "security_to_group", security_to_group)

    @_builtins.property
    @pulumi.getter
    def accesses(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigVacmAccess']]:
        return pulumi.get(self, "accesses")

    @_builtins.property
    @pulumi.getter(name="securityToGroup")
    def security_to_group(self) -> Optional['outputs.SwitchSnmpConfigV3ConfigVacmSecurityToGroup']:
        return pulumi.get(self, "security_to_group")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigVacmAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "prefixLists":
            suggest = "prefix_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigVacmAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigVacmAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigVacmAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 prefix_lists: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigVacmAccessPrefixList']] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigVacmAccessPrefixList']]:
        return pulumi.get(self, "prefix_lists")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigVacmAccessPrefixList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextPrefix":
            suggest = "context_prefix"
        elif key == "notifyView":
            suggest = "notify_view"
        elif key == "readView":
            suggest = "read_view"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "securityModel":
            suggest = "security_model"
        elif key == "writeView":
            suggest = "write_view"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigVacmAccessPrefixList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigVacmAccessPrefixList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigVacmAccessPrefixList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_prefix: Optional[_builtins.str] = None,
                 notify_view: Optional[_builtins.str] = None,
                 read_view: Optional[_builtins.str] = None,
                 security_level: Optional[_builtins.str] = None,
                 security_model: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 write_view: Optional[_builtins.str] = None):
        """
        :param _builtins.str context_prefix: Only required if `type`==`context_prefix`
        :param _builtins.str notify_view: Refer to view name
        :param _builtins.str read_view: Refer to view name
        :param _builtins.str security_level: enum: `authentication`, `none`, `privacy`
        :param _builtins.str security_model: enum: `any`, `usm`, `v1`, `v2c`
        :param _builtins.str type: enum: `context_prefix`, `default_context_prefix`
        :param _builtins.str write_view: Refer to view name
        """
        if context_prefix is not None:
            pulumi.set(__self__, "context_prefix", context_prefix)
        if notify_view is not None:
            pulumi.set(__self__, "notify_view", notify_view)
        if read_view is not None:
            pulumi.set(__self__, "read_view", read_view)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if write_view is not None:
            pulumi.set(__self__, "write_view", write_view)

    @_builtins.property
    @pulumi.getter(name="contextPrefix")
    def context_prefix(self) -> Optional[_builtins.str]:
        """
        Only required if `type`==`context_prefix`
        """
        return pulumi.get(self, "context_prefix")

    @_builtins.property
    @pulumi.getter(name="notifyView")
    def notify_view(self) -> Optional[_builtins.str]:
        """
        Refer to view name
        """
        return pulumi.get(self, "notify_view")

    @_builtins.property
    @pulumi.getter(name="readView")
    def read_view(self) -> Optional[_builtins.str]:
        """
        Refer to view name
        """
        return pulumi.get(self, "read_view")

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[_builtins.str]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @_builtins.property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="writeView")
    def write_view(self) -> Optional[_builtins.str]:
        """
        Refer to view name
        """
        return pulumi.get(self, "write_view")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigVacmSecurityToGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityModel":
            suggest = "security_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigVacmSecurityToGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigVacmSecurityToGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigVacmSecurityToGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent']] = None,
                 security_model: Optional[_builtins.str] = None):
        """
        :param _builtins.str security_model: enum: `usm`, `v1`, `v2c`
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[Sequence['outputs.SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent']]:
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[_builtins.str]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")


@pulumi.output_type
class SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityName":
            suggest = "security_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group: Optional[_builtins.str] = None,
                 security_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str group: Refer to group_name under access
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Refer to group_name under access
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_name")


@pulumi.output_type
class SwitchSnmpConfigView(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewName":
            suggest = "view_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSnmpConfigView. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSnmpConfigView.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSnmpConfigView.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include: Optional[_builtins.bool] = None,
                 oid: Optional[_builtins.str] = None,
                 view_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool include: If the root oid configured is included
        """
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @_builtins.property
    @pulumi.getter
    def include(self) -> Optional[_builtins.bool]:
        """
        If the root oid configured is included
        """
        return pulumi.get(self, "include")

    @_builtins.property
    @pulumi.getter
    def oid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oid")

    @_builtins.property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "view_name")


@pulumi.output_type
class SwitchStpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bridgePriority":
            suggest = "bridge_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchStpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchStpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchStpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bridge_priority: Optional[_builtins.str] = None):
        """
        :param _builtins.str bridge_priority: Switch STP priority. Range [0, 4k, 8k.. 60k] in steps of 4k. Bridge priority applies to both VSTP and RSTP.
        """
        if bridge_priority is not None:
            pulumi.set(__self__, "bridge_priority", bridge_priority)

    @_builtins.property
    @pulumi.getter(name="bridgePriority")
    def bridge_priority(self) -> Optional[_builtins.str]:
        """
        Switch STP priority. Range [0, 4k, 8k.. 60k] in steps of 4k. Bridge priority applies to both VSTP and RSTP.
        """
        return pulumi.get(self, "bridge_priority")


@pulumi.output_type
class SwitchSwitchMgmt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apAffinityThreshold":
            suggest = "ap_affinity_threshold"
        elif key == "cliBanner":
            suggest = "cli_banner"
        elif key == "cliIdleTimeout":
            suggest = "cli_idle_timeout"
        elif key == "configRevertTimer":
            suggest = "config_revert_timer"
        elif key == "dhcpOptionFqdn":
            suggest = "dhcp_option_fqdn"
        elif key == "disableOobDownAlarm":
            suggest = "disable_oob_down_alarm"
        elif key == "fipsEnabled":
            suggest = "fips_enabled"
        elif key == "localAccounts":
            suggest = "local_accounts"
        elif key == "mxedgeProxyHost":
            suggest = "mxedge_proxy_host"
        elif key == "mxedgeProxyPort":
            suggest = "mxedge_proxy_port"
        elif key == "protectRe":
            suggest = "protect_re"
        elif key == "removeExistingConfigs":
            suggest = "remove_existing_configs"
        elif key == "rootPassword":
            suggest = "root_password"
        elif key == "useMxedgeProxy":
            suggest = "use_mxedge_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSwitchMgmt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSwitchMgmt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSwitchMgmt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[_builtins.int] = None,
                 cli_banner: Optional[_builtins.str] = None,
                 cli_idle_timeout: Optional[_builtins.int] = None,
                 config_revert_timer: Optional[_builtins.int] = None,
                 dhcp_option_fqdn: Optional[_builtins.bool] = None,
                 disable_oob_down_alarm: Optional[_builtins.bool] = None,
                 fips_enabled: Optional[_builtins.bool] = None,
                 local_accounts: Optional[Mapping[str, 'outputs.SwitchSwitchMgmtLocalAccounts']] = None,
                 mxedge_proxy_host: Optional[_builtins.str] = None,
                 mxedge_proxy_port: Optional[_builtins.str] = None,
                 protect_re: Optional['outputs.SwitchSwitchMgmtProtectRe'] = None,
                 remove_existing_configs: Optional[_builtins.bool] = None,
                 root_password: Optional[_builtins.str] = None,
                 tacacs: Optional['outputs.SwitchSwitchMgmtTacacs'] = None,
                 use_mxedge_proxy: Optional[_builtins.bool] = None):
        """
        :param _builtins.int ap_affinity_threshold: AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        :param _builtins.str cli_banner: Set Banners for switches. Allows markup formatting
        :param _builtins.int cli_idle_timeout: Sets timeout for switches
        :param _builtins.int config_revert_timer: Rollback timer for commit confirmed
        :param _builtins.bool dhcp_option_fqdn: Enable to provide the FQDN with DHCP option 81
        :param Mapping[str, 'SwitchSwitchMgmtLocalAccountsArgs'] local_accounts: Property key is the user name. For Local user authentication
        :param _builtins.str mxedge_proxy_host: IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        :param _builtins.str mxedge_proxy_port: Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        :param 'SwitchSwitchMgmtProtectReArgs' protect_re: Restrict inbound-traffic to host
               when enabled, all traffic that is not essential to our operation will be dropped 
               e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        :param _builtins.bool remove_existing_configs: By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        :param _builtins.bool use_mxedge_proxy: To use mxedge as proxy
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)
        if cli_banner is not None:
            pulumi.set(__self__, "cli_banner", cli_banner)
        if cli_idle_timeout is not None:
            pulumi.set(__self__, "cli_idle_timeout", cli_idle_timeout)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if dhcp_option_fqdn is not None:
            pulumi.set(__self__, "dhcp_option_fqdn", dhcp_option_fqdn)
        if disable_oob_down_alarm is not None:
            pulumi.set(__self__, "disable_oob_down_alarm", disable_oob_down_alarm)
        if fips_enabled is not None:
            pulumi.set(__self__, "fips_enabled", fips_enabled)
        if local_accounts is not None:
            pulumi.set(__self__, "local_accounts", local_accounts)
        if mxedge_proxy_host is not None:
            pulumi.set(__self__, "mxedge_proxy_host", mxedge_proxy_host)
        if mxedge_proxy_port is not None:
            pulumi.set(__self__, "mxedge_proxy_port", mxedge_proxy_port)
        if protect_re is not None:
            pulumi.set(__self__, "protect_re", protect_re)
        if remove_existing_configs is not None:
            pulumi.set(__self__, "remove_existing_configs", remove_existing_configs)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if tacacs is not None:
            pulumi.set(__self__, "tacacs", tacacs)
        if use_mxedge_proxy is not None:
            pulumi.set(__self__, "use_mxedge_proxy", use_mxedge_proxy)

    @_builtins.property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[_builtins.int]:
        """
        AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")

    @_builtins.property
    @pulumi.getter(name="cliBanner")
    def cli_banner(self) -> Optional[_builtins.str]:
        """
        Set Banners for switches. Allows markup formatting
        """
        return pulumi.get(self, "cli_banner")

    @_builtins.property
    @pulumi.getter(name="cliIdleTimeout")
    def cli_idle_timeout(self) -> Optional[_builtins.int]:
        """
        Sets timeout for switches
        """
        return pulumi.get(self, "cli_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[_builtins.int]:
        """
        Rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @_builtins.property
    @pulumi.getter(name="dhcpOptionFqdn")
    def dhcp_option_fqdn(self) -> Optional[_builtins.bool]:
        """
        Enable to provide the FQDN with DHCP option 81
        """
        return pulumi.get(self, "dhcp_option_fqdn")

    @_builtins.property
    @pulumi.getter(name="disableOobDownAlarm")
    def disable_oob_down_alarm(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_oob_down_alarm")

    @_builtins.property
    @pulumi.getter(name="fipsEnabled")
    def fips_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fips_enabled")

    @_builtins.property
    @pulumi.getter(name="localAccounts")
    def local_accounts(self) -> Optional[Mapping[str, 'outputs.SwitchSwitchMgmtLocalAccounts']]:
        """
        Property key is the user name. For Local user authentication
        """
        return pulumi.get(self, "local_accounts")

    @_builtins.property
    @pulumi.getter(name="mxedgeProxyHost")
    def mxedge_proxy_host(self) -> Optional[_builtins.str]:
        """
        IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud
        """
        return pulumi.get(self, "mxedge_proxy_host")

    @_builtins.property
    @pulumi.getter(name="mxedgeProxyPort")
    def mxedge_proxy_port(self) -> Optional[_builtins.str]:
        """
        Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535
        """
        return pulumi.get(self, "mxedge_proxy_port")

    @_builtins.property
    @pulumi.getter(name="protectRe")
    def protect_re(self) -> Optional['outputs.SwitchSwitchMgmtProtectRe']:
        """
        Restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "protect_re")

    @_builtins.property
    @pulumi.getter(name="removeExistingConfigs")
    def remove_existing_configs(self) -> Optional[_builtins.bool]:
        """
        By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.
        """
        return pulumi.get(self, "remove_existing_configs")

    @_builtins.property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "root_password")

    @_builtins.property
    @pulumi.getter
    def tacacs(self) -> Optional['outputs.SwitchSwitchMgmtTacacs']:
        return pulumi.get(self, "tacacs")

    @_builtins.property
    @pulumi.getter(name="useMxedgeProxy")
    def use_mxedge_proxy(self) -> Optional[_builtins.bool]:
        """
        To use mxedge as proxy
        """
        return pulumi.get(self, "use_mxedge_proxy")


@pulumi.output_type
class SwitchSwitchMgmtLocalAccounts(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param _builtins.str role: enum: `admin`, `helpdesk`, `none`, `read`
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class SwitchSwitchMgmtProtectRe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedServices":
            suggest = "allowed_services"
        elif key == "hitCount":
            suggest = "hit_count"
        elif key == "trustedHosts":
            suggest = "trusted_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSwitchMgmtProtectRe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSwitchMgmtProtectRe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSwitchMgmtProtectRe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_services: Optional[Sequence[_builtins.str]] = None,
                 customs: Optional[Sequence['outputs.SwitchSwitchMgmtProtectReCustom']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 hit_count: Optional[_builtins.bool] = None,
                 trusted_hosts: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allowed_services: optionally, services we'll allow. enum: `icmp`, `ssh`
        :param _builtins.bool enabled: When enabled, all traffic that is not essential to our operation will be dropped
               e.g. ntp / dns / traffic to mist will be allowed by default
                    if dhcpd is enabled, we'll make sure it works
        :param _builtins.bool hit_count: Whether to enable hit count for Protect_RE policy
        :param Sequence[_builtins.str] trusted_hosts: host/subnets we'll allow traffic to/from
        """
        if allowed_services is not None:
            pulumi.set(__self__, "allowed_services", allowed_services)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hit_count is not None:
            pulumi.set(__self__, "hit_count", hit_count)
        if trusted_hosts is not None:
            pulumi.set(__self__, "trusted_hosts", trusted_hosts)

    @_builtins.property
    @pulumi.getter(name="allowedServices")
    def allowed_services(self) -> Optional[Sequence[_builtins.str]]:
        """
        optionally, services we'll allow. enum: `icmp`, `ssh`
        """
        return pulumi.get(self, "allowed_services")

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.SwitchSwitchMgmtProtectReCustom']]:
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="hitCount")
    def hit_count(self) -> Optional[_builtins.bool]:
        """
        Whether to enable hit count for Protect_RE policy
        """
        return pulumi.get(self, "hit_count")

    @_builtins.property
    @pulumi.getter(name="trustedHosts")
    def trusted_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        host/subnets we'll allow traffic to/from
        """
        return pulumi.get(self, "trusted_hosts")


@pulumi.output_type
class SwitchSwitchMgmtProtectReCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSwitchMgmtProtectReCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSwitchMgmtProtectReCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSwitchMgmtProtectReCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnets: Sequence[_builtins.str],
                 port_range: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str port_range: matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        :param _builtins.str protocol: enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        pulumi.set(__self__, "subnets", subnets)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class SwitchSwitchMgmtTacacs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acctServers":
            suggest = "acct_servers"
        elif key == "defaultRole":
            suggest = "default_role"
        elif key == "tacplusServers":
            suggest = "tacplus_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchSwitchMgmtTacacs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchSwitchMgmtTacacs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchSwitchMgmtTacacs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acct_servers: Optional[Sequence['outputs.SwitchSwitchMgmtTacacsAcctServer']] = None,
                 default_role: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 network: Optional[_builtins.str] = None,
                 tacplus_servers: Optional[Sequence['outputs.SwitchSwitchMgmtTacacsTacplusServer']] = None):
        """
        :param _builtins.str default_role: enum: `admin`, `helpdesk`, `none`, `read`
        :param _builtins.str network: Which network the TACACS server resides
        """
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if default_role is not None:
            pulumi.set(__self__, "default_role", default_role)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if tacplus_servers is not None:
            pulumi.set(__self__, "tacplus_servers", tacplus_servers)

    @_builtins.property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[Sequence['outputs.SwitchSwitchMgmtTacacsAcctServer']]:
        return pulumi.get(self, "acct_servers")

    @_builtins.property
    @pulumi.getter(name="defaultRole")
    def default_role(self) -> Optional[_builtins.str]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "default_role")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        Which network the TACACS server resides
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="tacplusServers")
    def tacplus_servers(self) -> Optional[Sequence['outputs.SwitchSwitchMgmtTacacsTacplusServer']]:
        return pulumi.get(self, "tacplus_servers")


@pulumi.output_type
class SwitchSwitchMgmtTacacsAcctServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SwitchSwitchMgmtTacacsTacplusServer(dict):
    def __init__(__self__, *,
                 host: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.int] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SwitchVirtualChassis(dict):
    def __init__(__self__, *,
                 members: Optional[Sequence['outputs.SwitchVirtualChassisMember']] = None,
                 preprovisioned: Optional[_builtins.bool] = None):
        """
        :param Sequence['SwitchVirtualChassisMemberArgs'] members: List of Virtual Chassis members
        :param _builtins.bool preprovisioned: To configure whether the VC is preprovisioned or nonprovisioned
        """
        if members is not None:
            pulumi.set(__self__, "members", members)
        if preprovisioned is not None:
            pulumi.set(__self__, "preprovisioned", preprovisioned)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[Sequence['outputs.SwitchVirtualChassisMember']]:
        """
        List of Virtual Chassis members
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter
    def preprovisioned(self) -> Optional[_builtins.bool]:
        """
        To configure whether the VC is preprovisioned or nonprovisioned
        """
        return pulumi.get(self, "preprovisioned")


@pulumi.output_type
class SwitchVirtualChassisMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memberId":
            suggest = "member_id"
        elif key == "vcRole":
            suggest = "vc_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchVirtualChassisMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchVirtualChassisMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchVirtualChassisMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mac: _builtins.str,
                 member_id: _builtins.int,
                 vc_role: _builtins.str):
        """
        :param _builtins.str mac: fpc0, same as the mac of device_id
        :param _builtins.str vc_role: Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
        """
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "member_id", member_id)
        pulumi.set(__self__, "vc_role", vc_role)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        fpc0, same as the mac of device_id
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.int:
        return pulumi.get(self, "member_id")

    @_builtins.property
    @pulumi.getter(name="vcRole")
    def vc_role(self) -> _builtins.str:
        """
        Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
        """
        return pulumi.get(self, "vc_role")


@pulumi.output_type
class SwitchVrfConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SwitchVrfInstances(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evpnAutoLoopbackSubnet":
            suggest = "evpn_auto_loopback_subnet"
        elif key == "evpnAutoLoopbackSubnet6":
            suggest = "evpn_auto_loopback_subnet6"
        elif key == "extraRoutes":
            suggest = "extra_routes"
        elif key == "extraRoutes6":
            suggest = "extra_routes6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchVrfInstances. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchVrfInstances.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchVrfInstances.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evpn_auto_loopback_subnet: Optional[_builtins.str] = None,
                 evpn_auto_loopback_subnet6: Optional[_builtins.str] = None,
                 extra_routes: Optional[Mapping[str, 'outputs.SwitchVrfInstancesExtraRoutes']] = None,
                 extra_routes6: Optional[Mapping[str, 'outputs.SwitchVrfInstancesExtraRoutes6']] = None,
                 networks: Optional[Sequence[_builtins.str]] = None):
        """
        :param Mapping[str, 'SwitchVrfInstancesExtraRoutesArgs'] extra_routes: Property key is the destination CIDR (e.g. "10.0.0.0/8")
        :param Mapping[str, 'SwitchVrfInstancesExtraRoutes6Args'] extra_routes6: Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        if evpn_auto_loopback_subnet is not None:
            pulumi.set(__self__, "evpn_auto_loopback_subnet", evpn_auto_loopback_subnet)
        if evpn_auto_loopback_subnet6 is not None:
            pulumi.set(__self__, "evpn_auto_loopback_subnet6", evpn_auto_loopback_subnet6)
        if extra_routes is not None:
            pulumi.set(__self__, "extra_routes", extra_routes)
        if extra_routes6 is not None:
            pulumi.set(__self__, "extra_routes6", extra_routes6)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter(name="evpnAutoLoopbackSubnet")
    def evpn_auto_loopback_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "evpn_auto_loopback_subnet")

    @_builtins.property
    @pulumi.getter(name="evpnAutoLoopbackSubnet6")
    def evpn_auto_loopback_subnet6(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "evpn_auto_loopback_subnet6")

    @_builtins.property
    @pulumi.getter(name="extraRoutes")
    def extra_routes(self) -> Optional[Mapping[str, 'outputs.SwitchVrfInstancesExtraRoutes']]:
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        return pulumi.get(self, "extra_routes")

    @_builtins.property
    @pulumi.getter(name="extraRoutes6")
    def extra_routes6(self) -> Optional[Mapping[str, 'outputs.SwitchVrfInstancesExtraRoutes6']]:
        """
        Property key is the destination CIDR (e.g. "2a02:1234:420a:10c9::/64")
        """
        return pulumi.get(self, "extra_routes6")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "networks")


@pulumi.output_type
class SwitchVrfInstancesExtraRoutes6(dict):
    def __init__(__self__, *,
                 via: Optional[_builtins.str] = None):
        """
        :param _builtins.str via: Next-hop address
        """
        if via is not None:
            pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> Optional[_builtins.str]:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")


@pulumi.output_type
class SwitchVrfInstancesExtraRoutes(dict):
    def __init__(__self__, *,
                 via: _builtins.str):
        """
        :param _builtins.str via: Next-hop address
        """
        pulumi.set(__self__, "via", via)

    @_builtins.property
    @pulumi.getter
    def via(self) -> _builtins.str:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")


@pulumi.output_type
class SwitchVrrpConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 groups: Optional[Mapping[str, 'outputs.SwitchVrrpConfigGroups']] = None):
        """
        :param Mapping[str, 'SwitchVrrpConfigGroupsArgs'] groups: Property key is the VRRP name
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Mapping[str, 'outputs.SwitchVrrpConfigGroups']]:
        """
        Property key is the VRRP name
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class SwitchVrrpConfigGroups(dict):
    def __init__(__self__, *,
                 preempt: Optional[_builtins.bool] = None,
                 priority: Optional[_builtins.int] = None):
        """
        :param _builtins.bool preempt: If `true`, allow preemption (a backup router can preempt a primary router)
        """
        if preempt is not None:
            pulumi.set(__self__, "preempt", preempt)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def preempt(self) -> Optional[_builtins.bool]:
        """
        If `true`, allow preemption (a backup router can preempt a primary router)
        """
        return pulumi.get(self, "preempt")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "priority")


@pulumi.output_type
class BaseLatlng(dict):
    def __init__(__self__, *,
                 lat: _builtins.float,
                 lng: _builtins.float):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> _builtins.float:
        return pulumi.get(self, "lat")

    @_builtins.property
    @pulumi.getter
    def lng(self) -> _builtins.float:
        return pulumi.get(self, "lng")


@pulumi.output_type
class GetApStatsDeviceApStatResult(dict):
    def __init__(__self__, *,
                 auto_placement: 'outputs.GetApStatsDeviceApStatAutoPlacementResult',
                 auto_upgrade_stat: 'outputs.GetApStatsDeviceApStatAutoUpgradeStatResult',
                 ble_stat: 'outputs.GetApStatsDeviceApStatBleStatResult',
                 cert_expiry: _builtins.float,
                 config_reverted: _builtins.bool,
                 cpu_system: _builtins.int,
                 cpu_util: _builtins.int,
                 created_time: _builtins.float,
                 deviceprofile_id: _builtins.str,
                 env_stat: 'outputs.GetApStatsDeviceApStatEnvStatResult',
                 esl_stat: 'outputs.GetApStatsDeviceApStatEslStatResult',
                 ext_ip: _builtins.str,
                 fwupdate: 'outputs.GetApStatsDeviceApStatFwupdateResult',
                 gps: 'outputs.GetApStatsDeviceApStatGpsResult',
                 hw_rev: _builtins.str,
                 id: _builtins.str,
                 inactive_wired_vlans: Sequence[_builtins.int],
                 iot_stat: Mapping[str, 'outputs.GetApStatsDeviceApStatIotStatResult'],
                 ip: _builtins.str,
                 ip_config: 'outputs.GetApStatsDeviceApStatIpConfigResult',
                 ip_stat: 'outputs.GetApStatsDeviceApStatIpStatResult',
                 l2tp_stat: Mapping[str, 'outputs.GetApStatsDeviceApStatL2tpStatResult'],
                 last_seen: _builtins.float,
                 last_trouble: 'outputs.GetApStatsDeviceApStatLastTroubleResult',
                 led: 'outputs.GetApStatsDeviceApStatLedResult',
                 lldp_stat: 'outputs.GetApStatsDeviceApStatLldpStatResult',
                 locating: _builtins.bool,
                 locked: _builtins.bool,
                 mac: _builtins.str,
                 map_id: _builtins.str,
                 mem_used_kb: _builtins.int,
                 mesh_downlinks: Mapping[str, 'outputs.GetApStatsDeviceApStatMeshDownlinksResult'],
                 mesh_uplink: 'outputs.GetApStatsDeviceApStatMeshUplinkResult',
                 model: _builtins.str,
                 modified_time: _builtins.float,
                 mount: _builtins.str,
                 name: _builtins.str,
                 notes: _builtins.str,
                 num_clients: _builtins.int,
                 num_wlans: _builtins.int,
                 org_id: _builtins.str,
                 port_stat: Mapping[str, 'outputs.GetApStatsDeviceApStatPortStatResult'],
                 power_budget: _builtins.int,
                 power_constrained: _builtins.bool,
                 power_opmode: _builtins.str,
                 power_src: _builtins.str,
                 radio_stat: 'outputs.GetApStatsDeviceApStatRadioStatResult',
                 rx_bps: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 serial: _builtins.str,
                 site_id: _builtins.str,
                 status: _builtins.str,
                 switch_redundancy: 'outputs.GetApStatsDeviceApStatSwitchRedundancyResult',
                 tx_bps: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 uptime: _builtins.float,
                 usb_stat: 'outputs.GetApStatsDeviceApStatUsbStatResult',
                 version: _builtins.str,
                 x: _builtins.float,
                 y: _builtins.float):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param 'GetApStatsDeviceApStatEnvStatArgs' env_stat: Device environment, including CPU temperature, Ambient temperature, Humidity, Attitude, Pressure, Accelerometers, Magnetometers and vCore Voltage
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param 'GetApStatsDeviceApStatIpConfigArgs' ip_config: IP AP settings
        :param Mapping[str, 'GetApStatsDeviceApStatL2tpStatArgs'] l2tp_stat: L2TP tunnel status (key is the wxtunnel_id)
        :param _builtins.float last_seen: Last seen timestamp
        :param 'GetApStatsDeviceApStatLastTroubleArgs' last_trouble: Last trouble code of switch
        :param 'GetApStatsDeviceApStatLedArgs' led: LED AP settings
        :param 'GetApStatsDeviceApStatLldpStatArgs' lldp_stat: LLDP Stat (neighbor information, power negotiations)
        :param _builtins.bool locked: Whether this AP is considered locked (placement / orientation has been vetted)
        :param _builtins.str mac: Device mac
        :param Mapping[str, 'GetApStatsDeviceApStatMeshDownlinksArgs'] mesh_downlinks: Property key is the mesh downlink id (e.g. `00000000-0000-0000-1000-5c5b35000010`)
        :param _builtins.str model: Device model
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.int num_clients: How many wireless clients are currently connected
        :param _builtins.int num_wlans: How many WLANs are applied to the device
        :param Mapping[str, 'GetApStatsDeviceApStatPortStatArgs'] port_stat: Property key is the port name (e.g. `eth0`)
        :param _builtins.int power_budget: In mW, surplus if positive or deficit if negative
        :param _builtins.bool power_constrained: Whether insufficient power
        :param _builtins.str power_opmode: Constrained mode
        :param _builtins.str power_src: DC Input / PoE 802.3at / PoE 802.3af / LLDP / ? (unknown)
        :param _builtins.int rx_bps: Rate of receiving traffic, bits/seconds, last known
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.str serial: Serial Number
        :param _builtins.int tx_bps: Rate of transmitting traffic, bits/seconds, last known
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.float uptime: How long, in seconds, has the device been up (or rebooted)
        """
        pulumi.set(__self__, "auto_placement", auto_placement)
        pulumi.set(__self__, "auto_upgrade_stat", auto_upgrade_stat)
        pulumi.set(__self__, "ble_stat", ble_stat)
        pulumi.set(__self__, "cert_expiry", cert_expiry)
        pulumi.set(__self__, "config_reverted", config_reverted)
        pulumi.set(__self__, "cpu_system", cpu_system)
        pulumi.set(__self__, "cpu_util", cpu_util)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        pulumi.set(__self__, "env_stat", env_stat)
        pulumi.set(__self__, "esl_stat", esl_stat)
        pulumi.set(__self__, "ext_ip", ext_ip)
        pulumi.set(__self__, "fwupdate", fwupdate)
        pulumi.set(__self__, "gps", gps)
        pulumi.set(__self__, "hw_rev", hw_rev)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inactive_wired_vlans", inactive_wired_vlans)
        pulumi.set(__self__, "iot_stat", iot_stat)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_config", ip_config)
        pulumi.set(__self__, "ip_stat", ip_stat)
        pulumi.set(__self__, "l2tp_stat", l2tp_stat)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "last_trouble", last_trouble)
        pulumi.set(__self__, "led", led)
        pulumi.set(__self__, "lldp_stat", lldp_stat)
        pulumi.set(__self__, "locating", locating)
        pulumi.set(__self__, "locked", locked)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "map_id", map_id)
        pulumi.set(__self__, "mem_used_kb", mem_used_kb)
        pulumi.set(__self__, "mesh_downlinks", mesh_downlinks)
        pulumi.set(__self__, "mesh_uplink", mesh_uplink)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "mount", mount)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "num_clients", num_clients)
        pulumi.set(__self__, "num_wlans", num_wlans)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "port_stat", port_stat)
        pulumi.set(__self__, "power_budget", power_budget)
        pulumi.set(__self__, "power_constrained", power_constrained)
        pulumi.set(__self__, "power_opmode", power_opmode)
        pulumi.set(__self__, "power_src", power_src)
        pulumi.set(__self__, "radio_stat", radio_stat)
        pulumi.set(__self__, "rx_bps", rx_bps)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "switch_redundancy", switch_redundancy)
        pulumi.set(__self__, "tx_bps", tx_bps)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "usb_stat", usb_stat)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @_builtins.property
    @pulumi.getter(name="autoPlacement")
    def auto_placement(self) -> 'outputs.GetApStatsDeviceApStatAutoPlacementResult':
        return pulumi.get(self, "auto_placement")

    @_builtins.property
    @pulumi.getter(name="autoUpgradeStat")
    def auto_upgrade_stat(self) -> 'outputs.GetApStatsDeviceApStatAutoUpgradeStatResult':
        return pulumi.get(self, "auto_upgrade_stat")

    @_builtins.property
    @pulumi.getter(name="bleStat")
    def ble_stat(self) -> 'outputs.GetApStatsDeviceApStatBleStatResult':
        return pulumi.get(self, "ble_stat")

    @_builtins.property
    @pulumi.getter(name="certExpiry")
    def cert_expiry(self) -> _builtins.float:
        return pulumi.get(self, "cert_expiry")

    @_builtins.property
    @pulumi.getter(name="configReverted")
    def config_reverted(self) -> _builtins.bool:
        return pulumi.get(self, "config_reverted")

    @_builtins.property
    @pulumi.getter(name="cpuSystem")
    def cpu_system(self) -> _builtins.int:
        return pulumi.get(self, "cpu_system")

    @_builtins.property
    @pulumi.getter(name="cpuUtil")
    def cpu_util(self) -> _builtins.int:
        return pulumi.get(self, "cpu_util")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> _builtins.str:
        return pulumi.get(self, "deviceprofile_id")

    @_builtins.property
    @pulumi.getter(name="envStat")
    def env_stat(self) -> 'outputs.GetApStatsDeviceApStatEnvStatResult':
        """
        Device environment, including CPU temperature, Ambient temperature, Humidity, Attitude, Pressure, Accelerometers, Magnetometers and vCore Voltage
        """
        return pulumi.get(self, "env_stat")

    @_builtins.property
    @pulumi.getter(name="eslStat")
    def esl_stat(self) -> 'outputs.GetApStatsDeviceApStatEslStatResult':
        return pulumi.get(self, "esl_stat")

    @_builtins.property
    @pulumi.getter(name="extIp")
    def ext_ip(self) -> _builtins.str:
        return pulumi.get(self, "ext_ip")

    @_builtins.property
    @pulumi.getter
    def fwupdate(self) -> 'outputs.GetApStatsDeviceApStatFwupdateResult':
        return pulumi.get(self, "fwupdate")

    @_builtins.property
    @pulumi.getter
    def gps(self) -> 'outputs.GetApStatsDeviceApStatGpsResult':
        return pulumi.get(self, "gps")

    @_builtins.property
    @pulumi.getter(name="hwRev")
    def hw_rev(self) -> _builtins.str:
        return pulumi.get(self, "hw_rev")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inactiveWiredVlans")
    def inactive_wired_vlans(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "inactive_wired_vlans")

    @_builtins.property
    @pulumi.getter(name="iotStat")
    def iot_stat(self) -> Mapping[str, 'outputs.GetApStatsDeviceApStatIotStatResult']:
        return pulumi.get(self, "iot_stat")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> 'outputs.GetApStatsDeviceApStatIpConfigResult':
        """
        IP AP settings
        """
        return pulumi.get(self, "ip_config")

    @_builtins.property
    @pulumi.getter(name="ipStat")
    def ip_stat(self) -> 'outputs.GetApStatsDeviceApStatIpStatResult':
        return pulumi.get(self, "ip_stat")

    @_builtins.property
    @pulumi.getter(name="l2tpStat")
    def l2tp_stat(self) -> Mapping[str, 'outputs.GetApStatsDeviceApStatL2tpStatResult']:
        """
        L2TP tunnel status (key is the wxtunnel_id)
        """
        return pulumi.get(self, "l2tp_stat")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter(name="lastTrouble")
    def last_trouble(self) -> 'outputs.GetApStatsDeviceApStatLastTroubleResult':
        """
        Last trouble code of switch
        """
        return pulumi.get(self, "last_trouble")

    @_builtins.property
    @pulumi.getter
    def led(self) -> 'outputs.GetApStatsDeviceApStatLedResult':
        """
        LED AP settings
        """
        return pulumi.get(self, "led")

    @_builtins.property
    @pulumi.getter(name="lldpStat")
    def lldp_stat(self) -> 'outputs.GetApStatsDeviceApStatLldpStatResult':
        """
        LLDP Stat (neighbor information, power negotiations)
        """
        return pulumi.get(self, "lldp_stat")

    @_builtins.property
    @pulumi.getter
    def locating(self) -> _builtins.bool:
        return pulumi.get(self, "locating")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> _builtins.bool:
        """
        Whether this AP is considered locked (placement / orientation has been vetted)
        """
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Device mac
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="mapId")
    def map_id(self) -> _builtins.str:
        return pulumi.get(self, "map_id")

    @_builtins.property
    @pulumi.getter(name="memUsedKb")
    def mem_used_kb(self) -> _builtins.int:
        return pulumi.get(self, "mem_used_kb")

    @_builtins.property
    @pulumi.getter(name="meshDownlinks")
    def mesh_downlinks(self) -> Mapping[str, 'outputs.GetApStatsDeviceApStatMeshDownlinksResult']:
        """
        Property key is the mesh downlink id (e.g. `00000000-0000-0000-1000-5c5b35000010`)
        """
        return pulumi.get(self, "mesh_downlinks")

    @_builtins.property
    @pulumi.getter(name="meshUplink")
    def mesh_uplink(self) -> 'outputs.GetApStatsDeviceApStatMeshUplinkResult':
        return pulumi.get(self, "mesh_uplink")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Device model
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> _builtins.str:
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> _builtins.str:
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="numClients")
    def num_clients(self) -> _builtins.int:
        """
        How many wireless clients are currently connected
        """
        return pulumi.get(self, "num_clients")

    @_builtins.property
    @pulumi.getter(name="numWlans")
    def num_wlans(self) -> _builtins.int:
        """
        How many WLANs are applied to the device
        """
        return pulumi.get(self, "num_wlans")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="portStat")
    def port_stat(self) -> Mapping[str, 'outputs.GetApStatsDeviceApStatPortStatResult']:
        """
        Property key is the port name (e.g. `eth0`)
        """
        return pulumi.get(self, "port_stat")

    @_builtins.property
    @pulumi.getter(name="powerBudget")
    def power_budget(self) -> _builtins.int:
        """
        In mW, surplus if positive or deficit if negative
        """
        return pulumi.get(self, "power_budget")

    @_builtins.property
    @pulumi.getter(name="powerConstrained")
    def power_constrained(self) -> _builtins.bool:
        """
        Whether insufficient power
        """
        return pulumi.get(self, "power_constrained")

    @_builtins.property
    @pulumi.getter(name="powerOpmode")
    def power_opmode(self) -> _builtins.str:
        """
        Constrained mode
        """
        return pulumi.get(self, "power_opmode")

    @_builtins.property
    @pulumi.getter(name="powerSrc")
    def power_src(self) -> _builtins.str:
        """
        DC Input / PoE 802.3at / PoE 802.3af / LLDP / ? (unknown)
        """
        return pulumi.get(self, "power_src")

    @_builtins.property
    @pulumi.getter(name="radioStat")
    def radio_stat(self) -> 'outputs.GetApStatsDeviceApStatRadioStatResult':
        return pulumi.get(self, "radio_stat")

    @_builtins.property
    @pulumi.getter(name="rxBps")
    def rx_bps(self) -> _builtins.int:
        """
        Rate of receiving traffic, bits/seconds, last known
        """
        return pulumi.get(self, "rx_bps")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial Number
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="switchRedundancy")
    def switch_redundancy(self) -> 'outputs.GetApStatsDeviceApStatSwitchRedundancyResult':
        return pulumi.get(self, "switch_redundancy")

    @_builtins.property
    @pulumi.getter(name="txBps")
    def tx_bps(self) -> _builtins.int:
        """
        Rate of transmitting traffic, bits/seconds, last known
        """
        return pulumi.get(self, "tx_bps")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.float:
        """
        How long, in seconds, has the device been up (or rebooted)
        """
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="usbStat")
    def usb_stat(self) -> 'outputs.GetApStatsDeviceApStatUsbStatResult':
        return pulumi.get(self, "usb_stat")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def x(self) -> _builtins.float:
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter
    def y(self) -> _builtins.float:
        return pulumi.get(self, "y")


@pulumi.output_type
class GetApStatsDeviceApStatAutoPlacementResult(dict):
    def __init__(__self__, *,
                 info: 'outputs.GetApStatsDeviceApStatAutoPlacementInfoResult',
                 recommended_anchor: _builtins.bool,
                 status: _builtins.str,
                 status_detail: _builtins.str,
                 x: _builtins.float,
                 x_m: _builtins.float,
                 y: _builtins.float,
                 y_m: _builtins.float):
        """
        :param 'GetApStatsDeviceApStatAutoPlacementInfoArgs' info: Additional information about auto placements AP data
        :param _builtins.bool recommended_anchor: Flag to represent if AP is recommended as an anchor by auto placement service
        :param _builtins.str status: Basic Placement Status
        :param _builtins.str status_detail: Additional info about placement status
        :param _builtins.float x: X Autoplaced Position in pixels
        :param _builtins.float x_m: X Autoplaced Position in meters
        :param _builtins.float y: Y Autoplaced Position in pixels
        :param _builtins.float y_m: X Autoplaced Position in meters
        """
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "recommended_anchor", recommended_anchor)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_detail", status_detail)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "x_m", x_m)
        pulumi.set(__self__, "y", y)
        pulumi.set(__self__, "y_m", y_m)

    @_builtins.property
    @pulumi.getter
    def info(self) -> 'outputs.GetApStatsDeviceApStatAutoPlacementInfoResult':
        """
        Additional information about auto placements AP data
        """
        return pulumi.get(self, "info")

    @_builtins.property
    @pulumi.getter(name="recommendedAnchor")
    def recommended_anchor(self) -> _builtins.bool:
        """
        Flag to represent if AP is recommended as an anchor by auto placement service
        """
        return pulumi.get(self, "recommended_anchor")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Basic Placement Status
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusDetail")
    def status_detail(self) -> _builtins.str:
        """
        Additional info about placement status
        """
        return pulumi.get(self, "status_detail")

    @_builtins.property
    @pulumi.getter
    def x(self) -> _builtins.float:
        """
        X Autoplaced Position in pixels
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter(name="xM")
    def x_m(self) -> _builtins.float:
        """
        X Autoplaced Position in meters
        """
        return pulumi.get(self, "x_m")

    @_builtins.property
    @pulumi.getter
    def y(self) -> _builtins.float:
        """
        Y Autoplaced Position in pixels
        """
        return pulumi.get(self, "y")

    @_builtins.property
    @pulumi.getter(name="yM")
    def y_m(self) -> _builtins.float:
        """
        X Autoplaced Position in meters
        """
        return pulumi.get(self, "y_m")


@pulumi.output_type
class GetApStatsDeviceApStatAutoPlacementInfoResult(dict):
    def __init__(__self__, *,
                 cluster_number: _builtins.int,
                 orientation_stats: _builtins.int,
                 probability_surface: 'outputs.GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurfaceResult'):
        """
        :param _builtins.int cluster_number: All APs sharing a given cluster number can be placed relative to each other
        :param _builtins.int orientation_stats: The orientation of an AP
        :param 'GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurfaceArgs' probability_surface: Coordinates representing a circle where the AP is most likely exists in the event of an inaccurate placement result
        """
        pulumi.set(__self__, "cluster_number", cluster_number)
        pulumi.set(__self__, "orientation_stats", orientation_stats)
        pulumi.set(__self__, "probability_surface", probability_surface)

    @_builtins.property
    @pulumi.getter(name="clusterNumber")
    def cluster_number(self) -> _builtins.int:
        """
        All APs sharing a given cluster number can be placed relative to each other
        """
        return pulumi.get(self, "cluster_number")

    @_builtins.property
    @pulumi.getter(name="orientationStats")
    def orientation_stats(self) -> _builtins.int:
        """
        The orientation of an AP
        """
        return pulumi.get(self, "orientation_stats")

    @_builtins.property
    @pulumi.getter(name="probabilitySurface")
    def probability_surface(self) -> 'outputs.GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurfaceResult':
        """
        Coordinates representing a circle where the AP is most likely exists in the event of an inaccurate placement result
        """
        return pulumi.get(self, "probability_surface")


@pulumi.output_type
class GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurfaceResult(dict):
    def __init__(__self__, *,
                 radius: _builtins.float,
                 radius_m: _builtins.float,
                 x: _builtins.float):
        """
        :param _builtins.float radius: The radius representing placement uncertainty, measured in pixels
        :param _builtins.float radius_m: The radius representing placement uncertainty, measured in meters
        :param _builtins.float x: Y-coordinate of the potential placements center, measured in pixels
        """
        pulumi.set(__self__, "radius", radius)
        pulumi.set(__self__, "radius_m", radius_m)
        pulumi.set(__self__, "x", x)

    @_builtins.property
    @pulumi.getter
    def radius(self) -> _builtins.float:
        """
        The radius representing placement uncertainty, measured in pixels
        """
        return pulumi.get(self, "radius")

    @_builtins.property
    @pulumi.getter(name="radiusM")
    def radius_m(self) -> _builtins.float:
        """
        The radius representing placement uncertainty, measured in meters
        """
        return pulumi.get(self, "radius_m")

    @_builtins.property
    @pulumi.getter
    def x(self) -> _builtins.float:
        """
        Y-coordinate of the potential placements center, measured in pixels
        """
        return pulumi.get(self, "x")


@pulumi.output_type
class GetApStatsDeviceApStatAutoUpgradeStatResult(dict):
    def __init__(__self__, *,
                 lastcheck: _builtins.int):
        pulumi.set(__self__, "lastcheck", lastcheck)

    @_builtins.property
    @pulumi.getter
    def lastcheck(self) -> _builtins.int:
        return pulumi.get(self, "lastcheck")


@pulumi.output_type
class GetApStatsDeviceApStatBleStatResult(dict):
    def __init__(__self__, *,
                 beacon_enabled: _builtins.bool,
                 beacon_rate: _builtins.int,
                 eddystone_uid_enabled: _builtins.bool,
                 eddystone_uid_freq_msec: _builtins.int,
                 eddystone_uid_instance: _builtins.str,
                 eddystone_uid_namespace: _builtins.str,
                 eddystone_url_enabled: _builtins.bool,
                 eddystone_url_freq_msec: _builtins.int,
                 eddystone_url_url: _builtins.str,
                 ibeacon_enabled: _builtins.bool,
                 ibeacon_freq_msec: _builtins.int,
                 ibeacon_major: _builtins.int,
                 ibeacon_minor: _builtins.int,
                 ibeacon_uuid: _builtins.str,
                 major: _builtins.int,
                 minors: Sequence[_builtins.int],
                 power: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 tx_resets: _builtins.int,
                 uuid: _builtins.str):
        """
        :param _builtins.int eddystone_url_freq_msec: Frequency (msec) of data emmit by Eddystone-UID beacon
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.int tx_resets: Resets due to tx hung
        """
        pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        pulumi.set(__self__, "beacon_rate", beacon_rate)
        pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        pulumi.set(__self__, "major", major)
        pulumi.set(__self__, "minors", minors)
        pulumi.set(__self__, "power", power)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "tx_resets", tx_resets)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "beacon_enabled")

    @_builtins.property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> _builtins.int:
        return pulumi.get(self, "beacon_rate")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "eddystone_uid_enabled")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> _builtins.int:
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> _builtins.str:
        return pulumi.get(self, "eddystone_uid_instance")

    @_builtins.property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> _builtins.str:
        return pulumi.get(self, "eddystone_uid_namespace")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "eddystone_url_enabled")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> _builtins.int:
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @_builtins.property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> _builtins.str:
        return pulumi.get(self, "eddystone_url_url")

    @_builtins.property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "ibeacon_enabled")

    @_builtins.property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> _builtins.int:
        return pulumi.get(self, "ibeacon_freq_msec")

    @_builtins.property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> _builtins.int:
        return pulumi.get(self, "ibeacon_major")

    @_builtins.property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> _builtins.int:
        return pulumi.get(self, "ibeacon_minor")

    @_builtins.property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> _builtins.str:
        return pulumi.get(self, "ibeacon_uuid")

    @_builtins.property
    @pulumi.getter
    def major(self) -> _builtins.int:
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minors(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "minors")

    @_builtins.property
    @pulumi.getter
    def power(self) -> _builtins.int:
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter(name="txResets")
    def tx_resets(self) -> _builtins.int:
        """
        Resets due to tx hung
        """
        return pulumi.get(self, "tx_resets")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetApStatsDeviceApStatEnvStatResult(dict):
    def __init__(__self__, *,
                 accel_x: _builtins.float,
                 accel_y: _builtins.float,
                 accel_z: _builtins.float,
                 ambient_temp: _builtins.int,
                 attitude: _builtins.int,
                 cpu_temp: _builtins.int,
                 humidity: _builtins.int,
                 magne_x: _builtins.float,
                 magne_y: _builtins.float,
                 magne_z: _builtins.float,
                 pressure: _builtins.float,
                 vcore_voltage: _builtins.int):
        pulumi.set(__self__, "accel_x", accel_x)
        pulumi.set(__self__, "accel_y", accel_y)
        pulumi.set(__self__, "accel_z", accel_z)
        pulumi.set(__self__, "ambient_temp", ambient_temp)
        pulumi.set(__self__, "attitude", attitude)
        pulumi.set(__self__, "cpu_temp", cpu_temp)
        pulumi.set(__self__, "humidity", humidity)
        pulumi.set(__self__, "magne_x", magne_x)
        pulumi.set(__self__, "magne_y", magne_y)
        pulumi.set(__self__, "magne_z", magne_z)
        pulumi.set(__self__, "pressure", pressure)
        pulumi.set(__self__, "vcore_voltage", vcore_voltage)

    @_builtins.property
    @pulumi.getter(name="accelX")
    def accel_x(self) -> _builtins.float:
        return pulumi.get(self, "accel_x")

    @_builtins.property
    @pulumi.getter(name="accelY")
    def accel_y(self) -> _builtins.float:
        return pulumi.get(self, "accel_y")

    @_builtins.property
    @pulumi.getter(name="accelZ")
    def accel_z(self) -> _builtins.float:
        return pulumi.get(self, "accel_z")

    @_builtins.property
    @pulumi.getter(name="ambientTemp")
    def ambient_temp(self) -> _builtins.int:
        return pulumi.get(self, "ambient_temp")

    @_builtins.property
    @pulumi.getter
    def attitude(self) -> _builtins.int:
        return pulumi.get(self, "attitude")

    @_builtins.property
    @pulumi.getter(name="cpuTemp")
    def cpu_temp(self) -> _builtins.int:
        return pulumi.get(self, "cpu_temp")

    @_builtins.property
    @pulumi.getter
    def humidity(self) -> _builtins.int:
        return pulumi.get(self, "humidity")

    @_builtins.property
    @pulumi.getter(name="magneX")
    def magne_x(self) -> _builtins.float:
        return pulumi.get(self, "magne_x")

    @_builtins.property
    @pulumi.getter(name="magneY")
    def magne_y(self) -> _builtins.float:
        return pulumi.get(self, "magne_y")

    @_builtins.property
    @pulumi.getter(name="magneZ")
    def magne_z(self) -> _builtins.float:
        return pulumi.get(self, "magne_z")

    @_builtins.property
    @pulumi.getter
    def pressure(self) -> _builtins.float:
        return pulumi.get(self, "pressure")

    @_builtins.property
    @pulumi.getter(name="vcoreVoltage")
    def vcore_voltage(self) -> _builtins.int:
        return pulumi.get(self, "vcore_voltage")


@pulumi.output_type
class GetApStatsDeviceApStatEslStatResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.int,
                 connected: _builtins.bool,
                 type: _builtins.str,
                 up: _builtins.bool):
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "connected", connected)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "up", up)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def connected(self) -> _builtins.bool:
        return pulumi.get(self, "connected")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")


@pulumi.output_type
class GetApStatsDeviceApStatFwupdateResult(dict):
    def __init__(__self__, *,
                 progress: _builtins.int,
                 status: _builtins.str,
                 status_id: _builtins.int,
                 timestamp: _builtins.float,
                 will_retry: _builtins.bool):
        """
        :param _builtins.str status: enum: `inprogress`, `failed`, `upgraded`
        :param _builtins.float timestamp: Epoch (seconds)
        """
        pulumi.set(__self__, "progress", progress)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_id", status_id)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "will_retry", will_retry)

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.int:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        enum: `inprogress`, `failed`, `upgraded`
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusId")
    def status_id(self) -> _builtins.int:
        return pulumi.get(self, "status_id")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="willRetry")
    def will_retry(self) -> _builtins.bool:
        return pulumi.get(self, "will_retry")


@pulumi.output_type
class GetApStatsDeviceApStatGpsResult(dict):
    def __init__(__self__, *,
                 accuracy: _builtins.float,
                 altitude: _builtins.float,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 src: _builtins.str,
                 timestamp: _builtins.float):
        """
        :param _builtins.float accuracy: The estimated accuracy or accuracy of the GPS coordinates, measured in meters.
        :param _builtins.float altitude: The elevation of the AP above sea level, measured in meters.
        :param _builtins.float latitude: The geographic latitude of the AP, measured in degrees.
        :param _builtins.float longitude: The geographic longitude of the AP, measured in degrees.
        :param _builtins.str src: The origin of the GPS data. enum:
                 * `gps`: from this devices GPS estimates
                 * `other_ap` from neighboring device GPS estimates
        :param _builtins.float timestamp: Epoch (seconds)
        """
        pulumi.set(__self__, "accuracy", accuracy)
        pulumi.set(__self__, "altitude", altitude)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "src", src)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter
    def accuracy(self) -> _builtins.float:
        """
        The estimated accuracy or accuracy of the GPS coordinates, measured in meters.
        """
        return pulumi.get(self, "accuracy")

    @_builtins.property
    @pulumi.getter
    def altitude(self) -> _builtins.float:
        """
        The elevation of the AP above sea level, measured in meters.
        """
        return pulumi.get(self, "altitude")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        """
        The geographic latitude of the AP, measured in degrees.
        """
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        """
        The geographic longitude of the AP, measured in degrees.
        """
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def src(self) -> _builtins.str:
        """
        The origin of the GPS data. enum:
          * `gps`: from this devices GPS estimates
          * `other_ap` from neighboring device GPS estimates
        """
        return pulumi.get(self, "src")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetApStatsDeviceApStatIotStatResult(dict):
    def __init__(__self__, *,
                 value: _builtins.int):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetApStatsDeviceApStatIpConfigResult(dict):
    def __init__(__self__, *,
                 dns: Sequence[_builtins.str],
                 dns_suffixes: Sequence[_builtins.str],
                 gateway: _builtins.str,
                 gateway6: _builtins.str,
                 ip: _builtins.str,
                 ip6: _builtins.str,
                 mtu: _builtins.int,
                 netmask: _builtins.str,
                 netmask6: _builtins.str,
                 type: _builtins.str,
                 type6: _builtins.str,
                 vlan_id: _builtins.int):
        """
        :param Sequence[_builtins.str] dns: If `type`==`static`
        :param Sequence[_builtins.str] dns_suffixes: Required if `type`==`static`
        :param _builtins.str gateway: Required if `type`==`static`
        :param _builtins.str ip: Required if `type`==`static`
        :param _builtins.str netmask: Required if `type`==`static`
        :param _builtins.str type: enum: `dhcp`, `static`
        :param _builtins.str type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        :param _builtins.int vlan_id: Management VLAN id, default is 1 (untagged)
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "gateway6", gateway6)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip6", ip6)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "netmask6", netmask6)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type6", type6)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        """
        If `type`==`static`
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Sequence[_builtins.str]:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> _builtins.str:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> _builtins.str:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> _builtins.int:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        """
        Required if `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> _builtins.str:
        return pulumi.get(self, "netmask6")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def type6(self) -> _builtins.str:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")

    @_builtins.property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> _builtins.int:
        """
        Management VLAN id, default is 1 (untagged)
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetApStatsDeviceApStatIpStatResult(dict):
    def __init__(__self__, *,
                 dhcp_server: _builtins.str,
                 dns: Sequence[_builtins.str],
                 dns_suffixes: Sequence[_builtins.str],
                 gateway: _builtins.str,
                 gateway6: _builtins.str,
                 ip: _builtins.str,
                 ip6: _builtins.str,
                 ips: Mapping[str, _builtins.str],
                 netmask: _builtins.str,
                 netmask6: _builtins.str):
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "gateway6", gateway6)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip6", ip6)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "netmask6", netmask6)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> _builtins.str:
        return pulumi.get(self, "dhcp_server")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> _builtins.str:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> _builtins.str:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> _builtins.str:
        return pulumi.get(self, "netmask6")


@pulumi.output_type
class GetApStatsDeviceApStatL2tpStatResult(dict):
    def __init__(__self__, *,
                 sessions: Sequence['outputs.GetApStatsDeviceApStatL2tpStatSessionResult'],
                 state: _builtins.str,
                 uptime: _builtins.int,
                 wxtunnel_id: _builtins.str):
        """
        :param Sequence['GetApStatsDeviceApStatL2tpStatSessionArgs'] sessions: List of sessions
        :param _builtins.str state: enum: `established`, `established_with_session`, `idle`, `wait-ctrl-conn`, `wait-ctrl-reply`
        :param _builtins.int uptime: Uptime
        :param _builtins.str wxtunnel_id: WxlanTunnel ID
        """
        pulumi.set(__self__, "sessions", sessions)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "wxtunnel_id", wxtunnel_id)

    @_builtins.property
    @pulumi.getter
    def sessions(self) -> Sequence['outputs.GetApStatsDeviceApStatL2tpStatSessionResult']:
        """
        List of sessions
        """
        return pulumi.get(self, "sessions")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        enum: `established`, `established_with_session`, `idle`, `wait-ctrl-conn`, `wait-ctrl-reply`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        """
        Uptime
        """
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="wxtunnelId")
    def wxtunnel_id(self) -> _builtins.str:
        """
        WxlanTunnel ID
        """
        return pulumi.get(self, "wxtunnel_id")


@pulumi.output_type
class GetApStatsDeviceApStatL2tpStatSessionResult(dict):
    def __init__(__self__, *,
                 local_sid: _builtins.int,
                 remote_id: _builtins.str,
                 remote_sid: _builtins.int,
                 state: _builtins.str):
        """
        :param _builtins.int local_sid: Remote sessions id (dynamically unless Tunnel is said to be static)
        :param _builtins.str remote_id: WxlanTunnel Remote ID (user-configured)
        :param _builtins.int remote_sid: Remote sessions id (dynamically unless Tunnel is said to be static)
        :param _builtins.str state: enum: `established`, `established_with_session`, `idle`, `wait-ctrl-conn`, `wait-ctrl-reply`
        """
        pulumi.set(__self__, "local_sid", local_sid)
        pulumi.set(__self__, "remote_id", remote_id)
        pulumi.set(__self__, "remote_sid", remote_sid)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="localSid")
    def local_sid(self) -> _builtins.int:
        """
        Remote sessions id (dynamically unless Tunnel is said to be static)
        """
        return pulumi.get(self, "local_sid")

    @_builtins.property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> _builtins.str:
        """
        WxlanTunnel Remote ID (user-configured)
        """
        return pulumi.get(self, "remote_id")

    @_builtins.property
    @pulumi.getter(name="remoteSid")
    def remote_sid(self) -> _builtins.int:
        """
        Remote sessions id (dynamically unless Tunnel is said to be static)
        """
        return pulumi.get(self, "remote_sid")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        enum: `established`, `established_with_session`, `idle`, `wait-ctrl-conn`, `wait-ctrl-reply`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetApStatsDeviceApStatLastTroubleResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 timestamp: _builtins.float):
        """
        :param _builtins.str code: Code definitions list at List Ap Led Definition
        :param _builtins.float timestamp: Epoch (seconds)
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Code definitions list at List Ap Led Definition
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetApStatsDeviceApStatLedResult(dict):
    def __init__(__self__, *,
                 brightness: _builtins.int,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "brightness", brightness)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def brightness(self) -> _builtins.int:
        return pulumi.get(self, "brightness")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetApStatsDeviceApStatLldpStatResult(dict):
    def __init__(__self__, *,
                 chassis_id: _builtins.str,
                 lldp_med_supported: _builtins.bool,
                 mgmt_addr: _builtins.str,
                 mgmt_addrs: Sequence[_builtins.str],
                 port_desc: _builtins.str,
                 port_id: _builtins.str,
                 power_allocated: _builtins.float,
                 power_draw: _builtins.float,
                 power_request_count: _builtins.int,
                 power_requested: _builtins.float,
                 system_desc: _builtins.str,
                 system_name: _builtins.str):
        """
        :param _builtins.bool lldp_med_supported: Whether it support LLDP-MED
        :param _builtins.str mgmt_addr: Switchs management address (if advertised), can be IPv4, IPv6, or MAC
        :param _builtins.str port_desc: ge-0/0/4
        :param _builtins.float power_allocated: In mW, provided/allocated by PSE
        :param _builtins.float power_draw: In mW, total power needed by PD
        :param _builtins.int power_request_count: Number of negotiations, if it keeps increasing, we don t have a stable power
        :param _builtins.float power_requested: In mW, the current power requested by PD
        :param _builtins.str system_desc: Description provided by switch
        :param _builtins.str system_name: Name of the switch
        """
        pulumi.set(__self__, "chassis_id", chassis_id)
        pulumi.set(__self__, "lldp_med_supported", lldp_med_supported)
        pulumi.set(__self__, "mgmt_addr", mgmt_addr)
        pulumi.set(__self__, "mgmt_addrs", mgmt_addrs)
        pulumi.set(__self__, "port_desc", port_desc)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "power_allocated", power_allocated)
        pulumi.set(__self__, "power_draw", power_draw)
        pulumi.set(__self__, "power_request_count", power_request_count)
        pulumi.set(__self__, "power_requested", power_requested)
        pulumi.set(__self__, "system_desc", system_desc)
        pulumi.set(__self__, "system_name", system_name)

    @_builtins.property
    @pulumi.getter(name="chassisId")
    def chassis_id(self) -> _builtins.str:
        return pulumi.get(self, "chassis_id")

    @_builtins.property
    @pulumi.getter(name="lldpMedSupported")
    def lldp_med_supported(self) -> _builtins.bool:
        """
        Whether it support LLDP-MED
        """
        return pulumi.get(self, "lldp_med_supported")

    @_builtins.property
    @pulumi.getter(name="mgmtAddr")
    def mgmt_addr(self) -> _builtins.str:
        """
        Switchs management address (if advertised), can be IPv4, IPv6, or MAC
        """
        return pulumi.get(self, "mgmt_addr")

    @_builtins.property
    @pulumi.getter(name="mgmtAddrs")
    def mgmt_addrs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "mgmt_addrs")

    @_builtins.property
    @pulumi.getter(name="portDesc")
    def port_desc(self) -> _builtins.str:
        """
        ge-0/0/4
        """
        return pulumi.get(self, "port_desc")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="powerAllocated")
    def power_allocated(self) -> _builtins.float:
        """
        In mW, provided/allocated by PSE
        """
        return pulumi.get(self, "power_allocated")

    @_builtins.property
    @pulumi.getter(name="powerDraw")
    def power_draw(self) -> _builtins.float:
        """
        In mW, total power needed by PD
        """
        return pulumi.get(self, "power_draw")

    @_builtins.property
    @pulumi.getter(name="powerRequestCount")
    def power_request_count(self) -> _builtins.int:
        """
        Number of negotiations, if it keeps increasing, we don t have a stable power
        """
        return pulumi.get(self, "power_request_count")

    @_builtins.property
    @pulumi.getter(name="powerRequested")
    def power_requested(self) -> _builtins.float:
        """
        In mW, the current power requested by PD
        """
        return pulumi.get(self, "power_requested")

    @_builtins.property
    @pulumi.getter(name="systemDesc")
    def system_desc(self) -> _builtins.str:
        """
        Description provided by switch
        """
        return pulumi.get(self, "system_desc")

    @_builtins.property
    @pulumi.getter(name="systemName")
    def system_name(self) -> _builtins.str:
        """
        Name of the switch
        """
        return pulumi.get(self, "system_name")


@pulumi.output_type
class GetApStatsDeviceApStatMeshDownlinksResult(dict):
    def __init__(__self__, *,
                 band: _builtins.str,
                 channel: _builtins.int,
                 idle_time: _builtins.int,
                 last_seen: _builtins.float,
                 proto: _builtins.str,
                 rssi: _builtins.int,
                 rx_bps: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_packets: _builtins.int,
                 rx_rate: _builtins.float,
                 rx_retries: _builtins.int,
                 site_id: _builtins.str,
                 snr: _builtins.int,
                 tx_bps: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_packets: _builtins.int,
                 tx_rate: _builtins.float,
                 tx_retries: _builtins.int):
        """
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.int rx_bps: Rate of receiving traffic, bits/seconds, last known
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_packets: Amount of packets received since connection
        :param _builtins.float rx_rate: RX Rate, Mbps
        :param _builtins.int rx_retries: Amount of rx retries
        :param _builtins.int tx_bps: Rate of transmitting traffic, bits/seconds, last known
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_packets: Amount of packets sent since connection
        :param _builtins.float tx_rate: TX Rate, Mbps
        :param _builtins.int tx_retries: Amount of tx retries
        """
        pulumi.set(__self__, "band", band)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "idle_time", idle_time)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "proto", proto)
        pulumi.set(__self__, "rssi", rssi)
        pulumi.set(__self__, "rx_bps", rx_bps)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_packets", rx_packets)
        pulumi.set(__self__, "rx_rate", rx_rate)
        pulumi.set(__self__, "rx_retries", rx_retries)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "snr", snr)
        pulumi.set(__self__, "tx_bps", tx_bps)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_packets", tx_packets)
        pulumi.set(__self__, "tx_rate", tx_rate)
        pulumi.set(__self__, "tx_retries", tx_retries)

    @_builtins.property
    @pulumi.getter
    def band(self) -> _builtins.str:
        return pulumi.get(self, "band")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="idleTime")
    def idle_time(self) -> _builtins.int:
        return pulumi.get(self, "idle_time")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def proto(self) -> _builtins.str:
        return pulumi.get(self, "proto")

    @_builtins.property
    @pulumi.getter
    def rssi(self) -> _builtins.int:
        return pulumi.get(self, "rssi")

    @_builtins.property
    @pulumi.getter(name="rxBps")
    def rx_bps(self) -> _builtins.int:
        """
        Rate of receiving traffic, bits/seconds, last known
        """
        return pulumi.get(self, "rx_bps")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPackets")
    def rx_packets(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_packets")

    @_builtins.property
    @pulumi.getter(name="rxRate")
    def rx_rate(self) -> _builtins.float:
        """
        RX Rate, Mbps
        """
        return pulumi.get(self, "rx_rate")

    @_builtins.property
    @pulumi.getter(name="rxRetries")
    def rx_retries(self) -> _builtins.int:
        """
        Amount of rx retries
        """
        return pulumi.get(self, "rx_retries")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def snr(self) -> _builtins.int:
        return pulumi.get(self, "snr")

    @_builtins.property
    @pulumi.getter(name="txBps")
    def tx_bps(self) -> _builtins.int:
        """
        Rate of transmitting traffic, bits/seconds, last known
        """
        return pulumi.get(self, "tx_bps")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPackets")
    def tx_packets(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_packets")

    @_builtins.property
    @pulumi.getter(name="txRate")
    def tx_rate(self) -> _builtins.float:
        """
        TX Rate, Mbps
        """
        return pulumi.get(self, "tx_rate")

    @_builtins.property
    @pulumi.getter(name="txRetries")
    def tx_retries(self) -> _builtins.int:
        """
        Amount of tx retries
        """
        return pulumi.get(self, "tx_retries")


@pulumi.output_type
class GetApStatsDeviceApStatMeshUplinkResult(dict):
    def __init__(__self__, *,
                 band: _builtins.str,
                 channel: _builtins.int,
                 idle_time: _builtins.int,
                 last_seen: _builtins.float,
                 proto: _builtins.str,
                 rssi: _builtins.int,
                 rx_bps: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_packets: _builtins.int,
                 rx_rate: _builtins.float,
                 rx_retries: _builtins.int,
                 site_id: _builtins.str,
                 snr: _builtins.int,
                 tx_bps: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_packets: _builtins.int,
                 tx_rate: _builtins.float,
                 tx_retries: _builtins.int,
                 uplink_ap_id: _builtins.str):
        """
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.int rx_bps: Rate of receiving traffic, bits/seconds, last known
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_packets: Amount of packets received since connection
        :param _builtins.float rx_rate: RX Rate, Mbps
        :param _builtins.int rx_retries: Amount of rx retries
        :param _builtins.int tx_bps: Rate of transmitting traffic, bits/seconds, last known
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_packets: Amount of packets sent since connection
        :param _builtins.float tx_rate: TX Rate, Mbps
        :param _builtins.int tx_retries: Amount of tx retries
        """
        pulumi.set(__self__, "band", band)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "idle_time", idle_time)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "proto", proto)
        pulumi.set(__self__, "rssi", rssi)
        pulumi.set(__self__, "rx_bps", rx_bps)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_packets", rx_packets)
        pulumi.set(__self__, "rx_rate", rx_rate)
        pulumi.set(__self__, "rx_retries", rx_retries)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "snr", snr)
        pulumi.set(__self__, "tx_bps", tx_bps)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_packets", tx_packets)
        pulumi.set(__self__, "tx_rate", tx_rate)
        pulumi.set(__self__, "tx_retries", tx_retries)
        pulumi.set(__self__, "uplink_ap_id", uplink_ap_id)

    @_builtins.property
    @pulumi.getter
    def band(self) -> _builtins.str:
        return pulumi.get(self, "band")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="idleTime")
    def idle_time(self) -> _builtins.int:
        return pulumi.get(self, "idle_time")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def proto(self) -> _builtins.str:
        return pulumi.get(self, "proto")

    @_builtins.property
    @pulumi.getter
    def rssi(self) -> _builtins.int:
        return pulumi.get(self, "rssi")

    @_builtins.property
    @pulumi.getter(name="rxBps")
    def rx_bps(self) -> _builtins.int:
        """
        Rate of receiving traffic, bits/seconds, last known
        """
        return pulumi.get(self, "rx_bps")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPackets")
    def rx_packets(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_packets")

    @_builtins.property
    @pulumi.getter(name="rxRate")
    def rx_rate(self) -> _builtins.float:
        """
        RX Rate, Mbps
        """
        return pulumi.get(self, "rx_rate")

    @_builtins.property
    @pulumi.getter(name="rxRetries")
    def rx_retries(self) -> _builtins.int:
        """
        Amount of rx retries
        """
        return pulumi.get(self, "rx_retries")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def snr(self) -> _builtins.int:
        return pulumi.get(self, "snr")

    @_builtins.property
    @pulumi.getter(name="txBps")
    def tx_bps(self) -> _builtins.int:
        """
        Rate of transmitting traffic, bits/seconds, last known
        """
        return pulumi.get(self, "tx_bps")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPackets")
    def tx_packets(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_packets")

    @_builtins.property
    @pulumi.getter(name="txRate")
    def tx_rate(self) -> _builtins.float:
        """
        TX Rate, Mbps
        """
        return pulumi.get(self, "tx_rate")

    @_builtins.property
    @pulumi.getter(name="txRetries")
    def tx_retries(self) -> _builtins.int:
        """
        Amount of tx retries
        """
        return pulumi.get(self, "tx_retries")

    @_builtins.property
    @pulumi.getter(name="uplinkApId")
    def uplink_ap_id(self) -> _builtins.str:
        return pulumi.get(self, "uplink_ap_id")


@pulumi.output_type
class GetApStatsDeviceApStatPortStatResult(dict):
    def __init__(__self__, *,
                 full_duplex: _builtins.bool,
                 rx_bytes: _builtins.int,
                 rx_errors: _builtins.int,
                 rx_peak_bps: _builtins.int,
                 rx_pkts: _builtins.int,
                 speed: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_peak_bps: _builtins.int,
                 tx_pkts: _builtins.int,
                 up: _builtins.bool):
        """
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        """
        pulumi.set(__self__, "full_duplex", full_duplex)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_errors", rx_errors)
        pulumi.set(__self__, "rx_peak_bps", rx_peak_bps)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "speed", speed)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_peak_bps", tx_peak_bps)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "up", up)

    @_builtins.property
    @pulumi.getter(name="fullDuplex")
    def full_duplex(self) -> _builtins.bool:
        return pulumi.get(self, "full_duplex")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxErrors")
    def rx_errors(self) -> _builtins.int:
        return pulumi.get(self, "rx_errors")

    @_builtins.property
    @pulumi.getter(name="rxPeakBps")
    def rx_peak_bps(self) -> _builtins.int:
        return pulumi.get(self, "rx_peak_bps")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> _builtins.int:
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPeakBps")
    def tx_peak_bps(self) -> _builtins.int:
        return pulumi.get(self, "tx_peak_bps")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")


@pulumi.output_type
class GetApStatsDeviceApStatRadioStatResult(dict):
    def __init__(__self__, *,
                 band24: 'outputs.GetApStatsDeviceApStatRadioStatBand24Result',
                 band5: 'outputs.GetApStatsDeviceApStatRadioStatBand5Result',
                 band6: 'outputs.GetApStatsDeviceApStatRadioStatBand6Result'):
        """
        :param 'GetApStatsDeviceApStatRadioStatBand24Args' band24: Radio stat
        :param 'GetApStatsDeviceApStatRadioStatBand5Args' band5: Radio stat
        :param 'GetApStatsDeviceApStatRadioStatBand6Args' band6: Radio stat
        """
        pulumi.set(__self__, "band24", band24)
        pulumi.set(__self__, "band5", band5)
        pulumi.set(__self__, "band6", band6)

    @_builtins.property
    @pulumi.getter
    def band24(self) -> 'outputs.GetApStatsDeviceApStatRadioStatBand24Result':
        """
        Radio stat
        """
        return pulumi.get(self, "band24")

    @_builtins.property
    @pulumi.getter
    def band5(self) -> 'outputs.GetApStatsDeviceApStatRadioStatBand5Result':
        """
        Radio stat
        """
        return pulumi.get(self, "band5")

    @_builtins.property
    @pulumi.getter
    def band6(self) -> 'outputs.GetApStatsDeviceApStatRadioStatBand6Result':
        """
        Radio stat
        """
        return pulumi.get(self, "band6")


@pulumi.output_type
class GetApStatsDeviceApStatRadioStatBand24Result(dict):
    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 channel: _builtins.int,
                 dynamic_chaining_enabled: _builtins.bool,
                 mac: _builtins.str,
                 noise_floor: _builtins.int,
                 num_clients: _builtins.int,
                 num_wlans: _builtins.int,
                 power: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 usage: _builtins.str,
                 util_all: _builtins.int,
                 util_non_wifi: _builtins.int,
                 util_rx_in_bss: _builtins.int,
                 util_rx_other_bss: _builtins.int,
                 util_tx: _builtins.int,
                 util_undecodable_wifi: _builtins.int,
                 util_unknown_wifi: _builtins.int):
        """
        :param _builtins.int bandwidth: channel width for the band.enum: `20`, `40`, `80` (only applicable for band_5 and band_6), `160` (only for band_6)
        :param _builtins.int channel: Current channel the radio is running on
        :param _builtins.bool dynamic_chaining_enabled: Use dynamic chaining for downlink
        :param _builtins.str mac: Radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
        :param _builtins.int num_wlans: How many WLANs are applied to the radio
        :param _builtins.int power: Transmit power (in dBm)
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.int util_all: All utilization in percentage
        :param _builtins.int util_non_wifi: Reception of "No Packets" utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
        :param _builtins.int util_rx_in_bss: Reception of "In BSS" utilization in percentage, only frames that are received from AP/STAs within the BSS
        :param _builtins.int util_rx_other_bss: Reception of "Other BSS" utilization in percentage, all frames received from AP/STAs that are outside the BSS
        :param _builtins.int util_tx: Transmission utilization in percentage
        :param _builtins.int util_undecodable_wifi: Reception of "UnDecodable Wifi" utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
        :param _builtins.int util_unknown_wifi: Reception of "No Category" utilization in percentage, all 802.11 frames that are corrupted at the receiver
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "dynamic_chaining_enabled", dynamic_chaining_enabled)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "noise_floor", noise_floor)
        pulumi.set(__self__, "num_clients", num_clients)
        pulumi.set(__self__, "num_wlans", num_wlans)
        pulumi.set(__self__, "power", power)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "util_all", util_all)
        pulumi.set(__self__, "util_non_wifi", util_non_wifi)
        pulumi.set(__self__, "util_rx_in_bss", util_rx_in_bss)
        pulumi.set(__self__, "util_rx_other_bss", util_rx_other_bss)
        pulumi.set(__self__, "util_tx", util_tx)
        pulumi.set(__self__, "util_undecodable_wifi", util_undecodable_wifi)
        pulumi.set(__self__, "util_unknown_wifi", util_unknown_wifi)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        """
        channel width for the band.enum: `20`, `40`, `80` (only applicable for band_5 and band_6), `160` (only for band_6)
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        """
        Current channel the radio is running on
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="dynamicChainingEnabled")
    def dynamic_chaining_enabled(self) -> _builtins.bool:
        """
        Use dynamic chaining for downlink
        """
        return pulumi.get(self, "dynamic_chaining_enabled")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="noiseFloor")
    def noise_floor(self) -> _builtins.int:
        return pulumi.get(self, "noise_floor")

    @_builtins.property
    @pulumi.getter(name="numClients")
    def num_clients(self) -> _builtins.int:
        return pulumi.get(self, "num_clients")

    @_builtins.property
    @pulumi.getter(name="numWlans")
    def num_wlans(self) -> _builtins.int:
        """
        How many WLANs are applied to the radio
        """
        return pulumi.get(self, "num_wlans")

    @_builtins.property
    @pulumi.getter
    def power(self) -> _builtins.int:
        """
        Transmit power (in dBm)
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="utilAll")
    def util_all(self) -> _builtins.int:
        """
        All utilization in percentage
        """
        return pulumi.get(self, "util_all")

    @_builtins.property
    @pulumi.getter(name="utilNonWifi")
    def util_non_wifi(self) -> _builtins.int:
        """
        Reception of "No Packets" utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
        """
        return pulumi.get(self, "util_non_wifi")

    @_builtins.property
    @pulumi.getter(name="utilRxInBss")
    def util_rx_in_bss(self) -> _builtins.int:
        """
        Reception of "In BSS" utilization in percentage, only frames that are received from AP/STAs within the BSS
        """
        return pulumi.get(self, "util_rx_in_bss")

    @_builtins.property
    @pulumi.getter(name="utilRxOtherBss")
    def util_rx_other_bss(self) -> _builtins.int:
        """
        Reception of "Other BSS" utilization in percentage, all frames received from AP/STAs that are outside the BSS
        """
        return pulumi.get(self, "util_rx_other_bss")

    @_builtins.property
    @pulumi.getter(name="utilTx")
    def util_tx(self) -> _builtins.int:
        """
        Transmission utilization in percentage
        """
        return pulumi.get(self, "util_tx")

    @_builtins.property
    @pulumi.getter(name="utilUndecodableWifi")
    def util_undecodable_wifi(self) -> _builtins.int:
        """
        Reception of "UnDecodable Wifi" utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
        """
        return pulumi.get(self, "util_undecodable_wifi")

    @_builtins.property
    @pulumi.getter(name="utilUnknownWifi")
    def util_unknown_wifi(self) -> _builtins.int:
        """
        Reception of "No Category" utilization in percentage, all 802.11 frames that are corrupted at the receiver
        """
        return pulumi.get(self, "util_unknown_wifi")


@pulumi.output_type
class GetApStatsDeviceApStatRadioStatBand5Result(dict):
    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 channel: _builtins.int,
                 dynamic_chaining_enabled: _builtins.bool,
                 mac: _builtins.str,
                 noise_floor: _builtins.int,
                 num_clients: _builtins.int,
                 num_wlans: _builtins.int,
                 power: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 usage: _builtins.str,
                 util_all: _builtins.int,
                 util_non_wifi: _builtins.int,
                 util_rx_in_bss: _builtins.int,
                 util_rx_other_bss: _builtins.int,
                 util_tx: _builtins.int,
                 util_undecodable_wifi: _builtins.int,
                 util_unknown_wifi: _builtins.int):
        """
        :param _builtins.int bandwidth: channel width for the band.enum: `20`, `40`, `80` (only applicable for band_5 and band_6), `160` (only for band_6)
        :param _builtins.int channel: Current channel the radio is running on
        :param _builtins.bool dynamic_chaining_enabled: Use dynamic chaining for downlink
        :param _builtins.str mac: Radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
        :param _builtins.int num_wlans: How many WLANs are applied to the radio
        :param _builtins.int power: Transmit power (in dBm)
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.int util_all: All utilization in percentage
        :param _builtins.int util_non_wifi: Reception of "No Packets" utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
        :param _builtins.int util_rx_in_bss: Reception of "In BSS" utilization in percentage, only frames that are received from AP/STAs within the BSS
        :param _builtins.int util_rx_other_bss: Reception of "Other BSS" utilization in percentage, all frames received from AP/STAs that are outside the BSS
        :param _builtins.int util_tx: Transmission utilization in percentage
        :param _builtins.int util_undecodable_wifi: Reception of "UnDecodable Wifi" utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
        :param _builtins.int util_unknown_wifi: Reception of "No Category" utilization in percentage, all 802.11 frames that are corrupted at the receiver
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "dynamic_chaining_enabled", dynamic_chaining_enabled)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "noise_floor", noise_floor)
        pulumi.set(__self__, "num_clients", num_clients)
        pulumi.set(__self__, "num_wlans", num_wlans)
        pulumi.set(__self__, "power", power)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "util_all", util_all)
        pulumi.set(__self__, "util_non_wifi", util_non_wifi)
        pulumi.set(__self__, "util_rx_in_bss", util_rx_in_bss)
        pulumi.set(__self__, "util_rx_other_bss", util_rx_other_bss)
        pulumi.set(__self__, "util_tx", util_tx)
        pulumi.set(__self__, "util_undecodable_wifi", util_undecodable_wifi)
        pulumi.set(__self__, "util_unknown_wifi", util_unknown_wifi)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        """
        channel width for the band.enum: `20`, `40`, `80` (only applicable for band_5 and band_6), `160` (only for band_6)
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        """
        Current channel the radio is running on
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="dynamicChainingEnabled")
    def dynamic_chaining_enabled(self) -> _builtins.bool:
        """
        Use dynamic chaining for downlink
        """
        return pulumi.get(self, "dynamic_chaining_enabled")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="noiseFloor")
    def noise_floor(self) -> _builtins.int:
        return pulumi.get(self, "noise_floor")

    @_builtins.property
    @pulumi.getter(name="numClients")
    def num_clients(self) -> _builtins.int:
        return pulumi.get(self, "num_clients")

    @_builtins.property
    @pulumi.getter(name="numWlans")
    def num_wlans(self) -> _builtins.int:
        """
        How many WLANs are applied to the radio
        """
        return pulumi.get(self, "num_wlans")

    @_builtins.property
    @pulumi.getter
    def power(self) -> _builtins.int:
        """
        Transmit power (in dBm)
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="utilAll")
    def util_all(self) -> _builtins.int:
        """
        All utilization in percentage
        """
        return pulumi.get(self, "util_all")

    @_builtins.property
    @pulumi.getter(name="utilNonWifi")
    def util_non_wifi(self) -> _builtins.int:
        """
        Reception of "No Packets" utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
        """
        return pulumi.get(self, "util_non_wifi")

    @_builtins.property
    @pulumi.getter(name="utilRxInBss")
    def util_rx_in_bss(self) -> _builtins.int:
        """
        Reception of "In BSS" utilization in percentage, only frames that are received from AP/STAs within the BSS
        """
        return pulumi.get(self, "util_rx_in_bss")

    @_builtins.property
    @pulumi.getter(name="utilRxOtherBss")
    def util_rx_other_bss(self) -> _builtins.int:
        """
        Reception of "Other BSS" utilization in percentage, all frames received from AP/STAs that are outside the BSS
        """
        return pulumi.get(self, "util_rx_other_bss")

    @_builtins.property
    @pulumi.getter(name="utilTx")
    def util_tx(self) -> _builtins.int:
        """
        Transmission utilization in percentage
        """
        return pulumi.get(self, "util_tx")

    @_builtins.property
    @pulumi.getter(name="utilUndecodableWifi")
    def util_undecodable_wifi(self) -> _builtins.int:
        """
        Reception of "UnDecodable Wifi" utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
        """
        return pulumi.get(self, "util_undecodable_wifi")

    @_builtins.property
    @pulumi.getter(name="utilUnknownWifi")
    def util_unknown_wifi(self) -> _builtins.int:
        """
        Reception of "No Category" utilization in percentage, all 802.11 frames that are corrupted at the receiver
        """
        return pulumi.get(self, "util_unknown_wifi")


@pulumi.output_type
class GetApStatsDeviceApStatRadioStatBand6Result(dict):
    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 channel: _builtins.int,
                 dynamic_chaining_enabled: _builtins.bool,
                 mac: _builtins.str,
                 noise_floor: _builtins.int,
                 num_clients: _builtins.int,
                 num_wlans: _builtins.int,
                 power: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 usage: _builtins.str,
                 util_all: _builtins.int,
                 util_non_wifi: _builtins.int,
                 util_rx_in_bss: _builtins.int,
                 util_rx_other_bss: _builtins.int,
                 util_tx: _builtins.int,
                 util_undecodable_wifi: _builtins.int,
                 util_unknown_wifi: _builtins.int):
        """
        :param _builtins.int bandwidth: channel width for the band.enum: `20`, `40`, `80` (only applicable for band_5 and band_6), `160` (only for band_6)
        :param _builtins.int channel: Current channel the radio is running on
        :param _builtins.bool dynamic_chaining_enabled: Use dynamic chaining for downlink
        :param _builtins.str mac: Radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
        :param _builtins.int num_wlans: How many WLANs are applied to the radio
        :param _builtins.int power: Transmit power (in dBm)
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.int util_all: All utilization in percentage
        :param _builtins.int util_non_wifi: Reception of "No Packets" utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
        :param _builtins.int util_rx_in_bss: Reception of "In BSS" utilization in percentage, only frames that are received from AP/STAs within the BSS
        :param _builtins.int util_rx_other_bss: Reception of "Other BSS" utilization in percentage, all frames received from AP/STAs that are outside the BSS
        :param _builtins.int util_tx: Transmission utilization in percentage
        :param _builtins.int util_undecodable_wifi: Reception of "UnDecodable Wifi" utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
        :param _builtins.int util_unknown_wifi: Reception of "No Category" utilization in percentage, all 802.11 frames that are corrupted at the receiver
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "dynamic_chaining_enabled", dynamic_chaining_enabled)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "noise_floor", noise_floor)
        pulumi.set(__self__, "num_clients", num_clients)
        pulumi.set(__self__, "num_wlans", num_wlans)
        pulumi.set(__self__, "power", power)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "usage", usage)
        pulumi.set(__self__, "util_all", util_all)
        pulumi.set(__self__, "util_non_wifi", util_non_wifi)
        pulumi.set(__self__, "util_rx_in_bss", util_rx_in_bss)
        pulumi.set(__self__, "util_rx_other_bss", util_rx_other_bss)
        pulumi.set(__self__, "util_tx", util_tx)
        pulumi.set(__self__, "util_undecodable_wifi", util_undecodable_wifi)
        pulumi.set(__self__, "util_unknown_wifi", util_unknown_wifi)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        """
        channel width for the band.enum: `20`, `40`, `80` (only applicable for band_5 and band_6), `160` (only for band_6)
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        """
        Current channel the radio is running on
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter(name="dynamicChainingEnabled")
    def dynamic_chaining_enabled(self) -> _builtins.bool:
        """
        Use dynamic chaining for downlink
        """
        return pulumi.get(self, "dynamic_chaining_enabled")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="noiseFloor")
    def noise_floor(self) -> _builtins.int:
        return pulumi.get(self, "noise_floor")

    @_builtins.property
    @pulumi.getter(name="numClients")
    def num_clients(self) -> _builtins.int:
        return pulumi.get(self, "num_clients")

    @_builtins.property
    @pulumi.getter(name="numWlans")
    def num_wlans(self) -> _builtins.int:
        """
        How many WLANs are applied to the radio
        """
        return pulumi.get(self, "num_wlans")

    @_builtins.property
    @pulumi.getter
    def power(self) -> _builtins.int:
        """
        Transmit power (in dBm)
        """
        return pulumi.get(self, "power")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.str:
        return pulumi.get(self, "usage")

    @_builtins.property
    @pulumi.getter(name="utilAll")
    def util_all(self) -> _builtins.int:
        """
        All utilization in percentage
        """
        return pulumi.get(self, "util_all")

    @_builtins.property
    @pulumi.getter(name="utilNonWifi")
    def util_non_wifi(self) -> _builtins.int:
        """
        Reception of "No Packets" utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
        """
        return pulumi.get(self, "util_non_wifi")

    @_builtins.property
    @pulumi.getter(name="utilRxInBss")
    def util_rx_in_bss(self) -> _builtins.int:
        """
        Reception of "In BSS" utilization in percentage, only frames that are received from AP/STAs within the BSS
        """
        return pulumi.get(self, "util_rx_in_bss")

    @_builtins.property
    @pulumi.getter(name="utilRxOtherBss")
    def util_rx_other_bss(self) -> _builtins.int:
        """
        Reception of "Other BSS" utilization in percentage, all frames received from AP/STAs that are outside the BSS
        """
        return pulumi.get(self, "util_rx_other_bss")

    @_builtins.property
    @pulumi.getter(name="utilTx")
    def util_tx(self) -> _builtins.int:
        """
        Transmission utilization in percentage
        """
        return pulumi.get(self, "util_tx")

    @_builtins.property
    @pulumi.getter(name="utilUndecodableWifi")
    def util_undecodable_wifi(self) -> _builtins.int:
        """
        Reception of "UnDecodable Wifi" utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
        """
        return pulumi.get(self, "util_undecodable_wifi")

    @_builtins.property
    @pulumi.getter(name="utilUnknownWifi")
    def util_unknown_wifi(self) -> _builtins.int:
        """
        Reception of "No Category" utilization in percentage, all 802.11 frames that are corrupted at the receiver
        """
        return pulumi.get(self, "util_unknown_wifi")


@pulumi.output_type
class GetApStatsDeviceApStatSwitchRedundancyResult(dict):
    def __init__(__self__, *,
                 num_redundant_aps: _builtins.int):
        pulumi.set(__self__, "num_redundant_aps", num_redundant_aps)

    @_builtins.property
    @pulumi.getter(name="numRedundantAps")
    def num_redundant_aps(self) -> _builtins.int:
        return pulumi.get(self, "num_redundant_aps")


@pulumi.output_type
class GetApStatsDeviceApStatUsbStatResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.int,
                 connected: _builtins.bool,
                 last_activity: _builtins.int,
                 type: _builtins.str,
                 up: _builtins.bool):
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "connected", connected)
        pulumi.set(__self__, "last_activity", last_activity)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "up", up)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.int:
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def connected(self) -> _builtins.bool:
        return pulumi.get(self, "connected")

    @_builtins.property
    @pulumi.getter(name="lastActivity")
    def last_activity(self) -> _builtins.int:
        return pulumi.get(self, "last_activity")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatResult(dict):
    def __init__(__self__, *,
                 ap_redundancy: 'outputs.GetGatewayStatsDeviceGatewayStatApRedundancyResult',
                 arp_table_stats: 'outputs.GetGatewayStatsDeviceGatewayStatArpTableStatsResult',
                 bgp_peers: Sequence['outputs.GetGatewayStatsDeviceGatewayStatBgpPeerResult'],
                 cert_expiry: _builtins.int,
                 cluster_config: 'outputs.GetGatewayStatsDeviceGatewayStatClusterConfigResult',
                 cluster_stat: 'outputs.GetGatewayStatsDeviceGatewayStatClusterStatResult',
                 conductor_name: _builtins.str,
                 config_status: _builtins.str,
                 cpu2_stat: 'outputs.GetGatewayStatsDeviceGatewayStatCpu2StatResult',
                 cpu_stat: 'outputs.GetGatewayStatsDeviceGatewayStatCpuStatResult',
                 created_time: _builtins.float,
                 deviceprofile_id: _builtins.str,
                 dhcpd2_stat: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatDhcpd2StatResult'],
                 dhcpd_stat: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatDhcpdStatResult'],
                 ext_ip: _builtins.str,
                 fwupdate: 'outputs.GetGatewayStatsDeviceGatewayStatFwupdateResult',
                 has_pcap: _builtins.bool,
                 hostname: _builtins.str,
                 id: _builtins.str,
                 if2_stat: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatIf2StatResult'],
                 if_stat: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatIfStatResult'],
                 ip: _builtins.str,
                 ip2_stat: 'outputs.GetGatewayStatsDeviceGatewayStatIp2StatResult',
                 ip_stat: 'outputs.GetGatewayStatsDeviceGatewayStatIpStatResult',
                 is_ha: _builtins.bool,
                 last_seen: _builtins.float,
                 mac: _builtins.str,
                 map_id: _builtins.str,
                 memory2_stat: 'outputs.GetGatewayStatsDeviceGatewayStatMemory2StatResult',
                 memory_stat: 'outputs.GetGatewayStatsDeviceGatewayStatMemoryStatResult',
                 model: _builtins.str,
                 modified_time: _builtins.float,
                 module2_stats: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatResult'],
                 module_stats: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatResult'],
                 name: _builtins.str,
                 node_name: _builtins.str,
                 org_id: _builtins.str,
                 ports: Sequence['outputs.GetGatewayStatsDeviceGatewayStatPortResult'],
                 route_summary_stats: 'outputs.GetGatewayStatsDeviceGatewayStatRouteSummaryStatsResult',
                 router_name: _builtins.str,
                 serial: _builtins.str,
                 service2_stat: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatService2StatResult'],
                 service_stat: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatServiceStatResult'],
                 service_status: 'outputs.GetGatewayStatsDeviceGatewayStatServiceStatusResult',
                 site_id: _builtins.str,
                 spu2_stats: Sequence['outputs.GetGatewayStatsDeviceGatewayStatSpu2StatResult'],
                 spu_stats: Sequence['outputs.GetGatewayStatsDeviceGatewayStatSpuStatResult'],
                 status: _builtins.str,
                 tunnels: Sequence['outputs.GetGatewayStatsDeviceGatewayStatTunnelResult'],
                 uptime: _builtins.float,
                 version: _builtins.str,
                 vpn_peers: Sequence['outputs.GetGatewayStatsDeviceGatewayStatVpnPeerResult']):
        """
        :param Sequence['GetGatewayStatsDeviceGatewayStatBgpPeerArgs'] bgp_peers: Only present when `bgp_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/bgp_peers/search` result object, except that org*id, site*id, mac, model are removed
        :param _builtins.float created_time: When the object has been created, in epoch
        :param Mapping[str, 'GetGatewayStatsDeviceGatewayStatDhcpd2StatArgs'] dhcpd2_stat: Property key is the network name
        :param Mapping[str, 'GetGatewayStatsDeviceGatewayStatDhcpdStatArgs'] dhcpd_stat: Property key is the network name
        :param _builtins.str ext_ip: IP address
        :param _builtins.str hostname: Hostname reported by the device
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param Mapping[str, 'GetGatewayStatsDeviceGatewayStatIf2StatArgs'] if2_stat: Property key is the interface name
        :param Mapping[str, 'GetGatewayStatsDeviceGatewayStatIfStatArgs'] if_stat: Property key is the interface name
        :param _builtins.str ip: IP address
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.str mac: Device mac
        :param _builtins.str map_id: Serial Number
        :param 'GetGatewayStatsDeviceGatewayStatMemory2StatArgs' memory2_stat: Memory usage stat (for virtual chassis, memory usage of master RE)
        :param 'GetGatewayStatsDeviceGatewayStatMemoryStatArgs' memory_stat: Memory usage stat (for virtual chassis, memory usage of master RE)
        :param _builtins.str model: Device model
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str name: Device name if configured
        :param Sequence['GetGatewayStatsDeviceGatewayStatPortArgs'] ports: Only present when `ports` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/ports/search` result object, except that org*id, site*id, mac, model are removed
        :param _builtins.str router_name: Device name if configured
        :param _builtins.str serial: Serial Number
        :param Sequence['GetGatewayStatsDeviceGatewayStatTunnelArgs'] tunnels: Only present when `tunnels` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/tunnels/search` result object, except that org*id, site*id, mac, model are removed
        :param Sequence['GetGatewayStatsDeviceGatewayStatVpnPeerArgs'] vpn_peers: Only present when `vpn_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/vpn_peers/search` result object, except that org*id, site*id, mac, model are removed
        """
        pulumi.set(__self__, "ap_redundancy", ap_redundancy)
        pulumi.set(__self__, "arp_table_stats", arp_table_stats)
        pulumi.set(__self__, "bgp_peers", bgp_peers)
        pulumi.set(__self__, "cert_expiry", cert_expiry)
        pulumi.set(__self__, "cluster_config", cluster_config)
        pulumi.set(__self__, "cluster_stat", cluster_stat)
        pulumi.set(__self__, "conductor_name", conductor_name)
        pulumi.set(__self__, "config_status", config_status)
        pulumi.set(__self__, "cpu2_stat", cpu2_stat)
        pulumi.set(__self__, "cpu_stat", cpu_stat)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        pulumi.set(__self__, "dhcpd2_stat", dhcpd2_stat)
        pulumi.set(__self__, "dhcpd_stat", dhcpd_stat)
        pulumi.set(__self__, "ext_ip", ext_ip)
        pulumi.set(__self__, "fwupdate", fwupdate)
        pulumi.set(__self__, "has_pcap", has_pcap)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "if2_stat", if2_stat)
        pulumi.set(__self__, "if_stat", if_stat)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip2_stat", ip2_stat)
        pulumi.set(__self__, "ip_stat", ip_stat)
        pulumi.set(__self__, "is_ha", is_ha)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "map_id", map_id)
        pulumi.set(__self__, "memory2_stat", memory2_stat)
        pulumi.set(__self__, "memory_stat", memory_stat)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "module2_stats", module2_stats)
        pulumi.set(__self__, "module_stats", module_stats)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "route_summary_stats", route_summary_stats)
        pulumi.set(__self__, "router_name", router_name)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "service2_stat", service2_stat)
        pulumi.set(__self__, "service_stat", service_stat)
        pulumi.set(__self__, "service_status", service_status)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "spu2_stats", spu2_stats)
        pulumi.set(__self__, "spu_stats", spu_stats)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tunnels", tunnels)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "vpn_peers", vpn_peers)

    @_builtins.property
    @pulumi.getter(name="apRedundancy")
    def ap_redundancy(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatApRedundancyResult':
        return pulumi.get(self, "ap_redundancy")

    @_builtins.property
    @pulumi.getter(name="arpTableStats")
    def arp_table_stats(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatArpTableStatsResult':
        return pulumi.get(self, "arp_table_stats")

    @_builtins.property
    @pulumi.getter(name="bgpPeers")
    def bgp_peers(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatBgpPeerResult']:
        """
        Only present when `bgp_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/bgp_peers/search` result object, except that org*id, site*id, mac, model are removed
        """
        return pulumi.get(self, "bgp_peers")

    @_builtins.property
    @pulumi.getter(name="certExpiry")
    def cert_expiry(self) -> _builtins.int:
        return pulumi.get(self, "cert_expiry")

    @_builtins.property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatClusterConfigResult':
        return pulumi.get(self, "cluster_config")

    @_builtins.property
    @pulumi.getter(name="clusterStat")
    def cluster_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatClusterStatResult':
        return pulumi.get(self, "cluster_stat")

    @_builtins.property
    @pulumi.getter(name="conductorName")
    def conductor_name(self) -> _builtins.str:
        return pulumi.get(self, "conductor_name")

    @_builtins.property
    @pulumi.getter(name="configStatus")
    def config_status(self) -> _builtins.str:
        return pulumi.get(self, "config_status")

    @_builtins.property
    @pulumi.getter(name="cpu2Stat")
    def cpu2_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatCpu2StatResult':
        return pulumi.get(self, "cpu2_stat")

    @_builtins.property
    @pulumi.getter(name="cpuStat")
    def cpu_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatCpuStatResult':
        return pulumi.get(self, "cpu_stat")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> _builtins.str:
        return pulumi.get(self, "deviceprofile_id")

    @_builtins.property
    @pulumi.getter(name="dhcpd2Stat")
    def dhcpd2_stat(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatDhcpd2StatResult']:
        """
        Property key is the network name
        """
        return pulumi.get(self, "dhcpd2_stat")

    @_builtins.property
    @pulumi.getter(name="dhcpdStat")
    def dhcpd_stat(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatDhcpdStatResult']:
        """
        Property key is the network name
        """
        return pulumi.get(self, "dhcpd_stat")

    @_builtins.property
    @pulumi.getter(name="extIp")
    def ext_ip(self) -> _builtins.str:
        """
        IP address
        """
        return pulumi.get(self, "ext_ip")

    @_builtins.property
    @pulumi.getter
    def fwupdate(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatFwupdateResult':
        return pulumi.get(self, "fwupdate")

    @_builtins.property
    @pulumi.getter(name="hasPcap")
    def has_pcap(self) -> _builtins.bool:
        return pulumi.get(self, "has_pcap")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname reported by the device
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="if2Stat")
    def if2_stat(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatIf2StatResult']:
        """
        Property key is the interface name
        """
        return pulumi.get(self, "if2_stat")

    @_builtins.property
    @pulumi.getter(name="ifStat")
    def if_stat(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatIfStatResult']:
        """
        Property key is the interface name
        """
        return pulumi.get(self, "if_stat")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="ip2Stat")
    def ip2_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatIp2StatResult':
        return pulumi.get(self, "ip2_stat")

    @_builtins.property
    @pulumi.getter(name="ipStat")
    def ip_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatIpStatResult':
        return pulumi.get(self, "ip_stat")

    @_builtins.property
    @pulumi.getter(name="isHa")
    def is_ha(self) -> _builtins.bool:
        return pulumi.get(self, "is_ha")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        """
        Device mac
        """
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="mapId")
    def map_id(self) -> _builtins.str:
        """
        Serial Number
        """
        return pulumi.get(self, "map_id")

    @_builtins.property
    @pulumi.getter(name="memory2Stat")
    def memory2_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatMemory2StatResult':
        """
        Memory usage stat (for virtual chassis, memory usage of master RE)
        """
        return pulumi.get(self, "memory2_stat")

    @_builtins.property
    @pulumi.getter(name="memoryStat")
    def memory_stat(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatMemoryStatResult':
        """
        Memory usage stat (for virtual chassis, memory usage of master RE)
        """
        return pulumi.get(self, "memory_stat")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Device model
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter(name="module2Stats")
    def module2_stats(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatResult']:
        return pulumi.get(self, "module2_stats")

    @_builtins.property
    @pulumi.getter(name="moduleStats")
    def module_stats(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatResult']:
        return pulumi.get(self, "module_stats")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Device name if configured
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatPortResult']:
        """
        Only present when `ports` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/ports/search` result object, except that org*id, site*id, mac, model are removed
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter(name="routeSummaryStats")
    def route_summary_stats(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatRouteSummaryStatsResult':
        return pulumi.get(self, "route_summary_stats")

    @_builtins.property
    @pulumi.getter(name="routerName")
    def router_name(self) -> _builtins.str:
        """
        Device name if configured
        """
        return pulumi.get(self, "router_name")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        """
        Serial Number
        """
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="service2Stat")
    def service2_stat(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatService2StatResult']:
        return pulumi.get(self, "service2_stat")

    @_builtins.property
    @pulumi.getter(name="serviceStat")
    def service_stat(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatServiceStatResult']:
        return pulumi.get(self, "service_stat")

    @_builtins.property
    @pulumi.getter(name="serviceStatus")
    def service_status(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatServiceStatusResult':
        return pulumi.get(self, "service_status")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter(name="spu2Stats")
    def spu2_stats(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatSpu2StatResult']:
        return pulumi.get(self, "spu2_stats")

    @_builtins.property
    @pulumi.getter(name="spuStats")
    def spu_stats(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatSpuStatResult']:
        return pulumi.get(self, "spu_stats")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tunnels(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatTunnelResult']:
        """
        Only present when `tunnels` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/tunnels/search` result object, except that org*id, site*id, mac, model are removed
        """
        return pulumi.get(self, "tunnels")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.float:
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="vpnPeers")
    def vpn_peers(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatVpnPeerResult']:
        """
        Only present when `vpn_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/vpn_peers/search` result object, except that org*id, site*id, mac, model are removed
        """
        return pulumi.get(self, "vpn_peers")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatApRedundancyResult(dict):
    def __init__(__self__, *,
                 modules: Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatApRedundancyModulesResult'],
                 num_aps: _builtins.int,
                 num_aps_with_switch_redundancy: _builtins.int):
        """
        :param Mapping[str, 'GetGatewayStatsDeviceGatewayStatApRedundancyModulesArgs'] modules: Property key is the node id
        """
        pulumi.set(__self__, "modules", modules)
        pulumi.set(__self__, "num_aps", num_aps)
        pulumi.set(__self__, "num_aps_with_switch_redundancy", num_aps_with_switch_redundancy)

    @_builtins.property
    @pulumi.getter
    def modules(self) -> Mapping[str, 'outputs.GetGatewayStatsDeviceGatewayStatApRedundancyModulesResult']:
        """
        Property key is the node id
        """
        return pulumi.get(self, "modules")

    @_builtins.property
    @pulumi.getter(name="numAps")
    def num_aps(self) -> _builtins.int:
        return pulumi.get(self, "num_aps")

    @_builtins.property
    @pulumi.getter(name="numApsWithSwitchRedundancy")
    def num_aps_with_switch_redundancy(self) -> _builtins.int:
        return pulumi.get(self, "num_aps_with_switch_redundancy")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatApRedundancyModulesResult(dict):
    def __init__(__self__, *,
                 num_aps: _builtins.int,
                 num_aps_with_switch_redundancy: _builtins.int):
        pulumi.set(__self__, "num_aps", num_aps)
        pulumi.set(__self__, "num_aps_with_switch_redundancy", num_aps_with_switch_redundancy)

    @_builtins.property
    @pulumi.getter(name="numAps")
    def num_aps(self) -> _builtins.int:
        return pulumi.get(self, "num_aps")

    @_builtins.property
    @pulumi.getter(name="numApsWithSwitchRedundancy")
    def num_aps_with_switch_redundancy(self) -> _builtins.int:
        return pulumi.get(self, "num_aps_with_switch_redundancy")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatArpTableStatsResult(dict):
    def __init__(__self__, *,
                 arp_table_count: _builtins.int,
                 max_entries_supported: _builtins.int):
        pulumi.set(__self__, "arp_table_count", arp_table_count)
        pulumi.set(__self__, "max_entries_supported", max_entries_supported)

    @_builtins.property
    @pulumi.getter(name="arpTableCount")
    def arp_table_count(self) -> _builtins.int:
        return pulumi.get(self, "arp_table_count")

    @_builtins.property
    @pulumi.getter(name="maxEntriesSupported")
    def max_entries_supported(self) -> _builtins.int:
        return pulumi.get(self, "max_entries_supported")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatBgpPeerResult(dict):
    def __init__(__self__, *,
                 evpn_overlay: _builtins.bool,
                 for_overlay: _builtins.bool,
                 local_as: _builtins.str,
                 neighbor: _builtins.str,
                 neighbor_as: _builtins.str,
                 neighbor_mac: _builtins.str,
                 node: _builtins.str,
                 rx_pkts: _builtins.int,
                 rx_routes: _builtins.int,
                 state: _builtins.str,
                 timestamp: _builtins.float,
                 tx_pkts: _builtins.int,
                 tx_routes: _builtins.int,
                 up: _builtins.bool,
                 uptime: _builtins.int,
                 vrf_name: _builtins.str):
        """
        :param _builtins.bool evpn_overlay: If this is created for evpn overlay
        :param _builtins.bool for_overlay: If this is created for overlay
        :param _builtins.str neighbor_mac: If it's another device in the same org
        :param _builtins.str node: Node0/node1
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int rx_routes: Number of received routes
        :param _builtins.str state: enum: `active`, `connect`, `established`, `idle`, `open_config`, `open_sent`
        :param _builtins.float timestamp: Epoch (seconds)
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        """
        pulumi.set(__self__, "evpn_overlay", evpn_overlay)
        pulumi.set(__self__, "for_overlay", for_overlay)
        pulumi.set(__self__, "local_as", local_as)
        pulumi.set(__self__, "neighbor", neighbor)
        pulumi.set(__self__, "neighbor_as", neighbor_as)
        pulumi.set(__self__, "neighbor_mac", neighbor_mac)
        pulumi.set(__self__, "node", node)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "rx_routes", rx_routes)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "tx_routes", tx_routes)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "vrf_name", vrf_name)

    @_builtins.property
    @pulumi.getter(name="evpnOverlay")
    def evpn_overlay(self) -> _builtins.bool:
        """
        If this is created for evpn overlay
        """
        return pulumi.get(self, "evpn_overlay")

    @_builtins.property
    @pulumi.getter(name="forOverlay")
    def for_overlay(self) -> _builtins.bool:
        """
        If this is created for overlay
        """
        return pulumi.get(self, "for_overlay")

    @_builtins.property
    @pulumi.getter(name="localAs")
    def local_as(self) -> _builtins.str:
        return pulumi.get(self, "local_as")

    @_builtins.property
    @pulumi.getter
    def neighbor(self) -> _builtins.str:
        return pulumi.get(self, "neighbor")

    @_builtins.property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> _builtins.str:
        return pulumi.get(self, "neighbor_as")

    @_builtins.property
    @pulumi.getter(name="neighborMac")
    def neighbor_mac(self) -> _builtins.str:
        """
        If it's another device in the same org
        """
        return pulumi.get(self, "neighbor_mac")

    @_builtins.property
    @pulumi.getter
    def node(self) -> _builtins.str:
        """
        Node0/node1
        """
        return pulumi.get(self, "node")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="rxRoutes")
    def rx_routes(self) -> _builtins.int:
        """
        Number of received routes
        """
        return pulumi.get(self, "rx_routes")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        enum: `active`, `connect`, `established`, `idle`, `open_config`, `open_sent`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter(name="txRoutes")
    def tx_routes(self) -> _builtins.int:
        return pulumi.get(self, "tx_routes")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> _builtins.str:
        return pulumi.get(self, "vrf_name")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatClusterConfigResult(dict):
    def __init__(__self__, *,
                 configuration: _builtins.str,
                 control_link_info: 'outputs.GetGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfoResult',
                 ethernet_connections: Sequence['outputs.GetGatewayStatsDeviceGatewayStatClusterConfigEthernetConnectionResult'],
                 fabric_link_info: 'outputs.GetGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfoResult',
                 last_status_change_reason: _builtins.str,
                 operational: _builtins.str,
                 primary_node_health: _builtins.str,
                 redundancy_group_informations: Sequence['outputs.GetGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformationResult'],
                 secondary_node_health: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "control_link_info", control_link_info)
        pulumi.set(__self__, "ethernet_connections", ethernet_connections)
        pulumi.set(__self__, "fabric_link_info", fabric_link_info)
        pulumi.set(__self__, "last_status_change_reason", last_status_change_reason)
        pulumi.set(__self__, "operational", operational)
        pulumi.set(__self__, "primary_node_health", primary_node_health)
        pulumi.set(__self__, "redundancy_group_informations", redundancy_group_informations)
        pulumi.set(__self__, "secondary_node_health", secondary_node_health)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> _builtins.str:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="controlLinkInfo")
    def control_link_info(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfoResult':
        return pulumi.get(self, "control_link_info")

    @_builtins.property
    @pulumi.getter(name="ethernetConnections")
    def ethernet_connections(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatClusterConfigEthernetConnectionResult']:
        return pulumi.get(self, "ethernet_connections")

    @_builtins.property
    @pulumi.getter(name="fabricLinkInfo")
    def fabric_link_info(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfoResult':
        return pulumi.get(self, "fabric_link_info")

    @_builtins.property
    @pulumi.getter(name="lastStatusChangeReason")
    def last_status_change_reason(self) -> _builtins.str:
        return pulumi.get(self, "last_status_change_reason")

    @_builtins.property
    @pulumi.getter
    def operational(self) -> _builtins.str:
        return pulumi.get(self, "operational")

    @_builtins.property
    @pulumi.getter(name="primaryNodeHealth")
    def primary_node_health(self) -> _builtins.str:
        return pulumi.get(self, "primary_node_health")

    @_builtins.property
    @pulumi.getter(name="redundancyGroupInformations")
    def redundancy_group_informations(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformationResult']:
        return pulumi.get(self, "redundancy_group_informations")

    @_builtins.property
    @pulumi.getter(name="secondaryNodeHealth")
    def secondary_node_health(self) -> _builtins.str:
        return pulumi.get(self, "secondary_node_health")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfoResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatClusterConfigEthernetConnectionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfoResult(dict):
    def __init__(__self__, *,
                 data_plane_notified_status: _builtins.str,
                 interfaces: Sequence[_builtins.str],
                 internal_status: _builtins.str,
                 state: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "data_plane_notified_status", data_plane_notified_status)
        pulumi.set(__self__, "interfaces", interfaces)
        pulumi.set(__self__, "internal_status", internal_status)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="dataPlaneNotifiedStatus")
    def data_plane_notified_status(self) -> _builtins.str:
        return pulumi.get(self, "data_plane_notified_status")

    @_builtins.property
    @pulumi.getter
    def interfaces(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "interfaces")

    @_builtins.property
    @pulumi.getter(name="internalStatus")
    def internal_status(self) -> _builtins.str:
        return pulumi.get(self, "internal_status")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformationResult(dict):
    def __init__(__self__, *,
                 id: _builtins.int,
                 monitoring_failure: _builtins.str,
                 threshold: _builtins.int):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "monitoring_failure", monitoring_failure)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="monitoringFailure")
    def monitoring_failure(self) -> _builtins.str:
        return pulumi.get(self, "monitoring_failure")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.int:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatClusterStatResult(dict):
    def __init__(__self__, *,
                 state: _builtins.str):
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatCpu2StatResult(dict):
    def __init__(__self__, *,
                 idle: _builtins.float,
                 interrupt: _builtins.float,
                 load_avgs: Sequence[_builtins.float],
                 system: _builtins.float,
                 user: _builtins.float):
        """
        :param _builtins.float idle: Percentage of CPU time that is idle
        :param _builtins.float interrupt: Percentage of CPU time being used by interrupts
        :param Sequence[_builtins.float] load_avgs: Load averages for the last 1, 5, and 15 minutes
        :param _builtins.float system: Percentage of CPU time being used by system processes
        :param _builtins.float user: Percentage of CPU time being used by user processes
        """
        pulumi.set(__self__, "idle", idle)
        pulumi.set(__self__, "interrupt", interrupt)
        pulumi.set(__self__, "load_avgs", load_avgs)
        pulumi.set(__self__, "system", system)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def idle(self) -> _builtins.float:
        """
        Percentage of CPU time that is idle
        """
        return pulumi.get(self, "idle")

    @_builtins.property
    @pulumi.getter
    def interrupt(self) -> _builtins.float:
        """
        Percentage of CPU time being used by interrupts
        """
        return pulumi.get(self, "interrupt")

    @_builtins.property
    @pulumi.getter(name="loadAvgs")
    def load_avgs(self) -> Sequence[_builtins.float]:
        """
        Load averages for the last 1, 5, and 15 minutes
        """
        return pulumi.get(self, "load_avgs")

    @_builtins.property
    @pulumi.getter
    def system(self) -> _builtins.float:
        """
        Percentage of CPU time being used by system processes
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.float:
        """
        Percentage of CPU time being used by user processes
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatCpuStatResult(dict):
    def __init__(__self__, *,
                 idle: _builtins.float,
                 interrupt: _builtins.float,
                 load_avgs: Sequence[_builtins.float],
                 system: _builtins.float,
                 user: _builtins.float):
        """
        :param _builtins.float idle: Percentage of CPU time that is idle
        :param _builtins.float interrupt: Percentage of CPU time being used by interrupts
        :param Sequence[_builtins.float] load_avgs: Load averages for the last 1, 5, and 15 minutes
        :param _builtins.float system: Percentage of CPU time being used by system processes
        :param _builtins.float user: Percentage of CPU time being used by user processes
        """
        pulumi.set(__self__, "idle", idle)
        pulumi.set(__self__, "interrupt", interrupt)
        pulumi.set(__self__, "load_avgs", load_avgs)
        pulumi.set(__self__, "system", system)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def idle(self) -> _builtins.float:
        """
        Percentage of CPU time that is idle
        """
        return pulumi.get(self, "idle")

    @_builtins.property
    @pulumi.getter
    def interrupt(self) -> _builtins.float:
        """
        Percentage of CPU time being used by interrupts
        """
        return pulumi.get(self, "interrupt")

    @_builtins.property
    @pulumi.getter(name="loadAvgs")
    def load_avgs(self) -> Sequence[_builtins.float]:
        """
        Load averages for the last 1, 5, and 15 minutes
        """
        return pulumi.get(self, "load_avgs")

    @_builtins.property
    @pulumi.getter
    def system(self) -> _builtins.float:
        """
        Percentage of CPU time being used by system processes
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.float:
        """
        Percentage of CPU time being used by user processes
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatDhcpd2StatResult(dict):
    def __init__(__self__, *,
                 num_ips: _builtins.int,
                 num_leased: _builtins.int):
        pulumi.set(__self__, "num_ips", num_ips)
        pulumi.set(__self__, "num_leased", num_leased)

    @_builtins.property
    @pulumi.getter(name="numIps")
    def num_ips(self) -> _builtins.int:
        return pulumi.get(self, "num_ips")

    @_builtins.property
    @pulumi.getter(name="numLeased")
    def num_leased(self) -> _builtins.int:
        return pulumi.get(self, "num_leased")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatDhcpdStatResult(dict):
    def __init__(__self__, *,
                 num_ips: _builtins.int,
                 num_leased: _builtins.int):
        pulumi.set(__self__, "num_ips", num_ips)
        pulumi.set(__self__, "num_leased", num_leased)

    @_builtins.property
    @pulumi.getter(name="numIps")
    def num_ips(self) -> _builtins.int:
        return pulumi.get(self, "num_ips")

    @_builtins.property
    @pulumi.getter(name="numLeased")
    def num_leased(self) -> _builtins.int:
        return pulumi.get(self, "num_leased")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatFwupdateResult(dict):
    def __init__(__self__, *,
                 progress: _builtins.int,
                 status: _builtins.str,
                 status_id: _builtins.int,
                 timestamp: _builtins.float,
                 will_retry: _builtins.bool):
        """
        :param _builtins.str status: enum: `inprogress`, `failed`, `upgraded`
        :param _builtins.float timestamp: Epoch (seconds)
        """
        pulumi.set(__self__, "progress", progress)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_id", status_id)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "will_retry", will_retry)

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.int:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        enum: `inprogress`, `failed`, `upgraded`
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusId")
    def status_id(self) -> _builtins.int:
        return pulumi.get(self, "status_id")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="willRetry")
    def will_retry(self) -> _builtins.bool:
        return pulumi.get(self, "will_retry")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatIf2StatResult(dict):
    def __init__(__self__, *,
                 address_mode: _builtins.str,
                 ips: Sequence[_builtins.str],
                 nat_addresses: Sequence[_builtins.str],
                 network_name: _builtins.str,
                 port_id: _builtins.str,
                 port_usage: _builtins.str,
                 redundancy_state: _builtins.str,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 servp_info: 'outputs.GetGatewayStatsDeviceGatewayStatIf2StatServpInfoResult',
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 up: _builtins.bool,
                 vlan: _builtins.int,
                 wan_name: _builtins.str,
                 wan_type: _builtins.str):
        """
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        """
        pulumi.set(__self__, "address_mode", address_mode)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "nat_addresses", nat_addresses)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "port_usage", port_usage)
        pulumi.set(__self__, "redundancy_state", redundancy_state)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "servp_info", servp_info)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "vlan", vlan)
        pulumi.set(__self__, "wan_name", wan_name)
        pulumi.set(__self__, "wan_type", wan_type)

    @_builtins.property
    @pulumi.getter(name="addressMode")
    def address_mode(self) -> _builtins.str:
        return pulumi.get(self, "address_mode")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="natAddresses")
    def nat_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "nat_addresses")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> _builtins.str:
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="redundancyState")
    def redundancy_state(self) -> _builtins.str:
        return pulumi.get(self, "redundancy_state")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="servpInfo")
    def servp_info(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatIf2StatServpInfoResult':
        return pulumi.get(self, "servp_info")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        return pulumi.get(self, "vlan")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> _builtins.str:
        return pulumi.get(self, "wan_name")

    @_builtins.property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> _builtins.str:
        return pulumi.get(self, "wan_type")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatIf2StatServpInfoResult(dict):
    def __init__(__self__, *,
                 asn: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 org: _builtins.str,
                 region_code: _builtins.str):
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "org", org)
        pulumi.set(__self__, "region_code", region_code)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> _builtins.str:
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def org(self) -> _builtins.str:
        return pulumi.get(self, "org")

    @_builtins.property
    @pulumi.getter(name="regionCode")
    def region_code(self) -> _builtins.str:
        return pulumi.get(self, "region_code")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatIfStatResult(dict):
    def __init__(__self__, *,
                 address_mode: _builtins.str,
                 ips: Sequence[_builtins.str],
                 nat_addresses: Sequence[_builtins.str],
                 network_name: _builtins.str,
                 port_id: _builtins.str,
                 port_usage: _builtins.str,
                 redundancy_state: _builtins.str,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 servp_info: 'outputs.GetGatewayStatsDeviceGatewayStatIfStatServpInfoResult',
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 up: _builtins.bool,
                 vlan: _builtins.int,
                 wan_name: _builtins.str,
                 wan_type: _builtins.str):
        """
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        """
        pulumi.set(__self__, "address_mode", address_mode)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "nat_addresses", nat_addresses)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "port_usage", port_usage)
        pulumi.set(__self__, "redundancy_state", redundancy_state)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "servp_info", servp_info)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "vlan", vlan)
        pulumi.set(__self__, "wan_name", wan_name)
        pulumi.set(__self__, "wan_type", wan_type)

    @_builtins.property
    @pulumi.getter(name="addressMode")
    def address_mode(self) -> _builtins.str:
        return pulumi.get(self, "address_mode")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="natAddresses")
    def nat_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "nat_addresses")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> _builtins.str:
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="redundancyState")
    def redundancy_state(self) -> _builtins.str:
        return pulumi.get(self, "redundancy_state")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="servpInfo")
    def servp_info(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatIfStatServpInfoResult':
        return pulumi.get(self, "servp_info")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        return pulumi.get(self, "vlan")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> _builtins.str:
        return pulumi.get(self, "wan_name")

    @_builtins.property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> _builtins.str:
        return pulumi.get(self, "wan_type")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatIfStatServpInfoResult(dict):
    def __init__(__self__, *,
                 asn: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 org: _builtins.str,
                 region_code: _builtins.str):
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "org", org)
        pulumi.set(__self__, "region_code", region_code)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> _builtins.str:
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def org(self) -> _builtins.str:
        return pulumi.get(self, "org")

    @_builtins.property
    @pulumi.getter(name="regionCode")
    def region_code(self) -> _builtins.str:
        return pulumi.get(self, "region_code")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatIp2StatResult(dict):
    def __init__(__self__, *,
                 dhcp_server: _builtins.str,
                 dns: Sequence[_builtins.str],
                 dns_suffixes: Sequence[_builtins.str],
                 gateway: _builtins.str,
                 gateway6: _builtins.str,
                 ip: _builtins.str,
                 ip6: _builtins.str,
                 ips: Mapping[str, _builtins.str],
                 netmask: _builtins.str,
                 netmask6: _builtins.str):
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "gateway6", gateway6)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip6", ip6)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "netmask6", netmask6)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> _builtins.str:
        return pulumi.get(self, "dhcp_server")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> _builtins.str:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> _builtins.str:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> _builtins.str:
        return pulumi.get(self, "netmask6")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatIpStatResult(dict):
    def __init__(__self__, *,
                 dhcp_server: _builtins.str,
                 dns: Sequence[_builtins.str],
                 dns_suffixes: Sequence[_builtins.str],
                 gateway: _builtins.str,
                 gateway6: _builtins.str,
                 ip: _builtins.str,
                 ip6: _builtins.str,
                 ips: Mapping[str, _builtins.str],
                 netmask: _builtins.str,
                 netmask6: _builtins.str):
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "gateway6", gateway6)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip6", ip6)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "netmask6", netmask6)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> _builtins.str:
        return pulumi.get(self, "dhcp_server")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> _builtins.str:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> _builtins.str:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> _builtins.str:
        return pulumi.get(self, "netmask6")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatMemory2StatResult(dict):
    def __init__(__self__, *,
                 usage: _builtins.float):
        pulumi.set(__self__, "usage", usage)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.float:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatMemoryStatResult(dict):
    def __init__(__self__, *,
                 usage: _builtins.float):
        pulumi.set(__self__, "usage", usage)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.float:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModule2StatResult(dict):
    def __init__(__self__, *,
                 backup_version: _builtins.str,
                 bios_version: _builtins.str,
                 cpld_version: _builtins.str,
                 fans: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatFanResult'],
                 fpga_version: _builtins.str,
                 last_seen: _builtins.float,
                 locating: _builtins.bool,
                 mac: _builtins.str,
                 model: _builtins.str,
                 optics_cpld_version: _builtins.str,
                 pending_version: _builtins.str,
                 poe: 'outputs.GetGatewayStatsDeviceGatewayStatModule2StatPoeResult',
                 poe_version: _builtins.str,
                 power_cpld_version: _builtins.str,
                 psuses: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatPsusResult'],
                 re_fpga_version: _builtins.str,
                 recovery_version: _builtins.str,
                 serial: _builtins.str,
                 status: _builtins.str,
                 temperatures: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatTemperatureResult'],
                 tmc_fpga_version: _builtins.str,
                 uboot_version: _builtins.str,
                 uptime: _builtins.int,
                 vc_links: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatVcLinkResult'],
                 vc_mode: _builtins.str,
                 vc_role: _builtins.str,
                 vc_state: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.str vc_role: enum: `master`, `backup`, `linecard`
        """
        pulumi.set(__self__, "backup_version", backup_version)
        pulumi.set(__self__, "bios_version", bios_version)
        pulumi.set(__self__, "cpld_version", cpld_version)
        pulumi.set(__self__, "fans", fans)
        pulumi.set(__self__, "fpga_version", fpga_version)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "locating", locating)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "optics_cpld_version", optics_cpld_version)
        pulumi.set(__self__, "pending_version", pending_version)
        pulumi.set(__self__, "poe", poe)
        pulumi.set(__self__, "poe_version", poe_version)
        pulumi.set(__self__, "power_cpld_version", power_cpld_version)
        pulumi.set(__self__, "psuses", psuses)
        pulumi.set(__self__, "re_fpga_version", re_fpga_version)
        pulumi.set(__self__, "recovery_version", recovery_version)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "temperatures", temperatures)
        pulumi.set(__self__, "tmc_fpga_version", tmc_fpga_version)
        pulumi.set(__self__, "uboot_version", uboot_version)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "vc_links", vc_links)
        pulumi.set(__self__, "vc_mode", vc_mode)
        pulumi.set(__self__, "vc_role", vc_role)
        pulumi.set(__self__, "vc_state", vc_state)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="backupVersion")
    def backup_version(self) -> _builtins.str:
        return pulumi.get(self, "backup_version")

    @_builtins.property
    @pulumi.getter(name="biosVersion")
    def bios_version(self) -> _builtins.str:
        return pulumi.get(self, "bios_version")

    @_builtins.property
    @pulumi.getter(name="cpldVersion")
    def cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "cpld_version")

    @_builtins.property
    @pulumi.getter
    def fans(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatFanResult']:
        return pulumi.get(self, "fans")

    @_builtins.property
    @pulumi.getter(name="fpgaVersion")
    def fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "fpga_version")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def locating(self) -> _builtins.bool:
        return pulumi.get(self, "locating")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="opticsCpldVersion")
    def optics_cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "optics_cpld_version")

    @_builtins.property
    @pulumi.getter(name="pendingVersion")
    def pending_version(self) -> _builtins.str:
        return pulumi.get(self, "pending_version")

    @_builtins.property
    @pulumi.getter
    def poe(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatModule2StatPoeResult':
        return pulumi.get(self, "poe")

    @_builtins.property
    @pulumi.getter(name="poeVersion")
    def poe_version(self) -> _builtins.str:
        return pulumi.get(self, "poe_version")

    @_builtins.property
    @pulumi.getter(name="powerCpldVersion")
    def power_cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "power_cpld_version")

    @_builtins.property
    @pulumi.getter
    def psuses(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatPsusResult']:
        return pulumi.get(self, "psuses")

    @_builtins.property
    @pulumi.getter(name="reFpgaVersion")
    def re_fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "re_fpga_version")

    @_builtins.property
    @pulumi.getter(name="recoveryVersion")
    def recovery_version(self) -> _builtins.str:
        return pulumi.get(self, "recovery_version")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def temperatures(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatTemperatureResult']:
        return pulumi.get(self, "temperatures")

    @_builtins.property
    @pulumi.getter(name="tmcFpgaVersion")
    def tmc_fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "tmc_fpga_version")

    @_builtins.property
    @pulumi.getter(name="ubootVersion")
    def uboot_version(self) -> _builtins.str:
        return pulumi.get(self, "uboot_version")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="vcLinks")
    def vc_links(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModule2StatVcLinkResult']:
        return pulumi.get(self, "vc_links")

    @_builtins.property
    @pulumi.getter(name="vcMode")
    def vc_mode(self) -> _builtins.str:
        return pulumi.get(self, "vc_mode")

    @_builtins.property
    @pulumi.getter(name="vcRole")
    def vc_role(self) -> _builtins.str:
        """
        enum: `master`, `backup`, `linecard`
        """
        return pulumi.get(self, "vc_role")

    @_builtins.property
    @pulumi.getter(name="vcState")
    def vc_state(self) -> _builtins.str:
        return pulumi.get(self, "vc_state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModule2StatFanResult(dict):
    def __init__(__self__, *,
                 airflow: _builtins.str,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "airflow", airflow)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def airflow(self) -> _builtins.str:
        return pulumi.get(self, "airflow")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModule2StatPoeResult(dict):
    def __init__(__self__, *,
                 max_power: _builtins.float,
                 power_draw: _builtins.float):
        pulumi.set(__self__, "max_power", max_power)
        pulumi.set(__self__, "power_draw", power_draw)

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> _builtins.float:
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="powerDraw")
    def power_draw(self) -> _builtins.float:
        return pulumi.get(self, "power_draw")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModule2StatPsusResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModule2StatTemperatureResult(dict):
    def __init__(__self__, *,
                 celsius: _builtins.float,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "celsius", celsius)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> _builtins.float:
        return pulumi.get(self, "celsius")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModule2StatVcLinkResult(dict):
    def __init__(__self__, *,
                 neighbor_module_idx: _builtins.int,
                 neighbor_port_id: _builtins.str,
                 port_id: _builtins.str):
        pulumi.set(__self__, "neighbor_module_idx", neighbor_module_idx)
        pulumi.set(__self__, "neighbor_port_id", neighbor_port_id)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="neighborModuleIdx")
    def neighbor_module_idx(self) -> _builtins.int:
        return pulumi.get(self, "neighbor_module_idx")

    @_builtins.property
    @pulumi.getter(name="neighborPortId")
    def neighbor_port_id(self) -> _builtins.str:
        return pulumi.get(self, "neighbor_port_id")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModuleStatResult(dict):
    def __init__(__self__, *,
                 backup_version: _builtins.str,
                 bios_version: _builtins.str,
                 cpld_version: _builtins.str,
                 fans: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatFanResult'],
                 fpga_version: _builtins.str,
                 last_seen: _builtins.float,
                 locating: _builtins.bool,
                 mac: _builtins.str,
                 model: _builtins.str,
                 optics_cpld_version: _builtins.str,
                 pending_version: _builtins.str,
                 poe: 'outputs.GetGatewayStatsDeviceGatewayStatModuleStatPoeResult',
                 poe_version: _builtins.str,
                 power_cpld_version: _builtins.str,
                 psuses: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatPsusResult'],
                 re_fpga_version: _builtins.str,
                 recovery_version: _builtins.str,
                 serial: _builtins.str,
                 status: _builtins.str,
                 temperatures: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatTemperatureResult'],
                 tmc_fpga_version: _builtins.str,
                 uboot_version: _builtins.str,
                 uptime: _builtins.int,
                 vc_links: Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatVcLinkResult'],
                 vc_mode: _builtins.str,
                 vc_role: _builtins.str,
                 vc_state: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.str vc_role: enum: `master`, `backup`, `linecard`
        """
        pulumi.set(__self__, "backup_version", backup_version)
        pulumi.set(__self__, "bios_version", bios_version)
        pulumi.set(__self__, "cpld_version", cpld_version)
        pulumi.set(__self__, "fans", fans)
        pulumi.set(__self__, "fpga_version", fpga_version)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "locating", locating)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "optics_cpld_version", optics_cpld_version)
        pulumi.set(__self__, "pending_version", pending_version)
        pulumi.set(__self__, "poe", poe)
        pulumi.set(__self__, "poe_version", poe_version)
        pulumi.set(__self__, "power_cpld_version", power_cpld_version)
        pulumi.set(__self__, "psuses", psuses)
        pulumi.set(__self__, "re_fpga_version", re_fpga_version)
        pulumi.set(__self__, "recovery_version", recovery_version)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "temperatures", temperatures)
        pulumi.set(__self__, "tmc_fpga_version", tmc_fpga_version)
        pulumi.set(__self__, "uboot_version", uboot_version)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "vc_links", vc_links)
        pulumi.set(__self__, "vc_mode", vc_mode)
        pulumi.set(__self__, "vc_role", vc_role)
        pulumi.set(__self__, "vc_state", vc_state)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="backupVersion")
    def backup_version(self) -> _builtins.str:
        return pulumi.get(self, "backup_version")

    @_builtins.property
    @pulumi.getter(name="biosVersion")
    def bios_version(self) -> _builtins.str:
        return pulumi.get(self, "bios_version")

    @_builtins.property
    @pulumi.getter(name="cpldVersion")
    def cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "cpld_version")

    @_builtins.property
    @pulumi.getter
    def fans(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatFanResult']:
        return pulumi.get(self, "fans")

    @_builtins.property
    @pulumi.getter(name="fpgaVersion")
    def fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "fpga_version")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def locating(self) -> _builtins.bool:
        return pulumi.get(self, "locating")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="opticsCpldVersion")
    def optics_cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "optics_cpld_version")

    @_builtins.property
    @pulumi.getter(name="pendingVersion")
    def pending_version(self) -> _builtins.str:
        return pulumi.get(self, "pending_version")

    @_builtins.property
    @pulumi.getter
    def poe(self) -> 'outputs.GetGatewayStatsDeviceGatewayStatModuleStatPoeResult':
        return pulumi.get(self, "poe")

    @_builtins.property
    @pulumi.getter(name="poeVersion")
    def poe_version(self) -> _builtins.str:
        return pulumi.get(self, "poe_version")

    @_builtins.property
    @pulumi.getter(name="powerCpldVersion")
    def power_cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "power_cpld_version")

    @_builtins.property
    @pulumi.getter
    def psuses(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatPsusResult']:
        return pulumi.get(self, "psuses")

    @_builtins.property
    @pulumi.getter(name="reFpgaVersion")
    def re_fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "re_fpga_version")

    @_builtins.property
    @pulumi.getter(name="recoveryVersion")
    def recovery_version(self) -> _builtins.str:
        return pulumi.get(self, "recovery_version")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def temperatures(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatTemperatureResult']:
        return pulumi.get(self, "temperatures")

    @_builtins.property
    @pulumi.getter(name="tmcFpgaVersion")
    def tmc_fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "tmc_fpga_version")

    @_builtins.property
    @pulumi.getter(name="ubootVersion")
    def uboot_version(self) -> _builtins.str:
        return pulumi.get(self, "uboot_version")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="vcLinks")
    def vc_links(self) -> Sequence['outputs.GetGatewayStatsDeviceGatewayStatModuleStatVcLinkResult']:
        return pulumi.get(self, "vc_links")

    @_builtins.property
    @pulumi.getter(name="vcMode")
    def vc_mode(self) -> _builtins.str:
        return pulumi.get(self, "vc_mode")

    @_builtins.property
    @pulumi.getter(name="vcRole")
    def vc_role(self) -> _builtins.str:
        """
        enum: `master`, `backup`, `linecard`
        """
        return pulumi.get(self, "vc_role")

    @_builtins.property
    @pulumi.getter(name="vcState")
    def vc_state(self) -> _builtins.str:
        return pulumi.get(self, "vc_state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModuleStatFanResult(dict):
    def __init__(__self__, *,
                 airflow: _builtins.str,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "airflow", airflow)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def airflow(self) -> _builtins.str:
        return pulumi.get(self, "airflow")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModuleStatPoeResult(dict):
    def __init__(__self__, *,
                 max_power: _builtins.float,
                 power_draw: _builtins.float):
        pulumi.set(__self__, "max_power", max_power)
        pulumi.set(__self__, "power_draw", power_draw)

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> _builtins.float:
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="powerDraw")
    def power_draw(self) -> _builtins.float:
        return pulumi.get(self, "power_draw")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModuleStatPsusResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModuleStatTemperatureResult(dict):
    def __init__(__self__, *,
                 celsius: _builtins.float,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "celsius", celsius)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> _builtins.float:
        return pulumi.get(self, "celsius")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatModuleStatVcLinkResult(dict):
    def __init__(__self__, *,
                 neighbor_module_idx: _builtins.int,
                 neighbor_port_id: _builtins.str,
                 port_id: _builtins.str):
        pulumi.set(__self__, "neighbor_module_idx", neighbor_module_idx)
        pulumi.set(__self__, "neighbor_port_id", neighbor_port_id)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="neighborModuleIdx")
    def neighbor_module_idx(self) -> _builtins.int:
        return pulumi.get(self, "neighbor_module_idx")

    @_builtins.property
    @pulumi.getter(name="neighborPortId")
    def neighbor_port_id(self) -> _builtins.str:
        return pulumi.get(self, "neighbor_port_id")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatPortResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 auth_state: _builtins.str,
                 disabled: _builtins.bool,
                 for_site: _builtins.bool,
                 full_duplex: _builtins.bool,
                 jitter: _builtins.float,
                 latency: _builtins.float,
                 loss: _builtins.float,
                 lte_iccid: _builtins.str,
                 lte_imei: _builtins.str,
                 lte_imsi: _builtins.str,
                 mac_count: _builtins.int,
                 mac_limit: _builtins.int,
                 neighbor_mac: _builtins.str,
                 neighbor_port_desc: _builtins.str,
                 neighbor_system_name: _builtins.str,
                 poe_disabled: _builtins.bool,
                 poe_mode: _builtins.str,
                 poe_on: _builtins.bool,
                 port_id: _builtins.str,
                 port_mac: _builtins.str,
                 port_usage: _builtins.str,
                 power_draw: _builtins.float,
                 rx_bcast_pkts: _builtins.int,
                 rx_bps: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_errors: _builtins.int,
                 rx_mcast_pkts: _builtins.int,
                 rx_pkts: _builtins.int,
                 speed: _builtins.int,
                 stp_role: _builtins.str,
                 stp_state: _builtins.str,
                 tx_bcast_pkts: _builtins.int,
                 tx_bps: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_errors: _builtins.int,
                 tx_mcast_pkts: _builtins.int,
                 tx_pkts: _builtins.int,
                 type: _builtins.str,
                 unconfigured: _builtins.bool,
                 up: _builtins.bool,
                 xcvr_model: _builtins.str,
                 xcvr_part_number: _builtins.str,
                 xcvr_serial: _builtins.str):
        """
        :param _builtins.bool active: Indicates if interface is active/inactive
        :param _builtins.str auth_state: if `up`==`true` and has Authenticator role. enum: `authenticated`, `authenticating`, `held`, `init`
        :param _builtins.bool disabled: Indicates if interface is disabled
        :param _builtins.bool full_duplex: Indicates full or half duplex
        :param _builtins.float jitter: Last sampled jitter of the interface
        :param _builtins.float latency: Last sampled latency of the interface
        :param _builtins.float loss: Last sampled loss of the interface
        :param _builtins.str lte_iccid: LTE ICCID value, Check for null/empty
        :param _builtins.str lte_imei: LTE IMEI value, Check for null/empty
        :param _builtins.str lte_imsi: LTE IMSI value, Check for null/empty
        :param _builtins.int mac_count: Number of mac addresses in the forwarding table
        :param _builtins.int mac_limit: Limit on number of dynamically learned macs
        :param _builtins.str neighbor_mac: chassis identifier of the chassis type listed
        :param _builtins.str neighbor_port_desc: Description supplied by the system on the interface E.g. "GigabitEthernet2/0/39"
        :param _builtins.str neighbor_system_name: Name supplied by the system on the interface E.g. neighbor system name E.g. "Kumar-Acc-SW.mist.local"
        :param _builtins.bool poe_disabled: Is the POE configured not be disabled.
        :param _builtins.str poe_mode: enum: `802.3af`, `802.3at`, `802.3bt`
        :param _builtins.bool poe_on: Is the device attached to POE
        :param _builtins.str port_mac: Interface mac address
        :param _builtins.str port_usage: gateway port usage. enum: `lan`
        :param _builtins.float power_draw: Amount of power being used by the interface at the time the command is executed. Unit in watts.
        :param _builtins.int rx_bcast_pkts: Broadcast input packets
        :param _builtins.int rx_bps: Rate of receiving traffic, bits/seconds, last known
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_errors: Input errors
        :param _builtins.int rx_mcast_pkts: Multicast input packets
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int speed: Port speed
        :param _builtins.str stp_role: if `up`==`true`. enum: `alternate`, `backup`, `designated`, `root`, `root-prevented`
        :param _builtins.str stp_state: if `up`==`true`. enum: `blocking`, `disabled`, `forwarding`, `learning`, `listening`
        :param _builtins.int tx_bcast_pkts: Broadcast output packets
        :param _builtins.int tx_bps: Rate of transmitting traffic, bits/seconds, last known
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_errors: Output errors
        :param _builtins.int tx_mcast_pkts: Multicast output packets
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.str type: device type. enum: `ap`, `ble`, `gateway`, `mxedge`, `nac`, `switch`
        :param _builtins.bool unconfigured: Indicates if interface is unconfigured
        :param _builtins.bool up: Indicates if interface is up
        :param _builtins.str xcvr_model: Optic Slot ModelName, Check for null/empty
        :param _builtins.str xcvr_part_number: Optic Slot Partnumber, Check for null/empty
        :param _builtins.str xcvr_serial: Optic Slot SerialNumber, Check for null/empty
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "auth_state", auth_state)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "for_site", for_site)
        pulumi.set(__self__, "full_duplex", full_duplex)
        pulumi.set(__self__, "jitter", jitter)
        pulumi.set(__self__, "latency", latency)
        pulumi.set(__self__, "loss", loss)
        pulumi.set(__self__, "lte_iccid", lte_iccid)
        pulumi.set(__self__, "lte_imei", lte_imei)
        pulumi.set(__self__, "lte_imsi", lte_imsi)
        pulumi.set(__self__, "mac_count", mac_count)
        pulumi.set(__self__, "mac_limit", mac_limit)
        pulumi.set(__self__, "neighbor_mac", neighbor_mac)
        pulumi.set(__self__, "neighbor_port_desc", neighbor_port_desc)
        pulumi.set(__self__, "neighbor_system_name", neighbor_system_name)
        pulumi.set(__self__, "poe_disabled", poe_disabled)
        pulumi.set(__self__, "poe_mode", poe_mode)
        pulumi.set(__self__, "poe_on", poe_on)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "port_mac", port_mac)
        pulumi.set(__self__, "port_usage", port_usage)
        pulumi.set(__self__, "power_draw", power_draw)
        pulumi.set(__self__, "rx_bcast_pkts", rx_bcast_pkts)
        pulumi.set(__self__, "rx_bps", rx_bps)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_errors", rx_errors)
        pulumi.set(__self__, "rx_mcast_pkts", rx_mcast_pkts)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "speed", speed)
        pulumi.set(__self__, "stp_role", stp_role)
        pulumi.set(__self__, "stp_state", stp_state)
        pulumi.set(__self__, "tx_bcast_pkts", tx_bcast_pkts)
        pulumi.set(__self__, "tx_bps", tx_bps)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_errors", tx_errors)
        pulumi.set(__self__, "tx_mcast_pkts", tx_mcast_pkts)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unconfigured", unconfigured)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "xcvr_model", xcvr_model)
        pulumi.set(__self__, "xcvr_part_number", xcvr_part_number)
        pulumi.set(__self__, "xcvr_serial", xcvr_serial)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Indicates if interface is active/inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="authState")
    def auth_state(self) -> _builtins.str:
        """
        if `up`==`true` and has Authenticator role. enum: `authenticated`, `authenticating`, `held`, `init`
        """
        return pulumi.get(self, "auth_state")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Indicates if interface is disabled
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="forSite")
    def for_site(self) -> _builtins.bool:
        return pulumi.get(self, "for_site")

    @_builtins.property
    @pulumi.getter(name="fullDuplex")
    def full_duplex(self) -> _builtins.bool:
        """
        Indicates full or half duplex
        """
        return pulumi.get(self, "full_duplex")

    @_builtins.property
    @pulumi.getter
    def jitter(self) -> _builtins.float:
        """
        Last sampled jitter of the interface
        """
        return pulumi.get(self, "jitter")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> _builtins.float:
        """
        Last sampled latency of the interface
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def loss(self) -> _builtins.float:
        """
        Last sampled loss of the interface
        """
        return pulumi.get(self, "loss")

    @_builtins.property
    @pulumi.getter(name="lteIccid")
    def lte_iccid(self) -> _builtins.str:
        """
        LTE ICCID value, Check for null/empty
        """
        return pulumi.get(self, "lte_iccid")

    @_builtins.property
    @pulumi.getter(name="lteImei")
    def lte_imei(self) -> _builtins.str:
        """
        LTE IMEI value, Check for null/empty
        """
        return pulumi.get(self, "lte_imei")

    @_builtins.property
    @pulumi.getter(name="lteImsi")
    def lte_imsi(self) -> _builtins.str:
        """
        LTE IMSI value, Check for null/empty
        """
        return pulumi.get(self, "lte_imsi")

    @_builtins.property
    @pulumi.getter(name="macCount")
    def mac_count(self) -> _builtins.int:
        """
        Number of mac addresses in the forwarding table
        """
        return pulumi.get(self, "mac_count")

    @_builtins.property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> _builtins.int:
        """
        Limit on number of dynamically learned macs
        """
        return pulumi.get(self, "mac_limit")

    @_builtins.property
    @pulumi.getter(name="neighborMac")
    def neighbor_mac(self) -> _builtins.str:
        """
        chassis identifier of the chassis type listed
        """
        return pulumi.get(self, "neighbor_mac")

    @_builtins.property
    @pulumi.getter(name="neighborPortDesc")
    def neighbor_port_desc(self) -> _builtins.str:
        """
        Description supplied by the system on the interface E.g. "GigabitEthernet2/0/39"
        """
        return pulumi.get(self, "neighbor_port_desc")

    @_builtins.property
    @pulumi.getter(name="neighborSystemName")
    def neighbor_system_name(self) -> _builtins.str:
        """
        Name supplied by the system on the interface E.g. neighbor system name E.g. "Kumar-Acc-SW.mist.local"
        """
        return pulumi.get(self, "neighbor_system_name")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> _builtins.bool:
        """
        Is the POE configured not be disabled.
        """
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="poeMode")
    def poe_mode(self) -> _builtins.str:
        """
        enum: `802.3af`, `802.3at`, `802.3bt`
        """
        return pulumi.get(self, "poe_mode")

    @_builtins.property
    @pulumi.getter(name="poeOn")
    def poe_on(self) -> _builtins.bool:
        """
        Is the device attached to POE
        """
        return pulumi.get(self, "poe_on")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="portMac")
    def port_mac(self) -> _builtins.str:
        """
        Interface mac address
        """
        return pulumi.get(self, "port_mac")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> _builtins.str:
        """
        gateway port usage. enum: `lan`
        """
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="powerDraw")
    def power_draw(self) -> _builtins.float:
        """
        Amount of power being used by the interface at the time the command is executed. Unit in watts.
        """
        return pulumi.get(self, "power_draw")

    @_builtins.property
    @pulumi.getter(name="rxBcastPkts")
    def rx_bcast_pkts(self) -> _builtins.int:
        """
        Broadcast input packets
        """
        return pulumi.get(self, "rx_bcast_pkts")

    @_builtins.property
    @pulumi.getter(name="rxBps")
    def rx_bps(self) -> _builtins.int:
        """
        Rate of receiving traffic, bits/seconds, last known
        """
        return pulumi.get(self, "rx_bps")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxErrors")
    def rx_errors(self) -> _builtins.int:
        """
        Input errors
        """
        return pulumi.get(self, "rx_errors")

    @_builtins.property
    @pulumi.getter(name="rxMcastPkts")
    def rx_mcast_pkts(self) -> _builtins.int:
        """
        Multicast input packets
        """
        return pulumi.get(self, "rx_mcast_pkts")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> _builtins.int:
        """
        Port speed
        """
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="stpRole")
    def stp_role(self) -> _builtins.str:
        """
        if `up`==`true`. enum: `alternate`, `backup`, `designated`, `root`, `root-prevented`
        """
        return pulumi.get(self, "stp_role")

    @_builtins.property
    @pulumi.getter(name="stpState")
    def stp_state(self) -> _builtins.str:
        """
        if `up`==`true`. enum: `blocking`, `disabled`, `forwarding`, `learning`, `listening`
        """
        return pulumi.get(self, "stp_state")

    @_builtins.property
    @pulumi.getter(name="txBcastPkts")
    def tx_bcast_pkts(self) -> _builtins.int:
        """
        Broadcast output packets
        """
        return pulumi.get(self, "tx_bcast_pkts")

    @_builtins.property
    @pulumi.getter(name="txBps")
    def tx_bps(self) -> _builtins.int:
        """
        Rate of transmitting traffic, bits/seconds, last known
        """
        return pulumi.get(self, "tx_bps")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txErrors")
    def tx_errors(self) -> _builtins.int:
        """
        Output errors
        """
        return pulumi.get(self, "tx_errors")

    @_builtins.property
    @pulumi.getter(name="txMcastPkts")
    def tx_mcast_pkts(self) -> _builtins.int:
        """
        Multicast output packets
        """
        return pulumi.get(self, "tx_mcast_pkts")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        device type. enum: `ap`, `ble`, `gateway`, `mxedge`, `nac`, `switch`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unconfigured(self) -> _builtins.bool:
        """
        Indicates if interface is unconfigured
        """
        return pulumi.get(self, "unconfigured")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        """
        Indicates if interface is up
        """
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter(name="xcvrModel")
    def xcvr_model(self) -> _builtins.str:
        """
        Optic Slot ModelName, Check for null/empty
        """
        return pulumi.get(self, "xcvr_model")

    @_builtins.property
    @pulumi.getter(name="xcvrPartNumber")
    def xcvr_part_number(self) -> _builtins.str:
        """
        Optic Slot Partnumber, Check for null/empty
        """
        return pulumi.get(self, "xcvr_part_number")

    @_builtins.property
    @pulumi.getter(name="xcvrSerial")
    def xcvr_serial(self) -> _builtins.str:
        """
        Optic Slot SerialNumber, Check for null/empty
        """
        return pulumi.get(self, "xcvr_serial")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatRouteSummaryStatsResult(dict):
    def __init__(__self__, *,
                 fib_routes: _builtins.int,
                 max_unicast_routes_supported: _builtins.int,
                 rib_routes: _builtins.int,
                 total_routes: _builtins.int):
        pulumi.set(__self__, "fib_routes", fib_routes)
        pulumi.set(__self__, "max_unicast_routes_supported", max_unicast_routes_supported)
        pulumi.set(__self__, "rib_routes", rib_routes)
        pulumi.set(__self__, "total_routes", total_routes)

    @_builtins.property
    @pulumi.getter(name="fibRoutes")
    def fib_routes(self) -> _builtins.int:
        return pulumi.get(self, "fib_routes")

    @_builtins.property
    @pulumi.getter(name="maxUnicastRoutesSupported")
    def max_unicast_routes_supported(self) -> _builtins.int:
        return pulumi.get(self, "max_unicast_routes_supported")

    @_builtins.property
    @pulumi.getter(name="ribRoutes")
    def rib_routes(self) -> _builtins.int:
        return pulumi.get(self, "rib_routes")

    @_builtins.property
    @pulumi.getter(name="totalRoutes")
    def total_routes(self) -> _builtins.int:
        return pulumi.get(self, "total_routes")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatService2StatResult(dict):
    def __init__(__self__, *,
                 ash_version: _builtins.str,
                 cia_version: _builtins.str,
                 ember_version: _builtins.str,
                 ipsec_client_version: _builtins.str,
                 mist_agent_version: _builtins.str,
                 package_version: _builtins.str,
                 testing_tools_version: _builtins.str,
                 wheeljack_version: _builtins.str):
        pulumi.set(__self__, "ash_version", ash_version)
        pulumi.set(__self__, "cia_version", cia_version)
        pulumi.set(__self__, "ember_version", ember_version)
        pulumi.set(__self__, "ipsec_client_version", ipsec_client_version)
        pulumi.set(__self__, "mist_agent_version", mist_agent_version)
        pulumi.set(__self__, "package_version", package_version)
        pulumi.set(__self__, "testing_tools_version", testing_tools_version)
        pulumi.set(__self__, "wheeljack_version", wheeljack_version)

    @_builtins.property
    @pulumi.getter(name="ashVersion")
    def ash_version(self) -> _builtins.str:
        return pulumi.get(self, "ash_version")

    @_builtins.property
    @pulumi.getter(name="ciaVersion")
    def cia_version(self) -> _builtins.str:
        return pulumi.get(self, "cia_version")

    @_builtins.property
    @pulumi.getter(name="emberVersion")
    def ember_version(self) -> _builtins.str:
        return pulumi.get(self, "ember_version")

    @_builtins.property
    @pulumi.getter(name="ipsecClientVersion")
    def ipsec_client_version(self) -> _builtins.str:
        return pulumi.get(self, "ipsec_client_version")

    @_builtins.property
    @pulumi.getter(name="mistAgentVersion")
    def mist_agent_version(self) -> _builtins.str:
        return pulumi.get(self, "mist_agent_version")

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> _builtins.str:
        return pulumi.get(self, "package_version")

    @_builtins.property
    @pulumi.getter(name="testingToolsVersion")
    def testing_tools_version(self) -> _builtins.str:
        return pulumi.get(self, "testing_tools_version")

    @_builtins.property
    @pulumi.getter(name="wheeljackVersion")
    def wheeljack_version(self) -> _builtins.str:
        return pulumi.get(self, "wheeljack_version")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatServiceStatResult(dict):
    def __init__(__self__, *,
                 ash_version: _builtins.str,
                 cia_version: _builtins.str,
                 ember_version: _builtins.str,
                 ipsec_client_version: _builtins.str,
                 mist_agent_version: _builtins.str,
                 package_version: _builtins.str,
                 testing_tools_version: _builtins.str,
                 wheeljack_version: _builtins.str):
        pulumi.set(__self__, "ash_version", ash_version)
        pulumi.set(__self__, "cia_version", cia_version)
        pulumi.set(__self__, "ember_version", ember_version)
        pulumi.set(__self__, "ipsec_client_version", ipsec_client_version)
        pulumi.set(__self__, "mist_agent_version", mist_agent_version)
        pulumi.set(__self__, "package_version", package_version)
        pulumi.set(__self__, "testing_tools_version", testing_tools_version)
        pulumi.set(__self__, "wheeljack_version", wheeljack_version)

    @_builtins.property
    @pulumi.getter(name="ashVersion")
    def ash_version(self) -> _builtins.str:
        return pulumi.get(self, "ash_version")

    @_builtins.property
    @pulumi.getter(name="ciaVersion")
    def cia_version(self) -> _builtins.str:
        return pulumi.get(self, "cia_version")

    @_builtins.property
    @pulumi.getter(name="emberVersion")
    def ember_version(self) -> _builtins.str:
        return pulumi.get(self, "ember_version")

    @_builtins.property
    @pulumi.getter(name="ipsecClientVersion")
    def ipsec_client_version(self) -> _builtins.str:
        return pulumi.get(self, "ipsec_client_version")

    @_builtins.property
    @pulumi.getter(name="mistAgentVersion")
    def mist_agent_version(self) -> _builtins.str:
        return pulumi.get(self, "mist_agent_version")

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> _builtins.str:
        return pulumi.get(self, "package_version")

    @_builtins.property
    @pulumi.getter(name="testingToolsVersion")
    def testing_tools_version(self) -> _builtins.str:
        return pulumi.get(self, "testing_tools_version")

    @_builtins.property
    @pulumi.getter(name="wheeljackVersion")
    def wheeljack_version(self) -> _builtins.str:
        return pulumi.get(self, "wheeljack_version")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatServiceStatusResult(dict):
    def __init__(__self__, *,
                 appid_install_result: _builtins.str,
                 appid_install_timestamp: _builtins.str,
                 appid_status: _builtins.str,
                 appid_version: _builtins.int,
                 ewf_status: _builtins.str,
                 idp_install_result: _builtins.str,
                 idp_install_timestamp: _builtins.str,
                 idp_policy: _builtins.str,
                 idp_status: _builtins.str,
                 idp_update_timestamp: _builtins.str):
        pulumi.set(__self__, "appid_install_result", appid_install_result)
        pulumi.set(__self__, "appid_install_timestamp", appid_install_timestamp)
        pulumi.set(__self__, "appid_status", appid_status)
        pulumi.set(__self__, "appid_version", appid_version)
        pulumi.set(__self__, "ewf_status", ewf_status)
        pulumi.set(__self__, "idp_install_result", idp_install_result)
        pulumi.set(__self__, "idp_install_timestamp", idp_install_timestamp)
        pulumi.set(__self__, "idp_policy", idp_policy)
        pulumi.set(__self__, "idp_status", idp_status)
        pulumi.set(__self__, "idp_update_timestamp", idp_update_timestamp)

    @_builtins.property
    @pulumi.getter(name="appidInstallResult")
    def appid_install_result(self) -> _builtins.str:
        return pulumi.get(self, "appid_install_result")

    @_builtins.property
    @pulumi.getter(name="appidInstallTimestamp")
    def appid_install_timestamp(self) -> _builtins.str:
        return pulumi.get(self, "appid_install_timestamp")

    @_builtins.property
    @pulumi.getter(name="appidStatus")
    def appid_status(self) -> _builtins.str:
        return pulumi.get(self, "appid_status")

    @_builtins.property
    @pulumi.getter(name="appidVersion")
    def appid_version(self) -> _builtins.int:
        return pulumi.get(self, "appid_version")

    @_builtins.property
    @pulumi.getter(name="ewfStatus")
    def ewf_status(self) -> _builtins.str:
        return pulumi.get(self, "ewf_status")

    @_builtins.property
    @pulumi.getter(name="idpInstallResult")
    def idp_install_result(self) -> _builtins.str:
        return pulumi.get(self, "idp_install_result")

    @_builtins.property
    @pulumi.getter(name="idpInstallTimestamp")
    def idp_install_timestamp(self) -> _builtins.str:
        return pulumi.get(self, "idp_install_timestamp")

    @_builtins.property
    @pulumi.getter(name="idpPolicy")
    def idp_policy(self) -> _builtins.str:
        return pulumi.get(self, "idp_policy")

    @_builtins.property
    @pulumi.getter(name="idpStatus")
    def idp_status(self) -> _builtins.str:
        return pulumi.get(self, "idp_status")

    @_builtins.property
    @pulumi.getter(name="idpUpdateTimestamp")
    def idp_update_timestamp(self) -> _builtins.str:
        return pulumi.get(self, "idp_update_timestamp")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatSpu2StatResult(dict):
    def __init__(__self__, *,
                 spu_cpu: _builtins.int,
                 spu_current_session: _builtins.int,
                 spu_max_session: _builtins.int,
                 spu_memory: _builtins.int,
                 spu_pending_session: _builtins.int,
                 spu_valid_session: _builtins.int):
        pulumi.set(__self__, "spu_cpu", spu_cpu)
        pulumi.set(__self__, "spu_current_session", spu_current_session)
        pulumi.set(__self__, "spu_max_session", spu_max_session)
        pulumi.set(__self__, "spu_memory", spu_memory)
        pulumi.set(__self__, "spu_pending_session", spu_pending_session)
        pulumi.set(__self__, "spu_valid_session", spu_valid_session)

    @_builtins.property
    @pulumi.getter(name="spuCpu")
    def spu_cpu(self) -> _builtins.int:
        return pulumi.get(self, "spu_cpu")

    @_builtins.property
    @pulumi.getter(name="spuCurrentSession")
    def spu_current_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_current_session")

    @_builtins.property
    @pulumi.getter(name="spuMaxSession")
    def spu_max_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_max_session")

    @_builtins.property
    @pulumi.getter(name="spuMemory")
    def spu_memory(self) -> _builtins.int:
        return pulumi.get(self, "spu_memory")

    @_builtins.property
    @pulumi.getter(name="spuPendingSession")
    def spu_pending_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_pending_session")

    @_builtins.property
    @pulumi.getter(name="spuValidSession")
    def spu_valid_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_valid_session")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatSpuStatResult(dict):
    def __init__(__self__, *,
                 spu_cpu: _builtins.int,
                 spu_current_session: _builtins.int,
                 spu_max_session: _builtins.int,
                 spu_memory: _builtins.int,
                 spu_pending_session: _builtins.int,
                 spu_valid_session: _builtins.int):
        pulumi.set(__self__, "spu_cpu", spu_cpu)
        pulumi.set(__self__, "spu_current_session", spu_current_session)
        pulumi.set(__self__, "spu_max_session", spu_max_session)
        pulumi.set(__self__, "spu_memory", spu_memory)
        pulumi.set(__self__, "spu_pending_session", spu_pending_session)
        pulumi.set(__self__, "spu_valid_session", spu_valid_session)

    @_builtins.property
    @pulumi.getter(name="spuCpu")
    def spu_cpu(self) -> _builtins.int:
        return pulumi.get(self, "spu_cpu")

    @_builtins.property
    @pulumi.getter(name="spuCurrentSession")
    def spu_current_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_current_session")

    @_builtins.property
    @pulumi.getter(name="spuMaxSession")
    def spu_max_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_max_session")

    @_builtins.property
    @pulumi.getter(name="spuMemory")
    def spu_memory(self) -> _builtins.int:
        return pulumi.get(self, "spu_memory")

    @_builtins.property
    @pulumi.getter(name="spuPendingSession")
    def spu_pending_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_pending_session")

    @_builtins.property
    @pulumi.getter(name="spuValidSession")
    def spu_valid_session(self) -> _builtins.int:
        return pulumi.get(self, "spu_valid_session")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatTunnelResult(dict):
    def __init__(__self__, *,
                 auth_algo: _builtins.str,
                 encrypt_algo: _builtins.str,
                 ike_version: _builtins.str,
                 ip: _builtins.str,
                 last_event: _builtins.str,
                 last_flapped: _builtins.float,
                 node: _builtins.str,
                 peer_host: _builtins.str,
                 peer_ip: _builtins.str,
                 priority: _builtins.str,
                 protocol: _builtins.str,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 tunnel_name: _builtins.str,
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 up: _builtins.bool,
                 uptime: _builtins.int,
                 wan_name: _builtins.str):
        """
        :param _builtins.str auth_algo: Authentication algorithm
        :param _builtins.str encrypt_algo: Encryption algorithm
        :param _builtins.str ike_version: IKE version
        :param _builtins.str ip: IP Address
        :param _builtins.str last_event: Reason of why the tunnel is down
        :param _builtins.float last_flapped: Indicates when the port was last flapped
        :param _builtins.str node: Node0/node1
        :param _builtins.str peer_host: Peer host
        :param _builtins.str peer_ip: Peer ip address
        :param _builtins.str priority: enum: `primary`, `secondary`
        :param _builtins.str protocol: enum: `gre`, `ipsec`
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.str tunnel_name: Mist Tunnel Name
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.int uptime: Duration from first (or last) SA was established
        :param _builtins.str wan_name: WAN interface name
        """
        pulumi.set(__self__, "auth_algo", auth_algo)
        pulumi.set(__self__, "encrypt_algo", encrypt_algo)
        pulumi.set(__self__, "ike_version", ike_version)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "last_event", last_event)
        pulumi.set(__self__, "last_flapped", last_flapped)
        pulumi.set(__self__, "node", node)
        pulumi.set(__self__, "peer_host", peer_host)
        pulumi.set(__self__, "peer_ip", peer_ip)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "tunnel_name", tunnel_name)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "wan_name", wan_name)

    @_builtins.property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> _builtins.str:
        """
        Authentication algorithm
        """
        return pulumi.get(self, "auth_algo")

    @_builtins.property
    @pulumi.getter(name="encryptAlgo")
    def encrypt_algo(self) -> _builtins.str:
        """
        Encryption algorithm
        """
        return pulumi.get(self, "encrypt_algo")

    @_builtins.property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> _builtins.str:
        """
        IKE version
        """
        return pulumi.get(self, "ike_version")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP Address
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="lastEvent")
    def last_event(self) -> _builtins.str:
        """
        Reason of why the tunnel is down
        """
        return pulumi.get(self, "last_event")

    @_builtins.property
    @pulumi.getter(name="lastFlapped")
    def last_flapped(self) -> _builtins.float:
        """
        Indicates when the port was last flapped
        """
        return pulumi.get(self, "last_flapped")

    @_builtins.property
    @pulumi.getter
    def node(self) -> _builtins.str:
        """
        Node0/node1
        """
        return pulumi.get(self, "node")

    @_builtins.property
    @pulumi.getter(name="peerHost")
    def peer_host(self) -> _builtins.str:
        """
        Peer host
        """
        return pulumi.get(self, "peer_host")

    @_builtins.property
    @pulumi.getter(name="peerIp")
    def peer_ip(self) -> _builtins.str:
        """
        Peer ip address
        """
        return pulumi.get(self, "peer_ip")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.str:
        """
        enum: `primary`, `secondary`
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> _builtins.str:
        """
        Mist Tunnel Name
        """
        return pulumi.get(self, "tunnel_name")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        """
        Duration from first (or last) SA was established
        """
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> _builtins.str:
        """
        WAN interface name
        """
        return pulumi.get(self, "wan_name")


@pulumi.output_type
class GetGatewayStatsDeviceGatewayStatVpnPeerResult(dict):
    def __init__(__self__, *,
                 is_active: _builtins.bool,
                 last_seen: _builtins.float,
                 latency: _builtins.float,
                 mos: _builtins.float,
                 mtu: _builtins.int,
                 peer_mac: _builtins.str,
                 peer_port_id: _builtins.str,
                 peer_router_name: _builtins.str,
                 peer_site_id: _builtins.str,
                 port_id: _builtins.str,
                 router_name: _builtins.str,
                 type: _builtins.str,
                 up: _builtins.bool,
                 uptime: _builtins.int):
        """
        :param _builtins.bool is_active: Redundancy status of the associated interface
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.str peer_mac: Peer router mac address
        :param _builtins.str peer_port_id: Peer router device interface
        :param _builtins.str port_id: Router device interface
        :param _builtins.str type: `ipsec`for SRX, `svr` for 128T
        """
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "latency", latency)
        pulumi.set(__self__, "mos", mos)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "peer_mac", peer_mac)
        pulumi.set(__self__, "peer_port_id", peer_port_id)
        pulumi.set(__self__, "peer_router_name", peer_router_name)
        pulumi.set(__self__, "peer_site_id", peer_site_id)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "router_name", router_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "uptime", uptime)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> _builtins.bool:
        """
        Redundancy status of the associated interface
        """
        return pulumi.get(self, "is_active")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> _builtins.float:
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def mos(self) -> _builtins.float:
        return pulumi.get(self, "mos")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> _builtins.int:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter(name="peerMac")
    def peer_mac(self) -> _builtins.str:
        """
        Peer router mac address
        """
        return pulumi.get(self, "peer_mac")

    @_builtins.property
    @pulumi.getter(name="peerPortId")
    def peer_port_id(self) -> _builtins.str:
        """
        Peer router device interface
        """
        return pulumi.get(self, "peer_port_id")

    @_builtins.property
    @pulumi.getter(name="peerRouterName")
    def peer_router_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_router_name")

    @_builtins.property
    @pulumi.getter(name="peerSiteId")
    def peer_site_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_site_id")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        """
        Router device interface
        """
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="routerName")
    def router_name(self) -> _builtins.str:
        return pulumi.get(self, "router_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        `ipsec`for SRX, `svr` for 128T
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        return pulumi.get(self, "uptime")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatResult(dict):
    def __init__(__self__, *,
                 ap_redundancy: 'outputs.GetSwitchStatsDeviceSwitchStatApRedundancyResult',
                 arp_table_stats: 'outputs.GetSwitchStatsDeviceSwitchStatArpTableStatsResult',
                 cert_expiry: _builtins.int,
                 clients: Sequence['outputs.GetSwitchStatsDeviceSwitchStatClientResult'],
                 clients_stats: 'outputs.GetSwitchStatsDeviceSwitchStatClientsStatsResult',
                 config_status: _builtins.str,
                 cpu_stat: 'outputs.GetSwitchStatsDeviceSwitchStatCpuStatResult',
                 created_time: _builtins.float,
                 deviceprofile_id: _builtins.str,
                 dhcpd_stat: Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatDhcpdStatResult'],
                 evpntopo_id: _builtins.str,
                 fw_versions_outofsync: _builtins.bool,
                 fwupdate: 'outputs.GetSwitchStatsDeviceSwitchStatFwupdateResult',
                 has_pcap: _builtins.bool,
                 hostname: _builtins.str,
                 hw_rev: _builtins.str,
                 id: _builtins.str,
                 if_stat: Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatIfStatResult'],
                 ip: _builtins.str,
                 ip_stat: 'outputs.GetSwitchStatsDeviceSwitchStatIpStatResult',
                 last_seen: _builtins.float,
                 last_trouble: 'outputs.GetSwitchStatsDeviceSwitchStatLastTroubleResult',
                 mac: _builtins.str,
                 mac_table_stats: 'outputs.GetSwitchStatsDeviceSwitchStatMacTableStatsResult',
                 map_id: _builtins.str,
                 memory_stat: 'outputs.GetSwitchStatsDeviceSwitchStatMemoryStatResult',
                 model: _builtins.str,
                 modified_time: _builtins.float,
                 module_stats: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatResult'],
                 name: _builtins.str,
                 org_id: _builtins.str,
                 ports: Sequence['outputs.GetSwitchStatsDeviceSwitchStatPortResult'],
                 route_summary_stats: 'outputs.GetSwitchStatsDeviceSwitchStatRouteSummaryStatsResult',
                 serial: _builtins.str,
                 service_stat: Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatServiceStatResult'],
                 site_id: _builtins.str,
                 status: _builtins.str,
                 uptime: _builtins.float,
                 vc_mac: _builtins.str,
                 vc_setup_info: 'outputs.GetSwitchStatsDeviceSwitchStatVcSetupInfoResult',
                 version: _builtins.str):
        """
        :param _builtins.float created_time: When the object has been created, in epoch
        :param Mapping[str, 'GetSwitchStatsDeviceSwitchStatDhcpdStatArgs'] dhcpd_stat: Property key is the network name
        :param _builtins.bool has_pcap: Whether the switch supports packet capture
        :param _builtins.str hostname: Hostname reported by the device
        :param _builtins.str hw_rev: Device hardware revision number
        :param _builtins.str id: Unique ID of the object instance in the Mist Organization
        :param Mapping[str, 'GetSwitchStatsDeviceSwitchStatIfStatArgs'] if_stat: Property key is the interface name
        :param _builtins.float last_seen: Last seen timestamp
        :param 'GetSwitchStatsDeviceSwitchStatLastTroubleArgs' last_trouble: Last trouble code of switch
        :param 'GetSwitchStatsDeviceSwitchStatMemoryStatArgs' memory_stat: Memory usage stat (for virtual chassis, memory usage of master RE)
        :param _builtins.float modified_time: When the object has been modified for the last time, in epoch
        :param _builtins.str name: Device name if configured
        """
        pulumi.set(__self__, "ap_redundancy", ap_redundancy)
        pulumi.set(__self__, "arp_table_stats", arp_table_stats)
        pulumi.set(__self__, "cert_expiry", cert_expiry)
        pulumi.set(__self__, "clients", clients)
        pulumi.set(__self__, "clients_stats", clients_stats)
        pulumi.set(__self__, "config_status", config_status)
        pulumi.set(__self__, "cpu_stat", cpu_stat)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "deviceprofile_id", deviceprofile_id)
        pulumi.set(__self__, "dhcpd_stat", dhcpd_stat)
        pulumi.set(__self__, "evpntopo_id", evpntopo_id)
        pulumi.set(__self__, "fw_versions_outofsync", fw_versions_outofsync)
        pulumi.set(__self__, "fwupdate", fwupdate)
        pulumi.set(__self__, "has_pcap", has_pcap)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "hw_rev", hw_rev)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "if_stat", if_stat)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_stat", ip_stat)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "last_trouble", last_trouble)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "mac_table_stats", mac_table_stats)
        pulumi.set(__self__, "map_id", map_id)
        pulumi.set(__self__, "memory_stat", memory_stat)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "modified_time", modified_time)
        pulumi.set(__self__, "module_stats", module_stats)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "route_summary_stats", route_summary_stats)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "service_stat", service_stat)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "vc_mac", vc_mac)
        pulumi.set(__self__, "vc_setup_info", vc_setup_info)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="apRedundancy")
    def ap_redundancy(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatApRedundancyResult':
        return pulumi.get(self, "ap_redundancy")

    @_builtins.property
    @pulumi.getter(name="arpTableStats")
    def arp_table_stats(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatArpTableStatsResult':
        return pulumi.get(self, "arp_table_stats")

    @_builtins.property
    @pulumi.getter(name="certExpiry")
    def cert_expiry(self) -> _builtins.int:
        return pulumi.get(self, "cert_expiry")

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatClientResult']:
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter(name="clientsStats")
    def clients_stats(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatClientsStatsResult':
        return pulumi.get(self, "clients_stats")

    @_builtins.property
    @pulumi.getter(name="configStatus")
    def config_status(self) -> _builtins.str:
        return pulumi.get(self, "config_status")

    @_builtins.property
    @pulumi.getter(name="cpuStat")
    def cpu_stat(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatCpuStatResult':
        return pulumi.get(self, "cpu_stat")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.float:
        """
        When the object has been created, in epoch
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="deviceprofileId")
    def deviceprofile_id(self) -> _builtins.str:
        return pulumi.get(self, "deviceprofile_id")

    @_builtins.property
    @pulumi.getter(name="dhcpdStat")
    def dhcpd_stat(self) -> Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatDhcpdStatResult']:
        """
        Property key is the network name
        """
        return pulumi.get(self, "dhcpd_stat")

    @_builtins.property
    @pulumi.getter(name="evpntopoId")
    def evpntopo_id(self) -> _builtins.str:
        return pulumi.get(self, "evpntopo_id")

    @_builtins.property
    @pulumi.getter(name="fwVersionsOutofsync")
    def fw_versions_outofsync(self) -> _builtins.bool:
        return pulumi.get(self, "fw_versions_outofsync")

    @_builtins.property
    @pulumi.getter
    def fwupdate(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatFwupdateResult':
        return pulumi.get(self, "fwupdate")

    @_builtins.property
    @pulumi.getter(name="hasPcap")
    def has_pcap(self) -> _builtins.bool:
        """
        Whether the switch supports packet capture
        """
        return pulumi.get(self, "has_pcap")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname reported by the device
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="hwRev")
    def hw_rev(self) -> _builtins.str:
        """
        Device hardware revision number
        """
        return pulumi.get(self, "hw_rev")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique ID of the object instance in the Mist Organization
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ifStat")
    def if_stat(self) -> Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatIfStatResult']:
        """
        Property key is the interface name
        """
        return pulumi.get(self, "if_stat")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="ipStat")
    def ip_stat(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatIpStatResult':
        return pulumi.get(self, "ip_stat")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter(name="lastTrouble")
    def last_trouble(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatLastTroubleResult':
        """
        Last trouble code of switch
        """
        return pulumi.get(self, "last_trouble")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="macTableStats")
    def mac_table_stats(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatMacTableStatsResult':
        return pulumi.get(self, "mac_table_stats")

    @_builtins.property
    @pulumi.getter(name="mapId")
    def map_id(self) -> _builtins.str:
        return pulumi.get(self, "map_id")

    @_builtins.property
    @pulumi.getter(name="memoryStat")
    def memory_stat(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatMemoryStatResult':
        """
        Memory usage stat (for virtual chassis, memory usage of master RE)
        """
        return pulumi.get(self, "memory_stat")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="modifiedTime")
    def modified_time(self) -> _builtins.float:
        """
        When the object has been modified for the last time, in epoch
        """
        return pulumi.get(self, "modified_time")

    @_builtins.property
    @pulumi.getter(name="moduleStats")
    def module_stats(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatResult']:
        return pulumi.get(self, "module_stats")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Device name if configured
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatPortResult']:
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter(name="routeSummaryStats")
    def route_summary_stats(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatRouteSummaryStatsResult':
        return pulumi.get(self, "route_summary_stats")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter(name="serviceStat")
    def service_stat(self) -> Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatServiceStatResult']:
        return pulumi.get(self, "service_stat")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.float:
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="vcMac")
    def vc_mac(self) -> _builtins.str:
        return pulumi.get(self, "vc_mac")

    @_builtins.property
    @pulumi.getter(name="vcSetupInfo")
    def vc_setup_info(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatVcSetupInfoResult':
        return pulumi.get(self, "vc_setup_info")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatApRedundancyResult(dict):
    def __init__(__self__, *,
                 modules: Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatApRedundancyModulesResult'],
                 num_aps: _builtins.int,
                 num_aps_with_switch_redundancy: _builtins.int):
        """
        :param Mapping[str, 'GetSwitchStatsDeviceSwitchStatApRedundancyModulesArgs'] modules: For a VC / stacked switches.
        """
        pulumi.set(__self__, "modules", modules)
        pulumi.set(__self__, "num_aps", num_aps)
        pulumi.set(__self__, "num_aps_with_switch_redundancy", num_aps_with_switch_redundancy)

    @_builtins.property
    @pulumi.getter
    def modules(self) -> Mapping[str, 'outputs.GetSwitchStatsDeviceSwitchStatApRedundancyModulesResult']:
        """
        For a VC / stacked switches.
        """
        return pulumi.get(self, "modules")

    @_builtins.property
    @pulumi.getter(name="numAps")
    def num_aps(self) -> _builtins.int:
        return pulumi.get(self, "num_aps")

    @_builtins.property
    @pulumi.getter(name="numApsWithSwitchRedundancy")
    def num_aps_with_switch_redundancy(self) -> _builtins.int:
        return pulumi.get(self, "num_aps_with_switch_redundancy")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatApRedundancyModulesResult(dict):
    def __init__(__self__, *,
                 num_aps: _builtins.int,
                 num_aps_with_switch_redundancy: _builtins.int):
        pulumi.set(__self__, "num_aps", num_aps)
        pulumi.set(__self__, "num_aps_with_switch_redundancy", num_aps_with_switch_redundancy)

    @_builtins.property
    @pulumi.getter(name="numAps")
    def num_aps(self) -> _builtins.int:
        return pulumi.get(self, "num_aps")

    @_builtins.property
    @pulumi.getter(name="numApsWithSwitchRedundancy")
    def num_aps_with_switch_redundancy(self) -> _builtins.int:
        return pulumi.get(self, "num_aps_with_switch_redundancy")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatArpTableStatsResult(dict):
    def __init__(__self__, *,
                 arp_table_count: _builtins.int,
                 max_entries_supported: _builtins.int):
        pulumi.set(__self__, "arp_table_count", arp_table_count)
        pulumi.set(__self__, "max_entries_supported", max_entries_supported)

    @_builtins.property
    @pulumi.getter(name="arpTableCount")
    def arp_table_count(self) -> _builtins.int:
        return pulumi.get(self, "arp_table_count")

    @_builtins.property
    @pulumi.getter(name="maxEntriesSupported")
    def max_entries_supported(self) -> _builtins.int:
        return pulumi.get(self, "max_entries_supported")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatClientResult(dict):
    def __init__(__self__, *,
                 device_mac: _builtins.str,
                 hostname: _builtins.str,
                 mac: _builtins.str,
                 port_id: _builtins.str):
        pulumi.set(__self__, "device_mac", device_mac)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="deviceMac")
    def device_mac(self) -> _builtins.str:
        return pulumi.get(self, "device_mac")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatClientsStatsResult(dict):
    def __init__(__self__, *,
                 total: 'outputs.GetSwitchStatsDeviceSwitchStatClientsStatsTotalResult'):
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def total(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatClientsStatsTotalResult':
        return pulumi.get(self, "total")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatClientsStatsTotalResult(dict):
    def __init__(__self__, *,
                 num_aps: Sequence[_builtins.int],
                 num_wired_clients: _builtins.int):
        pulumi.set(__self__, "num_aps", num_aps)
        pulumi.set(__self__, "num_wired_clients", num_wired_clients)

    @_builtins.property
    @pulumi.getter(name="numAps")
    def num_aps(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "num_aps")

    @_builtins.property
    @pulumi.getter(name="numWiredClients")
    def num_wired_clients(self) -> _builtins.int:
        return pulumi.get(self, "num_wired_clients")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatCpuStatResult(dict):
    def __init__(__self__, *,
                 idle: _builtins.float,
                 interrupt: _builtins.float,
                 load_avgs: Sequence[_builtins.float],
                 system: _builtins.float,
                 user: _builtins.float):
        """
        :param _builtins.float idle: Percentage of CPU time that is idle
        :param _builtins.float interrupt: Percentage of CPU time being used by interrupts
        :param Sequence[_builtins.float] load_avgs: Load averages for the last 1, 5, and 15 minutes
        :param _builtins.float system: Percentage of CPU time being used by system processes
        :param _builtins.float user: Percentage of CPU time being used by user processes
        """
        pulumi.set(__self__, "idle", idle)
        pulumi.set(__self__, "interrupt", interrupt)
        pulumi.set(__self__, "load_avgs", load_avgs)
        pulumi.set(__self__, "system", system)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def idle(self) -> _builtins.float:
        """
        Percentage of CPU time that is idle
        """
        return pulumi.get(self, "idle")

    @_builtins.property
    @pulumi.getter
    def interrupt(self) -> _builtins.float:
        """
        Percentage of CPU time being used by interrupts
        """
        return pulumi.get(self, "interrupt")

    @_builtins.property
    @pulumi.getter(name="loadAvgs")
    def load_avgs(self) -> Sequence[_builtins.float]:
        """
        Load averages for the last 1, 5, and 15 minutes
        """
        return pulumi.get(self, "load_avgs")

    @_builtins.property
    @pulumi.getter
    def system(self) -> _builtins.float:
        """
        Percentage of CPU time being used by system processes
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.float:
        """
        Percentage of CPU time being used by user processes
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatDhcpdStatResult(dict):
    def __init__(__self__, *,
                 num_ips: _builtins.int,
                 num_leased: _builtins.int):
        pulumi.set(__self__, "num_ips", num_ips)
        pulumi.set(__self__, "num_leased", num_leased)

    @_builtins.property
    @pulumi.getter(name="numIps")
    def num_ips(self) -> _builtins.int:
        return pulumi.get(self, "num_ips")

    @_builtins.property
    @pulumi.getter(name="numLeased")
    def num_leased(self) -> _builtins.int:
        return pulumi.get(self, "num_leased")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatFwupdateResult(dict):
    def __init__(__self__, *,
                 progress: _builtins.int,
                 status: _builtins.str,
                 status_id: _builtins.int,
                 timestamp: _builtins.float,
                 will_retry: _builtins.bool):
        """
        :param _builtins.str status: enum: `inprogress`, `failed`, `upgraded`
        :param _builtins.float timestamp: Epoch (seconds)
        """
        pulumi.set(__self__, "progress", progress)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_id", status_id)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "will_retry", will_retry)

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.int:
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        enum: `inprogress`, `failed`, `upgraded`
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusId")
    def status_id(self) -> _builtins.int:
        return pulumi.get(self, "status_id")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="willRetry")
    def will_retry(self) -> _builtins.bool:
        return pulumi.get(self, "will_retry")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatIfStatResult(dict):
    def __init__(__self__, *,
                 address_mode: _builtins.str,
                 ips: Sequence[_builtins.str],
                 nat_addresses: Sequence[_builtins.str],
                 network_name: _builtins.str,
                 port_id: _builtins.str,
                 port_usage: _builtins.str,
                 redundancy_state: _builtins.str,
                 rx_bytes: _builtins.int,
                 rx_pkts: _builtins.int,
                 servp_info: 'outputs.GetSwitchStatsDeviceSwitchStatIfStatServpInfoResult',
                 tx_bytes: _builtins.int,
                 tx_pkts: _builtins.int,
                 up: _builtins.bool,
                 vlan: _builtins.int,
                 wan_name: _builtins.str,
                 wan_type: _builtins.str):
        """
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        """
        pulumi.set(__self__, "address_mode", address_mode)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "nat_addresses", nat_addresses)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "port_usage", port_usage)
        pulumi.set(__self__, "redundancy_state", redundancy_state)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "servp_info", servp_info)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "vlan", vlan)
        pulumi.set(__self__, "wan_name", wan_name)
        pulumi.set(__self__, "wan_type", wan_type)

    @_builtins.property
    @pulumi.getter(name="addressMode")
    def address_mode(self) -> _builtins.str:
        return pulumi.get(self, "address_mode")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="natAddresses")
    def nat_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "nat_addresses")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> _builtins.str:
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="redundancyState")
    def redundancy_state(self) -> _builtins.str:
        return pulumi.get(self, "redundancy_state")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="servpInfo")
    def servp_info(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatIfStatServpInfoResult':
        return pulumi.get(self, "servp_info")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter
    def vlan(self) -> _builtins.int:
        return pulumi.get(self, "vlan")

    @_builtins.property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> _builtins.str:
        return pulumi.get(self, "wan_name")

    @_builtins.property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> _builtins.str:
        return pulumi.get(self, "wan_type")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatIfStatServpInfoResult(dict):
    def __init__(__self__, *,
                 asn: _builtins.str,
                 city: _builtins.str,
                 country_code: _builtins.str,
                 latitude: _builtins.float,
                 longitude: _builtins.float,
                 org: _builtins.str,
                 region_code: _builtins.str):
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "org", org)
        pulumi.set(__self__, "region_code", region_code)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> _builtins.str:
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> _builtins.str:
        return pulumi.get(self, "country_code")

    @_builtins.property
    @pulumi.getter
    def latitude(self) -> _builtins.float:
        return pulumi.get(self, "latitude")

    @_builtins.property
    @pulumi.getter
    def longitude(self) -> _builtins.float:
        return pulumi.get(self, "longitude")

    @_builtins.property
    @pulumi.getter
    def org(self) -> _builtins.str:
        return pulumi.get(self, "org")

    @_builtins.property
    @pulumi.getter(name="regionCode")
    def region_code(self) -> _builtins.str:
        return pulumi.get(self, "region_code")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatIpStatResult(dict):
    def __init__(__self__, *,
                 dhcp_server: _builtins.str,
                 dns: Sequence[_builtins.str],
                 dns_suffixes: Sequence[_builtins.str],
                 gateway: _builtins.str,
                 gateway6: _builtins.str,
                 ip: _builtins.str,
                 ip6: _builtins.str,
                 ips: Mapping[str, _builtins.str],
                 netmask: _builtins.str,
                 netmask6: _builtins.str):
        pulumi.set(__self__, "dhcp_server", dhcp_server)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "gateway6", gateway6)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip6", ip6)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "netmask6", netmask6)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> _builtins.str:
        return pulumi.get(self, "dhcp_server")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dns_suffixes")

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> _builtins.str:
        return pulumi.get(self, "gateway")

    @_builtins.property
    @pulumi.getter
    def gateway6(self) -> _builtins.str:
        return pulumi.get(self, "gateway6")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def ip6(self) -> _builtins.str:
        return pulumi.get(self, "ip6")

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter
    def netmask(self) -> _builtins.str:
        return pulumi.get(self, "netmask")

    @_builtins.property
    @pulumi.getter
    def netmask6(self) -> _builtins.str:
        return pulumi.get(self, "netmask6")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatLastTroubleResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 timestamp: _builtins.float):
        """
        :param _builtins.str code: Code definitions list at List Ap Led Definition
        :param _builtins.float timestamp: Epoch (seconds)
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Code definitions list at List Ap Led Definition
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.float:
        """
        Epoch (seconds)
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatMacTableStatsResult(dict):
    def __init__(__self__, *,
                 mac_table_count: _builtins.int,
                 max_mac_entries_supported: _builtins.int):
        pulumi.set(__self__, "mac_table_count", mac_table_count)
        pulumi.set(__self__, "max_mac_entries_supported", max_mac_entries_supported)

    @_builtins.property
    @pulumi.getter(name="macTableCount")
    def mac_table_count(self) -> _builtins.int:
        return pulumi.get(self, "mac_table_count")

    @_builtins.property
    @pulumi.getter(name="maxMacEntriesSupported")
    def max_mac_entries_supported(self) -> _builtins.int:
        return pulumi.get(self, "max_mac_entries_supported")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatMemoryStatResult(dict):
    def __init__(__self__, *,
                 usage: _builtins.float):
        pulumi.set(__self__, "usage", usage)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> _builtins.float:
        return pulumi.get(self, "usage")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatResult(dict):
    def __init__(__self__, *,
                 backup_version: _builtins.str,
                 bios_version: _builtins.str,
                 cpld_version: _builtins.str,
                 cpu_stat: 'outputs.GetSwitchStatsDeviceSwitchStatModuleStatCpuStatResult',
                 errors: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatErrorResult'],
                 fans: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatFanResult'],
                 fpc_idx: _builtins.int,
                 fpga_version: _builtins.str,
                 last_seen: _builtins.float,
                 locating: _builtins.bool,
                 mac: _builtins.str,
                 model: _builtins.str,
                 optics_cpld_version: _builtins.str,
                 pending_version: _builtins.str,
                 pics: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatPicResult'],
                 poe: 'outputs.GetSwitchStatsDeviceSwitchStatModuleStatPoeResult',
                 poe_version: _builtins.str,
                 power_cpld_version: _builtins.str,
                 psuses: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatPsusResult'],
                 re_fpga_version: _builtins.str,
                 recovery_version: _builtins.str,
                 serial: _builtins.str,
                 status: _builtins.str,
                 temperatures: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatTemperatureResult'],
                 tmc_fpga_version: _builtins.str,
                 type: _builtins.str,
                 uboot_version: _builtins.str,
                 uptime: _builtins.int,
                 vc_links: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatVcLinkResult'],
                 vc_mode: _builtins.str,
                 vc_role: _builtins.str,
                 vc_state: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence['GetSwitchStatsDeviceSwitchStatModuleStatErrorArgs'] errors: Used to report all error states the device node is running into. An error should always have `type` and `since` fields, and could have some other fields specific to that type.
        :param _builtins.float last_seen: Last seen timestamp
        :param _builtins.str vc_role: enum: `master`, `backup`, `linecard`
        """
        pulumi.set(__self__, "backup_version", backup_version)
        pulumi.set(__self__, "bios_version", bios_version)
        pulumi.set(__self__, "cpld_version", cpld_version)
        pulumi.set(__self__, "cpu_stat", cpu_stat)
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "fans", fans)
        pulumi.set(__self__, "fpc_idx", fpc_idx)
        pulumi.set(__self__, "fpga_version", fpga_version)
        pulumi.set(__self__, "last_seen", last_seen)
        pulumi.set(__self__, "locating", locating)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "optics_cpld_version", optics_cpld_version)
        pulumi.set(__self__, "pending_version", pending_version)
        pulumi.set(__self__, "pics", pics)
        pulumi.set(__self__, "poe", poe)
        pulumi.set(__self__, "poe_version", poe_version)
        pulumi.set(__self__, "power_cpld_version", power_cpld_version)
        pulumi.set(__self__, "psuses", psuses)
        pulumi.set(__self__, "re_fpga_version", re_fpga_version)
        pulumi.set(__self__, "recovery_version", recovery_version)
        pulumi.set(__self__, "serial", serial)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "temperatures", temperatures)
        pulumi.set(__self__, "tmc_fpga_version", tmc_fpga_version)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uboot_version", uboot_version)
        pulumi.set(__self__, "uptime", uptime)
        pulumi.set(__self__, "vc_links", vc_links)
        pulumi.set(__self__, "vc_mode", vc_mode)
        pulumi.set(__self__, "vc_role", vc_role)
        pulumi.set(__self__, "vc_state", vc_state)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="backupVersion")
    def backup_version(self) -> _builtins.str:
        return pulumi.get(self, "backup_version")

    @_builtins.property
    @pulumi.getter(name="biosVersion")
    def bios_version(self) -> _builtins.str:
        return pulumi.get(self, "bios_version")

    @_builtins.property
    @pulumi.getter(name="cpldVersion")
    def cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "cpld_version")

    @_builtins.property
    @pulumi.getter(name="cpuStat")
    def cpu_stat(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatModuleStatCpuStatResult':
        return pulumi.get(self, "cpu_stat")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatErrorResult']:
        """
        Used to report all error states the device node is running into. An error should always have `type` and `since` fields, and could have some other fields specific to that type.
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter
    def fans(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatFanResult']:
        return pulumi.get(self, "fans")

    @_builtins.property
    @pulumi.getter(name="fpcIdx")
    def fpc_idx(self) -> _builtins.int:
        return pulumi.get(self, "fpc_idx")

    @_builtins.property
    @pulumi.getter(name="fpgaVersion")
    def fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "fpga_version")

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> _builtins.float:
        """
        Last seen timestamp
        """
        return pulumi.get(self, "last_seen")

    @_builtins.property
    @pulumi.getter
    def locating(self) -> _builtins.bool:
        return pulumi.get(self, "locating")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter(name="opticsCpldVersion")
    def optics_cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "optics_cpld_version")

    @_builtins.property
    @pulumi.getter(name="pendingVersion")
    def pending_version(self) -> _builtins.str:
        return pulumi.get(self, "pending_version")

    @_builtins.property
    @pulumi.getter
    def pics(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatPicResult']:
        return pulumi.get(self, "pics")

    @_builtins.property
    @pulumi.getter
    def poe(self) -> 'outputs.GetSwitchStatsDeviceSwitchStatModuleStatPoeResult':
        return pulumi.get(self, "poe")

    @_builtins.property
    @pulumi.getter(name="poeVersion")
    def poe_version(self) -> _builtins.str:
        return pulumi.get(self, "poe_version")

    @_builtins.property
    @pulumi.getter(name="powerCpldVersion")
    def power_cpld_version(self) -> _builtins.str:
        return pulumi.get(self, "power_cpld_version")

    @_builtins.property
    @pulumi.getter
    def psuses(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatPsusResult']:
        return pulumi.get(self, "psuses")

    @_builtins.property
    @pulumi.getter(name="reFpgaVersion")
    def re_fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "re_fpga_version")

    @_builtins.property
    @pulumi.getter(name="recoveryVersion")
    def recovery_version(self) -> _builtins.str:
        return pulumi.get(self, "recovery_version")

    @_builtins.property
    @pulumi.getter
    def serial(self) -> _builtins.str:
        return pulumi.get(self, "serial")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def temperatures(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatTemperatureResult']:
        return pulumi.get(self, "temperatures")

    @_builtins.property
    @pulumi.getter(name="tmcFpgaVersion")
    def tmc_fpga_version(self) -> _builtins.str:
        return pulumi.get(self, "tmc_fpga_version")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="ubootVersion")
    def uboot_version(self) -> _builtins.str:
        return pulumi.get(self, "uboot_version")

    @_builtins.property
    @pulumi.getter
    def uptime(self) -> _builtins.int:
        return pulumi.get(self, "uptime")

    @_builtins.property
    @pulumi.getter(name="vcLinks")
    def vc_links(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatVcLinkResult']:
        return pulumi.get(self, "vc_links")

    @_builtins.property
    @pulumi.getter(name="vcMode")
    def vc_mode(self) -> _builtins.str:
        return pulumi.get(self, "vc_mode")

    @_builtins.property
    @pulumi.getter(name="vcRole")
    def vc_role(self) -> _builtins.str:
        """
        enum: `master`, `backup`, `linecard`
        """
        return pulumi.get(self, "vc_role")

    @_builtins.property
    @pulumi.getter(name="vcState")
    def vc_state(self) -> _builtins.str:
        return pulumi.get(self, "vc_state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatCpuStatResult(dict):
    def __init__(__self__, *,
                 idle: _builtins.float,
                 interrupt: _builtins.float,
                 load_avgs: Sequence[_builtins.float],
                 system: _builtins.float,
                 user: _builtins.float):
        """
        :param _builtins.float idle: Percentage of CPU time that is idle
        :param _builtins.float interrupt: Percentage of CPU time being used by interrupts
        :param Sequence[_builtins.float] load_avgs: Load averages for the last 1, 5, and 15 minutes
        :param _builtins.float system: Percentage of CPU time being used by system processes
        :param _builtins.float user: Percentage of CPU time being used by user processes
        """
        pulumi.set(__self__, "idle", idle)
        pulumi.set(__self__, "interrupt", interrupt)
        pulumi.set(__self__, "load_avgs", load_avgs)
        pulumi.set(__self__, "system", system)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def idle(self) -> _builtins.float:
        """
        Percentage of CPU time that is idle
        """
        return pulumi.get(self, "idle")

    @_builtins.property
    @pulumi.getter
    def interrupt(self) -> _builtins.float:
        """
        Percentage of CPU time being used by interrupts
        """
        return pulumi.get(self, "interrupt")

    @_builtins.property
    @pulumi.getter(name="loadAvgs")
    def load_avgs(self) -> Sequence[_builtins.float]:
        """
        Load averages for the last 1, 5, and 15 minutes
        """
        return pulumi.get(self, "load_avgs")

    @_builtins.property
    @pulumi.getter
    def system(self) -> _builtins.float:
        """
        Percentage of CPU time being used by system processes
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.float:
        """
        Percentage of CPU time being used by user processes
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatErrorResult(dict):
    def __init__(__self__, *,
                 feature: _builtins.str,
                 minimum_version: _builtins.str,
                 reason: _builtins.str,
                 since: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "feature", feature)
        pulumi.set(__self__, "minimum_version", minimum_version)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "since", since)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def feature(self) -> _builtins.str:
        return pulumi.get(self, "feature")

    @_builtins.property
    @pulumi.getter(name="minimumVersion")
    def minimum_version(self) -> _builtins.str:
        return pulumi.get(self, "minimum_version")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> _builtins.str:
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter
    def since(self) -> _builtins.int:
        return pulumi.get(self, "since")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatFanResult(dict):
    def __init__(__self__, *,
                 airflow: _builtins.str,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "airflow", airflow)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def airflow(self) -> _builtins.str:
        return pulumi.get(self, "airflow")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatPicResult(dict):
    def __init__(__self__, *,
                 index: _builtins.int,
                 model_number: _builtins.str,
                 port_groups: Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatPicPortGroupResult']):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "model_number", model_number)
        pulumi.set(__self__, "port_groups", port_groups)

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="modelNumber")
    def model_number(self) -> _builtins.str:
        return pulumi.get(self, "model_number")

    @_builtins.property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Sequence['outputs.GetSwitchStatsDeviceSwitchStatModuleStatPicPortGroupResult']:
        return pulumi.get(self, "port_groups")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatPicPortGroupResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatPoeResult(dict):
    def __init__(__self__, *,
                 max_power: _builtins.float,
                 power_draw: _builtins.float):
        pulumi.set(__self__, "max_power", max_power)
        pulumi.set(__self__, "power_draw", power_draw)

    @_builtins.property
    @pulumi.getter(name="maxPower")
    def max_power(self) -> _builtins.float:
        return pulumi.get(self, "max_power")

    @_builtins.property
    @pulumi.getter(name="powerDraw")
    def power_draw(self) -> _builtins.float:
        return pulumi.get(self, "power_draw")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatPsusResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatTemperatureResult(dict):
    def __init__(__self__, *,
                 celsius: _builtins.float,
                 name: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "celsius", celsius)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def celsius(self) -> _builtins.float:
        return pulumi.get(self, "celsius")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatModuleStatVcLinkResult(dict):
    def __init__(__self__, *,
                 neighbor_module_idx: _builtins.int,
                 neighbor_port_id: _builtins.str,
                 port_id: _builtins.str):
        pulumi.set(__self__, "neighbor_module_idx", neighbor_module_idx)
        pulumi.set(__self__, "neighbor_port_id", neighbor_port_id)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="neighborModuleIdx")
    def neighbor_module_idx(self) -> _builtins.int:
        return pulumi.get(self, "neighbor_module_idx")

    @_builtins.property
    @pulumi.getter(name="neighborPortId")
    def neighbor_port_id(self) -> _builtins.str:
        return pulumi.get(self, "neighbor_port_id")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatPortResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 auth_state: _builtins.str,
                 disabled: _builtins.bool,
                 for_site: _builtins.bool,
                 full_duplex: _builtins.bool,
                 jitter: _builtins.float,
                 last_flapped: _builtins.float,
                 latency: _builtins.float,
                 loss: _builtins.float,
                 lte_iccid: _builtins.str,
                 lte_imei: _builtins.str,
                 lte_imsi: _builtins.str,
                 mac: _builtins.str,
                 mac_count: _builtins.int,
                 mac_limit: _builtins.int,
                 neighbor_mac: _builtins.str,
                 neighbor_port_desc: _builtins.str,
                 neighbor_system_name: _builtins.str,
                 org_id: _builtins.str,
                 poe_disabled: _builtins.bool,
                 poe_mode: _builtins.str,
                 poe_on: _builtins.bool,
                 port_id: _builtins.str,
                 port_mac: _builtins.str,
                 port_usage: _builtins.str,
                 power_draw: _builtins.float,
                 rx_bcast_pkts: _builtins.int,
                 rx_bps: _builtins.int,
                 rx_bytes: _builtins.int,
                 rx_errors: _builtins.int,
                 rx_mcast_pkts: _builtins.int,
                 rx_pkts: _builtins.int,
                 site_id: _builtins.str,
                 speed: _builtins.int,
                 stp_role: _builtins.str,
                 stp_state: _builtins.str,
                 tx_bcast_pkts: _builtins.int,
                 tx_bps: _builtins.int,
                 tx_bytes: _builtins.int,
                 tx_errors: _builtins.int,
                 tx_mcast_pkts: _builtins.int,
                 tx_pkts: _builtins.int,
                 type: _builtins.str,
                 unconfigured: _builtins.bool,
                 up: _builtins.bool,
                 xcvr_model: _builtins.str,
                 xcvr_part_number: _builtins.str,
                 xcvr_serial: _builtins.str):
        """
        :param _builtins.bool active: Indicates if interface is active/inactive
        :param _builtins.str auth_state: if `up`==`true` and has Authenticator role. enum: `authenticated`, `authenticating`, `held`, `init`
        :param _builtins.bool disabled: Indicates if interface is disabled
        :param _builtins.bool full_duplex: Indicates full or half duplex
        :param _builtins.float jitter: Last sampled jitter of the interface
        :param _builtins.float last_flapped: Indicates when the port was last flapped
        :param _builtins.float latency: Last sampled latency of the interface
        :param _builtins.float loss: Last sampled loss of the interface
        :param _builtins.str lte_iccid: LTE ICCID value, Check for null/empty
        :param _builtins.str lte_imei: LTE IMEI value, Check for null/empty
        :param _builtins.str lte_imsi: LTE IMSI value, Check for null/empty
        :param _builtins.int mac_count: Number of mac addresses in the forwarding table
        :param _builtins.int mac_limit: Limit on number of dynamically learned macs
        :param _builtins.str neighbor_mac: chassis identifier of the chassis type listed
        :param _builtins.str neighbor_port_desc: Description supplied by the system on the interface E.g. "GigabitEthernet2/0/39"
        :param _builtins.str neighbor_system_name: Name supplied by the system on the interface E.g. neighbor system name E.g. "Kumar-Acc-SW.mist.local"
        :param _builtins.bool poe_disabled: Is the POE disabled
        :param _builtins.str poe_mode: enum: `802.3af`, `802.3at`, `802.3bt`
        :param _builtins.bool poe_on: Is the device attached to POE
        :param _builtins.str port_mac: Interface MAC address
        :param _builtins.str port_usage: gateway port usage. enum: `lan`
        :param _builtins.float power_draw: Amount of power being used by the interface at the time the command is executed. Unit in watts.
        :param _builtins.int rx_bcast_pkts: Broadcast input packets
        :param _builtins.int rx_bps: Rate of receiving traffic, bits/seconds, last known
        :param _builtins.int rx_bytes: Amount of traffic received since connection
        :param _builtins.int rx_errors: Input errors
        :param _builtins.int rx_mcast_pkts: Multicast input packets
        :param _builtins.int rx_pkts: Amount of packets received since connection
        :param _builtins.int speed: Port speed
        :param _builtins.str stp_role: if `up`==`true`. enum: `alternate`, `backup`, `designated`, `root`, `root-prevented`
        :param _builtins.str stp_state: if `up`==`true`. enum: `blocking`, `disabled`, `forwarding`, `learning`, `listening`
        :param _builtins.int tx_bcast_pkts: Broadcast output packets
        :param _builtins.int tx_bps: Rate of transmitting traffic, bits/seconds, last known
        :param _builtins.int tx_bytes: Amount of traffic sent since connection
        :param _builtins.int tx_errors: Output errors
        :param _builtins.int tx_mcast_pkts: Multicast output packets
        :param _builtins.int tx_pkts: Amount of packets sent since connection
        :param _builtins.str type: device type. enum: `ap`, `ble`, `gateway`, `mxedge`, `nac`, `switch`
        :param _builtins.bool unconfigured: Indicates if interface is unconfigured
        :param _builtins.bool up: Indicates if interface is up
        :param _builtins.str xcvr_model: Optic Slot ModelName, Check for null/empty
        :param _builtins.str xcvr_part_number: Optic Slot Partnumber, Check for null/empty
        :param _builtins.str xcvr_serial: Optic Slot SerialNumber, Check for null/empty
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "auth_state", auth_state)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "for_site", for_site)
        pulumi.set(__self__, "full_duplex", full_duplex)
        pulumi.set(__self__, "jitter", jitter)
        pulumi.set(__self__, "last_flapped", last_flapped)
        pulumi.set(__self__, "latency", latency)
        pulumi.set(__self__, "loss", loss)
        pulumi.set(__self__, "lte_iccid", lte_iccid)
        pulumi.set(__self__, "lte_imei", lte_imei)
        pulumi.set(__self__, "lte_imsi", lte_imsi)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "mac_count", mac_count)
        pulumi.set(__self__, "mac_limit", mac_limit)
        pulumi.set(__self__, "neighbor_mac", neighbor_mac)
        pulumi.set(__self__, "neighbor_port_desc", neighbor_port_desc)
        pulumi.set(__self__, "neighbor_system_name", neighbor_system_name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "poe_disabled", poe_disabled)
        pulumi.set(__self__, "poe_mode", poe_mode)
        pulumi.set(__self__, "poe_on", poe_on)
        pulumi.set(__self__, "port_id", port_id)
        pulumi.set(__self__, "port_mac", port_mac)
        pulumi.set(__self__, "port_usage", port_usage)
        pulumi.set(__self__, "power_draw", power_draw)
        pulumi.set(__self__, "rx_bcast_pkts", rx_bcast_pkts)
        pulumi.set(__self__, "rx_bps", rx_bps)
        pulumi.set(__self__, "rx_bytes", rx_bytes)
        pulumi.set(__self__, "rx_errors", rx_errors)
        pulumi.set(__self__, "rx_mcast_pkts", rx_mcast_pkts)
        pulumi.set(__self__, "rx_pkts", rx_pkts)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "speed", speed)
        pulumi.set(__self__, "stp_role", stp_role)
        pulumi.set(__self__, "stp_state", stp_state)
        pulumi.set(__self__, "tx_bcast_pkts", tx_bcast_pkts)
        pulumi.set(__self__, "tx_bps", tx_bps)
        pulumi.set(__self__, "tx_bytes", tx_bytes)
        pulumi.set(__self__, "tx_errors", tx_errors)
        pulumi.set(__self__, "tx_mcast_pkts", tx_mcast_pkts)
        pulumi.set(__self__, "tx_pkts", tx_pkts)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unconfigured", unconfigured)
        pulumi.set(__self__, "up", up)
        pulumi.set(__self__, "xcvr_model", xcvr_model)
        pulumi.set(__self__, "xcvr_part_number", xcvr_part_number)
        pulumi.set(__self__, "xcvr_serial", xcvr_serial)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Indicates if interface is active/inactive
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="authState")
    def auth_state(self) -> _builtins.str:
        """
        if `up`==`true` and has Authenticator role. enum: `authenticated`, `authenticating`, `held`, `init`
        """
        return pulumi.get(self, "auth_state")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Indicates if interface is disabled
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="forSite")
    def for_site(self) -> _builtins.bool:
        return pulumi.get(self, "for_site")

    @_builtins.property
    @pulumi.getter(name="fullDuplex")
    def full_duplex(self) -> _builtins.bool:
        """
        Indicates full or half duplex
        """
        return pulumi.get(self, "full_duplex")

    @_builtins.property
    @pulumi.getter
    def jitter(self) -> _builtins.float:
        """
        Last sampled jitter of the interface
        """
        return pulumi.get(self, "jitter")

    @_builtins.property
    @pulumi.getter(name="lastFlapped")
    def last_flapped(self) -> _builtins.float:
        """
        Indicates when the port was last flapped
        """
        return pulumi.get(self, "last_flapped")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> _builtins.float:
        """
        Last sampled latency of the interface
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def loss(self) -> _builtins.float:
        """
        Last sampled loss of the interface
        """
        return pulumi.get(self, "loss")

    @_builtins.property
    @pulumi.getter(name="lteIccid")
    def lte_iccid(self) -> _builtins.str:
        """
        LTE ICCID value, Check for null/empty
        """
        return pulumi.get(self, "lte_iccid")

    @_builtins.property
    @pulumi.getter(name="lteImei")
    def lte_imei(self) -> _builtins.str:
        """
        LTE IMEI value, Check for null/empty
        """
        return pulumi.get(self, "lte_imei")

    @_builtins.property
    @pulumi.getter(name="lteImsi")
    def lte_imsi(self) -> _builtins.str:
        """
        LTE IMSI value, Check for null/empty
        """
        return pulumi.get(self, "lte_imsi")

    @_builtins.property
    @pulumi.getter
    def mac(self) -> _builtins.str:
        return pulumi.get(self, "mac")

    @_builtins.property
    @pulumi.getter(name="macCount")
    def mac_count(self) -> _builtins.int:
        """
        Number of mac addresses in the forwarding table
        """
        return pulumi.get(self, "mac_count")

    @_builtins.property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> _builtins.int:
        """
        Limit on number of dynamically learned macs
        """
        return pulumi.get(self, "mac_limit")

    @_builtins.property
    @pulumi.getter(name="neighborMac")
    def neighbor_mac(self) -> _builtins.str:
        """
        chassis identifier of the chassis type listed
        """
        return pulumi.get(self, "neighbor_mac")

    @_builtins.property
    @pulumi.getter(name="neighborPortDesc")
    def neighbor_port_desc(self) -> _builtins.str:
        """
        Description supplied by the system on the interface E.g. "GigabitEthernet2/0/39"
        """
        return pulumi.get(self, "neighbor_port_desc")

    @_builtins.property
    @pulumi.getter(name="neighborSystemName")
    def neighbor_system_name(self) -> _builtins.str:
        """
        Name supplied by the system on the interface E.g. neighbor system name E.g. "Kumar-Acc-SW.mist.local"
        """
        return pulumi.get(self, "neighbor_system_name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> _builtins.bool:
        """
        Is the POE disabled
        """
        return pulumi.get(self, "poe_disabled")

    @_builtins.property
    @pulumi.getter(name="poeMode")
    def poe_mode(self) -> _builtins.str:
        """
        enum: `802.3af`, `802.3at`, `802.3bt`
        """
        return pulumi.get(self, "poe_mode")

    @_builtins.property
    @pulumi.getter(name="poeOn")
    def poe_on(self) -> _builtins.bool:
        """
        Is the device attached to POE
        """
        return pulumi.get(self, "poe_on")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        return pulumi.get(self, "port_id")

    @_builtins.property
    @pulumi.getter(name="portMac")
    def port_mac(self) -> _builtins.str:
        """
        Interface MAC address
        """
        return pulumi.get(self, "port_mac")

    @_builtins.property
    @pulumi.getter(name="portUsage")
    def port_usage(self) -> _builtins.str:
        """
        gateway port usage. enum: `lan`
        """
        return pulumi.get(self, "port_usage")

    @_builtins.property
    @pulumi.getter(name="powerDraw")
    def power_draw(self) -> _builtins.float:
        """
        Amount of power being used by the interface at the time the command is executed. Unit in watts.
        """
        return pulumi.get(self, "power_draw")

    @_builtins.property
    @pulumi.getter(name="rxBcastPkts")
    def rx_bcast_pkts(self) -> _builtins.int:
        """
        Broadcast input packets
        """
        return pulumi.get(self, "rx_bcast_pkts")

    @_builtins.property
    @pulumi.getter(name="rxBps")
    def rx_bps(self) -> _builtins.int:
        """
        Rate of receiving traffic, bits/seconds, last known
        """
        return pulumi.get(self, "rx_bps")

    @_builtins.property
    @pulumi.getter(name="rxBytes")
    def rx_bytes(self) -> _builtins.int:
        """
        Amount of traffic received since connection
        """
        return pulumi.get(self, "rx_bytes")

    @_builtins.property
    @pulumi.getter(name="rxErrors")
    def rx_errors(self) -> _builtins.int:
        """
        Input errors
        """
        return pulumi.get(self, "rx_errors")

    @_builtins.property
    @pulumi.getter(name="rxMcastPkts")
    def rx_mcast_pkts(self) -> _builtins.int:
        """
        Multicast input packets
        """
        return pulumi.get(self, "rx_mcast_pkts")

    @_builtins.property
    @pulumi.getter(name="rxPkts")
    def rx_pkts(self) -> _builtins.int:
        """
        Amount of packets received since connection
        """
        return pulumi.get(self, "rx_pkts")

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> _builtins.str:
        return pulumi.get(self, "site_id")

    @_builtins.property
    @pulumi.getter
    def speed(self) -> _builtins.int:
        """
        Port speed
        """
        return pulumi.get(self, "speed")

    @_builtins.property
    @pulumi.getter(name="stpRole")
    def stp_role(self) -> _builtins.str:
        """
        if `up`==`true`. enum: `alternate`, `backup`, `designated`, `root`, `root-prevented`
        """
        return pulumi.get(self, "stp_role")

    @_builtins.property
    @pulumi.getter(name="stpState")
    def stp_state(self) -> _builtins.str:
        """
        if `up`==`true`. enum: `blocking`, `disabled`, `forwarding`, `learning`, `listening`
        """
        return pulumi.get(self, "stp_state")

    @_builtins.property
    @pulumi.getter(name="txBcastPkts")
    def tx_bcast_pkts(self) -> _builtins.int:
        """
        Broadcast output packets
        """
        return pulumi.get(self, "tx_bcast_pkts")

    @_builtins.property
    @pulumi.getter(name="txBps")
    def tx_bps(self) -> _builtins.int:
        """
        Rate of transmitting traffic, bits/seconds, last known
        """
        return pulumi.get(self, "tx_bps")

    @_builtins.property
    @pulumi.getter(name="txBytes")
    def tx_bytes(self) -> _builtins.int:
        """
        Amount of traffic sent since connection
        """
        return pulumi.get(self, "tx_bytes")

    @_builtins.property
    @pulumi.getter(name="txErrors")
    def tx_errors(self) -> _builtins.int:
        """
        Output errors
        """
        return pulumi.get(self, "tx_errors")

    @_builtins.property
    @pulumi.getter(name="txMcastPkts")
    def tx_mcast_pkts(self) -> _builtins.int:
        """
        Multicast output packets
        """
        return pulumi.get(self, "tx_mcast_pkts")

    @_builtins.property
    @pulumi.getter(name="txPkts")
    def tx_pkts(self) -> _builtins.int:
        """
        Amount of packets sent since connection
        """
        return pulumi.get(self, "tx_pkts")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        device type. enum: `ap`, `ble`, `gateway`, `mxedge`, `nac`, `switch`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unconfigured(self) -> _builtins.bool:
        """
        Indicates if interface is unconfigured
        """
        return pulumi.get(self, "unconfigured")

    @_builtins.property
    @pulumi.getter
    def up(self) -> _builtins.bool:
        """
        Indicates if interface is up
        """
        return pulumi.get(self, "up")

    @_builtins.property
    @pulumi.getter(name="xcvrModel")
    def xcvr_model(self) -> _builtins.str:
        """
        Optic Slot ModelName, Check for null/empty
        """
        return pulumi.get(self, "xcvr_model")

    @_builtins.property
    @pulumi.getter(name="xcvrPartNumber")
    def xcvr_part_number(self) -> _builtins.str:
        """
        Optic Slot Partnumber, Check for null/empty
        """
        return pulumi.get(self, "xcvr_part_number")

    @_builtins.property
    @pulumi.getter(name="xcvrSerial")
    def xcvr_serial(self) -> _builtins.str:
        """
        Optic Slot SerialNumber, Check for null/empty
        """
        return pulumi.get(self, "xcvr_serial")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatRouteSummaryStatsResult(dict):
    def __init__(__self__, *,
                 fib_routes: _builtins.int,
                 max_unicast_routes_supported: _builtins.int,
                 rib_routes: _builtins.int,
                 total_routes: _builtins.int):
        pulumi.set(__self__, "fib_routes", fib_routes)
        pulumi.set(__self__, "max_unicast_routes_supported", max_unicast_routes_supported)
        pulumi.set(__self__, "rib_routes", rib_routes)
        pulumi.set(__self__, "total_routes", total_routes)

    @_builtins.property
    @pulumi.getter(name="fibRoutes")
    def fib_routes(self) -> _builtins.int:
        return pulumi.get(self, "fib_routes")

    @_builtins.property
    @pulumi.getter(name="maxUnicastRoutesSupported")
    def max_unicast_routes_supported(self) -> _builtins.int:
        return pulumi.get(self, "max_unicast_routes_supported")

    @_builtins.property
    @pulumi.getter(name="ribRoutes")
    def rib_routes(self) -> _builtins.int:
        return pulumi.get(self, "rib_routes")

    @_builtins.property
    @pulumi.getter(name="totalRoutes")
    def total_routes(self) -> _builtins.int:
        return pulumi.get(self, "total_routes")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatServiceStatResult(dict):
    def __init__(__self__, *,
                 ash_version: _builtins.str,
                 cia_version: _builtins.str,
                 ember_version: _builtins.str,
                 ipsec_client_version: _builtins.str,
                 mist_agent_version: _builtins.str,
                 package_version: _builtins.str,
                 testing_tools_version: _builtins.str,
                 wheeljack_version: _builtins.str):
        pulumi.set(__self__, "ash_version", ash_version)
        pulumi.set(__self__, "cia_version", cia_version)
        pulumi.set(__self__, "ember_version", ember_version)
        pulumi.set(__self__, "ipsec_client_version", ipsec_client_version)
        pulumi.set(__self__, "mist_agent_version", mist_agent_version)
        pulumi.set(__self__, "package_version", package_version)
        pulumi.set(__self__, "testing_tools_version", testing_tools_version)
        pulumi.set(__self__, "wheeljack_version", wheeljack_version)

    @_builtins.property
    @pulumi.getter(name="ashVersion")
    def ash_version(self) -> _builtins.str:
        return pulumi.get(self, "ash_version")

    @_builtins.property
    @pulumi.getter(name="ciaVersion")
    def cia_version(self) -> _builtins.str:
        return pulumi.get(self, "cia_version")

    @_builtins.property
    @pulumi.getter(name="emberVersion")
    def ember_version(self) -> _builtins.str:
        return pulumi.get(self, "ember_version")

    @_builtins.property
    @pulumi.getter(name="ipsecClientVersion")
    def ipsec_client_version(self) -> _builtins.str:
        return pulumi.get(self, "ipsec_client_version")

    @_builtins.property
    @pulumi.getter(name="mistAgentVersion")
    def mist_agent_version(self) -> _builtins.str:
        return pulumi.get(self, "mist_agent_version")

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> _builtins.str:
        return pulumi.get(self, "package_version")

    @_builtins.property
    @pulumi.getter(name="testingToolsVersion")
    def testing_tools_version(self) -> _builtins.str:
        return pulumi.get(self, "testing_tools_version")

    @_builtins.property
    @pulumi.getter(name="wheeljackVersion")
    def wheeljack_version(self) -> _builtins.str:
        return pulumi.get(self, "wheeljack_version")


@pulumi.output_type
class GetSwitchStatsDeviceSwitchStatVcSetupInfoResult(dict):
    def __init__(__self__, *,
                 config_type: _builtins.str,
                 current_stats: _builtins.str,
                 err_missing_dev_id_fpc: _builtins.bool,
                 last_update: _builtins.float,
                 request_time: _builtins.float,
                 request_type: _builtins.str):
        pulumi.set(__self__, "config_type", config_type)
        pulumi.set(__self__, "current_stats", current_stats)
        pulumi.set(__self__, "err_missing_dev_id_fpc", err_missing_dev_id_fpc)
        pulumi.set(__self__, "last_update", last_update)
        pulumi.set(__self__, "request_time", request_time)
        pulumi.set(__self__, "request_type", request_type)

    @_builtins.property
    @pulumi.getter(name="configType")
    def config_type(self) -> _builtins.str:
        return pulumi.get(self, "config_type")

    @_builtins.property
    @pulumi.getter(name="currentStats")
    def current_stats(self) -> _builtins.str:
        return pulumi.get(self, "current_stats")

    @_builtins.property
    @pulumi.getter(name="errMissingDevIdFpc")
    def err_missing_dev_id_fpc(self) -> _builtins.bool:
        return pulumi.get(self, "err_missing_dev_id_fpc")

    @_builtins.property
    @pulumi.getter(name="lastUpdate")
    def last_update(self) -> _builtins.float:
        return pulumi.get(self, "last_update")

    @_builtins.property
    @pulumi.getter(name="requestTime")
    def request_time(self) -> _builtins.float:
        return pulumi.get(self, "request_time")

    @_builtins.property
    @pulumi.getter(name="requestType")
    def request_type(self) -> _builtins.str:
        return pulumi.get(self, "request_type")


@pulumi.output_type
class GetVersionsDeviceVersionResult(dict):
    def __init__(__self__, *,
                 model: _builtins.str,
                 tag: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str model: Device model (as seen in the device stats)
        :param _builtins.str tag: Annotation, stable / beta / alpha. Or it can be empty or nothing which is likely a dev build
        :param _builtins.str version: Firmware version
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        Device model (as seen in the device stats)
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Annotation, stable / beta / alpha. Or it can be empty or nothing which is likely a dev build
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Firmware version
        """
        return pulumi.get(self, "version")


