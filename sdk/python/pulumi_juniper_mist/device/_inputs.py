# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApAeroscoutArgs',
    'ApAeroscoutArgsDict',
    'ApBleConfigArgs',
    'ApBleConfigArgsDict',
    'ApCentrakArgs',
    'ApCentrakArgsDict',
    'ApClientBridgeArgs',
    'ApClientBridgeArgsDict',
    'ApClientBridgeAuthArgs',
    'ApClientBridgeAuthArgsDict',
    'ApEslConfigArgs',
    'ApEslConfigArgsDict',
    'ApIpConfigArgs',
    'ApIpConfigArgsDict',
    'ApLedArgs',
    'ApLedArgsDict',
    'ApMeshArgs',
    'ApMeshArgsDict',
    'ApPwrConfigArgs',
    'ApPwrConfigArgsDict',
    'ApRadioConfigArgs',
    'ApRadioConfigArgsDict',
    'ApRadioConfigBand24Args',
    'ApRadioConfigBand24ArgsDict',
    'ApRadioConfigBand5Args',
    'ApRadioConfigBand5ArgsDict',
    'ApRadioConfigBand5On24RadioArgs',
    'ApRadioConfigBand5On24RadioArgsDict',
    'ApRadioConfigBand6Args',
    'ApRadioConfigBand6ArgsDict',
    'ApUplinkPortConfigArgs',
    'ApUplinkPortConfigArgsDict',
    'ApUsbConfigArgs',
    'ApUsbConfigArgsDict',
    'GatewayBgpConfigArgs',
    'GatewayBgpConfigArgsDict',
    'GatewayBgpConfigNeighborsArgs',
    'GatewayBgpConfigNeighborsArgsDict',
    'GatewayClusterNodeArgs',
    'GatewayClusterNodeArgsDict',
    'GatewayDhcpdConfigArgs',
    'GatewayDhcpdConfigArgsDict',
    'GatewayDhcpdConfigConfigArgs',
    'GatewayDhcpdConfigConfigArgsDict',
    'GatewayDhcpdConfigConfigFixedBindingsArgs',
    'GatewayDhcpdConfigConfigFixedBindingsArgsDict',
    'GatewayDhcpdConfigConfigOptionsArgs',
    'GatewayDhcpdConfigConfigOptionsArgsDict',
    'GatewayDhcpdConfigConfigVendorEncapulatedArgs',
    'GatewayDhcpdConfigConfigVendorEncapulatedArgsDict',
    'GatewayExtraRoutes6Args',
    'GatewayExtraRoutes6ArgsDict',
    'GatewayExtraRoutesArgs',
    'GatewayExtraRoutesArgsDict',
    'GatewayIdpProfilesArgs',
    'GatewayIdpProfilesArgsDict',
    'GatewayIdpProfilesOverwriteArgs',
    'GatewayIdpProfilesOverwriteArgsDict',
    'GatewayIdpProfilesOverwriteMatchingArgs',
    'GatewayIdpProfilesOverwriteMatchingArgsDict',
    'GatewayIpConfigsArgs',
    'GatewayIpConfigsArgsDict',
    'GatewayNetworkArgs',
    'GatewayNetworkArgsDict',
    'GatewayNetworkInternalAccessArgs',
    'GatewayNetworkInternalAccessArgsDict',
    'GatewayNetworkInternetAccessArgs',
    'GatewayNetworkInternetAccessArgsDict',
    'GatewayNetworkInternetAccessDestinationNatArgs',
    'GatewayNetworkInternetAccessDestinationNatArgsDict',
    'GatewayNetworkInternetAccessStaticNatArgs',
    'GatewayNetworkInternetAccessStaticNatArgsDict',
    'GatewayNetworkMulticastArgs',
    'GatewayNetworkMulticastArgsDict',
    'GatewayNetworkMulticastGroupsArgs',
    'GatewayNetworkMulticastGroupsArgsDict',
    'GatewayNetworkTenantsArgs',
    'GatewayNetworkTenantsArgsDict',
    'GatewayNetworkVpnAccessArgs',
    'GatewayNetworkVpnAccessArgsDict',
    'GatewayNetworkVpnAccessDestinationNatArgs',
    'GatewayNetworkVpnAccessDestinationNatArgsDict',
    'GatewayNetworkVpnAccessSourceNatArgs',
    'GatewayNetworkVpnAccessSourceNatArgsDict',
    'GatewayNetworkVpnAccessStaticNatArgs',
    'GatewayNetworkVpnAccessStaticNatArgsDict',
    'GatewayOobIpConfigArgs',
    'GatewayOobIpConfigArgsDict',
    'GatewayOobIpConfigNode1Args',
    'GatewayOobIpConfigNode1ArgsDict',
    'GatewayPathPreferencesArgs',
    'GatewayPathPreferencesArgsDict',
    'GatewayPathPreferencesPathArgs',
    'GatewayPathPreferencesPathArgsDict',
    'GatewayPortConfigArgs',
    'GatewayPortConfigArgsDict',
    'GatewayPortConfigIpConfigArgs',
    'GatewayPortConfigIpConfigArgsDict',
    'GatewayPortConfigTrafficShapingArgs',
    'GatewayPortConfigTrafficShapingArgsDict',
    'GatewayPortConfigVpnPathsArgs',
    'GatewayPortConfigVpnPathsArgsDict',
    'GatewayPortConfigVpnPathsTrafficShapingArgs',
    'GatewayPortConfigVpnPathsTrafficShapingArgsDict',
    'GatewayPortConfigWanExtraRoutesArgs',
    'GatewayPortConfigWanExtraRoutesArgsDict',
    'GatewayPortConfigWanProbeOverrideArgs',
    'GatewayPortConfigWanProbeOverrideArgsDict',
    'GatewayPortConfigWanSourceNatArgs',
    'GatewayPortConfigWanSourceNatArgsDict',
    'GatewayPortMirroringArgs',
    'GatewayPortMirroringArgsDict',
    'GatewayPortMirroringPortMirrorArgs',
    'GatewayPortMirroringPortMirrorArgsDict',
    'GatewayRoutingPoliciesArgs',
    'GatewayRoutingPoliciesArgsDict',
    'GatewayRoutingPoliciesTermArgs',
    'GatewayRoutingPoliciesTermArgsDict',
    'GatewayRoutingPoliciesTermActionArgs',
    'GatewayRoutingPoliciesTermActionArgsDict',
    'GatewayRoutingPoliciesTermMatchingArgs',
    'GatewayRoutingPoliciesTermMatchingArgsDict',
    'GatewayRoutingPoliciesTermMatchingRouteExistsArgs',
    'GatewayRoutingPoliciesTermMatchingRouteExistsArgsDict',
    'GatewayRoutingPoliciesTermMatchingVpnPathSlaArgs',
    'GatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict',
    'GatewayServicePolicyArgs',
    'GatewayServicePolicyArgsDict',
    'GatewayServicePolicyAppqoeArgs',
    'GatewayServicePolicyAppqoeArgsDict',
    'GatewayServicePolicyEwfArgs',
    'GatewayServicePolicyEwfArgsDict',
    'GatewayServicePolicyIdpArgs',
    'GatewayServicePolicyIdpArgsDict',
    'GatewayTunnelConfigsArgs',
    'GatewayTunnelConfigsArgsDict',
    'GatewayTunnelConfigsAutoProvisionArgs',
    'GatewayTunnelConfigsAutoProvisionArgsDict',
    'GatewayTunnelConfigsAutoProvisionLatlngArgs',
    'GatewayTunnelConfigsAutoProvisionLatlngArgsDict',
    'GatewayTunnelConfigsAutoProvisionPrimaryArgs',
    'GatewayTunnelConfigsAutoProvisionPrimaryArgsDict',
    'GatewayTunnelConfigsAutoProvisionSecondaryArgs',
    'GatewayTunnelConfigsAutoProvisionSecondaryArgsDict',
    'GatewayTunnelConfigsIkeProposalArgs',
    'GatewayTunnelConfigsIkeProposalArgsDict',
    'GatewayTunnelConfigsIpsecProposalArgs',
    'GatewayTunnelConfigsIpsecProposalArgsDict',
    'GatewayTunnelConfigsPrimaryArgs',
    'GatewayTunnelConfigsPrimaryArgsDict',
    'GatewayTunnelConfigsProbeArgs',
    'GatewayTunnelConfigsProbeArgsDict',
    'GatewayTunnelConfigsSecondaryArgs',
    'GatewayTunnelConfigsSecondaryArgsDict',
    'GatewayTunnelProviderOptionsArgs',
    'GatewayTunnelProviderOptionsArgsDict',
    'GatewayTunnelProviderOptionsJseArgs',
    'GatewayTunnelProviderOptionsJseArgsDict',
    'GatewayTunnelProviderOptionsZscalerArgs',
    'GatewayTunnelProviderOptionsZscalerArgsDict',
    'GatewayTunnelProviderOptionsZscalerSubLocationArgs',
    'GatewayTunnelProviderOptionsZscalerSubLocationArgsDict',
    'GatewayVrfConfigArgs',
    'GatewayVrfConfigArgsDict',
    'GatewayVrfInstancesArgs',
    'GatewayVrfInstancesArgsDict',
    'SwitchAclPolicyArgs',
    'SwitchAclPolicyArgsDict',
    'SwitchAclPolicyActionArgs',
    'SwitchAclPolicyActionArgsDict',
    'SwitchAclTagsArgs',
    'SwitchAclTagsArgsDict',
    'SwitchAclTagsSpecArgs',
    'SwitchAclTagsSpecArgsDict',
    'SwitchDhcpSnoopingArgs',
    'SwitchDhcpSnoopingArgsDict',
    'SwitchDhcpdConfigArgs',
    'SwitchDhcpdConfigArgsDict',
    'SwitchDhcpdConfigConfigArgs',
    'SwitchDhcpdConfigConfigArgsDict',
    'SwitchDhcpdConfigConfigFixedBindingsArgs',
    'SwitchDhcpdConfigConfigFixedBindingsArgsDict',
    'SwitchDhcpdConfigConfigOptionsArgs',
    'SwitchDhcpdConfigConfigOptionsArgsDict',
    'SwitchDhcpdConfigConfigVendorEncapulatedArgs',
    'SwitchDhcpdConfigConfigVendorEncapulatedArgsDict',
    'SwitchEvpnConfigArgs',
    'SwitchEvpnConfigArgsDict',
    'SwitchExtraRoutes6Args',
    'SwitchExtraRoutes6ArgsDict',
    'SwitchExtraRoutes6NextQualifiedArgs',
    'SwitchExtraRoutes6NextQualifiedArgsDict',
    'SwitchExtraRoutesArgs',
    'SwitchExtraRoutesArgsDict',
    'SwitchExtraRoutesNextQualifiedArgs',
    'SwitchExtraRoutesNextQualifiedArgsDict',
    'SwitchIpConfigArgs',
    'SwitchIpConfigArgsDict',
    'SwitchLocalPortConfigArgs',
    'SwitchLocalPortConfigArgsDict',
    'SwitchMistNacArgs',
    'SwitchMistNacArgsDict',
    'SwitchNetworksArgs',
    'SwitchNetworksArgsDict',
    'SwitchOobIpConfigArgs',
    'SwitchOobIpConfigArgsDict',
    'SwitchOspfAreasArgs',
    'SwitchOspfAreasArgsDict',
    'SwitchOspfAreasNetworksArgs',
    'SwitchOspfAreasNetworksArgsDict',
    'SwitchOtherIpConfigsArgs',
    'SwitchOtherIpConfigsArgsDict',
    'SwitchPortConfigArgs',
    'SwitchPortConfigArgsDict',
    'SwitchPortMirroringArgs',
    'SwitchPortMirroringArgsDict',
    'SwitchPortUsagesArgs',
    'SwitchPortUsagesArgsDict',
    'SwitchPortUsagesRuleArgs',
    'SwitchPortUsagesRuleArgsDict',
    'SwitchPortUsagesStormControlArgs',
    'SwitchPortUsagesStormControlArgsDict',
    'SwitchRadiusConfigArgs',
    'SwitchRadiusConfigArgsDict',
    'SwitchRadiusConfigAcctServerArgs',
    'SwitchRadiusConfigAcctServerArgsDict',
    'SwitchRadiusConfigAuthServerArgs',
    'SwitchRadiusConfigAuthServerArgsDict',
    'SwitchRemoteSyslogArgs',
    'SwitchRemoteSyslogArgsDict',
    'SwitchRemoteSyslogArchiveArgs',
    'SwitchRemoteSyslogArchiveArgsDict',
    'SwitchRemoteSyslogConsoleArgs',
    'SwitchRemoteSyslogConsoleArgsDict',
    'SwitchRemoteSyslogConsoleContentArgs',
    'SwitchRemoteSyslogConsoleContentArgsDict',
    'SwitchRemoteSyslogFileArgs',
    'SwitchRemoteSyslogFileArgsDict',
    'SwitchRemoteSyslogFileArchiveArgs',
    'SwitchRemoteSyslogFileArchiveArgsDict',
    'SwitchRemoteSyslogFileContentArgs',
    'SwitchRemoteSyslogFileContentArgsDict',
    'SwitchRemoteSyslogServerArgs',
    'SwitchRemoteSyslogServerArgsDict',
    'SwitchRemoteSyslogServerContentArgs',
    'SwitchRemoteSyslogServerContentArgsDict',
    'SwitchRemoteSyslogUserArgs',
    'SwitchRemoteSyslogUserArgsDict',
    'SwitchRemoteSyslogUserContentArgs',
    'SwitchRemoteSyslogUserContentArgsDict',
    'SwitchSnmpConfigArgs',
    'SwitchSnmpConfigArgsDict',
    'SwitchSnmpConfigClientListArgs',
    'SwitchSnmpConfigClientListArgsDict',
    'SwitchSnmpConfigTrapGroupArgs',
    'SwitchSnmpConfigTrapGroupArgsDict',
    'SwitchSnmpConfigV2cConfigArgs',
    'SwitchSnmpConfigV2cConfigArgsDict',
    'SwitchSnmpConfigV3ConfigArgs',
    'SwitchSnmpConfigV3ConfigArgsDict',
    'SwitchSnmpConfigV3ConfigNotifyArgs',
    'SwitchSnmpConfigV3ConfigNotifyArgsDict',
    'SwitchSnmpConfigV3ConfigNotifyFilterArgs',
    'SwitchSnmpConfigV3ConfigNotifyFilterArgsDict',
    'SwitchSnmpConfigV3ConfigNotifyFilterContentArgs',
    'SwitchSnmpConfigV3ConfigNotifyFilterContentArgsDict',
    'SwitchSnmpConfigV3ConfigTargetAddressArgs',
    'SwitchSnmpConfigV3ConfigTargetAddressArgsDict',
    'SwitchSnmpConfigV3ConfigTargetParameterArgs',
    'SwitchSnmpConfigV3ConfigTargetParameterArgsDict',
    'SwitchSnmpConfigV3ConfigUsmArgs',
    'SwitchSnmpConfigV3ConfigUsmArgsDict',
    'SwitchSnmpConfigV3ConfigUsmUserArgs',
    'SwitchSnmpConfigV3ConfigUsmUserArgsDict',
    'SwitchSnmpConfigV3ConfigVacmArgs',
    'SwitchSnmpConfigV3ConfigVacmArgsDict',
    'SwitchSnmpConfigV3ConfigVacmAccessArgs',
    'SwitchSnmpConfigV3ConfigVacmAccessArgsDict',
    'SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgs',
    'SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgsDict',
    'SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgs',
    'SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgsDict',
    'SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgs',
    'SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict',
    'SwitchSnmpConfigViewArgs',
    'SwitchSnmpConfigViewArgsDict',
    'SwitchStpConfigArgs',
    'SwitchStpConfigArgsDict',
    'SwitchSwitchMgmtArgs',
    'SwitchSwitchMgmtArgsDict',
    'SwitchSwitchMgmtLocalAccountsArgs',
    'SwitchSwitchMgmtLocalAccountsArgsDict',
    'SwitchSwitchMgmtProtectReArgs',
    'SwitchSwitchMgmtProtectReArgsDict',
    'SwitchSwitchMgmtProtectReCustomArgs',
    'SwitchSwitchMgmtProtectReCustomArgsDict',
    'SwitchSwitchMgmtTacacsArgs',
    'SwitchSwitchMgmtTacacsArgsDict',
    'SwitchSwitchMgmtTacacsAcctServerArgs',
    'SwitchSwitchMgmtTacacsAcctServerArgsDict',
    'SwitchSwitchMgmtTacacsTacplusServerArgs',
    'SwitchSwitchMgmtTacacsTacplusServerArgsDict',
    'SwitchVirtualChassisArgs',
    'SwitchVirtualChassisArgsDict',
    'SwitchVirtualChassisMemberArgs',
    'SwitchVirtualChassisMemberArgsDict',
    'SwitchVrfConfigArgs',
    'SwitchVrfConfigArgsDict',
    'SwitchVrfInstancesArgs',
    'SwitchVrfInstancesArgsDict',
    'SwitchVrfInstancesVrfExtraRoutesArgs',
    'SwitchVrfInstancesVrfExtraRoutesArgsDict',
    'SwitchVrrpConfigArgs',
    'SwitchVrrpConfigArgsDict',
    'SwitchVrrpConfigGroupsArgs',
    'SwitchVrrpConfigGroupsArgsDict',
    'BaseLatlngArgs',
    'BaseLatlngArgsDict',
]

MYPY = False

if not MYPY:
    class ApAeroscoutArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        whether to enable aeroscout config
        """
        host: NotRequired[pulumi.Input[str]]
        """
        required if enabled, aeroscout server host
        """
        locate_connected: NotRequired[pulumi.Input[bool]]
        """
        whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
elif False:
    ApAeroscoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApAeroscoutArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 locate_connected: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: whether to enable aeroscout config
        :param pulumi.Input[str] host: required if enabled, aeroscout server host
        :param pulumi.Input[bool] locate_connected: whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if locate_connected is not None:
            pulumi.set(__self__, "locate_connected", locate_connected)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable aeroscout config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        required if enabled, aeroscout server host
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="locateConnected")
    def locate_connected(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
        """
        return pulumi.get(self, "locate_connected")

    @locate_connected.setter
    def locate_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "locate_connected", value)


if not MYPY:
    class ApBleConfigArgsDict(TypedDict):
        beacon_enabled: NotRequired[pulumi.Input[bool]]
        """
        whether Mist beacons is enabled
        """
        beacon_rate: NotRequired[pulumi.Input[int]]
        """
        required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        beacon_rate_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `custom`, `default`
        """
        beam_disableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        custom_ble_packet_enabled: NotRequired[pulumi.Input[bool]]
        """
        can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        custom_ble_packet_frame: NotRequired[pulumi.Input[str]]
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        custom_ble_packet_freq_msec: NotRequired[pulumi.Input[int]]
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        eddystone_uid_adv_power: NotRequired[pulumi.Input[int]]
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        eddystone_uid_beams: NotRequired[pulumi.Input[str]]
        eddystone_uid_enabled: NotRequired[pulumi.Input[bool]]
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        eddystone_uid_freq_msec: NotRequired[pulumi.Input[int]]
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        eddystone_uid_instance: NotRequired[pulumi.Input[str]]
        """
        Eddystone-UID instance for the device
        """
        eddystone_uid_namespace: NotRequired[pulumi.Input[str]]
        """
        Eddystone-UID namespace
        """
        eddystone_url_adv_power: NotRequired[pulumi.Input[int]]
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        eddystone_url_beams: NotRequired[pulumi.Input[str]]
        eddystone_url_enabled: NotRequired[pulumi.Input[bool]]
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        eddystone_url_freq_msec: NotRequired[pulumi.Input[int]]
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        eddystone_url_url: NotRequired[pulumi.Input[str]]
        """
        URL pointed by Eddystone-URL beacon
        """
        ibeacon_adv_power: NotRequired[pulumi.Input[int]]
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        ibeacon_beams: NotRequired[pulumi.Input[str]]
        ibeacon_enabled: NotRequired[pulumi.Input[bool]]
        """
        can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        ibeacon_freq_msec: NotRequired[pulumi.Input[int]]
        """
        Frequency (msec) of data emmit for iBeacon
        """
        ibeacon_major: NotRequired[pulumi.Input[int]]
        """
        Major number for iBeacon
        """
        ibeacon_minor: NotRequired[pulumi.Input[int]]
        """
        Minor number for iBeacon
        """
        ibeacon_uuid: NotRequired[pulumi.Input[str]]
        """
        optional, if not specified, the same UUID as the beacon will be used
        """
        power: NotRequired[pulumi.Input[int]]
        """
        required if `power_mode`==`custom`
        """
        power_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `custom`, `default`
        """
elif False:
    ApBleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApBleConfigArgs:
    def __init__(__self__, *,
                 beacon_enabled: Optional[pulumi.Input[bool]] = None,
                 beacon_rate: Optional[pulumi.Input[int]] = None,
                 beacon_rate_mode: Optional[pulumi.Input[str]] = None,
                 beam_disableds: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 custom_ble_packet_enabled: Optional[pulumi.Input[bool]] = None,
                 custom_ble_packet_frame: Optional[pulumi.Input[str]] = None,
                 custom_ble_packet_freq_msec: Optional[pulumi.Input[int]] = None,
                 eddystone_uid_adv_power: Optional[pulumi.Input[int]] = None,
                 eddystone_uid_beams: Optional[pulumi.Input[str]] = None,
                 eddystone_uid_enabled: Optional[pulumi.Input[bool]] = None,
                 eddystone_uid_freq_msec: Optional[pulumi.Input[int]] = None,
                 eddystone_uid_instance: Optional[pulumi.Input[str]] = None,
                 eddystone_uid_namespace: Optional[pulumi.Input[str]] = None,
                 eddystone_url_adv_power: Optional[pulumi.Input[int]] = None,
                 eddystone_url_beams: Optional[pulumi.Input[str]] = None,
                 eddystone_url_enabled: Optional[pulumi.Input[bool]] = None,
                 eddystone_url_freq_msec: Optional[pulumi.Input[int]] = None,
                 eddystone_url_url: Optional[pulumi.Input[str]] = None,
                 ibeacon_adv_power: Optional[pulumi.Input[int]] = None,
                 ibeacon_beams: Optional[pulumi.Input[str]] = None,
                 ibeacon_enabled: Optional[pulumi.Input[bool]] = None,
                 ibeacon_freq_msec: Optional[pulumi.Input[int]] = None,
                 ibeacon_major: Optional[pulumi.Input[int]] = None,
                 ibeacon_minor: Optional[pulumi.Input[int]] = None,
                 ibeacon_uuid: Optional[pulumi.Input[str]] = None,
                 power: Optional[pulumi.Input[int]] = None,
                 power_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] beacon_enabled: whether Mist beacons is enabled
        :param pulumi.Input[int] beacon_rate: required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        :param pulumi.Input[str] beacon_rate_mode: enum: `custom`, `default`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] beam_disableds: list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        :param pulumi.Input[bool] custom_ble_packet_enabled: can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        :param pulumi.Input[str] custom_ble_packet_frame: The custom frame to be sent out in this beacon. The frame must be a hexstring
        :param pulumi.Input[int] custom_ble_packet_freq_msec: Frequency (msec) of data emitted by custom ble beacon
        :param pulumi.Input[int] eddystone_uid_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[bool] eddystone_uid_enabled: only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        :param pulumi.Input[int] eddystone_uid_freq_msec: Frequency (msec) of data emmit by Eddystone-UID beacon
        :param pulumi.Input[str] eddystone_uid_instance: Eddystone-UID instance for the device
        :param pulumi.Input[str] eddystone_uid_namespace: Eddystone-UID namespace
        :param pulumi.Input[int] eddystone_url_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[bool] eddystone_url_enabled: only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        :param pulumi.Input[int] eddystone_url_freq_msec: Frequency (msec) of data emit by Eddystone-UID beacon
        :param pulumi.Input[str] eddystone_url_url: URL pointed by Eddystone-URL beacon
        :param pulumi.Input[int] ibeacon_adv_power: advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        :param pulumi.Input[bool] ibeacon_enabled: can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        :param pulumi.Input[int] ibeacon_freq_msec: Frequency (msec) of data emmit for iBeacon
        :param pulumi.Input[int] ibeacon_major: Major number for iBeacon
        :param pulumi.Input[int] ibeacon_minor: Minor number for iBeacon
        :param pulumi.Input[str] ibeacon_uuid: optional, if not specified, the same UUID as the beacon will be used
        :param pulumi.Input[int] power: required if `power_mode`==`custom`
        :param pulumi.Input[str] power_mode: enum: `custom`, `default`
        """
        if beacon_enabled is not None:
            pulumi.set(__self__, "beacon_enabled", beacon_enabled)
        if beacon_rate is not None:
            pulumi.set(__self__, "beacon_rate", beacon_rate)
        if beacon_rate_mode is not None:
            pulumi.set(__self__, "beacon_rate_mode", beacon_rate_mode)
        if beam_disableds is not None:
            pulumi.set(__self__, "beam_disableds", beam_disableds)
        if custom_ble_packet_enabled is not None:
            pulumi.set(__self__, "custom_ble_packet_enabled", custom_ble_packet_enabled)
        if custom_ble_packet_frame is not None:
            pulumi.set(__self__, "custom_ble_packet_frame", custom_ble_packet_frame)
        if custom_ble_packet_freq_msec is not None:
            pulumi.set(__self__, "custom_ble_packet_freq_msec", custom_ble_packet_freq_msec)
        if eddystone_uid_adv_power is not None:
            pulumi.set(__self__, "eddystone_uid_adv_power", eddystone_uid_adv_power)
        if eddystone_uid_beams is not None:
            pulumi.set(__self__, "eddystone_uid_beams", eddystone_uid_beams)
        if eddystone_uid_enabled is not None:
            pulumi.set(__self__, "eddystone_uid_enabled", eddystone_uid_enabled)
        if eddystone_uid_freq_msec is not None:
            pulumi.set(__self__, "eddystone_uid_freq_msec", eddystone_uid_freq_msec)
        if eddystone_uid_instance is not None:
            pulumi.set(__self__, "eddystone_uid_instance", eddystone_uid_instance)
        if eddystone_uid_namespace is not None:
            pulumi.set(__self__, "eddystone_uid_namespace", eddystone_uid_namespace)
        if eddystone_url_adv_power is not None:
            pulumi.set(__self__, "eddystone_url_adv_power", eddystone_url_adv_power)
        if eddystone_url_beams is not None:
            pulumi.set(__self__, "eddystone_url_beams", eddystone_url_beams)
        if eddystone_url_enabled is not None:
            pulumi.set(__self__, "eddystone_url_enabled", eddystone_url_enabled)
        if eddystone_url_freq_msec is not None:
            pulumi.set(__self__, "eddystone_url_freq_msec", eddystone_url_freq_msec)
        if eddystone_url_url is not None:
            pulumi.set(__self__, "eddystone_url_url", eddystone_url_url)
        if ibeacon_adv_power is not None:
            pulumi.set(__self__, "ibeacon_adv_power", ibeacon_adv_power)
        if ibeacon_beams is not None:
            pulumi.set(__self__, "ibeacon_beams", ibeacon_beams)
        if ibeacon_enabled is not None:
            pulumi.set(__self__, "ibeacon_enabled", ibeacon_enabled)
        if ibeacon_freq_msec is not None:
            pulumi.set(__self__, "ibeacon_freq_msec", ibeacon_freq_msec)
        if ibeacon_major is not None:
            pulumi.set(__self__, "ibeacon_major", ibeacon_major)
        if ibeacon_minor is not None:
            pulumi.set(__self__, "ibeacon_minor", ibeacon_minor)
        if ibeacon_uuid is not None:
            pulumi.set(__self__, "ibeacon_uuid", ibeacon_uuid)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)

    @property
    @pulumi.getter(name="beaconEnabled")
    def beacon_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether Mist beacons is enabled
        """
        return pulumi.get(self, "beacon_enabled")

    @beacon_enabled.setter
    def beacon_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "beacon_enabled", value)

    @property
    @pulumi.getter(name="beaconRate")
    def beacon_rate(self) -> Optional[pulumi.Input[int]]:
        """
        required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
        """
        return pulumi.get(self, "beacon_rate")

    @beacon_rate.setter
    def beacon_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "beacon_rate", value)

    @property
    @pulumi.getter(name="beaconRateMode")
    def beacon_rate_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "beacon_rate_mode")

    @beacon_rate_mode.setter
    def beacon_rate_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "beacon_rate_mode", value)

    @property
    @pulumi.getter(name="beamDisableds")
    def beam_disableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
        """
        return pulumi.get(self, "beam_disableds")

    @beam_disableds.setter
    def beam_disableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "beam_disableds", value)

    @property
    @pulumi.getter(name="customBlePacketEnabled")
    def custom_ble_packet_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        can be enabled if `beacon_enabled`==`true`, whether to send custom packet
        """
        return pulumi.get(self, "custom_ble_packet_enabled")

    @custom_ble_packet_enabled.setter
    def custom_ble_packet_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_ble_packet_enabled", value)

    @property
    @pulumi.getter(name="customBlePacketFrame")
    def custom_ble_packet_frame(self) -> Optional[pulumi.Input[str]]:
        """
        The custom frame to be sent out in this beacon. The frame must be a hexstring
        """
        return pulumi.get(self, "custom_ble_packet_frame")

    @custom_ble_packet_frame.setter
    def custom_ble_packet_frame(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_ble_packet_frame", value)

    @property
    @pulumi.getter(name="customBlePacketFreqMsec")
    def custom_ble_packet_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emitted by custom ble beacon
        """
        return pulumi.get(self, "custom_ble_packet_freq_msec")

    @custom_ble_packet_freq_msec.setter
    def custom_ble_packet_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_ble_packet_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUidAdvPower")
    def eddystone_uid_adv_power(self) -> Optional[pulumi.Input[int]]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_uid_adv_power")

    @eddystone_uid_adv_power.setter
    def eddystone_uid_adv_power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_uid_adv_power", value)

    @property
    @pulumi.getter(name="eddystoneUidBeams")
    def eddystone_uid_beams(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "eddystone_uid_beams")

    @eddystone_uid_beams.setter
    def eddystone_uid_beams(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_uid_beams", value)

    @property
    @pulumi.getter(name="eddystoneUidEnabled")
    def eddystone_uid_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
        """
        return pulumi.get(self, "eddystone_uid_enabled")

    @eddystone_uid_enabled.setter
    def eddystone_uid_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eddystone_uid_enabled", value)

    @property
    @pulumi.getter(name="eddystoneUidFreqMsec")
    def eddystone_uid_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emmit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_uid_freq_msec")

    @eddystone_uid_freq_msec.setter
    def eddystone_uid_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_uid_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUidInstance")
    def eddystone_uid_instance(self) -> Optional[pulumi.Input[str]]:
        """
        Eddystone-UID instance for the device
        """
        return pulumi.get(self, "eddystone_uid_instance")

    @eddystone_uid_instance.setter
    def eddystone_uid_instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_uid_instance", value)

    @property
    @pulumi.getter(name="eddystoneUidNamespace")
    def eddystone_uid_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Eddystone-UID namespace
        """
        return pulumi.get(self, "eddystone_uid_namespace")

    @eddystone_uid_namespace.setter
    def eddystone_uid_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_uid_namespace", value)

    @property
    @pulumi.getter(name="eddystoneUrlAdvPower")
    def eddystone_url_adv_power(self) -> Optional[pulumi.Input[int]]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "eddystone_url_adv_power")

    @eddystone_url_adv_power.setter
    def eddystone_url_adv_power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_url_adv_power", value)

    @property
    @pulumi.getter(name="eddystoneUrlBeams")
    def eddystone_url_beams(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "eddystone_url_beams")

    @eddystone_url_beams.setter
    def eddystone_url_beams(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_url_beams", value)

    @property
    @pulumi.getter(name="eddystoneUrlEnabled")
    def eddystone_url_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
        """
        return pulumi.get(self, "eddystone_url_enabled")

    @eddystone_url_enabled.setter
    def eddystone_url_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eddystone_url_enabled", value)

    @property
    @pulumi.getter(name="eddystoneUrlFreqMsec")
    def eddystone_url_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emit by Eddystone-UID beacon
        """
        return pulumi.get(self, "eddystone_url_freq_msec")

    @eddystone_url_freq_msec.setter
    def eddystone_url_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "eddystone_url_freq_msec", value)

    @property
    @pulumi.getter(name="eddystoneUrlUrl")
    def eddystone_url_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL pointed by Eddystone-URL beacon
        """
        return pulumi.get(self, "eddystone_url_url")

    @eddystone_url_url.setter
    def eddystone_url_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eddystone_url_url", value)

    @property
    @pulumi.getter(name="ibeaconAdvPower")
    def ibeacon_adv_power(self) -> Optional[pulumi.Input[int]]:
        """
        advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
        """
        return pulumi.get(self, "ibeacon_adv_power")

    @ibeacon_adv_power.setter
    def ibeacon_adv_power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_adv_power", value)

    @property
    @pulumi.getter(name="ibeaconBeams")
    def ibeacon_beams(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ibeacon_beams")

    @ibeacon_beams.setter
    def ibeacon_beams(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ibeacon_beams", value)

    @property
    @pulumi.getter(name="ibeaconEnabled")
    def ibeacon_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
        """
        return pulumi.get(self, "ibeacon_enabled")

    @ibeacon_enabled.setter
    def ibeacon_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ibeacon_enabled", value)

    @property
    @pulumi.getter(name="ibeaconFreqMsec")
    def ibeacon_freq_msec(self) -> Optional[pulumi.Input[int]]:
        """
        Frequency (msec) of data emmit for iBeacon
        """
        return pulumi.get(self, "ibeacon_freq_msec")

    @ibeacon_freq_msec.setter
    def ibeacon_freq_msec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_freq_msec", value)

    @property
    @pulumi.getter(name="ibeaconMajor")
    def ibeacon_major(self) -> Optional[pulumi.Input[int]]:
        """
        Major number for iBeacon
        """
        return pulumi.get(self, "ibeacon_major")

    @ibeacon_major.setter
    def ibeacon_major(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_major", value)

    @property
    @pulumi.getter(name="ibeaconMinor")
    def ibeacon_minor(self) -> Optional[pulumi.Input[int]]:
        """
        Minor number for iBeacon
        """
        return pulumi.get(self, "ibeacon_minor")

    @ibeacon_minor.setter
    def ibeacon_minor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ibeacon_minor", value)

    @property
    @pulumi.getter(name="ibeaconUuid")
    def ibeacon_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        optional, if not specified, the same UUID as the beacon will be used
        """
        return pulumi.get(self, "ibeacon_uuid")

    @ibeacon_uuid.setter
    def ibeacon_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ibeacon_uuid", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[int]]:
        """
        required if `power_mode`==`custom`
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `custom`, `default`
        """
        return pulumi.get(self, "power_mode")

    @power_mode.setter
    def power_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "power_mode", value)


if not MYPY:
    class ApCentrakArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ApCentrakArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApCentrakArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApClientBridgeArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['ApClientBridgeAuthArgsDict']]
        enabled: NotRequired[pulumi.Input[bool]]
        """
        when acted as client bridge:
          * only 5G radio can be used
          * will not serve as AP on any radios
        """
        ssid: NotRequired[pulumi.Input[str]]
elif False:
    ApClientBridgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApClientBridgeArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['ApClientBridgeAuthArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 ssid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: when acted as client bridge:
                 * only 5G radio can be used
                 * will not serve as AP on any radios
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ssid is not None:
            pulumi.set(__self__, "ssid", ssid)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['ApClientBridgeAuthArgs']]:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['ApClientBridgeAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        when acted as client bridge:
          * only 5G radio can be used
          * will not serve as AP on any radios
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def ssid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssid")

    @ssid.setter
    def ssid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssid", value)


if not MYPY:
    class ApClientBridgeAuthArgsDict(TypedDict):
        psk: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
        """
elif False:
    ApClientBridgeAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApClientBridgeAuthArgs:
    def __init__(__self__, *,
                 psk: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
        """
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psk", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApEslConfigArgsDict(TypedDict):
        cacert: NotRequired[pulumi.Input[str]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        channel: NotRequired[pulumi.Input[int]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        usb_config is ignored if esl_config enabled
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        note: ble_config will be ingored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        """
        verify_cert: NotRequired[pulumi.Input[bool]]
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        vlan_id: NotRequired[pulumi.Input[int]]
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
elif False:
    ApEslConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApEslConfigArgs:
    def __init__(__self__, *,
                 cacert: Optional[pulumi.Input[str]] = None,
                 channel: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 verify_cert: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cacert: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[int] channel: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[bool] enabled: usb_config is ignored if esl_config enabled
        :param pulumi.Input[str] host: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[int] port: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[str] type: note: ble_config will be ingored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        :param pulumi.Input[bool] verify_cert: Only if `type`==`imagotag` or `type`==`native`
        :param pulumi.Input[int] vlan_id: Only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cacert", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        usb_config is ignored if esl_config enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        note: ble_config will be ingored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `type`==`imagotag` or `type`==`native`
        """
        return pulumi.get(self, "verify_cert")

    @verify_cert.setter
    def verify_cert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify_cert", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class ApIpConfigArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`static`
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        required if `type`==`static`
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        required if `type`==`static`
        """
        gateway6: NotRequired[pulumi.Input[str]]
        ip: NotRequired[pulumi.Input[str]]
        """
        required if `type`==`static`
        """
        ip6: NotRequired[pulumi.Input[str]]
        mtu: NotRequired[pulumi.Input[int]]
        netmask: NotRequired[pulumi.Input[str]]
        """
        required if `type`==`static`
        """
        netmask6: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
        type6: NotRequired[pulumi.Input[str]]
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        vlan_id: NotRequired[pulumi.Input[int]]
        """
        management vlan id, default is 1 (untagged)
        """
elif False:
    ApIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApIpConfigArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 gateway6: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 ip6: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 netmask6: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 type6: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns: if `type`==`static`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_suffixes: required if `type`==`static`
        :param pulumi.Input[str] gateway: required if `type`==`static`
        :param pulumi.Input[str] ip: required if `type`==`static`
        :param pulumi.Input[str] netmask: required if `type`==`static`
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        :param pulumi.Input[str] type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        :param pulumi.Input[int] vlan_id: management vlan id, default is 1 (untagged)
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`static`
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        required if `type`==`static`
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        required if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def gateway6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gateway6")

    @gateway6.setter
    def gateway6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway6", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def ip6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip6")

    @ip6.setter
    def ip6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip6", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        required if `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def netmask6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "netmask6")

    @netmask6.setter
    def netmask6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask6", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type6", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        management vlan id, default is 1 (untagged)
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class ApLedArgsDict(TypedDict):
        brightness: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ApLedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApLedArgs:
    def __init__(__self__, *,
                 brightness: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if brightness is not None:
            pulumi.set(__self__, "brightness", brightness)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def brightness(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "brightness")

    @brightness.setter
    def brightness(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "brightness", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApMeshArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        whether mesh is enabled on this AP
        """
        group: NotRequired[pulumi.Input[int]]
        """
        mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        """
        role: NotRequired[pulumi.Input[str]]
        """
        enum: `base`, `remote`
        """
elif False:
    ApMeshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApMeshArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 group: Optional[pulumi.Input[int]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: whether mesh is enabled on this AP
        :param pulumi.Input[int] group: mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        :param pulumi.Input[str] role: enum: `base`, `remote`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether mesh is enabled on this AP
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[int]]:
        """
        mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `base`, `remote`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ApPwrConfigArgsDict(TypedDict):
        base: NotRequired[pulumi.Input[int]]
        """
        additional power to request during negotiating with PSE over PoE, in mW
        """
        prefer_usb_over_wifi: NotRequired[pulumi.Input[bool]]
        """
        whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
        """
elif False:
    ApPwrConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApPwrConfigArgs:
    def __init__(__self__, *,
                 base: Optional[pulumi.Input[int]] = None,
                 prefer_usb_over_wifi: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] base: additional power to request during negotiating with PSE over PoE, in mW
        :param pulumi.Input[bool] prefer_usb_over_wifi: whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
        """
        if base is not None:
            pulumi.set(__self__, "base", base)
        if prefer_usb_over_wifi is not None:
            pulumi.set(__self__, "prefer_usb_over_wifi", prefer_usb_over_wifi)

    @property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[int]]:
        """
        additional power to request during negotiating with PSE over PoE, in mW
        """
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base", value)

    @property
    @pulumi.getter(name="preferUsbOverWifi")
    def prefer_usb_over_wifi(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
        """
        return pulumi.get(self, "prefer_usb_over_wifi")

    @prefer_usb_over_wifi.setter
    def prefer_usb_over_wifi(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prefer_usb_over_wifi", value)


if not MYPY:
    class ApRadioConfigArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[bool]]
        ant_gain24: NotRequired[pulumi.Input[int]]
        """
        antenna gain for 2.4G - for models with external antenna only
        """
        ant_gain5: NotRequired[pulumi.Input[int]]
        """
        antenna gain for 5G - for models with external antenna only
        """
        ant_gain6: NotRequired[pulumi.Input[int]]
        """
        antenna gain for 6G - for models with external antenna only
        """
        antenna_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        band24: NotRequired[pulumi.Input['ApRadioConfigBand24ArgsDict']]
        """
        Radio Band AP settings
        """
        band24_usage: NotRequired[pulumi.Input[str]]
        """
        enum: `24`, `5`, `6`, `auto`
        """
        band5: NotRequired[pulumi.Input['ApRadioConfigBand5ArgsDict']]
        """
        Radio Band AP settings
        """
        band5_on24_radio: NotRequired[pulumi.Input['ApRadioConfigBand5On24RadioArgsDict']]
        """
        Radio Band AP settings
        """
        band6: NotRequired[pulumi.Input['ApRadioConfigBand6ArgsDict']]
        """
        Radio Band AP settings
        """
        indoor_use: NotRequired[pulumi.Input[bool]]
        """
        to make an outdoor operate indoor.
        for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        """
        scanning_enabled: NotRequired[pulumi.Input[bool]]
        """
        whether scanning radio is enabled
        """
elif False:
    ApRadioConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApRadioConfigArgs:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[bool]] = None,
                 ant_gain24: Optional[pulumi.Input[int]] = None,
                 ant_gain5: Optional[pulumi.Input[int]] = None,
                 ant_gain6: Optional[pulumi.Input[int]] = None,
                 antenna_mode: Optional[pulumi.Input[str]] = None,
                 band24: Optional[pulumi.Input['ApRadioConfigBand24Args']] = None,
                 band24_usage: Optional[pulumi.Input[str]] = None,
                 band5: Optional[pulumi.Input['ApRadioConfigBand5Args']] = None,
                 band5_on24_radio: Optional[pulumi.Input['ApRadioConfigBand5On24RadioArgs']] = None,
                 band6: Optional[pulumi.Input['ApRadioConfigBand6Args']] = None,
                 indoor_use: Optional[pulumi.Input[bool]] = None,
                 scanning_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] ant_gain24: antenna gain for 2.4G - for models with external antenna only
        :param pulumi.Input[int] ant_gain5: antenna gain for 5G - for models with external antenna only
        :param pulumi.Input[int] ant_gain6: antenna gain for 6G - for models with external antenna only
        :param pulumi.Input[str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input['ApRadioConfigBand24Args'] band24: Radio Band AP settings
        :param pulumi.Input[str] band24_usage: enum: `24`, `5`, `6`, `auto`
        :param pulumi.Input['ApRadioConfigBand5Args'] band5: Radio Band AP settings
        :param pulumi.Input['ApRadioConfigBand5On24RadioArgs'] band5_on24_radio: Radio Band AP settings
        :param pulumi.Input['ApRadioConfigBand6Args'] band6: Radio Band AP settings
        :param pulumi.Input[bool] indoor_use: to make an outdoor operate indoor.
               for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        :param pulumi.Input[bool] scanning_enabled: whether scanning radio is enabled
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain24 is not None:
            pulumi.set(__self__, "ant_gain24", ant_gain24)
        if ant_gain5 is not None:
            pulumi.set(__self__, "ant_gain5", ant_gain5)
        if ant_gain6 is not None:
            pulumi.set(__self__, "ant_gain6", ant_gain6)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if band24 is not None:
            pulumi.set(__self__, "band24", band24)
        if band24_usage is not None:
            pulumi.set(__self__, "band24_usage", band24_usage)
        if band5 is not None:
            pulumi.set(__self__, "band5", band5)
        if band5_on24_radio is not None:
            pulumi.set(__self__, "band5_on24_radio", band5_on24_radio)
        if band6 is not None:
            pulumi.set(__self__, "band6", band6)
        if indoor_use is not None:
            pulumi.set(__self__, "indoor_use", indoor_use)
        if scanning_enabled is not None:
            pulumi.set(__self__, "scanning_enabled", scanning_enabled)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain24")
    def ant_gain24(self) -> Optional[pulumi.Input[int]]:
        """
        antenna gain for 2.4G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain24")

    @ant_gain24.setter
    def ant_gain24(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain24", value)

    @property
    @pulumi.getter(name="antGain5")
    def ant_gain5(self) -> Optional[pulumi.Input[int]]:
        """
        antenna gain for 5G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain5")

    @ant_gain5.setter
    def ant_gain5(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain5", value)

    @property
    @pulumi.getter(name="antGain6")
    def ant_gain6(self) -> Optional[pulumi.Input[int]]:
        """
        antenna gain for 6G - for models with external antenna only
        """
        return pulumi.get(self, "ant_gain6")

    @ant_gain6.setter
    def ant_gain6(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain6", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def band24(self) -> Optional[pulumi.Input['ApRadioConfigBand24Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band24")

    @band24.setter
    def band24(self, value: Optional[pulumi.Input['ApRadioConfigBand24Args']]):
        pulumi.set(self, "band24", value)

    @property
    @pulumi.getter(name="band24Usage")
    def band24_usage(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `24`, `5`, `6`, `auto`
        """
        return pulumi.get(self, "band24_usage")

    @band24_usage.setter
    def band24_usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "band24_usage", value)

    @property
    @pulumi.getter
    def band5(self) -> Optional[pulumi.Input['ApRadioConfigBand5Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5")

    @band5.setter
    def band5(self, value: Optional[pulumi.Input['ApRadioConfigBand5Args']]):
        pulumi.set(self, "band5", value)

    @property
    @pulumi.getter(name="band5On24Radio")
    def band5_on24_radio(self) -> Optional[pulumi.Input['ApRadioConfigBand5On24RadioArgs']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band5_on24_radio")

    @band5_on24_radio.setter
    def band5_on24_radio(self, value: Optional[pulumi.Input['ApRadioConfigBand5On24RadioArgs']]):
        pulumi.set(self, "band5_on24_radio", value)

    @property
    @pulumi.getter
    def band6(self) -> Optional[pulumi.Input['ApRadioConfigBand6Args']]:
        """
        Radio Band AP settings
        """
        return pulumi.get(self, "band6")

    @band6.setter
    def band6(self, value: Optional[pulumi.Input['ApRadioConfigBand6Args']]):
        pulumi.set(self, "band6", value)

    @property
    @pulumi.getter(name="indoorUse")
    def indoor_use(self) -> Optional[pulumi.Input[bool]]:
        """
        to make an outdoor operate indoor.
        for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
        """
        return pulumi.get(self, "indoor_use")

    @indoor_use.setter
    def indoor_use(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "indoor_use", value)

    @property
    @pulumi.getter(name="scanningEnabled")
    def scanning_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether scanning radio is enabled
        """
        return pulumi.get(self, "scanning_enabled")

    @scanning_enabled.setter
    def scanning_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scanning_enabled", value)


if not MYPY:
    class ApRadioConfigBand24ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[bool]]
        ant_gain: NotRequired[pulumi.Input[int]]
        antenna_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[int]]
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        channel: NotRequired[pulumi.Input[int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        whether to disable the radio
        """
        power: NotRequired[pulumi.Input[int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        power_max: NotRequired[pulumi.Input[int]]
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[int]]
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    ApRadioConfigBand24ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApRadioConfigBand24Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[bool]] = None,
                 ant_gain: Optional[pulumi.Input[int]] = None,
                 antenna_mode: Optional[pulumi.Input[str]] = None,
                 bandwidth: Optional[pulumi.Input[int]] = None,
                 channel: Optional[pulumi.Input[int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 power: Optional[pulumi.Input[int]] = None,
                 power_max: Optional[pulumi.Input[int]] = None,
                 power_min: Optional[pulumi.Input[int]] = None,
                 preamble: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[int] bandwidth: channel width for the 2.4GHz band. enum: `20`, `40`
        :param pulumi.Input[int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[bool] disabled: whether to disable the radio
        :param pulumi.Input[int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param pulumi.Input[int] power_max: when power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[int] power_min: when power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        channel width for the 2.4GHz band. enum: `20`, `40`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class ApRadioConfigBand5ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[bool]]
        ant_gain: NotRequired[pulumi.Input[int]]
        antenna_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channel: NotRequired[pulumi.Input[int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        whether to disable the radio
        """
        power: NotRequired[pulumi.Input[int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        power_max: NotRequired[pulumi.Input[int]]
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[int]]
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    ApRadioConfigBand5ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApRadioConfigBand5Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[bool]] = None,
                 ant_gain: Optional[pulumi.Input[int]] = None,
                 antenna_mode: Optional[pulumi.Input[str]] = None,
                 bandwidth: Optional[pulumi.Input[int]] = None,
                 channel: Optional[pulumi.Input[int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 power: Optional[pulumi.Input[int]] = None,
                 power_max: Optional[pulumi.Input[int]] = None,
                 power_min: Optional[pulumi.Input[int]] = None,
                 preamble: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[bool] disabled: whether to disable the radio
        :param pulumi.Input[int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param pulumi.Input[int] power_max: when power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[int] power_min: when power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class ApRadioConfigBand5On24RadioArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[bool]]
        ant_gain: NotRequired[pulumi.Input[int]]
        antenna_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[int]]
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        channel: NotRequired[pulumi.Input[int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        whether to disable the radio
        """
        power: NotRequired[pulumi.Input[int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        power_max: NotRequired[pulumi.Input[int]]
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[int]]
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `long`, `short`
        """
elif False:
    ApRadioConfigBand5On24RadioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApRadioConfigBand5On24RadioArgs:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[bool]] = None,
                 ant_gain: Optional[pulumi.Input[int]] = None,
                 antenna_mode: Optional[pulumi.Input[str]] = None,
                 bandwidth: Optional[pulumi.Input[int]] = None,
                 channel: Optional[pulumi.Input[int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 power: Optional[pulumi.Input[int]] = None,
                 power_max: Optional[pulumi.Input[int]] = None,
                 power_min: Optional[pulumi.Input[int]] = None,
                 preamble: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[int] bandwidth: channel width for the 5GHz band. enum: `20`, `40`, `80`
        :param pulumi.Input[int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[bool] disabled: whether to disable the radio
        :param pulumi.Input[int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param pulumi.Input[int] power_max: when power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[int] power_min: when power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[str] preamble: enum: `auto`, `long`, `short`
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        channel width for the 5GHz band. enum: `20`, `40`, `80`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preamble", value)


if not MYPY:
    class ApRadioConfigBand6ArgsDict(TypedDict):
        allow_rrm_disable: NotRequired[pulumi.Input[bool]]
        ant_gain: NotRequired[pulumi.Input[int]]
        antenna_mode: NotRequired[pulumi.Input[str]]
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        bandwidth: NotRequired[pulumi.Input[int]]
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        channel: NotRequired[pulumi.Input[int]]
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        whether to disable the radio
        """
        power: NotRequired[pulumi.Input[int]]
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        power_max: NotRequired[pulumi.Input[int]]
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        power_min: NotRequired[pulumi.Input[int]]
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        preamble: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `long`, `short`
        """
        standard_power: NotRequired[pulumi.Input[bool]]
        """
        for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
        """
elif False:
    ApRadioConfigBand6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApRadioConfigBand6Args:
    def __init__(__self__, *,
                 allow_rrm_disable: Optional[pulumi.Input[bool]] = None,
                 ant_gain: Optional[pulumi.Input[int]] = None,
                 antenna_mode: Optional[pulumi.Input[str]] = None,
                 bandwidth: Optional[pulumi.Input[int]] = None,
                 channel: Optional[pulumi.Input[int]] = None,
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 power: Optional[pulumi.Input[int]] = None,
                 power_max: Optional[pulumi.Input[int]] = None,
                 power_min: Optional[pulumi.Input[int]] = None,
                 preamble: Optional[pulumi.Input[str]] = None,
                 standard_power: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] antenna_mode: enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        :param pulumi.Input[int] bandwidth: channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        :param pulumi.Input[int] channel: For Device. (primary) channel for the band, 0 means using the Site Setting
        :param pulumi.Input[Sequence[pulumi.Input[int]]] channels: For RFTemplates. List of channels, null or empty array means auto
        :param pulumi.Input[bool] disabled: whether to disable the radio
        :param pulumi.Input[int] power: TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        :param pulumi.Input[int] power_max: when power=0, max tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[int] power_min: when power=0, min tx power to use, HW-specific values will be used if not set
        :param pulumi.Input[str] preamble: enum: `auto`, `long`, `short`
        :param pulumi.Input[bool] standard_power: for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
        """
        if allow_rrm_disable is not None:
            pulumi.set(__self__, "allow_rrm_disable", allow_rrm_disable)
        if ant_gain is not None:
            pulumi.set(__self__, "ant_gain", ant_gain)
        if antenna_mode is not None:
            pulumi.set(__self__, "antenna_mode", antenna_mode)
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if power_max is not None:
            pulumi.set(__self__, "power_max", power_max)
        if power_min is not None:
            pulumi.set(__self__, "power_min", power_min)
        if preamble is not None:
            pulumi.set(__self__, "preamble", preamble)
        if standard_power is not None:
            pulumi.set(__self__, "standard_power", standard_power)

    @property
    @pulumi.getter(name="allowRrmDisable")
    def allow_rrm_disable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_rrm_disable")

    @allow_rrm_disable.setter
    def allow_rrm_disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rrm_disable", value)

    @property
    @pulumi.getter(name="antGain")
    def ant_gain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ant_gain")

    @ant_gain.setter
    def ant_gain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ant_gain", value)

    @property
    @pulumi.getter(name="antennaMode")
    def antenna_mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
        """
        return pulumi.get(self, "antenna_mode")

    @antenna_mode.setter
    def antenna_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "antenna_mode", value)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[int]]:
        """
        channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[int]]:
        """
        For Device. (primary) channel for the band, 0 means using the Site Setting
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        For RFTemplates. List of channels, null or empty array means auto
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable the radio
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def power(self) -> Optional[pulumi.Input[int]]:
        """
        TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
        """
        return pulumi.get(self, "power")

    @power.setter
    def power(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power", value)

    @property
    @pulumi.getter(name="powerMax")
    def power_max(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, max tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_max")

    @power_max.setter
    def power_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_max", value)

    @property
    @pulumi.getter(name="powerMin")
    def power_min(self) -> Optional[pulumi.Input[int]]:
        """
        when power=0, min tx power to use, HW-specific values will be used if not set
        """
        return pulumi.get(self, "power_min")

    @power_min.setter
    def power_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "power_min", value)

    @property
    @pulumi.getter
    def preamble(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `long`, `short`
        """
        return pulumi.get(self, "preamble")

    @preamble.setter
    def preamble(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preamble", value)

    @property
    @pulumi.getter(name="standardPower")
    def standard_power(self) -> Optional[pulumi.Input[bool]]:
        """
        for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
        """
        return pulumi.get(self, "standard_power")

    @standard_power.setter
    def standard_power(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "standard_power", value)


if not MYPY:
    class ApUplinkPortConfigArgsDict(TypedDict):
        dot1x: NotRequired[pulumi.Input[bool]]
        """
        Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        keep_wlans_up_if_down: NotRequired[pulumi.Input[bool]]
        """
        by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
elif False:
    ApUplinkPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApUplinkPortConfigArgs:
    def __init__(__self__, *,
                 dot1x: Optional[pulumi.Input[bool]] = None,
                 keep_wlans_up_if_down: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] dot1x: Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        :param pulumi.Input[bool] keep_wlans_up_if_down: by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        if dot1x is not None:
            pulumi.set(__self__, "dot1x", dot1x)
        if keep_wlans_up_if_down is not None:
            pulumi.set(__self__, "keep_wlans_up_if_down", keep_wlans_up_if_down)

    @property
    @pulumi.getter
    def dot1x(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
        """
        return pulumi.get(self, "dot1x")

    @dot1x.setter
    def dot1x(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dot1x", value)

    @property
    @pulumi.getter(name="keepWlansUpIfDown")
    def keep_wlans_up_if_down(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
        """
        return pulumi.get(self, "keep_wlans_up_if_down")

    @keep_wlans_up_if_down.setter
    def keep_wlans_up_if_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_wlans_up_if_down", value)


if not MYPY:
    class ApUsbConfigArgsDict(TypedDict):
        cacert: NotRequired[pulumi.Input[str]]
        """
        only if `type`==`imagotag`
        """
        channel: NotRequired[pulumi.Input[int]]
        """
        only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        whether to enable any usb config
        """
        host: NotRequired[pulumi.Input[str]]
        """
        only if `type`==`imagotag`
        """
        port: NotRequired[pulumi.Input[int]]
        """
        only if `type`==`imagotag`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        usb config type. enum: `hanshow`, `imagotag`, `solum`
        """
        verify_cert: NotRequired[pulumi.Input[bool]]
        """
        only if `type`==`imagotag`, whether to turn on SSL verification
        """
        vlan_id: NotRequired[pulumi.Input[int]]
        """
        only if `type`==`solum` or `type`==`hanshow`
        """
elif False:
    ApUsbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApUsbConfigArgs:
    def __init__(__self__, *,
                 cacert: Optional[pulumi.Input[str]] = None,
                 channel: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 verify_cert: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cacert: only if `type`==`imagotag`
        :param pulumi.Input[int] channel: only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        :param pulumi.Input[bool] enabled: whether to enable any usb config
        :param pulumi.Input[str] host: only if `type`==`imagotag`
        :param pulumi.Input[int] port: only if `type`==`imagotag`
        :param pulumi.Input[str] type: usb config type. enum: `hanshow`, `imagotag`, `solum`
        :param pulumi.Input[bool] verify_cert: only if `type`==`imagotag`, whether to turn on SSL verification
        :param pulumi.Input[int] vlan_id: only if `type`==`solum` or `type`==`hanshow`
        """
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if verify_cert is not None:
            pulumi.set(__self__, "verify_cert", verify_cert)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[str]]:
        """
        only if `type`==`imagotag`
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cacert", value)

    @property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[int]]:
        """
        only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable any usb config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        only if `type`==`imagotag`
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        only if `type`==`imagotag`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        usb config type. enum: `hanshow`, `imagotag`, `solum`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="verifyCert")
    def verify_cert(self) -> Optional[pulumi.Input[bool]]:
        """
        only if `type`==`imagotag`, whether to turn on SSL verification
        """
        return pulumi.get(self, "verify_cert")

    @verify_cert.setter
    def verify_cert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify_cert", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        only if `type`==`solum` or `type`==`hanshow`
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GatewayBgpConfigArgsDict(TypedDict):
        auth_key: NotRequired[pulumi.Input[str]]
        bfd_minimum_interval: NotRequired[pulumi.Input[int]]
        """
        when bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        bfd_multiplier: NotRequired[pulumi.Input[int]]
        """
        when bfd_minimum_interval_is_configured alone
        """
        disable_bfd: NotRequired[pulumi.Input[bool]]
        """
        BFD provides faster path failure detection and is enabled by default
        """
        export: NotRequired[pulumi.Input[str]]
        export_policy: NotRequired[pulumi.Input[str]]
        """
        default export policies if no per-neighbor policies defined
        """
        extended_v4_nexthop: NotRequired[pulumi.Input[bool]]
        """
        by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
        for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        graceful_restart_time: NotRequired[pulumi.Input[int]]
        """
        `0` means disable
        """
        hold_time: NotRequired[pulumi.Input[int]]
        import_: NotRequired[pulumi.Input[str]]
        import_policy: NotRequired[pulumi.Input[str]]
        """
        default import policies if no per-neighbor policies defined
        """
        local_as: NotRequired[pulumi.Input[int]]
        neighbor_as: NotRequired[pulumi.Input[int]]
        neighbors: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayBgpConfigNeighborsArgsDict']]]]
        """
        if per-neighbor as is desired. Property key is the neighbor address
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        """
        no_readvertise_to_overlay: NotRequired[pulumi.Input[bool]]
        """
        by default, we'll re-advertise all learned BGP routers toward overlay
        """
        tunnel_name: NotRequired[pulumi.Input[str]]
        """
        if `type`==`tunnel`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `external`, `internal`
        """
        via: NotRequired[pulumi.Input[str]]
        """
        network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        vpn_name: NotRequired[pulumi.Input[str]]
        wan_name: NotRequired[pulumi.Input[str]]
        """
        if `via`==`wan`
        """
elif False:
    GatewayBgpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayBgpConfigArgs:
    def __init__(__self__, *,
                 auth_key: Optional[pulumi.Input[str]] = None,
                 bfd_minimum_interval: Optional[pulumi.Input[int]] = None,
                 bfd_multiplier: Optional[pulumi.Input[int]] = None,
                 disable_bfd: Optional[pulumi.Input[bool]] = None,
                 export: Optional[pulumi.Input[str]] = None,
                 export_policy: Optional[pulumi.Input[str]] = None,
                 extended_v4_nexthop: Optional[pulumi.Input[bool]] = None,
                 graceful_restart_time: Optional[pulumi.Input[int]] = None,
                 hold_time: Optional[pulumi.Input[int]] = None,
                 import_: Optional[pulumi.Input[str]] = None,
                 import_policy: Optional[pulumi.Input[str]] = None,
                 local_as: Optional[pulumi.Input[int]] = None,
                 neighbor_as: Optional[pulumi.Input[int]] = None,
                 neighbors: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayBgpConfigNeighborsArgs']]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[bool]] = None,
                 tunnel_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 via: Optional[pulumi.Input[str]] = None,
                 vpn_name: Optional[pulumi.Input[str]] = None,
                 wan_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bfd_minimum_interval: when bfd_multiplier is configured alone. Default:
                 * 1000 if `type`==`external`
                 * 350 `type`==`internal`
        :param pulumi.Input[int] bfd_multiplier: when bfd_minimum_interval_is_configured alone
        :param pulumi.Input[bool] disable_bfd: BFD provides faster path failure detection and is enabled by default
        :param pulumi.Input[str] export_policy: default export policies if no per-neighbor policies defined
        :param pulumi.Input[bool] extended_v4_nexthop: by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
               for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        :param pulumi.Input[int] graceful_restart_time: `0` means disable
        :param pulumi.Input[str] import_policy: default import policies if no per-neighbor policies defined
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayBgpConfigNeighborsArgs']]] neighbors: if per-neighbor as is desired. Property key is the neighbor address
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        :param pulumi.Input[bool] no_readvertise_to_overlay: by default, we'll re-advertise all learned BGP routers toward overlay
        :param pulumi.Input[str] tunnel_name: if `type`==`tunnel`
        :param pulumi.Input[str] type: enum: `external`, `internal`
        :param pulumi.Input[str] via: network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        :param pulumi.Input[str] wan_name: if `via`==`wan`
        """
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if bfd_multiplier is not None:
            pulumi.set(__self__, "bfd_multiplier", bfd_multiplier)
        if disable_bfd is not None:
            pulumi.set(__self__, "disable_bfd", disable_bfd)
        if export is not None:
            pulumi.set(__self__, "export", export)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if extended_v4_nexthop is not None:
            pulumi.set(__self__, "extended_v4_nexthop", extended_v4_nexthop)
        if graceful_restart_time is not None:
            pulumi.set(__self__, "graceful_restart_time", graceful_restart_time)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_ is not None:
            pulumi.set(__self__, "import_", import_)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if local_as is not None:
            pulumi.set(__self__, "local_as", local_as)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if tunnel_name is not None:
            pulumi.set(__self__, "tunnel_name", tunnel_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if via is not None:
            pulumi.set(__self__, "via", via)
        if vpn_name is not None:
            pulumi.set(__self__, "vpn_name", vpn_name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_key")

    @auth_key.setter
    def auth_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_key", value)

    @property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[pulumi.Input[int]]:
        """
        when bfd_multiplier is configured alone. Default:
          * 1000 if `type`==`external`
          * 350 `type`==`internal`
        """
        return pulumi.get(self, "bfd_minimum_interval")

    @bfd_minimum_interval.setter
    def bfd_minimum_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bfd_minimum_interval", value)

    @property
    @pulumi.getter(name="bfdMultiplier")
    def bfd_multiplier(self) -> Optional[pulumi.Input[int]]:
        """
        when bfd_minimum_interval_is_configured alone
        """
        return pulumi.get(self, "bfd_multiplier")

    @bfd_multiplier.setter
    def bfd_multiplier(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bfd_multiplier", value)

    @property
    @pulumi.getter(name="disableBfd")
    def disable_bfd(self) -> Optional[pulumi.Input[bool]]:
        """
        BFD provides faster path failure detection and is enabled by default
        """
        return pulumi.get(self, "disable_bfd")

    @disable_bfd.setter
    def disable_bfd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_bfd", value)

    @property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[str]]:
        """
        default export policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="extendedV4Nexthop")
    def extended_v4_nexthop(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
        for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
        """
        return pulumi.get(self, "extended_v4_nexthop")

    @extended_v4_nexthop.setter
    def extended_v4_nexthop(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extended_v4_nexthop", value)

    @property
    @pulumi.getter(name="gracefulRestartTime")
    def graceful_restart_time(self) -> Optional[pulumi.Input[int]]:
        """
        `0` means disable
        """
        return pulumi.get(self, "graceful_restart_time")

    @graceful_restart_time.setter
    def graceful_restart_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "graceful_restart_time", value)

    @property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hold_time", value)

    @property
    @pulumi.getter(name="import")
    def import_(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "import_")

    @import_.setter
    def import_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[str]]:
        """
        default import policies if no per-neighbor policies defined
        """
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="localAs")
    def local_as(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_as")

    @local_as.setter
    def local_as(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_as", value)

    @property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "neighbor_as")

    @neighbor_as.setter
    def neighbor_as(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "neighbor_as", value)

    @property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayBgpConfigNeighborsArgs']]]]:
        """
        if per-neighbor as is desired. Property key is the neighbor address
        """
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayBgpConfigNeighborsArgs']]]]):
        pulumi.set(self, "neighbors", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, we'll re-advertise all learned BGP routers toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="tunnelName")
    def tunnel_name(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`tunnel`
        """
        return pulumi.get(self, "tunnel_name")

    @tunnel_name.setter
    def tunnel_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `external`, `internal`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[str]]:
        """
        network name. enum: `lan`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter(name="vpnName")
    def vpn_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpn_name")

    @vpn_name.setter
    def vpn_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpn_name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[str]]:
        """
        if `via`==`wan`
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewayBgpConfigNeighborsArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        export_policy: NotRequired[pulumi.Input[str]]
        hold_time: NotRequired[pulumi.Input[int]]
        import_policy: NotRequired[pulumi.Input[str]]
        multihop_ttl: NotRequired[pulumi.Input[int]]
        """
        assuming BGP neighbor is directly connected
        """
        neighbor_as: NotRequired[pulumi.Input[int]]
elif False:
    GatewayBgpConfigNeighborsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayBgpConfigNeighborsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 export_policy: Optional[pulumi.Input[str]] = None,
                 hold_time: Optional[pulumi.Input[int]] = None,
                 import_policy: Optional[pulumi.Input[str]] = None,
                 multihop_ttl: Optional[pulumi.Input[int]] = None,
                 neighbor_as: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: If true, the BGP session to this neighbor will be administratively disabled/shutdown
        :param pulumi.Input[int] multihop_ttl: assuming BGP neighbor is directly connected
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hold_time is not None:
            pulumi.set(__self__, "hold_time", hold_time)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if multihop_ttl is not None:
            pulumi.set(__self__, "multihop_ttl", multihop_ttl)
        if neighbor_as is not None:
            pulumi.set(__self__, "neighbor_as", neighbor_as)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the BGP session to this neighbor will be administratively disabled/shutdown
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="holdTime")
    def hold_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hold_time")

    @hold_time.setter
    def hold_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hold_time", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="multihopTtl")
    def multihop_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        assuming BGP neighbor is directly connected
        """
        return pulumi.get(self, "multihop_ttl")

    @multihop_ttl.setter
    def multihop_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "multihop_ttl", value)

    @property
    @pulumi.getter(name="neighborAs")
    def neighbor_as(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "neighbor_as")

    @neighbor_as.setter
    def neighbor_as(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "neighbor_as", value)


if not MYPY:
    class GatewayClusterNodeArgsDict(TypedDict):
        mac: pulumi.Input[str]
        """
        Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
elif False:
    GatewayClusterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayClusterNodeArgs:
    def __init__(__self__, *,
                 mac: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mac: Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
        pulumi.set(__self__, "mac", mac)

    @property
    @pulumi.getter
    def mac(self) -> pulumi.Input[str]:
        """
        Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: pulumi.Input[str]):
        pulumi.set(self, "mac", value)


if not MYPY:
    class GatewayDhcpdConfigArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigArgsDict']]]]
        """
        Property key is the network name
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        if set to `false`, disable the DHCP server
        """
elif False:
    GatewayDhcpdConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayDhcpdConfigArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigArgs']]] config: Property key is the network name
        :param pulumi.Input[bool] enabled: if set to `false`, disable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigArgs']]]]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigArgs']]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if set to `false`, disable the DHCP server
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewayDhcpdConfigConfigArgsDict(TypedDict):
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        fixed_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigFixedBindingsArgsDict']]]]
        """
        if `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        if `type`==`local` - optional, `ip` will be used if not provided
        """
        ip_end: NotRequired[pulumi.Input[str]]
        """
        if `type`==`local`
        """
        ip_end6: NotRequired[pulumi.Input[str]]
        """
        if `type6`==`local`
        """
        ip_start: NotRequired[pulumi.Input[str]]
        """
        if `type`==`local`
        """
        ip_start6: NotRequired[pulumi.Input[str]]
        """
        if `type6`==`local`
        """
        lease_time: NotRequired[pulumi.Input[int]]
        """
        in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigOptionsArgsDict']]]]
        """
        if `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        server_id_override: NotRequired[pulumi.Input[bool]]
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`relay`
        """
        servers6s: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type6`==`relay`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        type6: NotRequired[pulumi.Input[str]]
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        vendor_encapulated: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigVendorEncapulatedArgsDict']]]]
        """
        if `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code'
        """
elif False:
    GatewayDhcpdConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayDhcpdConfigConfigArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fixed_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigFixedBindingsArgs']]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip_end: Optional[pulumi.Input[str]] = None,
                 ip_end6: Optional[pulumi.Input[str]] = None,
                 ip_start: Optional[pulumi.Input[str]] = None,
                 ip_start6: Optional[pulumi.Input[str]] = None,
                 lease_time: Optional[pulumi.Input[int]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigOptionsArgs']]]] = None,
                 server_id_override: Optional[pulumi.Input[bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 servers6s: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 type6: Optional[pulumi.Input[str]] = None,
                 vendor_encapulated: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigVendorEncapulatedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_suffixes: if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigFixedBindingsArgs']]] fixed_bindings: if `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        :param pulumi.Input[str] gateway: if `type`==`local` - optional, `ip` will be used if not provided
        :param pulumi.Input[str] ip_end: if `type`==`local`
        :param pulumi.Input[str] ip_end6: if `type6`==`local`
        :param pulumi.Input[str] ip_start: if `type`==`local`
        :param pulumi.Input[str] ip_start6: if `type6`==`local`
        :param pulumi.Input[int] lease_time: in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigOptionsArgs']]] options: if `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        :param pulumi.Input[bool] server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers: if `type`==`relay`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers6s: if `type6`==`relay`
        :param pulumi.Input[str] type: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param pulumi.Input[str] type6: enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigVendorEncapulatedArgs']]] vendor_encapulated: if `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code'
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_end6 is not None:
            pulumi.set(__self__, "ip_end6", ip_end6)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if ip_start6 is not None:
            pulumi.set(__self__, "ip_start6", ip_start6)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if servers6s is not None:
            pulumi.set(__self__, "servers6s", servers6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapulated is not None:
            pulumi.set(__self__, "vendor_encapulated", vendor_encapulated)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigFixedBindingsArgs']]]]:
        """
        if `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @fixed_bindings.setter
    def fixed_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigFixedBindingsArgs']]]]):
        pulumi.set(self, "fixed_bindings", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`local` - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`local`
        """
        return pulumi.get(self, "ip_end")

    @ip_end.setter
    def ip_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_end", value)

    @property
    @pulumi.getter(name="ipEnd6")
    def ip_end6(self) -> Optional[pulumi.Input[str]]:
        """
        if `type6`==`local`
        """
        return pulumi.get(self, "ip_end6")

    @ip_end6.setter
    def ip_end6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_end6", value)

    @property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`local`
        """
        return pulumi.get(self, "ip_start")

    @ip_start.setter
    def ip_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_start", value)

    @property
    @pulumi.getter(name="ipStart6")
    def ip_start6(self) -> Optional[pulumi.Input[str]]:
        """
        if `type6`==`local`
        """
        return pulumi.get(self, "ip_start6")

    @ip_start6.setter
    def ip_start6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_start6", value)

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[pulumi.Input[int]]:
        """
        in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @lease_time.setter
    def lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lease_time", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigOptionsArgs']]]]:
        """
        if `type`==`local` or `type6`==`local`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigOptionsArgs']]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[pulumi.Input[bool]]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @server_id_override.setter
    def server_id_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_id_override", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter
    def servers6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type6`==`relay`
        """
        return pulumi.get(self, "servers6s")

    @servers6s.setter
    def servers6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers6s", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type6", value)

    @property
    @pulumi.getter(name="vendorEncapulated")
    def vendor_encapulated(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigVendorEncapulatedArgs']]]]:
        """
        if `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code'
        """
        return pulumi.get(self, "vendor_encapulated")

    @vendor_encapulated.setter
    def vendor_encapulated(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayDhcpdConfigConfigVendorEncapulatedArgs']]]]):
        pulumi.set(self, "vendor_encapulated", value)


if not MYPY:
    class GatewayDhcpdConfigConfigFixedBindingsArgsDict(TypedDict):
        ip: pulumi.Input[str]
        name: NotRequired[pulumi.Input[str]]
elif False:
    GatewayDhcpdConfigConfigFixedBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayDhcpdConfigConfigFixedBindingsArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewayDhcpdConfigConfigOptionsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    GatewayDhcpdConfigConfigOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayDhcpdConfigConfigOptionsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewayDhcpdConfigConfigVendorEncapulatedArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    GatewayDhcpdConfigConfigVendorEncapulatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayDhcpdConfigConfigVendorEncapulatedArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GatewayExtraRoutes6ArgsDict(TypedDict):
        via: pulumi.Input[str]
elif False:
    GatewayExtraRoutes6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayExtraRoutes6Args:
    def __init__(__self__, *,
                 via: pulumi.Input[str]):
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class GatewayExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[str]
elif False:
    GatewayExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[str]):
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class GatewayIdpProfilesArgsDict(TypedDict):
        base_profile: NotRequired[pulumi.Input[str]]
        """
        enum: `critical`, `standard`, `strict`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique ID of the object instance in the Mist Organnization
        """
        name: NotRequired[pulumi.Input[str]]
        org_id: NotRequired[pulumi.Input[str]]
        overwrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayIdpProfilesOverwriteArgsDict']]]]
elif False:
    GatewayIdpProfilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIdpProfilesArgs:
    def __init__(__self__, *,
                 base_profile: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 overwrites: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayIdpProfilesOverwriteArgs']]]] = None):
        """
        :param pulumi.Input[str] base_profile: enum: `critical`, `standard`, `strict`
        :param pulumi.Input[str] id: Unique ID of the object instance in the Mist Organnization
        """
        if base_profile is not None:
            pulumi.set(__self__, "base_profile", base_profile)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if overwrites is not None:
            pulumi.set(__self__, "overwrites", overwrites)

    @property
    @pulumi.getter(name="baseProfile")
    def base_profile(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "base_profile")

    @base_profile.setter
    def base_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_profile", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique ID of the object instance in the Mist Organnization
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def overwrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayIdpProfilesOverwriteArgs']]]]:
        return pulumi.get(self, "overwrites")

    @overwrites.setter
    def overwrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayIdpProfilesOverwriteArgs']]]]):
        pulumi.set(self, "overwrites", value)


if not MYPY:
    class GatewayIdpProfilesOverwriteArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        enum:
          * alert (default)
          * drop: siliently dropping packets
          * close: notify client/server to close connection
        """
        matching: NotRequired[pulumi.Input['GatewayIdpProfilesOverwriteMatchingArgsDict']]
        name: NotRequired[pulumi.Input[str]]
elif False:
    GatewayIdpProfilesOverwriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIdpProfilesOverwriteArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 matching: Optional[pulumi.Input['GatewayIdpProfilesOverwriteMatchingArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: enum:
                 * alert (default)
                 * drop: siliently dropping packets
                 * close: notify client/server to close connection
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        enum:
          * alert (default)
          * drop: siliently dropping packets
          * close: notify client/server to close connection
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['GatewayIdpProfilesOverwriteMatchingArgs']]:
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['GatewayIdpProfilesOverwriteMatchingArgs']]):
        pulumi.set(self, "matching", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewayIdpProfilesOverwriteMatchingArgsDict(TypedDict):
        attack_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        dst_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    GatewayIdpProfilesOverwriteMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIdpProfilesOverwriteMatchingArgs:
    def __init__(__self__, *,
                 attack_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dst_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if attack_names is not None:
            pulumi.set(__self__, "attack_names", attack_names)
        if dst_subnets is not None:
            pulumi.set(__self__, "dst_subnets", dst_subnets)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)

    @property
    @pulumi.getter(name="attackNames")
    def attack_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "attack_names")

    @attack_names.setter
    def attack_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attack_names", value)

    @property
    @pulumi.getter(name="dstSubnets")
    def dst_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dst_subnets")

    @dst_subnets.setter
    def dst_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dst_subnets", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "severities", value)


if not MYPY:
    class GatewayIpConfigsArgsDict(TypedDict):
        ip: pulumi.Input[str]
        netmask: pulumi.Input[str]
        secondary_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        optional list of secondary IPs in CIDR format
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
elif False:
    GatewayIpConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIpConfigsArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 netmask: pulumi.Input[str],
                 secondary_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] secondary_ips: optional list of secondary IPs in CIDR format
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "netmask", netmask)
        if secondary_ips is not None:
            pulumi.set(__self__, "secondary_ips", secondary_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[str]:
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[str]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="secondaryIps")
    def secondary_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        optional list of secondary IPs in CIDR format
        """
        return pulumi.get(self, "secondary_ips")

    @secondary_ips.setter
    def secondary_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "secondary_ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayNetworkArgsDict(TypedDict):
        name: pulumi.Input[str]
        subnet: pulumi.Input[str]
        disallow_mist_services: NotRequired[pulumi.Input[bool]]
        """
        whether to disallow Mist Devices in the network
        """
        gateway: NotRequired[pulumi.Input[str]]
        gateway6: NotRequired[pulumi.Input[str]]
        internal_access: NotRequired[pulumi.Input['GatewayNetworkInternalAccessArgsDict']]
        internet_access: NotRequired[pulumi.Input['GatewayNetworkInternetAccessArgsDict']]
        """
        whether this network has direct internet access
        """
        isolation: NotRequired[pulumi.Input[bool]]
        """
        whether to allow clients in the network to talk to each other
        """
        multicast: NotRequired[pulumi.Input['GatewayNetworkMulticastArgsDict']]
        """
        whether to enable multicast support (only PIM-sparse mode is supported)
        """
        routed_for_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        subnet6: NotRequired[pulumi.Input[str]]
        tenants: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkTenantsArgsDict']]]]
        vlan_id: NotRequired[pulumi.Input[str]]
        vpn_access: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessArgsDict']]]]
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
elif False:
    GatewayNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 subnet: pulumi.Input[str],
                 disallow_mist_services: Optional[pulumi.Input[bool]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 gateway6: Optional[pulumi.Input[str]] = None,
                 internal_access: Optional[pulumi.Input['GatewayNetworkInternalAccessArgs']] = None,
                 internet_access: Optional[pulumi.Input['GatewayNetworkInternetAccessArgs']] = None,
                 isolation: Optional[pulumi.Input[bool]] = None,
                 multicast: Optional[pulumi.Input['GatewayNetworkMulticastArgs']] = None,
                 routed_for_networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet6: Optional[pulumi.Input[str]] = None,
                 tenants: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkTenantsArgs']]]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None,
                 vpn_access: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessArgs']]]] = None):
        """
        :param pulumi.Input[bool] disallow_mist_services: whether to disallow Mist Devices in the network
        :param pulumi.Input['GatewayNetworkInternetAccessArgs'] internet_access: whether this network has direct internet access
        :param pulumi.Input[bool] isolation: whether to allow clients in the network to talk to each other
        :param pulumi.Input['GatewayNetworkMulticastArgs'] multicast: whether to enable multicast support (only PIM-sparse mode is supported)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] routed_for_networks: for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessArgs']]] vpn_access: Property key is the VPN name. Whether this network can be accessed from vpn
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        if disallow_mist_services is not None:
            pulumi.set(__self__, "disallow_mist_services", disallow_mist_services)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if gateway6 is not None:
            pulumi.set(__self__, "gateway6", gateway6)
        if internal_access is not None:
            pulumi.set(__self__, "internal_access", internal_access)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if multicast is not None:
            pulumi.set(__self__, "multicast", multicast)
        if routed_for_networks is not None:
            pulumi.set(__self__, "routed_for_networks", routed_for_networks)
        if subnet6 is not None:
            pulumi.set(__self__, "subnet6", subnet6)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_access is not None:
            pulumi.set(__self__, "vpn_access", vpn_access)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="disallowMistServices")
    def disallow_mist_services(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disallow Mist Devices in the network
        """
        return pulumi.get(self, "disallow_mist_services")

    @disallow_mist_services.setter
    def disallow_mist_services(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disallow_mist_services", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def gateway6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gateway6")

    @gateway6.setter
    def gateway6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway6", value)

    @property
    @pulumi.getter(name="internalAccess")
    def internal_access(self) -> Optional[pulumi.Input['GatewayNetworkInternalAccessArgs']]:
        return pulumi.get(self, "internal_access")

    @internal_access.setter
    def internal_access(self, value: Optional[pulumi.Input['GatewayNetworkInternalAccessArgs']]):
        pulumi.set(self, "internal_access", value)

    @property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[pulumi.Input['GatewayNetworkInternetAccessArgs']]:
        """
        whether this network has direct internet access
        """
        return pulumi.get(self, "internet_access")

    @internet_access.setter
    def internet_access(self, value: Optional[pulumi.Input['GatewayNetworkInternetAccessArgs']]):
        pulumi.set(self, "internet_access", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to allow clients in the network to talk to each other
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter
    def multicast(self) -> Optional[pulumi.Input['GatewayNetworkMulticastArgs']]:
        """
        whether to enable multicast support (only PIM-sparse mode is supported)
        """
        return pulumi.get(self, "multicast")

    @multicast.setter
    def multicast(self, value: Optional[pulumi.Input['GatewayNetworkMulticastArgs']]):
        pulumi.set(self, "multicast", value)

    @property
    @pulumi.getter(name="routedForNetworks")
    def routed_for_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
        """
        return pulumi.get(self, "routed_for_networks")

    @routed_for_networks.setter
    def routed_for_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "routed_for_networks", value)

    @property
    @pulumi.getter
    def subnet6(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet6")

    @subnet6.setter
    def subnet6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet6", value)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkTenantsArgs']]]]:
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkTenantsArgs']]]]):
        pulumi.set(self, "tenants", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vpnAccess")
    def vpn_access(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessArgs']]]]:
        """
        Property key is the VPN name. Whether this network can be accessed from vpn
        """
        return pulumi.get(self, "vpn_access")

    @vpn_access.setter
    def vpn_access(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessArgs']]]]):
        pulumi.set(self, "vpn_access", value)


if not MYPY:
    class GatewayNetworkInternalAccessArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    GatewayNetworkInternalAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkInternalAccessArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewayNetworkInternetAccessArgsDict(TypedDict):
        create_simple_service_policy: NotRequired[pulumi.Input[bool]]
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessDestinationNatArgsDict']]]]
        """
        Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
        """
        enabled: NotRequired[pulumi.Input[bool]]
        restricted: NotRequired[pulumi.Input[bool]]
        """
        by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessStaticNatArgsDict']]]]
        """
        Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
        """
elif False:
    GatewayNetworkInternetAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkInternetAccessArgs:
    def __init__(__self__, *,
                 create_simple_service_policy: Optional[pulumi.Input[bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessDestinationNatArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 restricted: Optional[pulumi.Input[bool]] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessStaticNatArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessDestinationNatArgs']]] destination_nat: Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
        :param pulumi.Input[bool] restricted: by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessStaticNatArgs']]] static_nat: Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
        """
        if create_simple_service_policy is not None:
            pulumi.set(__self__, "create_simple_service_policy", create_simple_service_policy)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)

    @property
    @pulumi.getter(name="createSimpleServicePolicy")
    def create_simple_service_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_simple_service_policy")

    @create_simple_service_policy.setter
    def create_simple_service_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_simple_service_policy", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessDestinationNatArgs']]]]:
        """
        Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def restricted(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
        """
        return pulumi.get(self, "restricted")

    @restricted.setter
    def restricted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restricted", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessStaticNatArgs']]]]:
        """
        Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkInternetAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)


if not MYPY:
    class GatewayNetworkInternetAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
elif False:
    GatewayNetworkInternetAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkInternetAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewayNetworkInternetAccessStaticNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        wan_name: NotRequired[pulumi.Input[str]]
        """
        If not set, we configure the nat policies against all WAN ports for simplicity
        """
elif False:
    GatewayNetworkInternetAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkInternetAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 wan_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] wan_name: If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[str]]:
        """
        If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewayNetworkMulticastArgsDict(TypedDict):
        disable_igmp: NotRequired[pulumi.Input[bool]]
        """
        if the network will only be the soruce of the multicast traffic, IGMP can be disabled
        """
        enabled: NotRequired[pulumi.Input[bool]]
        groups: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkMulticastGroupsArgsDict']]]]
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
elif False:
    GatewayNetworkMulticastArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkMulticastArgs:
    def __init__(__self__, *,
                 disable_igmp: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkMulticastGroupsArgs']]]] = None):
        """
        :param pulumi.Input[bool] disable_igmp: if the network will only be the soruce of the multicast traffic, IGMP can be disabled
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkMulticastGroupsArgs']]] groups: Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        if disable_igmp is not None:
            pulumi.set(__self__, "disable_igmp", disable_igmp)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter(name="disableIgmp")
    def disable_igmp(self) -> Optional[pulumi.Input[bool]]:
        """
        if the network will only be the soruce of the multicast traffic, IGMP can be disabled
        """
        return pulumi.get(self, "disable_igmp")

    @disable_igmp.setter
    def disable_igmp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_igmp", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkMulticastGroupsArgs']]]]:
        """
        Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkMulticastGroupsArgs']]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class GatewayNetworkMulticastGroupsArgsDict(TypedDict):
        rp_ip: NotRequired[pulumi.Input[str]]
        """
        RP (rendezvous point) IP Address
        """
elif False:
    GatewayNetworkMulticastGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkMulticastGroupsArgs:
    def __init__(__self__, *,
                 rp_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rp_ip: RP (rendezvous point) IP Address
        """
        if rp_ip is not None:
            pulumi.set(__self__, "rp_ip", rp_ip)

    @property
    @pulumi.getter(name="rpIp")
    def rp_ip(self) -> Optional[pulumi.Input[str]]:
        """
        RP (rendezvous point) IP Address
        """
        return pulumi.get(self, "rp_ip")

    @rp_ip.setter
    def rp_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rp_ip", value)


if not MYPY:
    class GatewayNetworkTenantsArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    GatewayNetworkTenantsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkTenantsArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class GatewayNetworkVpnAccessArgsDict(TypedDict):
        advertised_subnet: NotRequired[pulumi.Input[str]]
        """
        if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        allow_ping: NotRequired[pulumi.Input[bool]]
        """
        whether to allow ping from vpn into this routed network
        """
        destination_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessDestinationNatArgsDict']]]]
        """
        Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
        """
        nat_pool: NotRequired[pulumi.Input[str]]
        """
        if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        no_readvertise_to_lan_bgp: NotRequired[pulumi.Input[bool]]
        """
        toward LAN-side BGP peers
        """
        no_readvertise_to_lan_ospf: NotRequired[pulumi.Input[bool]]
        """
        toward LAN-side OSPF peers
        """
        no_readvertise_to_overlay: NotRequired[pulumi.Input[bool]]
        """
        toward overlay
        how HUB should deal with routes it received from Spokes
        """
        other_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        by default, the routes are only readvertised toward the same vrf on spoke
        to allow it to be leaked to other vrfs
        """
        routed: NotRequired[pulumi.Input[bool]]
        """
        whether this network is routable
        """
        source_nat: NotRequired[pulumi.Input['GatewayNetworkVpnAccessSourceNatArgsDict']]
        """
        if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        static_nat: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessStaticNatArgsDict']]]]
        """
        Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
        """
        summarized_subnet: NotRequired[pulumi.Input[str]]
        """
        toward overlay
        how HUB should deal with routes it received from Spokes
        """
        summarized_subnet_to_lan_bgp: NotRequired[pulumi.Input[str]]
        """
        toward LAN-side BGP peers
        """
        summarized_subnet_to_lan_ospf: NotRequired[pulumi.Input[str]]
        """
        toward LAN-side OSPF peers
        """
elif False:
    GatewayNetworkVpnAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkVpnAccessArgs:
    def __init__(__self__, *,
                 advertised_subnet: Optional[pulumi.Input[str]] = None,
                 allow_ping: Optional[pulumi.Input[bool]] = None,
                 destination_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessDestinationNatArgs']]]] = None,
                 nat_pool: Optional[pulumi.Input[str]] = None,
                 no_readvertise_to_lan_bgp: Optional[pulumi.Input[bool]] = None,
                 no_readvertise_to_lan_ospf: Optional[pulumi.Input[bool]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[bool]] = None,
                 other_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 routed: Optional[pulumi.Input[bool]] = None,
                 source_nat: Optional[pulumi.Input['GatewayNetworkVpnAccessSourceNatArgs']] = None,
                 static_nat: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessStaticNatArgs']]]] = None,
                 summarized_subnet: Optional[pulumi.Input[str]] = None,
                 summarized_subnet_to_lan_bgp: Optional[pulumi.Input[str]] = None,
                 summarized_subnet_to_lan_ospf: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] advertised_subnet: if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        :param pulumi.Input[bool] allow_ping: whether to allow ping from vpn into this routed network
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessDestinationNatArgs']]] destination_nat: Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
        :param pulumi.Input[str] nat_pool: if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        :param pulumi.Input[bool] no_readvertise_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[bool] no_readvertise_to_lan_ospf: toward LAN-side OSPF peers
        :param pulumi.Input[bool] no_readvertise_to_overlay: toward overlay
               how HUB should deal with routes it received from Spokes
        :param pulumi.Input[Sequence[pulumi.Input[str]]] other_vrfs: by default, the routes are only readvertised toward the same vrf on spoke
               to allow it to be leaked to other vrfs
        :param pulumi.Input[bool] routed: whether this network is routable
        :param pulumi.Input['GatewayNetworkVpnAccessSourceNatArgs'] source_nat: if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessStaticNatArgs']]] static_nat: Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
        :param pulumi.Input[str] summarized_subnet: toward overlay
               how HUB should deal with routes it received from Spokes
        :param pulumi.Input[str] summarized_subnet_to_lan_bgp: toward LAN-side BGP peers
        :param pulumi.Input[str] summarized_subnet_to_lan_ospf: toward LAN-side OSPF peers
        """
        if advertised_subnet is not None:
            pulumi.set(__self__, "advertised_subnet", advertised_subnet)
        if allow_ping is not None:
            pulumi.set(__self__, "allow_ping", allow_ping)
        if destination_nat is not None:
            pulumi.set(__self__, "destination_nat", destination_nat)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)
        if no_readvertise_to_lan_bgp is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_bgp", no_readvertise_to_lan_bgp)
        if no_readvertise_to_lan_ospf is not None:
            pulumi.set(__self__, "no_readvertise_to_lan_ospf", no_readvertise_to_lan_ospf)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if other_vrfs is not None:
            pulumi.set(__self__, "other_vrfs", other_vrfs)
        if routed is not None:
            pulumi.set(__self__, "routed", routed)
        if source_nat is not None:
            pulumi.set(__self__, "source_nat", source_nat)
        if static_nat is not None:
            pulumi.set(__self__, "static_nat", static_nat)
        if summarized_subnet is not None:
            pulumi.set(__self__, "summarized_subnet", summarized_subnet)
        if summarized_subnet_to_lan_bgp is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_bgp", summarized_subnet_to_lan_bgp)
        if summarized_subnet_to_lan_ospf is not None:
            pulumi.set(__self__, "summarized_subnet_to_lan_ospf", summarized_subnet_to_lan_ospf)

    @property
    @pulumi.getter(name="advertisedSubnet")
    def advertised_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
        """
        return pulumi.get(self, "advertised_subnet")

    @advertised_subnet.setter
    def advertised_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "advertised_subnet", value)

    @property
    @pulumi.getter(name="allowPing")
    def allow_ping(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to allow ping from vpn into this routed network
        """
        return pulumi.get(self, "allow_ping")

    @allow_ping.setter
    def allow_ping(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_ping", value)

    @property
    @pulumi.getter(name="destinationNat")
    def destination_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessDestinationNatArgs']]]]:
        """
        Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
        """
        return pulumi.get(self, "destination_nat")

    @destination_nat.setter
    def destination_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessDestinationNatArgs']]]]):
        pulumi.set(self, "destination_nat", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[str]]:
        """
        if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_pool", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanBgp")
    def no_readvertise_to_lan_bgp(self) -> Optional[pulumi.Input[bool]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_bgp")

    @no_readvertise_to_lan_bgp.setter
    def no_readvertise_to_lan_bgp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_readvertise_to_lan_bgp", value)

    @property
    @pulumi.getter(name="noReadvertiseToLanOspf")
    def no_readvertise_to_lan_ospf(self) -> Optional[pulumi.Input[bool]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "no_readvertise_to_lan_ospf")

    @no_readvertise_to_lan_ospf.setter
    def no_readvertise_to_lan_ospf(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_readvertise_to_lan_ospf", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[bool]]:
        """
        toward overlay
        how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter(name="otherVrfs")
    def other_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        by default, the routes are only readvertised toward the same vrf on spoke
        to allow it to be leaked to other vrfs
        """
        return pulumi.get(self, "other_vrfs")

    @other_vrfs.setter
    def other_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "other_vrfs", value)

    @property
    @pulumi.getter
    def routed(self) -> Optional[pulumi.Input[bool]]:
        """
        whether this network is routable
        """
        return pulumi.get(self, "routed")

    @routed.setter
    def routed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "routed", value)

    @property
    @pulumi.getter(name="sourceNat")
    def source_nat(self) -> Optional[pulumi.Input['GatewayNetworkVpnAccessSourceNatArgs']]:
        """
        if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
        """
        return pulumi.get(self, "source_nat")

    @source_nat.setter
    def source_nat(self, value: Optional[pulumi.Input['GatewayNetworkVpnAccessSourceNatArgs']]):
        pulumi.set(self, "source_nat", value)

    @property
    @pulumi.getter(name="staticNat")
    def static_nat(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessStaticNatArgs']]]]:
        """
        Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
        """
        return pulumi.get(self, "static_nat")

    @static_nat.setter
    def static_nat(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayNetworkVpnAccessStaticNatArgs']]]]):
        pulumi.set(self, "static_nat", value)

    @property
    @pulumi.getter(name="summarizedSubnet")
    def summarized_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        toward overlay
        how HUB should deal with routes it received from Spokes
        """
        return pulumi.get(self, "summarized_subnet")

    @summarized_subnet.setter
    def summarized_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summarized_subnet", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanBgp")
    def summarized_subnet_to_lan_bgp(self) -> Optional[pulumi.Input[str]]:
        """
        toward LAN-side BGP peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_bgp")

    @summarized_subnet_to_lan_bgp.setter
    def summarized_subnet_to_lan_bgp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summarized_subnet_to_lan_bgp", value)

    @property
    @pulumi.getter(name="summarizedSubnetToLanOspf")
    def summarized_subnet_to_lan_ospf(self) -> Optional[pulumi.Input[str]]:
        """
        toward LAN-side OSPF peers
        """
        return pulumi.get(self, "summarized_subnet_to_lan_ospf")

    @summarized_subnet_to_lan_ospf.setter
    def summarized_subnet_to_lan_ospf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summarized_subnet_to_lan_ospf", value)


if not MYPY:
    class GatewayNetworkVpnAccessDestinationNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
elif False:
    GatewayNetworkVpnAccessDestinationNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkVpnAccessDestinationNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GatewayNetworkVpnAccessSourceNatArgsDict(TypedDict):
        external_ip: NotRequired[pulumi.Input[str]]
elif False:
    GatewayNetworkVpnAccessSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkVpnAccessSourceNatArgs:
    def __init__(__self__, *,
                 external_ip: Optional[pulumi.Input[str]] = None):
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)

    @property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_ip")

    @external_ip.setter
    def external_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_ip", value)


if not MYPY:
    class GatewayNetworkVpnAccessStaticNatArgsDict(TypedDict):
        internal_ip: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        wan_name: NotRequired[pulumi.Input[str]]
        """
        If not set, we configure the nat policies against all WAN ports for simplicity
        """
elif False:
    GatewayNetworkVpnAccessStaticNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkVpnAccessStaticNatArgs:
    def __init__(__self__, *,
                 internal_ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 wan_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] wan_name: If not set, we configure the nat policies against all WAN ports for simplicity
        """
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[str]]:
        """
        If not set, we configure the nat policies against all WAN ports for simplicity
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewayOobIpConfigArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[str]]
        """
        if `type`==`static`
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        if `type`==`static`
        """
        netmask: NotRequired[pulumi.Input[str]]
        """
        if `type`==`static`
        """
        node1: NotRequired[pulumi.Input['GatewayOobIpConfigNode1ArgsDict']]
        """
        for HA Cluster, node1 can have different IP Config
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[bool]]
        """
        if supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[bool]]
        """
        for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        vlan_id: NotRequired[pulumi.Input[str]]
elif False:
    GatewayOobIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayOobIpConfigArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 node1: Optional[pulumi.Input['GatewayOobIpConfigNode1Args']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: if `type`==`static`
        :param pulumi.Input[str] ip: if `type`==`static`
        :param pulumi.Input[str] netmask: if `type`==`static`
        :param pulumi.Input['GatewayOobIpConfigNode1Args'] node1: for HA Cluster, node1 can have different IP Config
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        :param pulumi.Input[bool] use_mgmt_vrf: if supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[bool] use_mgmt_vrf_for_host_out: for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if node1 is not None:
            pulumi.set(__self__, "node1", node1)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`static`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def node1(self) -> Optional[pulumi.Input['GatewayOobIpConfigNode1Args']]:
        """
        for HA Cluster, node1 can have different IP Config
        """
        return pulumi.get(self, "node1")

    @node1.setter
    def node1(self, value: Optional[pulumi.Input['GatewayOobIpConfigNode1Args']]):
        pulumi.set(self, "node1", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[bool]]:
        """
        if supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[bool]]:
        """
        for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GatewayOobIpConfigNode1ArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[str]]
        """
        if `type`==`static`
        """
        ip: NotRequired[pulumi.Input[str]]
        netmask: NotRequired[pulumi.Input[str]]
        """
        used only if `subnet` is not specified in `networks`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[bool]]
        """
        if supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[bool]]
        """
        whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        vlan_id: NotRequired[pulumi.Input[str]]
elif False:
    GatewayOobIpConfigNode1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayOobIpConfigNode1Args:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[bool]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: if `type`==`static`
        :param pulumi.Input[str] netmask: used only if `subnet` is not specified in `networks`
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        :param pulumi.Input[bool] use_mgmt_vrf: if supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[bool] use_mgmt_vrf_for_host_out: whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`static`
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[bool]]:
        """
        if supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GatewayPathPreferencesArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayPathPreferencesPathArgsDict']]]]
        strategy: NotRequired[pulumi.Input[str]]
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
elif False:
    GatewayPathPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPathPreferencesArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayPathPreferencesPathArgs']]]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] strategy: enum: `ecmp`, `ordered`, `weighted`
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayPathPreferencesPathArgs']]]]:
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayPathPreferencesPathArgs']]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ecmp`, `ordered`, `weighted`
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class GatewayPathPreferencesPathArgsDict(TypedDict):
        cost: NotRequired[pulumi.Input[int]]
        disabled: NotRequired[pulumi.Input[bool]]
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        gateway_ip: NotRequired[pulumi.Input[str]]
        """
        only if `type`==`local`, if a different gateway is desired
        """
        internet_access: NotRequired[pulumi.Input[bool]]
        """
        only if `type`==`vpn`, if this vpn path can be used for internet
        """
        name: NotRequired[pulumi.Input[str]]
        """
        required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use'
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        required when `type`==`local`
        """
        target_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`local`, if destination IP is to be replaced
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        wan_name: NotRequired[pulumi.Input[str]]
        """
        optional if `type`==`vpn`
        """
elif False:
    GatewayPathPreferencesPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPathPreferencesPathArgs:
    def __init__(__self__, *,
                 cost: Optional[pulumi.Input[int]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 gateway_ip: Optional[pulumi.Input[str]] = None,
                 internet_access: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 wan_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: For SSR Only. `true`, if this specific path is undesired
        :param pulumi.Input[str] gateway_ip: only if `type`==`local`, if a different gateway is desired
        :param pulumi.Input[bool] internet_access: only if `type`==`vpn`, if this vpn path can be used for internet
        :param pulumi.Input[str] name: required when 
                 * `type`==`vpn`: the name of the VPN Path to use 
                 * `type`==`wan`: the name of the WAN interface to use'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: required when `type`==`local`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_ips: if `type`==`local`, if destination IP is to be replaced
        :param pulumi.Input[str] type: enum: `local`, `tunnel`, `vpn`, `wan`
        :param pulumi.Input[str] wan_name: optional if `type`==`vpn`
        """
        if cost is not None:
            pulumi.set(__self__, "cost", cost)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)
        if internet_access is not None:
            pulumi.set(__self__, "internet_access", internet_access)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wan_name is not None:
            pulumi.set(__self__, "wan_name", wan_name)

    @property
    @pulumi.getter
    def cost(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cost")

    @cost.setter
    def cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cost", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        For SSR Only. `true`, if this specific path is undesired
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[pulumi.Input[str]]:
        """
        only if `type`==`local`, if a different gateway is desired
        """
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_ip", value)

    @property
    @pulumi.getter(name="internetAccess")
    def internet_access(self) -> Optional[pulumi.Input[bool]]:
        """
        only if `type`==`vpn`, if this vpn path can be used for internet
        """
        return pulumi.get(self, "internet_access")

    @internet_access.setter
    def internet_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "internet_access", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        required when 
          * `type`==`vpn`: the name of the VPN Path to use 
          * `type`==`wan`: the name of the WAN interface to use'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        required when `type`==`local`
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`local`, if destination IP is to be replaced
        """
        return pulumi.get(self, "target_ips")

    @target_ips.setter
    def target_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `local`, `tunnel`, `vpn`, `wan`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="wanName")
    def wan_name(self) -> Optional[pulumi.Input[str]]:
        """
        optional if `type`==`vpn`
        """
        return pulumi.get(self, "wan_name")

    @wan_name.setter
    def wan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_name", value)


if not MYPY:
    class GatewayPortConfigArgsDict(TypedDict):
        usage: pulumi.Input[str]
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        ae_disable_lacp: NotRequired[pulumi.Input[bool]]
        """
        if `aggregated`==`true`. To disable LCP support for the AE interface
        """
        ae_idx: NotRequired[pulumi.Input[str]]
        """
        if `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        ae_lacp_force_up: NotRequired[pulumi.Input[bool]]
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability.\\n
        Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end\\n
        Note: Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        aggregated: NotRequired[pulumi.Input[bool]]
        critical: NotRequired[pulumi.Input[bool]]
        """
        if want to generate port up/down alarm, set it to true
        """
        description: NotRequired[pulumi.Input[str]]
        disable_autoneg: NotRequired[pulumi.Input[bool]]
        disabled: NotRequired[pulumi.Input[bool]]
        """
        port admin up (true) / down (false)
        """
        dsl_type: NotRequired[pulumi.Input[str]]
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        dsl_vci: NotRequired[pulumi.Input[int]]
        """
        if `wan_type`==`dsl`
        16 bit int
        """
        dsl_vpi: NotRequired[pulumi.Input[int]]
        """
        if `wan_type`==`dsl`
        8 bit int
        """
        duplex: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `full`, `half`
        """
        ip_config: NotRequired[pulumi.Input['GatewayPortConfigIpConfigArgsDict']]
        """
        Junos IP Config
        """
        lte_apn: NotRequired[pulumi.Input[str]]
        """
        if `wan_type`==`lte`
        """
        lte_auth: NotRequired[pulumi.Input[str]]
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        lte_backup: NotRequired[pulumi.Input[bool]]
        lte_password: NotRequired[pulumi.Input[str]]
        """
        if `wan_type`==`lte`
        """
        lte_username: NotRequired[pulumi.Input[str]]
        """
        if `wan_type`==`lte`
        """
        mtu: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        name that we'll use to derive config
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `usage`==`lan`
        """
        outer_vlan_id: NotRequired[pulumi.Input[int]]
        """
        for Q-in-Q
        """
        poe_disabled: NotRequired[pulumi.Input[bool]]
        port_network: NotRequired[pulumi.Input[str]]
        """
        if `usage`==`lan`
        """
        preserve_dscp: NotRequired[pulumi.Input[bool]]
        """
        whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        redundant: NotRequired[pulumi.Input[bool]]
        """
        if HA mode
        """
        reth_idx: NotRequired[pulumi.Input[int]]
        """
        if HA mode
        """
        reth_node: NotRequired[pulumi.Input[str]]
        """
        if HA mode
        """
        reth_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        speed: NotRequired[pulumi.Input[str]]
        ssr_no_virtual_mac: NotRequired[pulumi.Input[bool]]
        """
        when SSR is running as VM, this is required on certain hosting platforms
        """
        svr_port_range: NotRequired[pulumi.Input[str]]
        """
        for SSR only
        """
        traffic_shaping: NotRequired[pulumi.Input['GatewayPortConfigTrafficShapingArgsDict']]
        vlan_id: NotRequired[pulumi.Input[int]]
        """
        if WAN interface is on a VLAN
        """
        vpn_paths: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigVpnPathsArgsDict']]]]
        """
        Property key is the VPN name
        """
        wan_arp_policer: NotRequired[pulumi.Input[str]]
        """
        when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        wan_ext_ip: NotRequired[pulumi.Input[str]]
        """
        optional, if spoke should reach this port by a different IP
        """
        wan_extra_routes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigWanExtraRoutesArgsDict']]]]
        """
        Property Key is the destianation CIDR (e.g "100.100.100.0/24")
        """
        wan_probe_override: NotRequired[pulumi.Input['GatewayPortConfigWanProbeOverrideArgsDict']]
        """
        if `usage`==`wan`
        """
        wan_source_nat: NotRequired[pulumi.Input['GatewayPortConfigWanSourceNatArgsDict']]
        """
        optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        wan_type: NotRequired[pulumi.Input[str]]
        """
        if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
elif False:
    GatewayPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[str],
                 ae_disable_lacp: Optional[pulumi.Input[bool]] = None,
                 ae_idx: Optional[pulumi.Input[str]] = None,
                 ae_lacp_force_up: Optional[pulumi.Input[bool]] = None,
                 aggregated: Optional[pulumi.Input[bool]] = None,
                 critical: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_autoneg: Optional[pulumi.Input[bool]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dsl_type: Optional[pulumi.Input[str]] = None,
                 dsl_vci: Optional[pulumi.Input[int]] = None,
                 dsl_vpi: Optional[pulumi.Input[int]] = None,
                 duplex: Optional[pulumi.Input[str]] = None,
                 ip_config: Optional[pulumi.Input['GatewayPortConfigIpConfigArgs']] = None,
                 lte_apn: Optional[pulumi.Input[str]] = None,
                 lte_auth: Optional[pulumi.Input[str]] = None,
                 lte_backup: Optional[pulumi.Input[bool]] = None,
                 lte_password: Optional[pulumi.Input[str]] = None,
                 lte_username: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 outer_vlan_id: Optional[pulumi.Input[int]] = None,
                 poe_disabled: Optional[pulumi.Input[bool]] = None,
                 port_network: Optional[pulumi.Input[str]] = None,
                 preserve_dscp: Optional[pulumi.Input[bool]] = None,
                 redundant: Optional[pulumi.Input[bool]] = None,
                 reth_idx: Optional[pulumi.Input[int]] = None,
                 reth_node: Optional[pulumi.Input[str]] = None,
                 reth_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 speed: Optional[pulumi.Input[str]] = None,
                 ssr_no_virtual_mac: Optional[pulumi.Input[bool]] = None,
                 svr_port_range: Optional[pulumi.Input[str]] = None,
                 traffic_shaping: Optional[pulumi.Input['GatewayPortConfigTrafficShapingArgs']] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None,
                 vpn_paths: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigVpnPathsArgs']]]] = None,
                 wan_arp_policer: Optional[pulumi.Input[str]] = None,
                 wan_ext_ip: Optional[pulumi.Input[str]] = None,
                 wan_extra_routes: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigWanExtraRoutesArgs']]]] = None,
                 wan_probe_override: Optional[pulumi.Input['GatewayPortConfigWanProbeOverrideArgs']] = None,
                 wan_source_nat: Optional[pulumi.Input['GatewayPortConfigWanSourceNatArgs']] = None,
                 wan_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] usage: port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        :param pulumi.Input[bool] ae_disable_lacp: if `aggregated`==`true`. To disable LCP support for the AE interface
        :param pulumi.Input[str] ae_idx: if `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        :param pulumi.Input[bool] ae_lacp_force_up: For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability.\\n
               Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end\\n
               Note: Turning this on will enable force-up on one of the interfaces in the bundle only
        :param pulumi.Input[bool] critical: if want to generate port up/down alarm, set it to true
        :param pulumi.Input[bool] disabled: port admin up (true) / down (false)
        :param pulumi.Input[str] dsl_type: if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        :param pulumi.Input[int] dsl_vci: if `wan_type`==`dsl`
               16 bit int
        :param pulumi.Input[int] dsl_vpi: if `wan_type`==`dsl`
               8 bit int
        :param pulumi.Input[str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input['GatewayPortConfigIpConfigArgs'] ip_config: Junos IP Config
        :param pulumi.Input[str] lte_apn: if `wan_type`==`lte`
        :param pulumi.Input[str] lte_auth: if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        :param pulumi.Input[str] lte_password: if `wan_type`==`lte`
        :param pulumi.Input[str] lte_username: if `wan_type`==`lte`
        :param pulumi.Input[str] name: name that we'll use to derive config
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: if `usage`==`lan`
        :param pulumi.Input[int] outer_vlan_id: for Q-in-Q
        :param pulumi.Input[str] port_network: if `usage`==`lan`
        :param pulumi.Input[bool] preserve_dscp: whether to preserve dscp when sending traffic over VPN (SSR-only)
        :param pulumi.Input[bool] redundant: if HA mode
        :param pulumi.Input[int] reth_idx: if HA mode
        :param pulumi.Input[str] reth_node: if HA mode
        :param pulumi.Input[Sequence[pulumi.Input[str]]] reth_nodes: SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        :param pulumi.Input[bool] ssr_no_virtual_mac: when SSR is running as VM, this is required on certain hosting platforms
        :param pulumi.Input[str] svr_port_range: for SSR only
        :param pulumi.Input[int] vlan_id: if WAN interface is on a VLAN
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigVpnPathsArgs']]] vpn_paths: Property key is the VPN name
        :param pulumi.Input[str] wan_arp_policer: when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        :param pulumi.Input[str] wan_ext_ip: optional, if spoke should reach this port by a different IP
        :param pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigWanExtraRoutesArgs']]] wan_extra_routes: Property Key is the destianation CIDR (e.g "100.100.100.0/24")
        :param pulumi.Input['GatewayPortConfigWanProbeOverrideArgs'] wan_probe_override: if `usage`==`wan`
        :param pulumi.Input['GatewayPortConfigWanSourceNatArgs'] wan_source_nat: optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
        :param pulumi.Input[str] wan_type: if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_force_up is not None:
            pulumi.set(__self__, "ae_lacp_force_up", ae_lacp_force_up)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dsl_type is not None:
            pulumi.set(__self__, "dsl_type", dsl_type)
        if dsl_vci is not None:
            pulumi.set(__self__, "dsl_vci", dsl_vci)
        if dsl_vpi is not None:
            pulumi.set(__self__, "dsl_vpi", dsl_vpi)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if ip_config is not None:
            pulumi.set(__self__, "ip_config", ip_config)
        if lte_apn is not None:
            pulumi.set(__self__, "lte_apn", lte_apn)
        if lte_auth is not None:
            pulumi.set(__self__, "lte_auth", lte_auth)
        if lte_backup is not None:
            pulumi.set(__self__, "lte_backup", lte_backup)
        if lte_password is not None:
            pulumi.set(__self__, "lte_password", lte_password)
        if lte_username is not None:
            pulumi.set(__self__, "lte_username", lte_username)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if outer_vlan_id is not None:
            pulumi.set(__self__, "outer_vlan_id", outer_vlan_id)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if preserve_dscp is not None:
            pulumi.set(__self__, "preserve_dscp", preserve_dscp)
        if redundant is not None:
            pulumi.set(__self__, "redundant", redundant)
        if reth_idx is not None:
            pulumi.set(__self__, "reth_idx", reth_idx)
        if reth_node is not None:
            pulumi.set(__self__, "reth_node", reth_node)
        if reth_nodes is not None:
            pulumi.set(__self__, "reth_nodes", reth_nodes)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssr_no_virtual_mac is not None:
            pulumi.set(__self__, "ssr_no_virtual_mac", ssr_no_virtual_mac)
        if svr_port_range is not None:
            pulumi.set(__self__, "svr_port_range", svr_port_range)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)
        if wan_arp_policer is not None:
            pulumi.set(__self__, "wan_arp_policer", wan_arp_policer)
        if wan_ext_ip is not None:
            pulumi.set(__self__, "wan_ext_ip", wan_ext_ip)
        if wan_extra_routes is not None:
            pulumi.set(__self__, "wan_extra_routes", wan_extra_routes)
        if wan_probe_override is not None:
            pulumi.set(__self__, "wan_probe_override", wan_probe_override)
        if wan_source_nat is not None:
            pulumi.set(__self__, "wan_source_nat", wan_source_nat)
        if wan_type is not None:
            pulumi.set(__self__, "wan_type", wan_type)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[str]:
        """
        port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[pulumi.Input[bool]]:
        """
        if `aggregated`==`true`. To disable LCP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @ae_disable_lacp.setter
    def ae_disable_lacp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ae_disable_lacp", value)

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[pulumi.Input[str]]:
        """
        if `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
        """
        return pulumi.get(self, "ae_idx")

    @ae_idx.setter
    def ae_idx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ae_idx", value)

    @property
    @pulumi.getter(name="aeLacpForceUp")
    def ae_lacp_force_up(self) -> Optional[pulumi.Input[bool]]:
        """
        For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability.\\n
        Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end\\n
        Note: Turning this on will enable force-up on one of the interfaces in the bundle only
        """
        return pulumi.get(self, "ae_lacp_force_up")

    @ae_lacp_force_up.setter
    def ae_lacp_force_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ae_lacp_force_up", value)

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "aggregated")

    @aggregated.setter
    def aggregated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aggregated", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[bool]]:
        """
        if want to generate port up/down alarm, set it to true
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        port admin up (true) / down (false)
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="dslType")
    def dsl_type(self) -> Optional[pulumi.Input[str]]:
        """
        if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
        """
        return pulumi.get(self, "dsl_type")

    @dsl_type.setter
    def dsl_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dsl_type", value)

    @property
    @pulumi.getter(name="dslVci")
    def dsl_vci(self) -> Optional[pulumi.Input[int]]:
        """
        if `wan_type`==`dsl`
        16 bit int
        """
        return pulumi.get(self, "dsl_vci")

    @dsl_vci.setter
    def dsl_vci(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dsl_vci", value)

    @property
    @pulumi.getter(name="dslVpi")
    def dsl_vpi(self) -> Optional[pulumi.Input[int]]:
        """
        if `wan_type`==`dsl`
        8 bit int
        """
        return pulumi.get(self, "dsl_vpi")

    @dsl_vpi.setter
    def dsl_vpi(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dsl_vpi", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="ipConfig")
    def ip_config(self) -> Optional[pulumi.Input['GatewayPortConfigIpConfigArgs']]:
        """
        Junos IP Config
        """
        return pulumi.get(self, "ip_config")

    @ip_config.setter
    def ip_config(self, value: Optional[pulumi.Input['GatewayPortConfigIpConfigArgs']]):
        pulumi.set(self, "ip_config", value)

    @property
    @pulumi.getter(name="lteApn")
    def lte_apn(self) -> Optional[pulumi.Input[str]]:
        """
        if `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_apn")

    @lte_apn.setter
    def lte_apn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lte_apn", value)

    @property
    @pulumi.getter(name="lteAuth")
    def lte_auth(self) -> Optional[pulumi.Input[str]]:
        """
        if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "lte_auth")

    @lte_auth.setter
    def lte_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lte_auth", value)

    @property
    @pulumi.getter(name="lteBackup")
    def lte_backup(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "lte_backup")

    @lte_backup.setter
    def lte_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lte_backup", value)

    @property
    @pulumi.getter(name="ltePassword")
    def lte_password(self) -> Optional[pulumi.Input[str]]:
        """
        if `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_password")

    @lte_password.setter
    def lte_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lte_password", value)

    @property
    @pulumi.getter(name="lteUsername")
    def lte_username(self) -> Optional[pulumi.Input[str]]:
        """
        if `wan_type`==`lte`
        """
        return pulumi.get(self, "lte_username")

    @lte_username.setter
    def lte_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lte_username", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name that we'll use to derive config
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `usage`==`lan`
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="outerVlanId")
    def outer_vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        for Q-in-Q
        """
        return pulumi.get(self, "outer_vlan_id")

    @outer_vlan_id.setter
    def outer_vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "outer_vlan_id", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[pulumi.Input[str]]:
        """
        if `usage`==`lan`
        """
        return pulumi.get(self, "port_network")

    @port_network.setter
    def port_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_network", value)

    @property
    @pulumi.getter(name="preserveDscp")
    def preserve_dscp(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to preserve dscp when sending traffic over VPN (SSR-only)
        """
        return pulumi.get(self, "preserve_dscp")

    @preserve_dscp.setter
    def preserve_dscp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_dscp", value)

    @property
    @pulumi.getter
    def redundant(self) -> Optional[pulumi.Input[bool]]:
        """
        if HA mode
        """
        return pulumi.get(self, "redundant")

    @redundant.setter
    def redundant(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redundant", value)

    @property
    @pulumi.getter(name="rethIdx")
    def reth_idx(self) -> Optional[pulumi.Input[int]]:
        """
        if HA mode
        """
        return pulumi.get(self, "reth_idx")

    @reth_idx.setter
    def reth_idx(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reth_idx", value)

    @property
    @pulumi.getter(name="rethNode")
    def reth_node(self) -> Optional[pulumi.Input[str]]:
        """
        if HA mode
        """
        return pulumi.get(self, "reth_node")

    @reth_node.setter
    def reth_node(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reth_node", value)

    @property
    @pulumi.getter(name="rethNodes")
    def reth_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        SSR only - supporting vlan-based redundancy (matching the size of `networks`)
        """
        return pulumi.get(self, "reth_nodes")

    @reth_nodes.setter
    def reth_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "reth_nodes", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="ssrNoVirtualMac")
    def ssr_no_virtual_mac(self) -> Optional[pulumi.Input[bool]]:
        """
        when SSR is running as VM, this is required on certain hosting platforms
        """
        return pulumi.get(self, "ssr_no_virtual_mac")

    @ssr_no_virtual_mac.setter
    def ssr_no_virtual_mac(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssr_no_virtual_mac", value)

    @property
    @pulumi.getter(name="svrPortRange")
    def svr_port_range(self) -> Optional[pulumi.Input[str]]:
        """
        for SSR only
        """
        return pulumi.get(self, "svr_port_range")

    @svr_port_range.setter
    def svr_port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "svr_port_range", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['GatewayPortConfigTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['GatewayPortConfigTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        if WAN interface is on a VLAN
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigVpnPathsArgs']]]]:
        """
        Property key is the VPN name
        """
        return pulumi.get(self, "vpn_paths")

    @vpn_paths.setter
    def vpn_paths(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigVpnPathsArgs']]]]):
        pulumi.set(self, "vpn_paths", value)

    @property
    @pulumi.getter(name="wanArpPolicer")
    def wan_arp_policer(self) -> Optional[pulumi.Input[str]]:
        """
        when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
        """
        return pulumi.get(self, "wan_arp_policer")

    @wan_arp_policer.setter
    def wan_arp_policer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_arp_policer", value)

    @property
    @pulumi.getter(name="wanExtIp")
    def wan_ext_ip(self) -> Optional[pulumi.Input[str]]:
        """
        optional, if spoke should reach this port by a different IP
        """
        return pulumi.get(self, "wan_ext_ip")

    @wan_ext_ip.setter
    def wan_ext_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_ext_ip", value)

    @property
    @pulumi.getter(name="wanExtraRoutes")
    def wan_extra_routes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigWanExtraRoutesArgs']]]]:
        """
        Property Key is the destianation CIDR (e.g "100.100.100.0/24")
        """
        return pulumi.get(self, "wan_extra_routes")

    @wan_extra_routes.setter
    def wan_extra_routes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GatewayPortConfigWanExtraRoutesArgs']]]]):
        pulumi.set(self, "wan_extra_routes", value)

    @property
    @pulumi.getter(name="wanProbeOverride")
    def wan_probe_override(self) -> Optional[pulumi.Input['GatewayPortConfigWanProbeOverrideArgs']]:
        """
        if `usage`==`wan`
        """
        return pulumi.get(self, "wan_probe_override")

    @wan_probe_override.setter
    def wan_probe_override(self, value: Optional[pulumi.Input['GatewayPortConfigWanProbeOverrideArgs']]):
        pulumi.set(self, "wan_probe_override", value)

    @property
    @pulumi.getter(name="wanSourceNat")
    def wan_source_nat(self) -> Optional[pulumi.Input['GatewayPortConfigWanSourceNatArgs']]:
        """
        optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
        """
        return pulumi.get(self, "wan_source_nat")

    @wan_source_nat.setter
    def wan_source_nat(self, value: Optional[pulumi.Input['GatewayPortConfigWanSourceNatArgs']]):
        pulumi.set(self, "wan_source_nat", value)

    @property
    @pulumi.getter(name="wanType")
    def wan_type(self) -> Optional[pulumi.Input[str]]:
        """
        if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
        """
        return pulumi.get(self, "wan_type")

    @wan_type.setter
    def wan_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wan_type", value)


if not MYPY:
    class GatewayPortConfigIpConfigArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        except for out-of_band interface (vme/em0/fxp0)
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        except for out-of_band interface (vme/em0/fxp0)
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        except for out-of_band interface (vme/em0/fxp0)
        """
        ip: NotRequired[pulumi.Input[str]]
        netmask: NotRequired[pulumi.Input[str]]
        """
        used only if `subnet` is not specified in `networks`
        """
        network: NotRequired[pulumi.Input[str]]
        """
        optional, the network to be used for mgmt
        """
        poser_password: NotRequired[pulumi.Input[str]]
        """
        if `type`==`pppoe`
        """
        pppoe_auth: NotRequired[pulumi.Input[str]]
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        pppoe_username: NotRequired[pulumi.Input[str]]
        """
        if `type`==`pppoe`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `pppoe`, `static`
        """
elif False:
    GatewayPortConfigIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigIpConfigArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 poser_password: Optional[pulumi.Input[str]] = None,
                 pppoe_auth: Optional[pulumi.Input[str]] = None,
                 pppoe_username: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns: except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_suffixes: except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[str] gateway: except for out-of_band interface (vme/em0/fxp0)
        :param pulumi.Input[str] netmask: used only if `subnet` is not specified in `networks`
        :param pulumi.Input[str] network: optional, the network to be used for mgmt
        :param pulumi.Input[str] poser_password: if `type`==`pppoe`
        :param pulumi.Input[str] pppoe_auth: if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        :param pulumi.Input[str] pppoe_username: if `type`==`pppoe`
        :param pulumi.Input[str] type: enum: `dhcp`, `pppoe`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if poser_password is not None:
            pulumi.set(__self__, "poser_password", poser_password)
        if pppoe_auth is not None:
            pulumi.set(__self__, "pppoe_auth", pppoe_auth)
        if pppoe_username is not None:
            pulumi.set(__self__, "pppoe_username", pppoe_username)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        except for out-of_band interface (vme/em0/fxp0)
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="poserPassword")
    def poser_password(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`pppoe`
        """
        return pulumi.get(self, "poser_password")

    @poser_password.setter
    def poser_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "poser_password", value)

    @property
    @pulumi.getter(name="pppoeAuth")
    def pppoe_auth(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`pppoe`. enum: `chap`, `none`, `pap`
        """
        return pulumi.get(self, "pppoe_auth")

    @pppoe_auth.setter
    def pppoe_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pppoe_auth", value)

    @property
    @pulumi.getter(name="pppoeUsername")
    def pppoe_username(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`pppoe`
        """
        return pulumi.get(self, "pppoe_username")

    @pppoe_username.setter
    def pppoe_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pppoe_username", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `pppoe`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayPortConfigTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        percentages for differet class of traffic: high / medium / low / best-effort
        sum must be equal to 100
        """
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    GatewayPortConfigTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] class_percentages: percentages for differet class of traffic: high / medium / low / best-effort
               sum must be equal to 100
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        percentages for differet class of traffic: high / medium / low / best-effort
        sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewayPortConfigVpnPathsArgsDict(TypedDict):
        bfd_profile: NotRequired[pulumi.Input[str]]
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        bfd_use_tunnel_mode: NotRequired[pulumi.Input[bool]]
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        link_name: NotRequired[pulumi.Input[str]]
        """
        Only if the VPN `type`==`mesh`
        """
        preference: NotRequired[pulumi.Input[int]]
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Only if the VPN `type`==`hub_spoke`. enum: `hub`, `spoke`
        """
        traffic_shaping: NotRequired[pulumi.Input['GatewayPortConfigVpnPathsTrafficShapingArgsDict']]
elif False:
    GatewayPortConfigVpnPathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigVpnPathsArgs:
    def __init__(__self__, *,
                 bfd_profile: Optional[pulumi.Input[str]] = None,
                 bfd_use_tunnel_mode: Optional[pulumi.Input[bool]] = None,
                 link_name: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[int]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 traffic_shaping: Optional[pulumi.Input['GatewayPortConfigVpnPathsTrafficShapingArgs']] = None):
        """
        :param pulumi.Input[str] bfd_profile: Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        :param pulumi.Input[bool] bfd_use_tunnel_mode: Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        :param pulumi.Input[str] link_name: Only if the VPN `type`==`mesh`
        :param pulumi.Input[int] preference: Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        :param pulumi.Input[str] role: Only if the VPN `type`==`hub_spoke`. enum: `hub`, `spoke`
        """
        if bfd_profile is not None:
            pulumi.set(__self__, "bfd_profile", bfd_profile)
        if bfd_use_tunnel_mode is not None:
            pulumi.set(__self__, "bfd_use_tunnel_mode", bfd_use_tunnel_mode)
        if link_name is not None:
            pulumi.set(__self__, "link_name", link_name)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_shaping is not None:
            pulumi.set(__self__, "traffic_shaping", traffic_shaping)

    @property
    @pulumi.getter(name="bfdProfile")
    def bfd_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`
        """
        return pulumi.get(self, "bfd_profile")

    @bfd_profile.setter
    def bfd_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bfd_profile", value)

    @property
    @pulumi.getter(name="bfdUseTunnelMode")
    def bfd_use_tunnel_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only
        """
        return pulumi.get(self, "bfd_use_tunnel_mode")

    @bfd_use_tunnel_mode.setter
    def bfd_use_tunnel_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bfd_use_tunnel_mode", value)

    @property
    @pulumi.getter(name="linkName")
    def link_name(self) -> Optional[pulumi.Input[str]]:
        """
        Only if the VPN `type`==`mesh`
        """
        return pulumi.get(self, "link_name")

    @link_name.setter
    def link_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link_name", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        """
        Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Only if the VPN `type`==`hub_spoke`. enum: `hub`, `spoke`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="trafficShaping")
    def traffic_shaping(self) -> Optional[pulumi.Input['GatewayPortConfigVpnPathsTrafficShapingArgs']]:
        return pulumi.get(self, "traffic_shaping")

    @traffic_shaping.setter
    def traffic_shaping(self, value: Optional[pulumi.Input['GatewayPortConfigVpnPathsTrafficShapingArgs']]):
        pulumi.set(self, "traffic_shaping", value)


if not MYPY:
    class GatewayPortConfigVpnPathsTrafficShapingArgsDict(TypedDict):
        class_percentages: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        percentages for differet class of traffic: high / medium / low / best-effort
        sum must be equal to 100
        """
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    GatewayPortConfigVpnPathsTrafficShapingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigVpnPathsTrafficShapingArgs:
    def __init__(__self__, *,
                 class_percentages: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] class_percentages: percentages for differet class of traffic: high / medium / low / best-effort
               sum must be equal to 100
        """
        if class_percentages is not None:
            pulumi.set(__self__, "class_percentages", class_percentages)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="classPercentages")
    def class_percentages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        percentages for differet class of traffic: high / medium / low / best-effort
        sum must be equal to 100
        """
        return pulumi.get(self, "class_percentages")

    @class_percentages.setter
    def class_percentages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "class_percentages", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewayPortConfigWanExtraRoutesArgsDict(TypedDict):
        via: NotRequired[pulumi.Input[str]]
elif False:
    GatewayPortConfigWanExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigWanExtraRoutesArgs:
    def __init__(__self__, *,
                 via: Optional[pulumi.Input[str]] = None):
        if via is not None:
            pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "via", value)


if not MYPY:
    class GatewayPortConfigWanProbeOverrideArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        probe_profile: NotRequired[pulumi.Input[str]]
        """
        enum: `broadband`, `lte`
        """
elif False:
    GatewayPortConfigWanProbeOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigWanProbeOverrideArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 probe_profile: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] probe_profile: enum: `broadband`, `lte`
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if probe_profile is not None:
            pulumi.set(__self__, "probe_profile", probe_profile)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="probeProfile")
    def probe_profile(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `broadband`, `lte`
        """
        return pulumi.get(self, "probe_profile")

    @probe_profile.setter
    def probe_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probe_profile", value)


if not MYPY:
    class GatewayPortConfigWanSourceNatArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        or to disable the source-nat
        """
        nat_pool: NotRequired[pulumi.Input[str]]
        """
        if alternative nat_pool is desired
        """
elif False:
    GatewayPortConfigWanSourceNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortConfigWanSourceNatArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 nat_pool: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disabled: or to disable the source-nat
        :param pulumi.Input[str] nat_pool: if alternative nat_pool is desired
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if nat_pool is not None:
            pulumi.set(__self__, "nat_pool", nat_pool)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        or to disable the source-nat
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="natPool")
    def nat_pool(self) -> Optional[pulumi.Input[str]]:
        """
        if alternative nat_pool is desired
        """
        return pulumi.get(self, "nat_pool")

    @nat_pool.setter
    def nat_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nat_pool", value)


if not MYPY:
    class GatewayPortMirroringArgsDict(TypedDict):
        port_mirror: NotRequired[pulumi.Input['GatewayPortMirroringPortMirrorArgsDict']]
elif False:
    GatewayPortMirroringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortMirroringArgs:
    def __init__(__self__, *,
                 port_mirror: Optional[pulumi.Input['GatewayPortMirroringPortMirrorArgs']] = None):
        if port_mirror is not None:
            pulumi.set(__self__, "port_mirror", port_mirror)

    @property
    @pulumi.getter(name="portMirror")
    def port_mirror(self) -> Optional[pulumi.Input['GatewayPortMirroringPortMirrorArgs']]:
        return pulumi.get(self, "port_mirror")

    @port_mirror.setter
    def port_mirror(self, value: Optional[pulumi.Input['GatewayPortMirroringPortMirrorArgs']]):
        pulumi.set(self, "port_mirror", value)


if not MYPY:
    class GatewayPortMirroringPortMirrorArgsDict(TypedDict):
        family_type: NotRequired[pulumi.Input[str]]
        ingress_port_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        output_port_id: NotRequired[pulumi.Input[str]]
        rate: NotRequired[pulumi.Input[int]]
        run_length: NotRequired[pulumi.Input[int]]
elif False:
    GatewayPortMirroringPortMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayPortMirroringPortMirrorArgs:
    def __init__(__self__, *,
                 family_type: Optional[pulumi.Input[str]] = None,
                 ingress_port_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_port_id: Optional[pulumi.Input[str]] = None,
                 rate: Optional[pulumi.Input[int]] = None,
                 run_length: Optional[pulumi.Input[int]] = None):
        if family_type is not None:
            pulumi.set(__self__, "family_type", family_type)
        if ingress_port_ids is not None:
            pulumi.set(__self__, "ingress_port_ids", ingress_port_ids)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if run_length is not None:
            pulumi.set(__self__, "run_length", run_length)

    @property
    @pulumi.getter(name="familyType")
    def family_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "family_type")

    @family_type.setter
    def family_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family_type", value)

    @property
    @pulumi.getter(name="ingressPortIds")
    def ingress_port_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ingress_port_ids")

    @ingress_port_ids.setter
    def ingress_port_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ingress_port_ids", value)

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "output_port_id")

    @output_port_id.setter
    def output_port_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_port_id", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter(name="runLength")
    def run_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_length")

    @run_length.setter
    def run_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_length", value)


if not MYPY:
    class GatewayRoutingPoliciesArgsDict(TypedDict):
        terms: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayRoutingPoliciesTermArgsDict']]]]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
elif False:
    GatewayRoutingPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRoutingPoliciesArgs:
    def __init__(__self__, *,
                 terms: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRoutingPoliciesTermArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GatewayRoutingPoliciesTermArgs']]] terms: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @property
    @pulumi.getter
    def terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRoutingPoliciesTermArgs']]]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "terms")

    @terms.setter
    def terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayRoutingPoliciesTermArgs']]]]):
        pulumi.set(self, "terms", value)


if not MYPY:
    class GatewayRoutingPoliciesTermArgsDict(TypedDict):
        action: NotRequired[pulumi.Input['GatewayRoutingPoliciesTermActionArgsDict']]
        """
        when used as import policy
        """
        matching: NotRequired[pulumi.Input['GatewayRoutingPoliciesTermMatchingArgsDict']]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
elif False:
    GatewayRoutingPoliciesTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRoutingPoliciesTermArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['GatewayRoutingPoliciesTermActionArgs']] = None,
                 matching: Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingArgs']] = None):
        """
        :param pulumi.Input['GatewayRoutingPoliciesTermActionArgs'] action: when used as import policy
        :param pulumi.Input['GatewayRoutingPoliciesTermMatchingArgs'] matching: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if matching is not None:
            pulumi.set(__self__, "matching", matching)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['GatewayRoutingPoliciesTermActionArgs']]:
        """
        when used as import policy
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['GatewayRoutingPoliciesTermActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def matching(self) -> Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingArgs']]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "matching")

    @matching.setter
    def matching(self, value: Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingArgs']]):
        pulumi.set(self, "matching", value)


if not MYPY:
    class GatewayRoutingPoliciesTermActionArgsDict(TypedDict):
        accept: NotRequired[pulumi.Input[bool]]
        add_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        add_target_vrfs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        for SSR, hub decides how VRF routes are leaked on spoke
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        when used as export policy, optional
        """
        exclude_as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        when used as export policy, optional. To exclude certain AS
        """
        exclude_communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        export_communitites: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        when used as export policy, optional
        """
        local_preference: NotRequired[pulumi.Input[str]]
        """
        optional, for an import policy, local_preference can be changed
        """
        prepend_as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        when used as export policy, optional. By default, the local AS will be prepended, to change it
        """
elif False:
    GatewayRoutingPoliciesTermActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRoutingPoliciesTermActionArgs:
    def __init__(__self__, *,
                 accept: Optional[pulumi.Input[bool]] = None,
                 add_communities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 add_target_vrfs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_communities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 export_communitites: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 local_preference: Optional[pulumi.Input[str]] = None,
                 prepend_as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] add_target_vrfs: for SSR, hub decides how VRF routes are leaked on spoke
        :param pulumi.Input[Sequence[pulumi.Input[str]]] communities: when used as export policy, optional
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_as_paths: when used as export policy, optional. To exclude certain AS
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_communitites: when used as export policy, optional
        :param pulumi.Input[str] local_preference: optional, for an import policy, local_preference can be changed
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prepend_as_paths: when used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if add_communities is not None:
            pulumi.set(__self__, "add_communities", add_communities)
        if add_target_vrfs is not None:
            pulumi.set(__self__, "add_target_vrfs", add_target_vrfs)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if exclude_as_paths is not None:
            pulumi.set(__self__, "exclude_as_paths", exclude_as_paths)
        if exclude_communities is not None:
            pulumi.set(__self__, "exclude_communities", exclude_communities)
        if export_communitites is not None:
            pulumi.set(__self__, "export_communitites", export_communitites)
        if local_preference is not None:
            pulumi.set(__self__, "local_preference", local_preference)
        if prepend_as_paths is not None:
            pulumi.set(__self__, "prepend_as_paths", prepend_as_paths)

    @property
    @pulumi.getter
    def accept(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "accept")

    @accept.setter
    def accept(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept", value)

    @property
    @pulumi.getter(name="addCommunities")
    def add_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add_communities")

    @add_communities.setter
    def add_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add_communities", value)

    @property
    @pulumi.getter(name="addTargetVrfs")
    def add_target_vrfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        for SSR, hub decides how VRF routes are leaked on spoke
        """
        return pulumi.get(self, "add_target_vrfs")

    @add_target_vrfs.setter
    def add_target_vrfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add_target_vrfs", value)

    @property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when used as export policy, optional
        """
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "communities", value)

    @property
    @pulumi.getter(name="excludeAsPaths")
    def exclude_as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when used as export policy, optional. To exclude certain AS
        """
        return pulumi.get(self, "exclude_as_paths")

    @exclude_as_paths.setter
    def exclude_as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_as_paths", value)

    @property
    @pulumi.getter(name="excludeCommunities")
    def exclude_communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclude_communities")

    @exclude_communities.setter
    def exclude_communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_communities", value)

    @property
    @pulumi.getter(name="exportCommunitites")
    def export_communitites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when used as export policy, optional
        """
        return pulumi.get(self, "export_communitites")

    @export_communitites.setter
    def export_communitites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_communitites", value)

    @property
    @pulumi.getter(name="localPreference")
    def local_preference(self) -> Optional[pulumi.Input[str]]:
        """
        optional, for an import policy, local_preference can be changed
        """
        return pulumi.get(self, "local_preference")

    @local_preference.setter
    def local_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_preference", value)

    @property
    @pulumi.getter(name="prependAsPaths")
    def prepend_as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        when used as export policy, optional. By default, the local AS will be prepended, to change it
        """
        return pulumi.get(self, "prepend_as_paths")

    @prepend_as_paths.setter
    def prepend_as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prepend_as_paths", value)


if not MYPY:
    class GatewayRoutingPoliciesTermMatchingArgsDict(TypedDict):
        as_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        takes regular expression
        """
        communities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        `direct`, `bgp`, `osp`, ...
        """
        route_exists: NotRequired[pulumi.Input['GatewayRoutingPoliciesTermMatchingRouteExistsArgsDict']]
        vpn_neighbor_macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        vpn_path_sla: NotRequired[pulumi.Input['GatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict']]
        vpn_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        ordered-
        """
elif False:
    GatewayRoutingPoliciesTermMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRoutingPoliciesTermMatchingArgs:
    def __init__(__self__, *,
                 as_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 communities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 route_exists: Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingRouteExistsArgs']] = None,
                 vpn_neighbor_macs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vpn_path_sla: Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingVpnPathSlaArgs']] = None,
                 vpn_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] as_paths: takes regular expression
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefixes: zero or more criteria/filter can be specified to match the term, all criteria have to be met
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: `direct`, `bgp`, `osp`, ...
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vpn_neighbor_macs: overlay-facing criteria (used for bgp_config where via=vpn)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vpn_paths: overlay-facing criteria (used for bgp_config where via=vpn)
               ordered-
        """
        if as_paths is not None:
            pulumi.set(__self__, "as_paths", as_paths)
        if communities is not None:
            pulumi.set(__self__, "communities", communities)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_exists is not None:
            pulumi.set(__self__, "route_exists", route_exists)
        if vpn_neighbor_macs is not None:
            pulumi.set(__self__, "vpn_neighbor_macs", vpn_neighbor_macs)
        if vpn_path_sla is not None:
            pulumi.set(__self__, "vpn_path_sla", vpn_path_sla)
        if vpn_paths is not None:
            pulumi.set(__self__, "vpn_paths", vpn_paths)

    @property
    @pulumi.getter(name="asPaths")
    def as_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        takes regular expression
        """
        return pulumi.get(self, "as_paths")

    @as_paths.setter
    def as_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "as_paths", value)

    @property
    @pulumi.getter
    def communities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "communities")

    @communities.setter
    def communities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "communities", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        zero or more criteria/filter can be specified to match the term, all criteria have to be met
        """
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        `direct`, `bgp`, `osp`, ...
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="routeExists")
    def route_exists(self) -> Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingRouteExistsArgs']]:
        return pulumi.get(self, "route_exists")

    @route_exists.setter
    def route_exists(self, value: Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingRouteExistsArgs']]):
        pulumi.set(self, "route_exists", value)

    @property
    @pulumi.getter(name="vpnNeighborMacs")
    def vpn_neighbor_macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        """
        return pulumi.get(self, "vpn_neighbor_macs")

    @vpn_neighbor_macs.setter
    def vpn_neighbor_macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vpn_neighbor_macs", value)

    @property
    @pulumi.getter(name="vpnPathSla")
    def vpn_path_sla(self) -> Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingVpnPathSlaArgs']]:
        return pulumi.get(self, "vpn_path_sla")

    @vpn_path_sla.setter
    def vpn_path_sla(self, value: Optional[pulumi.Input['GatewayRoutingPoliciesTermMatchingVpnPathSlaArgs']]):
        pulumi.set(self, "vpn_path_sla", value)

    @property
    @pulumi.getter(name="vpnPaths")
    def vpn_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        overlay-facing criteria (used for bgp_config where via=vpn)
        ordered-
        """
        return pulumi.get(self, "vpn_paths")

    @vpn_paths.setter
    def vpn_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vpn_paths", value)


if not MYPY:
    class GatewayRoutingPoliciesTermMatchingRouteExistsArgsDict(TypedDict):
        route: NotRequired[pulumi.Input[str]]
        vrf_name: NotRequired[pulumi.Input[str]]
        """
        name of the vrf instance
        it can also be the name of the VPN or wan if they
        """
elif False:
    GatewayRoutingPoliciesTermMatchingRouteExistsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRoutingPoliciesTermMatchingRouteExistsArgs:
    def __init__(__self__, *,
                 route: Optional[pulumi.Input[str]] = None,
                 vrf_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vrf_name: name of the vrf instance
               it can also be the name of the VPN or wan if they
        """
        if route is not None:
            pulumi.set(__self__, "route", route)
        if vrf_name is not None:
            pulumi.set(__self__, "vrf_name", vrf_name)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the vrf instance
        it can also be the name of the VPN or wan if they
        """
        return pulumi.get(self, "vrf_name")

    @vrf_name.setter
    def vrf_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vrf_name", value)


if not MYPY:
    class GatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict(TypedDict):
        max_jitter: NotRequired[pulumi.Input[int]]
        max_latency: NotRequired[pulumi.Input[int]]
        max_loss: NotRequired[pulumi.Input[int]]
elif False:
    GatewayRoutingPoliciesTermMatchingVpnPathSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRoutingPoliciesTermMatchingVpnPathSlaArgs:
    def __init__(__self__, *,
                 max_jitter: Optional[pulumi.Input[int]] = None,
                 max_latency: Optional[pulumi.Input[int]] = None,
                 max_loss: Optional[pulumi.Input[int]] = None):
        if max_jitter is not None:
            pulumi.set(__self__, "max_jitter", max_jitter)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_loss is not None:
            pulumi.set(__self__, "max_loss", max_loss)

    @property
    @pulumi.getter(name="maxJitter")
    def max_jitter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_jitter")

    @max_jitter.setter
    def max_jitter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_jitter", value)

    @property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_latency", value)

    @property
    @pulumi.getter(name="maxLoss")
    def max_loss(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_loss")

    @max_loss.setter
    def max_loss(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_loss", value)


if not MYPY:
    class GatewayServicePolicyArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        appqoe: NotRequired[pulumi.Input['GatewayServicePolicyAppqoeArgsDict']]
        """
        For SRX Only
        """
        ewfs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayServicePolicyEwfArgsDict']]]]
        idp: NotRequired[pulumi.Input['GatewayServicePolicyIdpArgsDict']]
        local_routing: NotRequired[pulumi.Input[bool]]
        """
        access within the same VRF
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        path_preference: NotRequired[pulumi.Input[str]]
        """
        by default, we derive all paths available and use them
        optionally, you can customize by using `path_preference`
        """
        servicepolicy_id: NotRequired[pulumi.Input[str]]
        """
        used to link servicepolicy defined at org level and overwrite some attributes
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Desctinations
        """
        tenants: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
elif False:
    GatewayServicePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayServicePolicyArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 appqoe: Optional[pulumi.Input['GatewayServicePolicyAppqoeArgs']] = None,
                 ewfs: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayServicePolicyEwfArgs']]]] = None,
                 idp: Optional[pulumi.Input['GatewayServicePolicyIdpArgs']] = None,
                 local_routing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path_preference: Optional[pulumi.Input[str]] = None,
                 servicepolicy_id: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tenants: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        :param pulumi.Input['GatewayServicePolicyAppqoeArgs'] appqoe: For SRX Only
        :param pulumi.Input[bool] local_routing: access within the same VRF
        :param pulumi.Input[str] name: Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        :param pulumi.Input[str] path_preference: by default, we derive all paths available and use them
               optionally, you can customize by using `path_preference`
        :param pulumi.Input[str] servicepolicy_id: used to link servicepolicy defined at org level and overwrite some attributes
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: Required when `servicepolicy_id` is not defined. List of Applications / Desctinations
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tenants: Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if appqoe is not None:
            pulumi.set(__self__, "appqoe", appqoe)
        if ewfs is not None:
            pulumi.set(__self__, "ewfs", ewfs)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if local_routing is not None:
            pulumi.set(__self__, "local_routing", local_routing)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path_preference is not None:
            pulumi.set(__self__, "path_preference", path_preference)
        if servicepolicy_id is not None:
            pulumi.set(__self__, "servicepolicy_id", servicepolicy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def appqoe(self) -> Optional[pulumi.Input['GatewayServicePolicyAppqoeArgs']]:
        """
        For SRX Only
        """
        return pulumi.get(self, "appqoe")

    @appqoe.setter
    def appqoe(self, value: Optional[pulumi.Input['GatewayServicePolicyAppqoeArgs']]):
        pulumi.set(self, "appqoe", value)

    @property
    @pulumi.getter
    def ewfs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayServicePolicyEwfArgs']]]]:
        return pulumi.get(self, "ewfs")

    @ewfs.setter
    def ewfs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayServicePolicyEwfArgs']]]]):
        pulumi.set(self, "ewfs", value)

    @property
    @pulumi.getter
    def idp(self) -> Optional[pulumi.Input['GatewayServicePolicyIdpArgs']]:
        return pulumi.get(self, "idp")

    @idp.setter
    def idp(self, value: Optional[pulumi.Input['GatewayServicePolicyIdpArgs']]):
        pulumi.set(self, "idp", value)

    @property
    @pulumi.getter(name="localRouting")
    def local_routing(self) -> Optional[pulumi.Input[bool]]:
        """
        access within the same VRF
        """
        return pulumi.get(self, "local_routing")

    @local_routing.setter
    def local_routing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_routing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pathPreference")
    def path_preference(self) -> Optional[pulumi.Input[str]]:
        """
        by default, we derive all paths available and use them
        optionally, you can customize by using `path_preference`
        """
        return pulumi.get(self, "path_preference")

    @path_preference.setter
    def path_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_preference", value)

    @property
    @pulumi.getter(name="servicepolicyId")
    def servicepolicy_id(self) -> Optional[pulumi.Input[str]]:
        """
        used to link servicepolicy defined at org level and overwrite some attributes
        """
        return pulumi.get(self, "servicepolicy_id")

    @servicepolicy_id.setter
    def servicepolicy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "servicepolicy_id", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Required when `servicepolicy_id` is not defined. List of Applications / Desctinations
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Required when `servicepolicy_id` is not defined. List of Networks / Users
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tenants", value)


if not MYPY:
    class GatewayServicePolicyAppqoeArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    GatewayServicePolicyAppqoeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayServicePolicyAppqoeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewayServicePolicyEwfArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[bool]]
        block_message: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        profile: NotRequired[pulumi.Input[str]]
        """
        enum: `critical`, `standard`, `strict`
        """
elif False:
    GatewayServicePolicyEwfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayServicePolicyEwfArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[bool]] = None,
                 block_message: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 profile: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] profile: enum: `critical`, `standard`, `strict`
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if block_message is not None:
            pulumi.set(__self__, "block_message", block_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter(name="blockMessage")
    def block_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "block_message")

    @block_message.setter
    def block_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_message", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `critical`, `standard`, `strict`
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class GatewayServicePolicyIdpArgsDict(TypedDict):
        alert_only: NotRequired[pulumi.Input[bool]]
        enabled: NotRequired[pulumi.Input[bool]]
        idpprofile_id: NotRequired[pulumi.Input[str]]
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        profile: NotRequired[pulumi.Input[str]]
        """
        `strict` (default) / `standard` / or keys from from idp_profiles
        """
elif False:
    GatewayServicePolicyIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayServicePolicyIdpArgs:
    def __init__(__self__, *,
                 alert_only: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 idpprofile_id: Optional[pulumi.Input[str]] = None,
                 profile: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] idpprofile_id: org_level IDP Profile can be used, this takes precedence over `profile`
        :param pulumi.Input[str] profile: `strict` (default) / `standard` / or keys from from idp_profiles
        """
        if alert_only is not None:
            pulumi.set(__self__, "alert_only", alert_only)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idpprofile_id is not None:
            pulumi.set(__self__, "idpprofile_id", idpprofile_id)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter(name="alertOnly")
    def alert_only(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "alert_only")

    @alert_only.setter
    def alert_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_only", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idpprofileId")
    def idpprofile_id(self) -> Optional[pulumi.Input[str]]:
        """
        org_level IDP Profile can be used, this takes precedence over `profile`
        """
        return pulumi.get(self, "idpprofile_id")

    @idpprofile_id.setter
    def idpprofile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idpprofile_id", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[str]]:
        """
        `strict` (default) / `standard` / or keys from from idp_profiles
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class GatewayTunnelConfigsArgsDict(TypedDict):
        auto_provision: NotRequired[pulumi.Input['GatewayTunnelConfigsAutoProvisionArgsDict']]
        ike_lifetime: NotRequired[pulumi.Input[int]]
        """
        Only if `provider`== `custom-ipsec`
        """
        ike_mode: NotRequired[pulumi.Input[str]]
        """
        Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
        """
        ike_proposals: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIkeProposalArgsDict']]]]
        """
        if `provider`== `custom-ipsec`
        """
        ipsec_lifetime: NotRequired[pulumi.Input[int]]
        """
        if `provider`== `custom-ipsec`
        """
        ipsec_proposals: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIpsecProposalArgsDict']]]]
        """
        Only if  `provider`== `custom-ipsec`
        """
        local_id: NotRequired[pulumi.Input[str]]
        """
        Only if:
          * `provider`== `zscaler-ipsec`
          * `provider`==`jse-ipsec`
          * `provider`== `custom-ipsec`
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        enum: `active-active`, `active-standby`
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        networks reachable via this tunnel
        """
        primary: NotRequired[pulumi.Input['GatewayTunnelConfigsPrimaryArgsDict']]
        probe: NotRequired[pulumi.Input['GatewayTunnelConfigsProbeArgsDict']]
        """
        Only if `provider`== `custom-ipsec`
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        psk: NotRequired[pulumi.Input[str]]
        """
        Only if:
          * `provider`== `zscaler-ipsec`
          * `provider`==`jse-ipsec`
          * `provider`== `custom-ipsec`
        """
        secondary: NotRequired[pulumi.Input['GatewayTunnelConfigsSecondaryArgsDict']]
        version: NotRequired[pulumi.Input[str]]
        """
        Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
        """
elif False:
    GatewayTunnelConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsArgs:
    def __init__(__self__, *,
                 auto_provision: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionArgs']] = None,
                 ike_lifetime: Optional[pulumi.Input[int]] = None,
                 ike_mode: Optional[pulumi.Input[str]] = None,
                 ike_proposals: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIkeProposalArgs']]]] = None,
                 ipsec_lifetime: Optional[pulumi.Input[int]] = None,
                 ipsec_proposals: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIpsecProposalArgs']]]] = None,
                 local_id: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary: Optional[pulumi.Input['GatewayTunnelConfigsPrimaryArgs']] = None,
                 probe: Optional[pulumi.Input['GatewayTunnelConfigsProbeArgs']] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 psk: Optional[pulumi.Input[str]] = None,
                 secondary: Optional[pulumi.Input['GatewayTunnelConfigsSecondaryArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] ike_lifetime: Only if `provider`== `custom-ipsec`
        :param pulumi.Input[str] ike_mode: Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
        :param pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIkeProposalArgs']]] ike_proposals: if `provider`== `custom-ipsec`
        :param pulumi.Input[int] ipsec_lifetime: if `provider`== `custom-ipsec`
        :param pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIpsecProposalArgs']]] ipsec_proposals: Only if  `provider`== `custom-ipsec`
        :param pulumi.Input[str] local_id: Only if:
                 * `provider`== `zscaler-ipsec`
                 * `provider`==`jse-ipsec`
                 * `provider`== `custom-ipsec`
        :param pulumi.Input[str] mode: enum: `active-active`, `active-standby`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: networks reachable via this tunnel
        :param pulumi.Input['GatewayTunnelConfigsProbeArgs'] probe: Only if `provider`== `custom-ipsec`
        :param pulumi.Input[str] protocol: Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
        :param pulumi.Input[str] provider: enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        :param pulumi.Input[str] psk: Only if:
                 * `provider`== `zscaler-ipsec`
                 * `provider`==`jse-ipsec`
                 * `provider`== `custom-ipsec`
        :param pulumi.Input[str] version: Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
        """
        if auto_provision is not None:
            pulumi.set(__self__, "auto_provision", auto_provision)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if ike_mode is not None:
            pulumi.set(__self__, "ike_mode", ike_mode)
        if ike_proposals is not None:
            pulumi.set(__self__, "ike_proposals", ike_proposals)
        if ipsec_lifetime is not None:
            pulumi.set(__self__, "ipsec_lifetime", ipsec_lifetime)
        if ipsec_proposals is not None:
            pulumi.set(__self__, "ipsec_proposals", ipsec_proposals)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if probe is not None:
            pulumi.set(__self__, "probe", probe)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if psk is not None:
            pulumi.set(__self__, "psk", psk)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="autoProvision")
    def auto_provision(self) -> Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionArgs']]:
        return pulumi.get(self, "auto_provision")

    @auto_provision.setter
    def auto_provision(self, value: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionArgs']]):
        pulumi.set(self, "auto_provision", value)

    @property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ike_lifetime", value)

    @property
    @pulumi.getter(name="ikeMode")
    def ike_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
        """
        return pulumi.get(self, "ike_mode")

    @ike_mode.setter
    def ike_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ike_mode", value)

    @property
    @pulumi.getter(name="ikeProposals")
    def ike_proposals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIkeProposalArgs']]]]:
        """
        if `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "ike_proposals")

    @ike_proposals.setter
    def ike_proposals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIkeProposalArgs']]]]):
        pulumi.set(self, "ike_proposals", value)

    @property
    @pulumi.getter(name="ipsecLifetime")
    def ipsec_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        if `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "ipsec_lifetime")

    @ipsec_lifetime.setter
    def ipsec_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ipsec_lifetime", value)

    @property
    @pulumi.getter(name="ipsecProposals")
    def ipsec_proposals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIpsecProposalArgs']]]]:
        """
        Only if  `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "ipsec_proposals")

    @ipsec_proposals.setter
    def ipsec_proposals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelConfigsIpsecProposalArgs']]]]):
        pulumi.set(self, "ipsec_proposals", value)

    @property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[str]]:
        """
        Only if:
          * `provider`== `zscaler-ipsec`
          * `provider`==`jse-ipsec`
          * `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_id", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `active-active`, `active-standby`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        networks reachable via this tunnel
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['GatewayTunnelConfigsPrimaryArgs']]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['GatewayTunnelConfigsPrimaryArgs']]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def probe(self) -> Optional[pulumi.Input['GatewayTunnelConfigsProbeArgs']]:
        """
        Only if `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "probe")

    @probe.setter
    def probe(self, value: Optional[pulumi.Input['GatewayTunnelConfigsProbeArgs']]):
        pulumi.set(self, "probe", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def psk(self) -> Optional[pulumi.Input[str]]:
        """
        Only if:
          * `provider`== `zscaler-ipsec`
          * `provider`==`jse-ipsec`
          * `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psk", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input['GatewayTunnelConfigsSecondaryArgs']]:
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input['GatewayTunnelConfigsSecondaryArgs']]):
        pulumi.set(self, "secondary", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GatewayTunnelConfigsAutoProvisionArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[bool]]
        latlng: NotRequired[pulumi.Input['GatewayTunnelConfigsAutoProvisionLatlngArgsDict']]
        primary: NotRequired[pulumi.Input['GatewayTunnelConfigsAutoProvisionPrimaryArgsDict']]
        secondary: NotRequired[pulumi.Input['GatewayTunnelConfigsAutoProvisionSecondaryArgsDict']]
elif False:
    GatewayTunnelConfigsAutoProvisionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsAutoProvisionArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 latlng: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionLatlngArgs']] = None,
                 primary: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionPrimaryArgs']] = None,
                 secondary: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionSecondaryArgs']] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if latlng is not None:
            pulumi.set(__self__, "latlng", latlng)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if secondary is not None:
            pulumi.set(__self__, "secondary", secondary)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def latlng(self) -> Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionLatlngArgs']]:
        return pulumi.get(self, "latlng")

    @latlng.setter
    def latlng(self, value: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionLatlngArgs']]):
        pulumi.set(self, "latlng", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionPrimaryArgs']]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionPrimaryArgs']]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def secondary(self) -> Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionSecondaryArgs']]:
        return pulumi.get(self, "secondary")

    @secondary.setter
    def secondary(self, value: Optional[pulumi.Input['GatewayTunnelConfigsAutoProvisionSecondaryArgs']]):
        pulumi.set(self, "secondary", value)


if not MYPY:
    class GatewayTunnelConfigsAutoProvisionLatlngArgsDict(TypedDict):
        lat: pulumi.Input[float]
        lng: pulumi.Input[float]
elif False:
    GatewayTunnelConfigsAutoProvisionLatlngArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsAutoProvisionLatlngArgs:
    def __init__(__self__, *,
                 lat: pulumi.Input[float],
                 lng: pulumi.Input[float]):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @property
    @pulumi.getter
    def lat(self) -> pulumi.Input[float]:
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: pulumi.Input[float]):
        pulumi.set(self, "lat", value)

    @property
    @pulumi.getter
    def lng(self) -> pulumi.Input[float]:
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: pulumi.Input[float]):
        pulumi.set(self, "lng", value)


if not MYPY:
    class GatewayTunnelConfigsAutoProvisionPrimaryArgsDict(TypedDict):
        num_hosts: NotRequired[pulumi.Input[str]]
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        optional, only needed if `vars_only`==`false`
        """
elif False:
    GatewayTunnelConfigsAutoProvisionPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsAutoProvisionPrimaryArgs:
    def __init__(__self__, *,
                 num_hosts: Optional[pulumi.Input[str]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wan_names: optional, only needed if `vars_only`==`false`
        """
        if num_hosts is not None:
            pulumi.set(__self__, "num_hosts", num_hosts)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter(name="numHosts")
    def num_hosts(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "num_hosts")

    @num_hosts.setter
    def num_hosts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "num_hosts", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class GatewayTunnelConfigsAutoProvisionSecondaryArgsDict(TypedDict):
        num_hosts: NotRequired[pulumi.Input[str]]
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        optional, only needed if `vars_only`==`false`
        """
elif False:
    GatewayTunnelConfigsAutoProvisionSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsAutoProvisionSecondaryArgs:
    def __init__(__self__, *,
                 num_hosts: Optional[pulumi.Input[str]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wan_names: optional, only needed if `vars_only`==`false`
        """
        if num_hosts is not None:
            pulumi.set(__self__, "num_hosts", num_hosts)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter(name="numHosts")
    def num_hosts(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "num_hosts")

    @num_hosts.setter
    def num_hosts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "num_hosts", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        optional, only needed if `vars_only`==`false`
        """
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class GatewayTunnelConfigsIkeProposalArgsDict(TypedDict):
        auth_algo: NotRequired[pulumi.Input[str]]
        """
        enum: `md5`, `sha1`, `sha2`
        """
        dh_group: NotRequired[pulumi.Input[str]]
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        enc_algo: NotRequired[pulumi.Input[str]]
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
elif False:
    GatewayTunnelConfigsIkeProposalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsIkeProposalArgs:
    def __init__(__self__, *,
                 auth_algo: Optional[pulumi.Input[str]] = None,
                 dh_group: Optional[pulumi.Input[str]] = None,
                 enc_algo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_algo: enum: `md5`, `sha1`, `sha2`
        :param pulumi.Input[str] dh_group: enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param pulumi.Input[str] enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @auth_algo.setter
    def auth_algo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_algo", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[str]]:
        """
        enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")

    @enc_algo.setter
    def enc_algo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enc_algo", value)


if not MYPY:
    class GatewayTunnelConfigsIpsecProposalArgsDict(TypedDict):
        auth_algo: NotRequired[pulumi.Input[str]]
        """
        enum: `md5`, `sha1`, `sha2`
        """
        dh_group: NotRequired[pulumi.Input[str]]
        """
        Only if `provider`== `custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        enc_algo: NotRequired[pulumi.Input[str]]
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
elif False:
    GatewayTunnelConfigsIpsecProposalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsIpsecProposalArgs:
    def __init__(__self__, *,
                 auth_algo: Optional[pulumi.Input[str]] = None,
                 dh_group: Optional[pulumi.Input[str]] = None,
                 enc_algo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_algo: enum: `md5`, `sha1`, `sha2`
        :param pulumi.Input[str] dh_group: Only if `provider`== `custom-ipsec`. enum:
                 * 1
                 * 2 (1024-bit)
                 * 5
                 * 14 (default, 2048-bit)
                 * 15 (3072-bit)
                 * 16 (4096-bit)
                 * 19 (256-bit ECP)
                 * 20 (384-bit ECP)
                 * 21 (521-bit ECP)
                 * 24 (2048-bit ECP)
        :param pulumi.Input[str] enc_algo: enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        if auth_algo is not None:
            pulumi.set(__self__, "auth_algo", auth_algo)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if enc_algo is not None:
            pulumi.set(__self__, "enc_algo", enc_algo)

    @property
    @pulumi.getter(name="authAlgo")
    def auth_algo(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `md5`, `sha1`, `sha2`
        """
        return pulumi.get(self, "auth_algo")

    @auth_algo.setter
    def auth_algo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_algo", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `provider`== `custom-ipsec`. enum:
          * 1
          * 2 (1024-bit)
          * 5
          * 14 (default, 2048-bit)
          * 15 (3072-bit)
          * 16 (4096-bit)
          * 19 (256-bit ECP)
          * 20 (384-bit ECP)
          * 21 (521-bit ECP)
          * 24 (2048-bit ECP)
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="encAlgo")
    def enc_algo(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
        """
        return pulumi.get(self, "enc_algo")

    @enc_algo.setter
    def enc_algo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enc_algo", value)


if not MYPY:
    class GatewayTunnelConfigsPrimaryArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        internal_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only if:
          * `provider`== `zscaler-gre`
          * `provider`== `custom-gre`
        """
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        remote_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only if `provider`== `custom-ipsec`
        """
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    GatewayTunnelConfigsPrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsPrimaryArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 internal_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 remote_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] internal_ips: Only if:
                 * `provider`== `zscaler-gre`
                 * `provider`== `custom-gre`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remote_ids: Only if `provider`== `custom-ipsec`
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if:
          * `provider`== `zscaler-gre`
          * `provider`== `custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @internal_ips.setter
    def internal_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "internal_ips", value)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")

    @remote_ids.setter
    def remote_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remote_ids", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class GatewayTunnelConfigsProbeArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[int]]
        """
        how often to trigger the probe
        """
        threshold: NotRequired[pulumi.Input[int]]
        """
        number of consecutive misses before declaring the tunnel down
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        time within which to complete the connectivity check
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `http`, `icmp`
        """
elif False:
    GatewayTunnelConfigsProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsProbeArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] interval: how often to trigger the probe
        :param pulumi.Input[int] threshold: number of consecutive misses before declaring the tunnel down
        :param pulumi.Input[int] timeout: time within which to complete the connectivity check
        :param pulumi.Input[str] type: enum: `http`, `icmp`
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        how often to trigger the probe
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[int]]:
        """
        number of consecutive misses before declaring the tunnel down
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        time within which to complete the connectivity check
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `http`, `icmp`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayTunnelConfigsSecondaryArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        internal_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only if:
          * `provider`== `zscaler-gre`
          * `provider`== `custom-gre`
        """
        probe_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        remote_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only if `provider`== `custom-ipsec`
        """
        wan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    GatewayTunnelConfigsSecondaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelConfigsSecondaryArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 internal_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 probe_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 remote_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wan_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] internal_ips: Only if:
                 * `provider`== `zscaler-gre`
                 * `provider`== `custom-gre`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] remote_ids: Only if `provider`== `custom-ipsec`
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if internal_ips is not None:
            pulumi.set(__self__, "internal_ips", internal_ips)
        if probe_ips is not None:
            pulumi.set(__self__, "probe_ips", probe_ips)
        if remote_ids is not None:
            pulumi.set(__self__, "remote_ids", remote_ids)
        if wan_names is not None:
            pulumi.set(__self__, "wan_names", wan_names)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="internalIps")
    def internal_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if:
          * `provider`== `zscaler-gre`
          * `provider`== `custom-gre`
        """
        return pulumi.get(self, "internal_ips")

    @internal_ips.setter
    def internal_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "internal_ips", value)

    @property
    @pulumi.getter(name="probeIps")
    def probe_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "probe_ips")

    @probe_ips.setter
    def probe_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "probe_ips", value)

    @property
    @pulumi.getter(name="remoteIds")
    def remote_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if `provider`== `custom-ipsec`
        """
        return pulumi.get(self, "remote_ids")

    @remote_ids.setter
    def remote_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remote_ids", value)

    @property
    @pulumi.getter(name="wanNames")
    def wan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "wan_names")

    @wan_names.setter
    def wan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wan_names", value)


if not MYPY:
    class GatewayTunnelProviderOptionsArgsDict(TypedDict):
        jse: NotRequired[pulumi.Input['GatewayTunnelProviderOptionsJseArgsDict']]
        """
        for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        zscaler: NotRequired[pulumi.Input['GatewayTunnelProviderOptionsZscalerArgsDict']]
        """
        for zscaler-ipsec and zscaler-gre
        """
elif False:
    GatewayTunnelProviderOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelProviderOptionsArgs:
    def __init__(__self__, *,
                 jse: Optional[pulumi.Input['GatewayTunnelProviderOptionsJseArgs']] = None,
                 zscaler: Optional[pulumi.Input['GatewayTunnelProviderOptionsZscalerArgs']] = None):
        """
        :param pulumi.Input['GatewayTunnelProviderOptionsJseArgs'] jse: for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
        :param pulumi.Input['GatewayTunnelProviderOptionsZscalerArgs'] zscaler: for zscaler-ipsec and zscaler-gre
        """
        if jse is not None:
            pulumi.set(__self__, "jse", jse)
        if zscaler is not None:
            pulumi.set(__self__, "zscaler", zscaler)

    @property
    @pulumi.getter
    def jse(self) -> Optional[pulumi.Input['GatewayTunnelProviderOptionsJseArgs']]:
        """
        for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
        """
        return pulumi.get(self, "jse")

    @jse.setter
    def jse(self, value: Optional[pulumi.Input['GatewayTunnelProviderOptionsJseArgs']]):
        pulumi.set(self, "jse", value)

    @property
    @pulumi.getter
    def zscaler(self) -> Optional[pulumi.Input['GatewayTunnelProviderOptionsZscalerArgs']]:
        """
        for zscaler-ipsec and zscaler-gre
        """
        return pulumi.get(self, "zscaler")

    @zscaler.setter
    def zscaler(self, value: Optional[pulumi.Input['GatewayTunnelProviderOptionsZscalerArgs']]):
        pulumi.set(self, "zscaler", value)


if not MYPY:
    class GatewayTunnelProviderOptionsJseArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        num_users: NotRequired[pulumi.Input[int]]
elif False:
    GatewayTunnelProviderOptionsJseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelProviderOptionsJseArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 num_users: Optional[pulumi.Input[int]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_users is not None:
            pulumi.set(__self__, "num_users", num_users)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numUsers")
    def num_users(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_users")

    @num_users.setter
    def num_users(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_users", value)


if not MYPY:
    class GatewayTunnelProviderOptionsZscalerArgsDict(TypedDict):
        aup_acceptance_required: NotRequired[pulumi.Input[bool]]
        aup_expire: NotRequired[pulumi.Input[int]]
        """
        days before AUP is requested again
        """
        aup_ssl_proxy: NotRequired[pulumi.Input[bool]]
        """
        proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        download_mbps: NotRequired[pulumi.Input[int]]
        """
        the download bandwidth cap of the link, in Mbps
        """
        enable_aup: NotRequired[pulumi.Input[bool]]
        """
        if `use_xff`==`true`, display Acceptable Use Policy (AUP)
        """
        enable_caution: NotRequired[pulumi.Input[bool]]
        """
        when `enforce_authentication`==`false`, display caution notification for non-authenticated users
        """
        enforce_authentication: NotRequired[pulumi.Input[bool]]
        name: NotRequired[pulumi.Input[str]]
        sub_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelProviderOptionsZscalerSubLocationArgsDict']]]]
        """
        if `use_xff`==`true`
        """
        upload_mbps: NotRequired[pulumi.Input[int]]
        """
        the download bandwidth cap of the link, in Mbps
        """
        use_xff: NotRequired[pulumi.Input[bool]]
        """
        location uses proxy chaining to forward traffic
        """
elif False:
    GatewayTunnelProviderOptionsZscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelProviderOptionsZscalerArgs:
    def __init__(__self__, *,
                 aup_acceptance_required: Optional[pulumi.Input[bool]] = None,
                 aup_expire: Optional[pulumi.Input[int]] = None,
                 aup_ssl_proxy: Optional[pulumi.Input[bool]] = None,
                 download_mbps: Optional[pulumi.Input[int]] = None,
                 enable_aup: Optional[pulumi.Input[bool]] = None,
                 enable_caution: Optional[pulumi.Input[bool]] = None,
                 enforce_authentication: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 sub_locations: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelProviderOptionsZscalerSubLocationArgs']]]] = None,
                 upload_mbps: Optional[pulumi.Input[int]] = None,
                 use_xff: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] aup_expire: days before AUP is requested again
        :param pulumi.Input[bool] aup_ssl_proxy: proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param pulumi.Input[int] download_mbps: the download bandwidth cap of the link, in Mbps
        :param pulumi.Input[bool] enable_aup: if `use_xff`==`true`, display Acceptable Use Policy (AUP)
        :param pulumi.Input[bool] enable_caution: when `enforce_authentication`==`false`, display caution notification for non-authenticated users
        :param pulumi.Input[Sequence[pulumi.Input['GatewayTunnelProviderOptionsZscalerSubLocationArgs']]] sub_locations: if `use_xff`==`true`
        :param pulumi.Input[int] upload_mbps: the download bandwidth cap of the link, in Mbps
        :param pulumi.Input[bool] use_xff: location uses proxy chaining to forward traffic
        """
        if aup_acceptance_required is not None:
            pulumi.set(__self__, "aup_acceptance_required", aup_acceptance_required)
        if aup_expire is not None:
            pulumi.set(__self__, "aup_expire", aup_expire)
        if aup_ssl_proxy is not None:
            pulumi.set(__self__, "aup_ssl_proxy", aup_ssl_proxy)
        if download_mbps is not None:
            pulumi.set(__self__, "download_mbps", download_mbps)
        if enable_aup is not None:
            pulumi.set(__self__, "enable_aup", enable_aup)
        if enable_caution is not None:
            pulumi.set(__self__, "enable_caution", enable_caution)
        if enforce_authentication is not None:
            pulumi.set(__self__, "enforce_authentication", enforce_authentication)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sub_locations is not None:
            pulumi.set(__self__, "sub_locations", sub_locations)
        if upload_mbps is not None:
            pulumi.set(__self__, "upload_mbps", upload_mbps)
        if use_xff is not None:
            pulumi.set(__self__, "use_xff", use_xff)

    @property
    @pulumi.getter(name="aupAcceptanceRequired")
    def aup_acceptance_required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "aup_acceptance_required")

    @aup_acceptance_required.setter
    def aup_acceptance_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aup_acceptance_required", value)

    @property
    @pulumi.getter(name="aupExpire")
    def aup_expire(self) -> Optional[pulumi.Input[int]]:
        """
        days before AUP is requested again
        """
        return pulumi.get(self, "aup_expire")

    @aup_expire.setter
    def aup_expire(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "aup_expire", value)

    @property
    @pulumi.getter(name="aupSslProxy")
    def aup_ssl_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_ssl_proxy")

    @aup_ssl_proxy.setter
    def aup_ssl_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aup_ssl_proxy", value)

    @property
    @pulumi.getter(name="downloadMbps")
    def download_mbps(self) -> Optional[pulumi.Input[int]]:
        """
        the download bandwidth cap of the link, in Mbps
        """
        return pulumi.get(self, "download_mbps")

    @download_mbps.setter
    def download_mbps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "download_mbps", value)

    @property
    @pulumi.getter(name="enableAup")
    def enable_aup(self) -> Optional[pulumi.Input[bool]]:
        """
        if `use_xff`==`true`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "enable_aup")

    @enable_aup.setter
    def enable_aup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_aup", value)

    @property
    @pulumi.getter(name="enableCaution")
    def enable_caution(self) -> Optional[pulumi.Input[bool]]:
        """
        when `enforce_authentication`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "enable_caution")

    @enable_caution.setter
    def enable_caution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_caution", value)

    @property
    @pulumi.getter(name="enforceAuthentication")
    def enforce_authentication(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enforce_authentication")

    @enforce_authentication.setter
    def enforce_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce_authentication", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subLocations")
    def sub_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelProviderOptionsZscalerSubLocationArgs']]]]:
        """
        if `use_xff`==`true`
        """
        return pulumi.get(self, "sub_locations")

    @sub_locations.setter
    def sub_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayTunnelProviderOptionsZscalerSubLocationArgs']]]]):
        pulumi.set(self, "sub_locations", value)

    @property
    @pulumi.getter(name="uploadMbps")
    def upload_mbps(self) -> Optional[pulumi.Input[int]]:
        """
        the download bandwidth cap of the link, in Mbps
        """
        return pulumi.get(self, "upload_mbps")

    @upload_mbps.setter
    def upload_mbps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "upload_mbps", value)

    @property
    @pulumi.getter(name="useXff")
    def use_xff(self) -> Optional[pulumi.Input[bool]]:
        """
        location uses proxy chaining to forward traffic
        """
        return pulumi.get(self, "use_xff")

    @use_xff.setter
    def use_xff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_xff", value)


if not MYPY:
    class GatewayTunnelProviderOptionsZscalerSubLocationArgsDict(TypedDict):
        aup_acceptance_required: NotRequired[pulumi.Input[bool]]
        aup_expire: NotRequired[pulumi.Input[int]]
        """
        days before AUP is requested again
        """
        aup_ssl_proxy: NotRequired[pulumi.Input[bool]]
        """
        proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        download_mbps: NotRequired[pulumi.Input[int]]
        """
        the download bandwidth cap of the link, in Mbps
        """
        enable_aup: NotRequired[pulumi.Input[bool]]
        """
        if `use_xff`==`true`, display Acceptable Use Policy (AUP)
        """
        enable_caution: NotRequired[pulumi.Input[bool]]
        """
        when `enforce_authentication`==`false`, display caution notification for non-authenticated users
        """
        enforce_authentication: NotRequired[pulumi.Input[bool]]
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        upload_mbps: NotRequired[pulumi.Input[int]]
        """
        the download bandwidth cap of the link, in Mbps
        """
elif False:
    GatewayTunnelProviderOptionsZscalerSubLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayTunnelProviderOptionsZscalerSubLocationArgs:
    def __init__(__self__, *,
                 aup_acceptance_required: Optional[pulumi.Input[bool]] = None,
                 aup_expire: Optional[pulumi.Input[int]] = None,
                 aup_ssl_proxy: Optional[pulumi.Input[bool]] = None,
                 download_mbps: Optional[pulumi.Input[int]] = None,
                 enable_aup: Optional[pulumi.Input[bool]] = None,
                 enable_caution: Optional[pulumi.Input[bool]] = None,
                 enforce_authentication: Optional[pulumi.Input[bool]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 upload_mbps: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] aup_expire: days before AUP is requested again
        :param pulumi.Input[bool] aup_ssl_proxy: proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        :param pulumi.Input[int] download_mbps: the download bandwidth cap of the link, in Mbps
        :param pulumi.Input[bool] enable_aup: if `use_xff`==`true`, display Acceptable Use Policy (AUP)
        :param pulumi.Input[bool] enable_caution: when `enforce_authentication`==`false`, display caution notification for non-authenticated users
        :param pulumi.Input[int] upload_mbps: the download bandwidth cap of the link, in Mbps
        """
        if aup_acceptance_required is not None:
            pulumi.set(__self__, "aup_acceptance_required", aup_acceptance_required)
        if aup_expire is not None:
            pulumi.set(__self__, "aup_expire", aup_expire)
        if aup_ssl_proxy is not None:
            pulumi.set(__self__, "aup_ssl_proxy", aup_ssl_proxy)
        if download_mbps is not None:
            pulumi.set(__self__, "download_mbps", download_mbps)
        if enable_aup is not None:
            pulumi.set(__self__, "enable_aup", enable_aup)
        if enable_caution is not None:
            pulumi.set(__self__, "enable_caution", enable_caution)
        if enforce_authentication is not None:
            pulumi.set(__self__, "enforce_authentication", enforce_authentication)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if upload_mbps is not None:
            pulumi.set(__self__, "upload_mbps", upload_mbps)

    @property
    @pulumi.getter(name="aupAcceptanceRequired")
    def aup_acceptance_required(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "aup_acceptance_required")

    @aup_acceptance_required.setter
    def aup_acceptance_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aup_acceptance_required", value)

    @property
    @pulumi.getter(name="aupExpire")
    def aup_expire(self) -> Optional[pulumi.Input[int]]:
        """
        days before AUP is requested again
        """
        return pulumi.get(self, "aup_expire")

    @aup_expire.setter
    def aup_expire(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "aup_expire", value)

    @property
    @pulumi.getter(name="aupSslProxy")
    def aup_ssl_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
        """
        return pulumi.get(self, "aup_ssl_proxy")

    @aup_ssl_proxy.setter
    def aup_ssl_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aup_ssl_proxy", value)

    @property
    @pulumi.getter(name="downloadMbps")
    def download_mbps(self) -> Optional[pulumi.Input[int]]:
        """
        the download bandwidth cap of the link, in Mbps
        """
        return pulumi.get(self, "download_mbps")

    @download_mbps.setter
    def download_mbps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "download_mbps", value)

    @property
    @pulumi.getter(name="enableAup")
    def enable_aup(self) -> Optional[pulumi.Input[bool]]:
        """
        if `use_xff`==`true`, display Acceptable Use Policy (AUP)
        """
        return pulumi.get(self, "enable_aup")

    @enable_aup.setter
    def enable_aup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_aup", value)

    @property
    @pulumi.getter(name="enableCaution")
    def enable_caution(self) -> Optional[pulumi.Input[bool]]:
        """
        when `enforce_authentication`==`false`, display caution notification for non-authenticated users
        """
        return pulumi.get(self, "enable_caution")

    @enable_caution.setter
    def enable_caution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_caution", value)

    @property
    @pulumi.getter(name="enforceAuthentication")
    def enforce_authentication(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enforce_authentication")

    @enforce_authentication.setter
    def enforce_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce_authentication", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="uploadMbps")
    def upload_mbps(self) -> Optional[pulumi.Input[int]]:
        """
        the download bandwidth cap of the link, in Mbps
        """
        return pulumi.get(self, "upload_mbps")

    @upload_mbps.setter
    def upload_mbps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "upload_mbps", value)


if not MYPY:
    class GatewayVrfConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        whether to enable VRF (when supported on the device)
        """
elif False:
    GatewayVrfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayVrfConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GatewayVrfInstancesArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    GatewayVrfInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayVrfInstancesArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class SwitchAclPolicyArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchAclPolicyActionArgsDict']]]]
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        name: NotRequired[pulumi.Input[str]]
        src_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
elif False:
    SwitchAclPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAclPolicyArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchAclPolicyActionArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 src_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SwitchAclPolicyActionArgs']]] actions: - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
               - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        :param pulumi.Input[Sequence[pulumi.Input[str]]] src_tags: - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
               - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_tags is not None:
            pulumi.set(__self__, "src_tags", src_tags)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchAclPolicyActionArgs']]]]:
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchAclPolicyActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="srcTags")
    def src_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
        - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
        """
        return pulumi.get(self, "src_tags")

    @src_tags.setter
    def src_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "src_tags", value)


if not MYPY:
    class SwitchAclPolicyActionArgsDict(TypedDict):
        dst_tag: pulumi.Input[str]
        action: NotRequired[pulumi.Input[str]]
        """
        enum: `allow`, `deny`
        """
elif False:
    SwitchAclPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAclPolicyActionArgs:
    def __init__(__self__, *,
                 dst_tag: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: enum: `allow`, `deny`
        """
        pulumi.set(__self__, "dst_tag", dst_tag)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter(name="dstTag")
    def dst_tag(self) -> pulumi.Input[str]:
        return pulumi.get(self, "dst_tag")

    @dst_tag.setter
    def dst_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "dst_tag", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `allow`, `deny`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class SwitchAclTagsArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        enum: 
          * `any`: matching anything not identified
          * `dynamic_gbp`: from the gbp_tag received from RADIUS
          * `gbp_resource`: can only be used in `dst_tags`
          * `mac`
          * `network`
          * `radius_group`
          * `resource`: can only be used in `dst_tags`
          * `static_gbp`: applying gbp tag against matching conditions
          * `subnet`'
        """
        gbp_tag: NotRequired[pulumi.Input[int]]
        """
        required if
        - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
        - `type`==`gbp_resource`
        - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        macs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        network: NotRequired[pulumi.Input[str]]
        """
        if:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)'
        """
        radius_group: NotRequired[pulumi.Input[str]]
        """
        required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchAclTagsSpecArgsDict']]]]
        """
        if `type`==`resource` or `type`==`gbp_resource`
        empty means unrestricted, i.e. any
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
elif False:
    SwitchAclTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAclTagsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 gbp_tag: Optional[pulumi.Input[int]] = None,
                 macs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 radius_group: Optional[pulumi.Input[str]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchAclTagsSpecArgs']]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: enum: 
                 * `any`: matching anything not identified
                 * `dynamic_gbp`: from the gbp_tag received from RADIUS
                 * `gbp_resource`: can only be used in `dst_tags`
                 * `mac`
                 * `network`
                 * `radius_group`
                 * `resource`: can only be used in `dst_tags`
                 * `static_gbp`: applying gbp tag against matching conditions
                 * `subnet`'
        :param pulumi.Input[int] gbp_tag: required if
               - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
               - `type`==`gbp_resource`
               - `type`==`static_gbp` (applying gbp tag against matching conditions)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] macs: required if 
               - `type`==`mac`
               - `type`==`static_gbp` if from matching mac
        :param pulumi.Input[str] network: if:
                 * `type`==`mac` (optional. default is `any`)
                 * `type`==`subnet` (optional. default is `any`)
                 * `type`==`network`
                 * `type`==`resource` (optional. default is `any`)
                 * `type`==`static_gbp` if from matching network (vlan)'
        :param pulumi.Input[str] radius_group: required if:
                 * `type`==`radius_group`
                 * `type`==`static_gbp`
               if from matching radius_group
        :param pulumi.Input[Sequence[pulumi.Input['SwitchAclTagsSpecArgs']]] specs: if `type`==`resource` or `type`==`gbp_resource`
               empty means unrestricted, i.e. any
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: if 
               - `type`==`subnet` 
               - `type`==`resource` (optional. default is `any`)
               - `type`==`static_gbp` if from matching subnet
        """
        pulumi.set(__self__, "type", type)
        if gbp_tag is not None:
            pulumi.set(__self__, "gbp_tag", gbp_tag)
        if macs is not None:
            pulumi.set(__self__, "macs", macs)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if radius_group is not None:
            pulumi.set(__self__, "radius_group", radius_group)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        enum: 
          * `any`: matching anything not identified
          * `dynamic_gbp`: from the gbp_tag received from RADIUS
          * `gbp_resource`: can only be used in `dst_tags`
          * `mac`
          * `network`
          * `radius_group`
          * `resource`: can only be used in `dst_tags`
          * `static_gbp`: applying gbp tag against matching conditions
          * `subnet`'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="gbpTag")
    def gbp_tag(self) -> Optional[pulumi.Input[int]]:
        """
        required if
        - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
        - `type`==`gbp_resource`
        - `type`==`static_gbp` (applying gbp tag against matching conditions)
        """
        return pulumi.get(self, "gbp_tag")

    @gbp_tag.setter
    def gbp_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gbp_tag", value)

    @property
    @pulumi.getter
    def macs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        required if 
        - `type`==`mac`
        - `type`==`static_gbp` if from matching mac
        """
        return pulumi.get(self, "macs")

    @macs.setter
    def macs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "macs", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        if:
          * `type`==`mac` (optional. default is `any`)
          * `type`==`subnet` (optional. default is `any`)
          * `type`==`network`
          * `type`==`resource` (optional. default is `any`)
          * `type`==`static_gbp` if from matching network (vlan)'
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="radiusGroup")
    def radius_group(self) -> Optional[pulumi.Input[str]]:
        """
        required if:
          * `type`==`radius_group`
          * `type`==`static_gbp`
        if from matching radius_group
        """
        return pulumi.get(self, "radius_group")

    @radius_group.setter
    def radius_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "radius_group", value)

    @property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchAclTagsSpecArgs']]]]:
        """
        if `type`==`resource` or `type`==`gbp_resource`
        empty means unrestricted, i.e. any
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchAclTagsSpecArgs']]]]):
        pulumi.set(self, "specs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if 
        - `type`==`subnet` 
        - `type`==`resource` (optional. default is `any`)
        - `type`==`static_gbp` if from matching subnet
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class SwitchAclTagsSpecArgsDict(TypedDict):
        port_range: NotRequired[pulumi.Input[str]]
        """
        matched dst port, "0" means any
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
elif False:
    SwitchAclTagsSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchAclTagsSpecArgs:
    def __init__(__self__, *,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port_range: matched dst port, "0" means any
        :param pulumi.Input[str] protocol: `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        matched dst port, "0" means any
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class SwitchDhcpSnoopingArgsDict(TypedDict):
        all_networks: NotRequired[pulumi.Input[bool]]
        enable_arp_spoof_check: NotRequired[pulumi.Input[bool]]
        """
        Enable for dynamic ARP inspection check
        """
        enable_ip_source_guard: NotRequired[pulumi.Input[bool]]
        """
        Enable for check for forging source IP address
        """
        enabled: NotRequired[pulumi.Input[bool]]
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
elif False:
    SwitchDhcpSnoopingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpSnoopingArgs:
    def __init__(__self__, *,
                 all_networks: Optional[pulumi.Input[bool]] = None,
                 enable_arp_spoof_check: Optional[pulumi.Input[bool]] = None,
                 enable_ip_source_guard: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enable_arp_spoof_check: Enable for dynamic ARP inspection check
        :param pulumi.Input[bool] enable_ip_source_guard: Enable for check for forging source IP address
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if enable_arp_spoof_check is not None:
            pulumi.set(__self__, "enable_arp_spoof_check", enable_arp_spoof_check)
        if enable_ip_source_guard is not None:
            pulumi.set(__self__, "enable_ip_source_guard", enable_ip_source_guard)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "all_networks")

    @all_networks.setter
    def all_networks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all_networks", value)

    @property
    @pulumi.getter(name="enableArpSpoofCheck")
    def enable_arp_spoof_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable for dynamic ARP inspection check
        """
        return pulumi.get(self, "enable_arp_spoof_check")

    @enable_arp_spoof_check.setter
    def enable_arp_spoof_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_arp_spoof_check", value)

    @property
    @pulumi.getter(name="enableIpSourceGuard")
    def enable_ip_source_guard(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable for check for forging source IP address
        """
        return pulumi.get(self, "enable_ip_source_guard")

    @enable_ip_source_guard.setter
    def enable_ip_source_guard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_source_guard", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `all_networks`==`false`, list of network with DHCP snooping enabled
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class SwitchDhcpdConfigArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigArgsDict']]]]
        """
        Property key is the network name
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        if set to `true`, enable the DHCP server
        """
elif False:
    SwitchDhcpdConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpdConfigArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigArgs']]] config: Property key is the network name
        :param pulumi.Input[bool] enabled: if set to `true`, enable the DHCP server
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigArgs']]]]:
        """
        Property key is the network name
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigArgs']]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        if set to `true`, enable the DHCP server
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SwitchDhcpdConfigConfigArgsDict(TypedDict):
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        """
        fixed_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigFixedBindingsArgsDict']]]]
        """
        if `type`==`server` or `type6`==`server`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        if `type`==`server`  - optional, `ip` will be used if not provided
        """
        ip_end: NotRequired[pulumi.Input[str]]
        """
        if `type`==`server`
        """
        ip_end6: NotRequired[pulumi.Input[str]]
        """
        if `type6`==`server`
        """
        ip_start: NotRequired[pulumi.Input[str]]
        """
        if `type`==`server`
        """
        ip_start6: NotRequired[pulumi.Input[str]]
        """
        if `type6`==`server`
        """
        lease_time: NotRequired[pulumi.Input[int]]
        """
        in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigOptionsArgsDict']]]]
        """
        if `type`==`server` or `type6`==`server`. Property key is the DHCP option number
        """
        server_id_override: NotRequired[pulumi.Input[bool]]
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type`==`relay`
        """
        servers6s: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        if `type6`==`relay`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        """
        type6: NotRequired[pulumi.Input[str]]
        """
        enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        """
        vendor_encapulated: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigVendorEncapulatedArgsDict']]]]
        """
        if `type`==`server` or `type6`==`server`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code'
        """
elif False:
    SwitchDhcpdConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpdConfigConfigArgs:
    def __init__(__self__, *,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fixed_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigFixedBindingsArgs']]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip_end: Optional[pulumi.Input[str]] = None,
                 ip_end6: Optional[pulumi.Input[str]] = None,
                 ip_start: Optional[pulumi.Input[str]] = None,
                 ip_start6: Optional[pulumi.Input[str]] = None,
                 lease_time: Optional[pulumi.Input[int]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigOptionsArgs']]]] = None,
                 server_id_override: Optional[pulumi.Input[bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 servers6s: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 type6: Optional[pulumi.Input[str]] = None,
                 vendor_encapulated: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigVendorEncapulatedArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_suffixes: if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigFixedBindingsArgs']]] fixed_bindings: if `type`==`server` or `type6`==`server`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        :param pulumi.Input[str] gateway: if `type`==`server`  - optional, `ip` will be used if not provided
        :param pulumi.Input[str] ip_end: if `type`==`server`
        :param pulumi.Input[str] ip_end6: if `type6`==`server`
        :param pulumi.Input[str] ip_start: if `type`==`server`
        :param pulumi.Input[str] ip_start6: if `type6`==`server`
        :param pulumi.Input[int] lease_time: in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigOptionsArgs']]] options: if `type`==`server` or `type6`==`server`. Property key is the DHCP option number
        :param pulumi.Input[bool] server_id_override: `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
               should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers: if `type`==`relay`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers6s: if `type6`==`relay`
        :param pulumi.Input[str] type: enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        :param pulumi.Input[str] type6: enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigVendorEncapulatedArgs']]] vendor_encapulated: if `type`==`server` or `type6`==`server`. Property key is <enterprise number>:<sub option code>, with
                 * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
                 * sub option code: 1-255, sub-option code'
        """
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if fixed_bindings is not None:
            pulumi.set(__self__, "fixed_bindings", fixed_bindings)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip_end is not None:
            pulumi.set(__self__, "ip_end", ip_end)
        if ip_end6 is not None:
            pulumi.set(__self__, "ip_end6", ip_end6)
        if ip_start is not None:
            pulumi.set(__self__, "ip_start", ip_start)
        if ip_start6 is not None:
            pulumi.set(__self__, "ip_start6", ip_start6)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if server_id_override is not None:
            pulumi.set(__self__, "server_id_override", server_id_override)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if servers6s is not None:
            pulumi.set(__self__, "servers6s", servers6s)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)
        if vendor_encapulated is not None:
            pulumi.set(__self__, "vendor_encapulated", vendor_encapulated)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
        """
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter(name="fixedBindings")
    def fixed_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigFixedBindingsArgs']]]]:
        """
        if `type`==`server` or `type6`==`server`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
        """
        return pulumi.get(self, "fixed_bindings")

    @fixed_bindings.setter
    def fixed_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigFixedBindingsArgs']]]]):
        pulumi.set(self, "fixed_bindings", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`server`  - optional, `ip` will be used if not provided
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="ipEnd")
    def ip_end(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`server`
        """
        return pulumi.get(self, "ip_end")

    @ip_end.setter
    def ip_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_end", value)

    @property
    @pulumi.getter(name="ipEnd6")
    def ip_end6(self) -> Optional[pulumi.Input[str]]:
        """
        if `type6`==`server`
        """
        return pulumi.get(self, "ip_end6")

    @ip_end6.setter
    def ip_end6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_end6", value)

    @property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> Optional[pulumi.Input[str]]:
        """
        if `type`==`server`
        """
        return pulumi.get(self, "ip_start")

    @ip_start.setter
    def ip_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_start", value)

    @property
    @pulumi.getter(name="ipStart6")
    def ip_start6(self) -> Optional[pulumi.Input[str]]:
        """
        if `type6`==`server`
        """
        return pulumi.get(self, "ip_start6")

    @ip_start6.setter
    def ip_start6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_start6", value)

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[pulumi.Input[int]]:
        """
        in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
        """
        return pulumi.get(self, "lease_time")

    @lease_time.setter
    def lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lease_time", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigOptionsArgs']]]]:
        """
        if `type`==`server` or `type6`==`server`. Property key is the DHCP option number
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigOptionsArgs']]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="serverIdOverride")
    def server_id_override(self) -> Optional[pulumi.Input[bool]]:
        """
        `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
        should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
        """
        return pulumi.get(self, "server_id_override")

    @server_id_override.setter
    def server_id_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_id_override", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type`==`relay`
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter
    def servers6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        if `type6`==`relay`
        """
        return pulumi.get(self, "servers6s")

    @servers6s.setter
    def servers6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers6s", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type6", value)

    @property
    @pulumi.getter(name="vendorEncapulated")
    def vendor_encapulated(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigVendorEncapulatedArgs']]]]:
        """
        if `type`==`server` or `type6`==`server`. Property key is <enterprise number>:<sub option code>, with
          * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
          * sub option code: 1-255, sub-option code'
        """
        return pulumi.get(self, "vendor_encapulated")

    @vendor_encapulated.setter
    def vendor_encapulated(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchDhcpdConfigConfigVendorEncapulatedArgs']]]]):
        pulumi.set(self, "vendor_encapulated", value)


if not MYPY:
    class SwitchDhcpdConfigConfigFixedBindingsArgsDict(TypedDict):
        ip: pulumi.Input[str]
        name: NotRequired[pulumi.Input[str]]
elif False:
    SwitchDhcpdConfigConfigFixedBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpdConfigConfigFixedBindingsArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwitchDhcpdConfigConfigOptionsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    SwitchDhcpdConfigConfigOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpdConfigConfigOptionsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwitchDhcpdConfigConfigVendorEncapulatedArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    SwitchDhcpdConfigConfigVendorEncapulatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchDhcpdConfigConfigVendorEncapulatedArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SwitchEvpnConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        role: NotRequired[pulumi.Input[str]]
        """
        enum: `access`, `core`, `distribution`
        """
elif False:
    SwitchEvpnConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchEvpnConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role: enum: `access`, `core`, `distribution`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `access`, `core`, `distribution`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class SwitchExtraRoutes6ArgsDict(TypedDict):
        via: pulumi.Input[str]
        """
        next-hop IP Address
        """
        discard: NotRequired[pulumi.Input[bool]]
        """
        this takes precedence
        """
        metric: NotRequired[pulumi.Input[int]]
        next_qualified: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutes6NextQualifiedArgsDict']]]]
        no_resolve: NotRequired[pulumi.Input[bool]]
        preference: NotRequired[pulumi.Input[int]]
elif False:
    SwitchExtraRoutes6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchExtraRoutes6Args:
    def __init__(__self__, *,
                 via: pulumi.Input[str],
                 discard: Optional[pulumi.Input[bool]] = None,
                 metric: Optional[pulumi.Input[int]] = None,
                 next_qualified: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutes6NextQualifiedArgs']]]] = None,
                 no_resolve: Optional[pulumi.Input[bool]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] via: next-hop IP Address
        :param pulumi.Input[bool] discard: this takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        """
        next-hop IP Address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[bool]]:
        """
        this takes precedence
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutes6NextQualifiedArgs']]]]:
        return pulumi.get(self, "next_qualified")

    @next_qualified.setter
    def next_qualified(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutes6NextQualifiedArgs']]]]):
        pulumi.set(self, "next_qualified", value)

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "no_resolve")

    @no_resolve.setter
    def no_resolve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_resolve", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class SwitchExtraRoutes6NextQualifiedArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[int]]
        preference: NotRequired[pulumi.Input[int]]
elif False:
    SwitchExtraRoutes6NextQualifiedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchExtraRoutes6NextQualifiedArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[int]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class SwitchExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[str]
        """
        next-hop IP Address
        """
        discard: NotRequired[pulumi.Input[bool]]
        """
        this takes precedence
        """
        metric: NotRequired[pulumi.Input[int]]
        next_qualified: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutesNextQualifiedArgsDict']]]]
        no_resolve: NotRequired[pulumi.Input[bool]]
        preference: NotRequired[pulumi.Input[int]]
elif False:
    SwitchExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[str],
                 discard: Optional[pulumi.Input[bool]] = None,
                 metric: Optional[pulumi.Input[int]] = None,
                 next_qualified: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutesNextQualifiedArgs']]]] = None,
                 no_resolve: Optional[pulumi.Input[bool]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] via: next-hop IP Address
        :param pulumi.Input[bool] discard: this takes precedence
        """
        pulumi.set(__self__, "via", via)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if next_qualified is not None:
            pulumi.set(__self__, "next_qualified", next_qualified)
        if no_resolve is not None:
            pulumi.set(__self__, "no_resolve", no_resolve)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        """
        next-hop IP Address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[bool]]:
        """
        this takes precedence
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="nextQualified")
    def next_qualified(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutesNextQualifiedArgs']]]]:
        return pulumi.get(self, "next_qualified")

    @next_qualified.setter
    def next_qualified(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchExtraRoutesNextQualifiedArgs']]]]):
        pulumi.set(self, "next_qualified", value)

    @property
    @pulumi.getter(name="noResolve")
    def no_resolve(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "no_resolve")

    @no_resolve.setter
    def no_resolve(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_resolve", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class SwitchExtraRoutesNextQualifiedArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[int]]
        preference: NotRequired[pulumi.Input[int]]
elif False:
    SwitchExtraRoutesNextQualifiedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchExtraRoutesNextQualifiedArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[int]] = None,
                 preference: Optional[pulumi.Input[int]] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class SwitchIpConfigArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Required when `type`==`static`
        """
        dns_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        gateway: NotRequired[pulumi.Input[str]]
        ip: NotRequired[pulumi.Input[str]]
        netmask: NotRequired[pulumi.Input[str]]
        """
        used only if `subnet` is not specified in `networks`
        """
        network: NotRequired[pulumi.Input[str]]
        """
        the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
elif False:
    SwitchIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchIpConfigArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns: Required when `type`==`static`
        :param pulumi.Input[str] netmask: used only if `subnet` is not specified in `networks`
        :param pulumi.Input[str] network: the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if dns_suffixes is not None:
            pulumi.set(__self__, "dns_suffixes", dns_suffixes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Required when `type`==`static`
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dnsSuffixes")
    def dns_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dns_suffixes")

    @dns_suffixes.setter
    def dns_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_suffixes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SwitchLocalPortConfigArgsDict(TypedDict):
        usage: pulumi.Input[str]
        """
        port usage name. 

        If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        critical: NotRequired[pulumi.Input[bool]]
        """
        if want to generate port up/down alarm
        """
        description: NotRequired[pulumi.Input[str]]
        disable_autoneg: NotRequired[pulumi.Input[bool]]
        """
        if `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        duplex: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `full`, `half`
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        poe_disabled: NotRequired[pulumi.Input[bool]]
        speed: NotRequired[pulumi.Input[str]]
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
elif False:
    SwitchLocalPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchLocalPortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[str],
                 critical: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_autoneg: Optional[pulumi.Input[bool]] = None,
                 duplex: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 poe_disabled: Optional[pulumi.Input[bool]] = None,
                 speed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] usage: port usage name. 
               
               If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param pulumi.Input[bool] critical: if want to generate port up/down alarm
        :param pulumi.Input[bool] disable_autoneg: if `speed` and `duplex` are specified, whether to disable autonegotiation
        :param pulumi.Input[str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input[int] mtu: media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param pulumi.Input[str] speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        pulumi.set(__self__, "usage", usage)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[str]:
        """
        port usage name. 

        If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[bool]]:
        """
        if want to generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[bool]]:
        """
        if `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed", value)


if not MYPY:
    class SwitchMistNacArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        network: NotRequired[pulumi.Input[str]]
elif False:
    SwitchMistNacArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchMistNacArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 network: Optional[pulumi.Input[str]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)


if not MYPY:
    class SwitchNetworksArgsDict(TypedDict):
        vlan_id: pulumi.Input[str]
        isolation: NotRequired[pulumi.Input[bool]]
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
        NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        """
        isolation_vlan_id: NotRequired[pulumi.Input[str]]
        subnet: NotRequired[pulumi.Input[str]]
        """
        optional for pure switching, required when L3 / routing features are used
        """
elif False:
    SwitchNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchNetworksArgs:
    def __init__(__self__, *,
                 vlan_id: pulumi.Input[str],
                 isolation: Optional[pulumi.Input[bool]] = None,
                 isolation_vlan_id: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] isolation: whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
               NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        :param pulumi.Input[str] subnet: optional for pure switching, required when L3 / routing features are used
        """
        pulumi.set(__self__, "vlan_id", vlan_id)
        if isolation is not None:
            pulumi.set(__self__, "isolation", isolation)
        if isolation_vlan_id is not None:
            pulumi.set(__self__, "isolation_vlan_id", isolation_vlan_id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vlan_id", value)

    @property
    @pulumi.getter
    def isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
        NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
        """
        return pulumi.get(self, "isolation")

    @isolation.setter
    def isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "isolation", value)

    @property
    @pulumi.getter(name="isolationVlanId")
    def isolation_vlan_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "isolation_vlan_id")

    @isolation_vlan_id.setter
    def isolation_vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "isolation_vlan_id", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        optional for pure switching, required when L3 / routing features are used
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class SwitchOobIpConfigArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[str]]
        ip: NotRequired[pulumi.Input[str]]
        netmask: NotRequired[pulumi.Input[str]]
        """
        used only if `subnet` is not specified in `networks`
        """
        network: NotRequired[pulumi.Input[str]]
        """
        optional, the network to be used for mgmt
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
        use_mgmt_vrf: NotRequired[pulumi.Input[bool]]
        """
        f supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        use_mgmt_vrf_for_host_out: NotRequired[pulumi.Input[bool]]
        """
        for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
elif False:
    SwitchOobIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchOobIpConfigArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 use_mgmt_vrf: Optional[pulumi.Input[bool]] = None,
                 use_mgmt_vrf_for_host_out: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] netmask: used only if `subnet` is not specified in `networks`
        :param pulumi.Input[str] network: optional, the network to be used for mgmt
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        :param pulumi.Input[bool] use_mgmt_vrf: f supported on the platform. If enabled, DNS will be using this routing-instance, too
        :param pulumi.Input[bool] use_mgmt_vrf_for_host_out: for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_mgmt_vrf is not None:
            pulumi.set(__self__, "use_mgmt_vrf", use_mgmt_vrf)
        if use_mgmt_vrf_for_host_out is not None:
            pulumi.set(__self__, "use_mgmt_vrf_for_host_out", use_mgmt_vrf_for_host_out)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        used only if `subnet` is not specified in `networks`
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        optional, the network to be used for mgmt
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useMgmtVrf")
    def use_mgmt_vrf(self) -> Optional[pulumi.Input[bool]]:
        """
        f supported on the platform. If enabled, DNS will be using this routing-instance, too
        """
        return pulumi.get(self, "use_mgmt_vrf")

    @use_mgmt_vrf.setter
    def use_mgmt_vrf(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mgmt_vrf", value)

    @property
    @pulumi.getter(name="useMgmtVrfForHostOut")
    def use_mgmt_vrf_for_host_out(self) -> Optional[pulumi.Input[bool]]:
        """
        for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
        """
        return pulumi.get(self, "use_mgmt_vrf_for_host_out")

    @use_mgmt_vrf_for_host_out.setter
    def use_mgmt_vrf_for_host_out(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mgmt_vrf_for_host_out", value)


if not MYPY:
    class SwitchOspfAreasArgsDict(TypedDict):
        networks: pulumi.Input[Mapping[str, pulumi.Input['SwitchOspfAreasNetworksArgsDict']]]
        include_loopback: NotRequired[pulumi.Input[bool]]
        type: NotRequired[pulumi.Input[str]]
        """
        OSPF type. enum: `default`, `nssa`, `stub`
        """
elif False:
    SwitchOspfAreasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchOspfAreasArgs:
    def __init__(__self__, *,
                 networks: pulumi.Input[Mapping[str, pulumi.Input['SwitchOspfAreasNetworksArgs']]],
                 include_loopback: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: OSPF type. enum: `default`, `nssa`, `stub`
        """
        pulumi.set(__self__, "networks", networks)
        if include_loopback is not None:
            pulumi.set(__self__, "include_loopback", include_loopback)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def networks(self) -> pulumi.Input[Mapping[str, pulumi.Input['SwitchOspfAreasNetworksArgs']]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: pulumi.Input[Mapping[str, pulumi.Input['SwitchOspfAreasNetworksArgs']]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="includeLoopback")
    def include_loopback(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_loopback")

    @include_loopback.setter
    def include_loopback(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_loopback", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        OSPF type. enum: `default`, `nssa`, `stub`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SwitchOspfAreasNetworksArgsDict(TypedDict):
        auth_keys: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Required if `auth_type`==`md5`. Property key is the key number
        """
        auth_password: NotRequired[pulumi.Input[str]]
        """
        Required if `auth_type`==`password`, the password, max length is 8
        """
        auth_type: NotRequired[pulumi.Input[str]]
        """
        auth type. enum: `md5`, `none`, `password`
        """
        bfd_minimum_interval: NotRequired[pulumi.Input[int]]
        dead_interval: NotRequired[pulumi.Input[int]]
        export_policy: NotRequired[pulumi.Input[str]]
        hello_interval: NotRequired[pulumi.Input[int]]
        import_policy: NotRequired[pulumi.Input[str]]
        interface_type: NotRequired[pulumi.Input[str]]
        """
        interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        """
        metric: NotRequired[pulumi.Input[int]]
        no_readvertise_to_overlay: NotRequired[pulumi.Input[bool]]
        """
        by default, we'll re-advertise all learned OSPF routes toward overlay
        """
        passive: NotRequired[pulumi.Input[bool]]
        """
        whether to send OSPF-Hello
        """
elif False:
    SwitchOspfAreasNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchOspfAreasNetworksArgs:
    def __init__(__self__, *,
                 auth_keys: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 auth_password: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input[str]] = None,
                 bfd_minimum_interval: Optional[pulumi.Input[int]] = None,
                 dead_interval: Optional[pulumi.Input[int]] = None,
                 export_policy: Optional[pulumi.Input[str]] = None,
                 hello_interval: Optional[pulumi.Input[int]] = None,
                 import_policy: Optional[pulumi.Input[str]] = None,
                 interface_type: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[int]] = None,
                 no_readvertise_to_overlay: Optional[pulumi.Input[bool]] = None,
                 passive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] auth_keys: Required if `auth_type`==`md5`. Property key is the key number
        :param pulumi.Input[str] auth_password: Required if `auth_type`==`password`, the password, max length is 8
        :param pulumi.Input[str] auth_type: auth type. enum: `md5`, `none`, `password`
        :param pulumi.Input[str] interface_type: interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        :param pulumi.Input[bool] no_readvertise_to_overlay: by default, we'll re-advertise all learned OSPF routes toward overlay
        :param pulumi.Input[bool] passive: whether to send OSPF-Hello
        """
        if auth_keys is not None:
            pulumi.set(__self__, "auth_keys", auth_keys)
        if auth_password is not None:
            pulumi.set(__self__, "auth_password", auth_password)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if bfd_minimum_interval is not None:
            pulumi.set(__self__, "bfd_minimum_interval", bfd_minimum_interval)
        if dead_interval is not None:
            pulumi.set(__self__, "dead_interval", dead_interval)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if hello_interval is not None:
            pulumi.set(__self__, "hello_interval", hello_interval)
        if import_policy is not None:
            pulumi.set(__self__, "import_policy", import_policy)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if no_readvertise_to_overlay is not None:
            pulumi.set(__self__, "no_readvertise_to_overlay", no_readvertise_to_overlay)
        if passive is not None:
            pulumi.set(__self__, "passive", passive)

    @property
    @pulumi.getter(name="authKeys")
    def auth_keys(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Required if `auth_type`==`md5`. Property key is the key number
        """
        return pulumi.get(self, "auth_keys")

    @auth_keys.setter
    def auth_keys(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "auth_keys", value)

    @property
    @pulumi.getter(name="authPassword")
    def auth_password(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `auth_type`==`password`, the password, max length is 8
        """
        return pulumi.get(self, "auth_password")

    @auth_password.setter
    def auth_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_password", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[str]]:
        """
        auth type. enum: `md5`, `none`, `password`
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="bfdMinimumInterval")
    def bfd_minimum_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "bfd_minimum_interval")

    @bfd_minimum_interval.setter
    def bfd_minimum_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bfd_minimum_interval", value)

    @property
    @pulumi.getter(name="deadInterval")
    def dead_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dead_interval")

    @dead_interval.setter
    def dead_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dead_interval", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="helloInterval")
    def hello_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hello_interval")

    @hello_interval.setter
    def hello_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hello_interval", value)

    @property
    @pulumi.getter(name="importPolicy")
    def import_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "import_policy")

    @import_policy.setter
    def import_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_policy", value)

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[pulumi.Input[str]]:
        """
        interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
        """
        return pulumi.get(self, "interface_type")

    @interface_type.setter
    def interface_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_type", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="noReadvertiseToOverlay")
    def no_readvertise_to_overlay(self) -> Optional[pulumi.Input[bool]]:
        """
        by default, we'll re-advertise all learned OSPF routes toward overlay
        """
        return pulumi.get(self, "no_readvertise_to_overlay")

    @no_readvertise_to_overlay.setter
    def no_readvertise_to_overlay(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_readvertise_to_overlay", value)

    @property
    @pulumi.getter
    def passive(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to send OSPF-Hello
        """
        return pulumi.get(self, "passive")

    @passive.setter
    def passive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "passive", value)


if not MYPY:
    class SwitchOtherIpConfigsArgsDict(TypedDict):
        evpn_anycast: NotRequired[pulumi.Input[bool]]
        """
        for EVPN, if anycast is desired
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        required if `type`==`static`
        """
        ip6: NotRequired[pulumi.Input[str]]
        """
        required if `type6`==`static`
        """
        netmask: NotRequired[pulumi.Input[str]]
        """
        optional, `subnet` from `network` definition will be used if defined
        """
        netmask6: NotRequired[pulumi.Input[str]]
        """
        optional, `subnet` from `network` definition will be used if defined
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `dhcp`, `static`
        """
        type6: NotRequired[pulumi.Input[str]]
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
elif False:
    SwitchOtherIpConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchOtherIpConfigsArgs:
    def __init__(__self__, *,
                 evpn_anycast: Optional[pulumi.Input[bool]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 ip6: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 netmask6: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 type6: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] evpn_anycast: for EVPN, if anycast is desired
        :param pulumi.Input[str] ip: required if `type`==`static`
        :param pulumi.Input[str] ip6: required if `type6`==`static`
        :param pulumi.Input[str] netmask: optional, `subnet` from `network` definition will be used if defined
        :param pulumi.Input[str] netmask6: optional, `subnet` from `network` definition will be used if defined
        :param pulumi.Input[str] type: enum: `dhcp`, `static`
        :param pulumi.Input[str] type6: enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        if evpn_anycast is not None:
            pulumi.set(__self__, "evpn_anycast", evpn_anycast)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip6 is not None:
            pulumi.set(__self__, "ip6", ip6)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if netmask6 is not None:
            pulumi.set(__self__, "netmask6", netmask6)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type6 is not None:
            pulumi.set(__self__, "type6", type6)

    @property
    @pulumi.getter(name="evpnAnycast")
    def evpn_anycast(self) -> Optional[pulumi.Input[bool]]:
        """
        for EVPN, if anycast is desired
        """
        return pulumi.get(self, "evpn_anycast")

    @evpn_anycast.setter
    def evpn_anycast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "evpn_anycast", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        required if `type`==`static`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def ip6(self) -> Optional[pulumi.Input[str]]:
        """
        required if `type6`==`static`
        """
        return pulumi.get(self, "ip6")

    @ip6.setter
    def ip6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip6", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        optional, `subnet` from `network` definition will be used if defined
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def netmask6(self) -> Optional[pulumi.Input[str]]:
        """
        optional, `subnet` from `network` definition will be used if defined
        """
        return pulumi.get(self, "netmask6")

    @netmask6.setter
    def netmask6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask6", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `dhcp`, `static`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def type6(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `autoconf`, `dhcp`, `disabled`, `static`
        """
        return pulumi.get(self, "type6")

    @type6.setter
    def type6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type6", value)


if not MYPY:
    class SwitchPortConfigArgsDict(TypedDict):
        usage: pulumi.Input[str]
        """
        port usage name. 

        If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        ae_disable_lacp: NotRequired[pulumi.Input[bool]]
        """
        To disable LACP support for the AE interface
        """
        ae_idx: NotRequired[pulumi.Input[int]]
        """
        Users could force to use the designated AE name
        """
        ae_lacp_slow: NotRequired[pulumi.Input[bool]]
        """
        to use fast timeout
        """
        aggregated: NotRequired[pulumi.Input[bool]]
        critical: NotRequired[pulumi.Input[bool]]
        """
        if want to generate port up/down alarm
        """
        description: NotRequired[pulumi.Input[str]]
        disable_autoneg: NotRequired[pulumi.Input[bool]]
        """
        if `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        duplex: NotRequired[pulumi.Input[str]]
        """
        enum: `auto`, `full`, `half`
        """
        dynamic_usage: NotRequired[pulumi.Input[str]]
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        esilag: NotRequired[pulumi.Input[bool]]
        mtu: NotRequired[pulumi.Input[int]]
        """
        media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        no_local_overwrite: NotRequired[pulumi.Input[bool]]
        """
        prevent helpdesk to override the port config
        """
        poe_disabled: NotRequired[pulumi.Input[bool]]
        speed: NotRequired[pulumi.Input[str]]
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
elif False:
    SwitchPortConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortConfigArgs:
    def __init__(__self__, *,
                 usage: pulumi.Input[str],
                 ae_disable_lacp: Optional[pulumi.Input[bool]] = None,
                 ae_idx: Optional[pulumi.Input[int]] = None,
                 ae_lacp_slow: Optional[pulumi.Input[bool]] = None,
                 aggregated: Optional[pulumi.Input[bool]] = None,
                 critical: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_autoneg: Optional[pulumi.Input[bool]] = None,
                 duplex: Optional[pulumi.Input[str]] = None,
                 dynamic_usage: Optional[pulumi.Input[str]] = None,
                 esilag: Optional[pulumi.Input[bool]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 no_local_overwrite: Optional[pulumi.Input[bool]] = None,
                 poe_disabled: Optional[pulumi.Input[bool]] = None,
                 speed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] usage: port usage name. 
               
               If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        :param pulumi.Input[bool] ae_disable_lacp: To disable LACP support for the AE interface
        :param pulumi.Input[int] ae_idx: Users could force to use the designated AE name
        :param pulumi.Input[bool] ae_lacp_slow: to use fast timeout
        :param pulumi.Input[bool] critical: if want to generate port up/down alarm
        :param pulumi.Input[bool] disable_autoneg: if `speed` and `duplex` are specified, whether to disable autonegotiation
        :param pulumi.Input[str] duplex: enum: `auto`, `full`, `half`
        :param pulumi.Input[str] dynamic_usage: Enable dynamic usage for this port. Set to `dynamic` to enable.
        :param pulumi.Input[int] mtu: media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        :param pulumi.Input[bool] no_local_overwrite: prevent helpdesk to override the port config
        :param pulumi.Input[str] speed: enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        pulumi.set(__self__, "usage", usage)
        if ae_disable_lacp is not None:
            pulumi.set(__self__, "ae_disable_lacp", ae_disable_lacp)
        if ae_idx is not None:
            pulumi.set(__self__, "ae_idx", ae_idx)
        if ae_lacp_slow is not None:
            pulumi.set(__self__, "ae_lacp_slow", ae_lacp_slow)
        if aggregated is not None:
            pulumi.set(__self__, "aggregated", aggregated)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_usage is not None:
            pulumi.set(__self__, "dynamic_usage", dynamic_usage)
        if esilag is not None:
            pulumi.set(__self__, "esilag", esilag)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if no_local_overwrite is not None:
            pulumi.set(__self__, "no_local_overwrite", no_local_overwrite)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)

    @property
    @pulumi.getter
    def usage(self) -> pulumi.Input[str]:
        """
        port usage name. 

        If EVPN is used, use `evpn_uplink`or `evpn_downlink`
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: pulumi.Input[str]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter(name="aeDisableLacp")
    def ae_disable_lacp(self) -> Optional[pulumi.Input[bool]]:
        """
        To disable LACP support for the AE interface
        """
        return pulumi.get(self, "ae_disable_lacp")

    @ae_disable_lacp.setter
    def ae_disable_lacp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ae_disable_lacp", value)

    @property
    @pulumi.getter(name="aeIdx")
    def ae_idx(self) -> Optional[pulumi.Input[int]]:
        """
        Users could force to use the designated AE name
        """
        return pulumi.get(self, "ae_idx")

    @ae_idx.setter
    def ae_idx(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ae_idx", value)

    @property
    @pulumi.getter(name="aeLacpSlow")
    def ae_lacp_slow(self) -> Optional[pulumi.Input[bool]]:
        """
        to use fast timeout
        """
        return pulumi.get(self, "ae_lacp_slow")

    @ae_lacp_slow.setter
    def ae_lacp_slow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ae_lacp_slow", value)

    @property
    @pulumi.getter
    def aggregated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "aggregated")

    @aggregated.setter
    def aggregated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aggregated", value)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[bool]]:
        """
        if want to generate port up/down alarm
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[bool]]:
        """
        if `speed` and `duplex` are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="dynamicUsage")
    def dynamic_usage(self) -> Optional[pulumi.Input[str]]:
        """
        Enable dynamic usage for this port. Set to `dynamic` to enable.
        """
        return pulumi.get(self, "dynamic_usage")

    @dynamic_usage.setter
    def dynamic_usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamic_usage", value)

    @property
    @pulumi.getter
    def esilag(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "esilag")

    @esilag.setter
    def esilag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "esilag", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="noLocalOverwrite")
    def no_local_overwrite(self) -> Optional[pulumi.Input[bool]]:
        """
        prevent helpdesk to override the port config
        """
        return pulumi.get(self, "no_local_overwrite")

    @no_local_overwrite.setter
    def no_local_overwrite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_local_overwrite", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed", value)


if not MYPY:
    class SwitchPortMirroringArgsDict(TypedDict):
        input_networks_ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        input_port_ids_egresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        input_port_ids_ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        output_network: NotRequired[pulumi.Input[str]]
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        output_port_id: NotRequired[pulumi.Input[str]]
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
elif False:
    SwitchPortMirroringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortMirroringArgs:
    def __init__(__self__, *,
                 input_networks_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_port_ids_egresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_port_ids_ingresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_network: Optional[pulumi.Input[str]] = None,
                 output_port_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_networks_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_port_ids_egresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_port_ids_ingresses: at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        :param pulumi.Input[str] output_network: exaclty one of the `output_port_id` or `output_network` should be provided
        :param pulumi.Input[str] output_port_id: exaclty one of the `output_port_id` or `output_network` should be provided
        """
        if input_networks_ingresses is not None:
            pulumi.set(__self__, "input_networks_ingresses", input_networks_ingresses)
        if input_port_ids_egresses is not None:
            pulumi.set(__self__, "input_port_ids_egresses", input_port_ids_egresses)
        if input_port_ids_ingresses is not None:
            pulumi.set(__self__, "input_port_ids_ingresses", input_port_ids_ingresses)
        if output_network is not None:
            pulumi.set(__self__, "output_network", output_network)
        if output_port_id is not None:
            pulumi.set(__self__, "output_port_id", output_port_id)

    @property
    @pulumi.getter(name="inputNetworksIngresses")
    def input_networks_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_networks_ingresses")

    @input_networks_ingresses.setter
    def input_networks_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_networks_ingresses", value)

    @property
    @pulumi.getter(name="inputPortIdsEgresses")
    def input_port_ids_egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_egresses")

    @input_port_ids_egresses.setter
    def input_port_ids_egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_port_ids_egresses", value)

    @property
    @pulumi.getter(name="inputPortIdsIngresses")
    def input_port_ids_ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
        """
        return pulumi.get(self, "input_port_ids_ingresses")

    @input_port_ids_ingresses.setter
    def input_port_ids_ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_port_ids_ingresses", value)

    @property
    @pulumi.getter(name="outputNetwork")
    def output_network(self) -> Optional[pulumi.Input[str]]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_network")

    @output_network.setter
    def output_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_network", value)

    @property
    @pulumi.getter(name="outputPortId")
    def output_port_id(self) -> Optional[pulumi.Input[str]]:
        """
        exaclty one of the `output_port_id` or `output_network` should be provided
        """
        return pulumi.get(self, "output_port_id")

    @output_port_id.setter
    def output_port_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_port_id", value)


if not MYPY:
    class SwitchPortUsagesArgsDict(TypedDict):
        all_networks: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        allow_dhcpd: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.

        When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        """
        allow_multiple_supplicants: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic`
        """
        bypass_auth_when_server_down: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        bypass_auth_when_server_down_for_unkonwn_client: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic`
        """
        disable_autoneg: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        duplex: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        """
        dynamic_vlan_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        enable_mac_auth: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        enable_qos: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic`
        """
        guest_network: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        inter_switch_link: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
        NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        mac_auth_only: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        mac_auth_preferred: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        mac_auth_protocol: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        mac_limit: NotRequired[pulumi.Input[int]]
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        persist_mac: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        poe_disabled: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        port_auth: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        port_network: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        reauth_interval: NotRequired[pulumi.Input[int]]
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        """
        reset_default_when: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchPortUsagesRuleArgsDict']]]]
        """
        Only if `mode`==`dynamic`
        """
        server_fail_network: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        server_reject_network: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        speed: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        """
        storm_control: NotRequired[pulumi.Input['SwitchPortUsagesStormControlArgsDict']]
        """
        Switch storm control
        Only if `mode`!=`dynamic`
        """
        stp_edge: NotRequired[pulumi.Input[bool]]
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        stp_no_root_port: NotRequired[pulumi.Input[bool]]
        stp_p2p: NotRequired[pulumi.Input[bool]]
        use_vstp: NotRequired[pulumi.Input[bool]]
        """
        if this is connected to a vstp network
        """
        voip_network: NotRequired[pulumi.Input[str]]
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
elif False:
    SwitchPortUsagesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortUsagesArgs:
    def __init__(__self__, *,
                 all_networks: Optional[pulumi.Input[bool]] = None,
                 allow_dhcpd: Optional[pulumi.Input[bool]] = None,
                 allow_multiple_supplicants: Optional[pulumi.Input[bool]] = None,
                 bypass_auth_when_server_down: Optional[pulumi.Input[bool]] = None,
                 bypass_auth_when_server_down_for_unkonwn_client: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_autoneg: Optional[pulumi.Input[bool]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 duplex: Optional[pulumi.Input[str]] = None,
                 dynamic_vlan_networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_mac_auth: Optional[pulumi.Input[bool]] = None,
                 enable_qos: Optional[pulumi.Input[bool]] = None,
                 guest_network: Optional[pulumi.Input[str]] = None,
                 inter_switch_link: Optional[pulumi.Input[bool]] = None,
                 mac_auth_only: Optional[pulumi.Input[bool]] = None,
                 mac_auth_preferred: Optional[pulumi.Input[bool]] = None,
                 mac_auth_protocol: Optional[pulumi.Input[str]] = None,
                 mac_limit: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 persist_mac: Optional[pulumi.Input[bool]] = None,
                 poe_disabled: Optional[pulumi.Input[bool]] = None,
                 port_auth: Optional[pulumi.Input[str]] = None,
                 port_network: Optional[pulumi.Input[str]] = None,
                 reauth_interval: Optional[pulumi.Input[int]] = None,
                 reset_default_when: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchPortUsagesRuleArgs']]]] = None,
                 server_fail_network: Optional[pulumi.Input[str]] = None,
                 server_reject_network: Optional[pulumi.Input[str]] = None,
                 speed: Optional[pulumi.Input[str]] = None,
                 storm_control: Optional[pulumi.Input['SwitchPortUsagesStormControlArgs']] = None,
                 stp_edge: Optional[pulumi.Input[bool]] = None,
                 stp_no_root_port: Optional[pulumi.Input[bool]] = None,
                 stp_p2p: Optional[pulumi.Input[bool]] = None,
                 use_vstp: Optional[pulumi.Input[bool]] = None,
                 voip_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] all_networks: Only if `mode`==`trunk` whether to trunk all network/vlans
        :param pulumi.Input[bool] allow_dhcpd: Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
               
               When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        :param pulumi.Input[bool] allow_multiple_supplicants: Only if `mode`!=`dynamic`
        :param pulumi.Input[bool] bypass_auth_when_server_down: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        :param pulumi.Input[bool] bypass_auth_when_server_down_for_unkonwn_client: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        :param pulumi.Input[str] description: Only if `mode`!=`dynamic`
        :param pulumi.Input[bool] disable_autoneg: Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        :param pulumi.Input[bool] disabled: Only if `mode`!=`dynamic` whether the port is disabled
        :param pulumi.Input[str] duplex: Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dynamic_vlan_networks: Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        :param pulumi.Input[bool] enable_mac_auth: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        :param pulumi.Input[bool] enable_qos: Only if `mode`!=`dynamic`
        :param pulumi.Input[str] guest_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        :param pulumi.Input[bool] inter_switch_link: Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
               NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        :param pulumi.Input[bool] mac_auth_only: Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        :param pulumi.Input[bool] mac_auth_preferred: Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        :param pulumi.Input[str] mac_auth_protocol: Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        :param pulumi.Input[int] mac_limit: Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        :param pulumi.Input[str] mode: `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        :param pulumi.Input[int] mtu: Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: Only if `mode`==`trunk`, the list of network/vlans
        :param pulumi.Input[bool] persist_mac: Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        :param pulumi.Input[bool] poe_disabled: Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        :param pulumi.Input[str] port_auth: Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        :param pulumi.Input[str] port_network: Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        :param pulumi.Input[int] reauth_interval: Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        :param pulumi.Input[str] reset_default_when: Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        :param pulumi.Input[Sequence[pulumi.Input['SwitchPortUsagesRuleArgs']]] rules: Only if `mode`==`dynamic`
        :param pulumi.Input[str] server_fail_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        :param pulumi.Input[str] server_reject_network: Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        :param pulumi.Input[str] speed: Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        :param pulumi.Input['SwitchPortUsagesStormControlArgs'] storm_control: Switch storm control
               Only if `mode`!=`dynamic`
        :param pulumi.Input[bool] stp_edge: Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        :param pulumi.Input[bool] use_vstp: if this is connected to a vstp network
        :param pulumi.Input[str] voip_network: Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        if all_networks is not None:
            pulumi.set(__self__, "all_networks", all_networks)
        if allow_dhcpd is not None:
            pulumi.set(__self__, "allow_dhcpd", allow_dhcpd)
        if allow_multiple_supplicants is not None:
            pulumi.set(__self__, "allow_multiple_supplicants", allow_multiple_supplicants)
        if bypass_auth_when_server_down is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down", bypass_auth_when_server_down)
        if bypass_auth_when_server_down_for_unkonwn_client is not None:
            pulumi.set(__self__, "bypass_auth_when_server_down_for_unkonwn_client", bypass_auth_when_server_down_for_unkonwn_client)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_autoneg is not None:
            pulumi.set(__self__, "disable_autoneg", disable_autoneg)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if duplex is not None:
            pulumi.set(__self__, "duplex", duplex)
        if dynamic_vlan_networks is not None:
            pulumi.set(__self__, "dynamic_vlan_networks", dynamic_vlan_networks)
        if enable_mac_auth is not None:
            pulumi.set(__self__, "enable_mac_auth", enable_mac_auth)
        if enable_qos is not None:
            pulumi.set(__self__, "enable_qos", enable_qos)
        if guest_network is not None:
            pulumi.set(__self__, "guest_network", guest_network)
        if inter_switch_link is not None:
            pulumi.set(__self__, "inter_switch_link", inter_switch_link)
        if mac_auth_only is not None:
            pulumi.set(__self__, "mac_auth_only", mac_auth_only)
        if mac_auth_preferred is not None:
            pulumi.set(__self__, "mac_auth_preferred", mac_auth_preferred)
        if mac_auth_protocol is not None:
            pulumi.set(__self__, "mac_auth_protocol", mac_auth_protocol)
        if mac_limit is not None:
            pulumi.set(__self__, "mac_limit", mac_limit)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if persist_mac is not None:
            pulumi.set(__self__, "persist_mac", persist_mac)
        if poe_disabled is not None:
            pulumi.set(__self__, "poe_disabled", poe_disabled)
        if port_auth is not None:
            pulumi.set(__self__, "port_auth", port_auth)
        if port_network is not None:
            pulumi.set(__self__, "port_network", port_network)
        if reauth_interval is not None:
            pulumi.set(__self__, "reauth_interval", reauth_interval)
        if reset_default_when is not None:
            pulumi.set(__self__, "reset_default_when", reset_default_when)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if server_fail_network is not None:
            pulumi.set(__self__, "server_fail_network", server_fail_network)
        if server_reject_network is not None:
            pulumi.set(__self__, "server_reject_network", server_reject_network)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if storm_control is not None:
            pulumi.set(__self__, "storm_control", storm_control)
        if stp_edge is not None:
            pulumi.set(__self__, "stp_edge", stp_edge)
        if stp_no_root_port is not None:
            pulumi.set(__self__, "stp_no_root_port", stp_no_root_port)
        if stp_p2p is not None:
            pulumi.set(__self__, "stp_p2p", stp_p2p)
        if use_vstp is not None:
            pulumi.set(__self__, "use_vstp", use_vstp)
        if voip_network is not None:
            pulumi.set(__self__, "voip_network", voip_network)

    @property
    @pulumi.getter(name="allNetworks")
    def all_networks(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`==`trunk` whether to trunk all network/vlans
        """
        return pulumi.get(self, "all_networks")

    @all_networks.setter
    def all_networks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all_networks", value)

    @property
    @pulumi.getter(name="allowDhcpd")
    def allow_dhcpd(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.

        When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
        """
        return pulumi.get(self, "allow_dhcpd")

    @allow_dhcpd.setter
    def allow_dhcpd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_dhcpd", value)

    @property
    @pulumi.getter(name="allowMultipleSupplicants")
    def allow_multiple_supplicants(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "allow_multiple_supplicants")

    @allow_multiple_supplicants.setter
    def allow_multiple_supplicants(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_multiple_supplicants", value)

    @property
    @pulumi.getter(name="bypassAuthWhenServerDown")
    def bypass_auth_when_server_down(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down")

    @bypass_auth_when_server_down.setter
    def bypass_auth_when_server_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_auth_when_server_down", value)

    @property
    @pulumi.getter(name="bypassAuthWhenServerDownForUnkonwnClient")
    def bypass_auth_when_server_down_for_unkonwn_client(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
        """
        return pulumi.get(self, "bypass_auth_when_server_down_for_unkonwn_client")

    @bypass_auth_when_server_down_for_unkonwn_client.setter
    def bypass_auth_when_server_down_for_unkonwn_client(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_auth_when_server_down_for_unkonwn_client", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoneg")
    def disable_autoneg(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
        """
        return pulumi.get(self, "disable_autoneg")

    @disable_autoneg.setter
    def disable_autoneg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_autoneg", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` whether the port is disabled
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def duplex(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
        """
        return pulumi.get(self, "duplex")

    @duplex.setter
    def duplex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duplex", value)

    @property
    @pulumi.getter(name="dynamicVlanNetworks")
    def dynamic_vlan_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
        """
        return pulumi.get(self, "dynamic_vlan_networks")

    @dynamic_vlan_networks.setter
    def dynamic_vlan_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dynamic_vlan_networks", value)

    @property
    @pulumi.getter(name="enableMacAuth")
    def enable_mac_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
        """
        return pulumi.get(self, "enable_mac_auth")

    @enable_mac_auth.setter
    def enable_mac_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_mac_auth", value)

    @property
    @pulumi.getter(name="enableQos")
    def enable_qos(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "enable_qos")

    @enable_qos.setter
    def enable_qos(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_qos", value)

    @property
    @pulumi.getter(name="guestNetwork")
    def guest_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
        """
        return pulumi.get(self, "guest_network")

    @guest_network.setter
    def guest_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_network", value)

    @property
    @pulumi.getter(name="interSwitchLink")
    def inter_switch_link(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
        NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
        """
        return pulumi.get(self, "inter_switch_link")

    @inter_switch_link.setter
    def inter_switch_link(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inter_switch_link", value)

    @property
    @pulumi.getter(name="macAuthOnly")
    def mac_auth_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
        """
        return pulumi.get(self, "mac_auth_only")

    @mac_auth_only.setter
    def mac_auth_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mac_auth_only", value)

    @property
    @pulumi.getter(name="macAuthPreferred")
    def mac_auth_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
        """
        return pulumi.get(self, "mac_auth_preferred")

    @mac_auth_preferred.setter
    def mac_auth_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mac_auth_preferred", value)

    @property
    @pulumi.getter(name="macAuthProtocol")
    def mac_auth_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
        """
        return pulumi.get(self, "mac_auth_protocol")

    @mac_auth_protocol.setter
    def mac_auth_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_auth_protocol", value)

    @property
    @pulumi.getter(name="macLimit")
    def mac_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
        """
        return pulumi.get(self, "mac_limit")

    @mac_limit.setter
    def mac_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mac_limit", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only if `mode`==`trunk`, the list of network/vlans
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="persistMac")
    def persist_mac(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
        """
        return pulumi.get(self, "persist_mac")

    @persist_mac.setter
    def persist_mac(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "persist_mac", value)

    @property
    @pulumi.getter(name="poeDisabled")
    def poe_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
        """
        return pulumi.get(self, "poe_disabled")

    @poe_disabled.setter
    def poe_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "poe_disabled", value)

    @property
    @pulumi.getter(name="portAuth")
    def port_auth(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
        """
        return pulumi.get(self, "port_auth")

    @port_auth.setter
    def port_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_auth", value)

    @property
    @pulumi.getter(name="portNetwork")
    def port_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` native network/vlan for untagged traffic
        """
        return pulumi.get(self, "port_network")

    @port_network.setter
    def port_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_network", value)

    @property
    @pulumi.getter(name="reauthInterval")
    def reauth_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
        """
        return pulumi.get(self, "reauth_interval")

    @reauth_interval.setter
    def reauth_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reauth_interval", value)

    @property
    @pulumi.getter(name="resetDefaultWhen")
    def reset_default_when(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
        """
        return pulumi.get(self, "reset_default_when")

    @reset_default_when.setter
    def reset_default_when(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reset_default_when", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchPortUsagesRuleArgs']]]]:
        """
        Only if `mode`==`dynamic`
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchPortUsagesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="serverFailNetwork")
    def server_fail_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
        """
        return pulumi.get(self, "server_fail_network")

    @server_fail_network.setter
    def server_fail_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_fail_network", value)

    @property
    @pulumi.getter(name="serverRejectNetwork")
    def server_reject_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
        """
        return pulumi.get(self, "server_reject_network")

    @server_reject_network.setter
    def server_reject_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_reject_network", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="stormControl")
    def storm_control(self) -> Optional[pulumi.Input['SwitchPortUsagesStormControlArgs']]:
        """
        Switch storm control
        Only if `mode`!=`dynamic`
        """
        return pulumi.get(self, "storm_control")

    @storm_control.setter
    def storm_control(self, value: Optional[pulumi.Input['SwitchPortUsagesStormControlArgs']]):
        pulumi.set(self, "storm_control", value)

    @property
    @pulumi.getter(name="stpEdge")
    def stp_edge(self) -> Optional[pulumi.Input[bool]]:
        """
        Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
        """
        return pulumi.get(self, "stp_edge")

    @stp_edge.setter
    def stp_edge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stp_edge", value)

    @property
    @pulumi.getter(name="stpNoRootPort")
    def stp_no_root_port(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "stp_no_root_port")

    @stp_no_root_port.setter
    def stp_no_root_port(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stp_no_root_port", value)

    @property
    @pulumi.getter(name="stpP2p")
    def stp_p2p(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "stp_p2p")

    @stp_p2p.setter
    def stp_p2p(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stp_p2p", value)

    @property
    @pulumi.getter(name="useVstp")
    def use_vstp(self) -> Optional[pulumi.Input[bool]]:
        """
        if this is connected to a vstp network
        """
        return pulumi.get(self, "use_vstp")

    @use_vstp.setter
    def use_vstp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_vstp", value)

    @property
    @pulumi.getter(name="voipNetwork")
    def voip_network(self) -> Optional[pulumi.Input[str]]:
        """
        Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
        """
        return pulumi.get(self, "voip_network")

    @voip_network.setter
    def voip_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "voip_network", value)


if not MYPY:
    class SwitchPortUsagesRuleArgsDict(TypedDict):
        src: pulumi.Input[str]
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        equals: NotRequired[pulumi.Input[str]]
        equals_anies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        use `equals_any` to match any item in a list
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        usage: NotRequired[pulumi.Input[str]]
        """
        `port_usage` name
        """
elif False:
    SwitchPortUsagesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortUsagesRuleArgs:
    def __init__(__self__, *,
                 src: pulumi.Input[str],
                 equals: Optional[pulumi.Input[str]] = None,
                 equals_anies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 usage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] src: enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] equals_anies: use `equals_any` to match any item in a list
        :param pulumi.Input[str] expression: "[0:3]":"abcdef" > "abc"
               "split(.)[1]": "a.b.c" > "b"
               "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        :param pulumi.Input[str] usage: `port_usage` name
        """
        pulumi.set(__self__, "src", src)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if equals_anies is not None:
            pulumi.set(__self__, "equals_anies", equals_anies)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def src(self) -> pulumi.Input[str]:
        """
        enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
        """
        return pulumi.get(self, "src")

    @src.setter
    def src(self, value: pulumi.Input[str]):
        pulumi.set(self, "src", value)

    @property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "equals", value)

    @property
    @pulumi.getter(name="equalsAnies")
    def equals_anies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        use `equals_any` to match any item in a list
        """
        return pulumi.get(self, "equals_anies")

    @equals_anies.setter
    def equals_anies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "equals_anies", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        "[0:3]":"abcdef" > "abc"
        "split(.)[1]": "a.b.c" > "b"
        "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[str]]:
        """
        `port_usage` name
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class SwitchPortUsagesStormControlArgsDict(TypedDict):
        no_broadcast: NotRequired[pulumi.Input[bool]]
        """
        whether to disable storm control on broadcast traffic
        """
        no_multicast: NotRequired[pulumi.Input[bool]]
        """
        whether to disable storm control on multicast traffic
        """
        no_registered_multicast: NotRequired[pulumi.Input[bool]]
        """
        whether to disable storm control on registered multicast traffic
        """
        no_unknown_unicast: NotRequired[pulumi.Input[bool]]
        """
        whether to disable storm control on unknown unicast traffic
        """
        percentage: NotRequired[pulumi.Input[int]]
        """
        bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
elif False:
    SwitchPortUsagesStormControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchPortUsagesStormControlArgs:
    def __init__(__self__, *,
                 no_broadcast: Optional[pulumi.Input[bool]] = None,
                 no_multicast: Optional[pulumi.Input[bool]] = None,
                 no_registered_multicast: Optional[pulumi.Input[bool]] = None,
                 no_unknown_unicast: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] no_broadcast: whether to disable storm control on broadcast traffic
        :param pulumi.Input[bool] no_multicast: whether to disable storm control on multicast traffic
        :param pulumi.Input[bool] no_registered_multicast: whether to disable storm control on registered multicast traffic
        :param pulumi.Input[bool] no_unknown_unicast: whether to disable storm control on unknown unicast traffic
        :param pulumi.Input[int] percentage: bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        if no_broadcast is not None:
            pulumi.set(__self__, "no_broadcast", no_broadcast)
        if no_multicast is not None:
            pulumi.set(__self__, "no_multicast", no_multicast)
        if no_registered_multicast is not None:
            pulumi.set(__self__, "no_registered_multicast", no_registered_multicast)
        if no_unknown_unicast is not None:
            pulumi.set(__self__, "no_unknown_unicast", no_unknown_unicast)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="noBroadcast")
    def no_broadcast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on broadcast traffic
        """
        return pulumi.get(self, "no_broadcast")

    @no_broadcast.setter
    def no_broadcast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_broadcast", value)

    @property
    @pulumi.getter(name="noMulticast")
    def no_multicast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on multicast traffic
        """
        return pulumi.get(self, "no_multicast")

    @no_multicast.setter
    def no_multicast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_multicast", value)

    @property
    @pulumi.getter(name="noRegisteredMulticast")
    def no_registered_multicast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on registered multicast traffic
        """
        return pulumi.get(self, "no_registered_multicast")

    @no_registered_multicast.setter
    def no_registered_multicast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_registered_multicast", value)

    @property
    @pulumi.getter(name="noUnknownUnicast")
    def no_unknown_unicast(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to disable storm control on unknown unicast traffic
        """
        return pulumi.get(self, "no_unknown_unicast")

    @no_unknown_unicast.setter
    def no_unknown_unicast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_unknown_unicast", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class SwitchRadiusConfigArgsDict(TypedDict):
        acct_interim_interval: NotRequired[pulumi.Input[int]]
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        acct_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAcctServerArgsDict']]]]
        auth_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAuthServerArgsDict']]]]
        auth_servers_retries: NotRequired[pulumi.Input[int]]
        """
        radius auth session retries
        """
        auth_servers_timeout: NotRequired[pulumi.Input[int]]
        """
        radius auth session timeout
        """
        network: NotRequired[pulumi.Input[str]]
        """
        use `network`or `source_ip`
        which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        source_ip: NotRequired[pulumi.Input[str]]
        """
        use `network`or `source_ip`
        """
elif False:
    SwitchRadiusConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRadiusConfigArgs:
    def __init__(__self__, *,
                 acct_interim_interval: Optional[pulumi.Input[int]] = None,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAcctServerArgs']]]] = None,
                 auth_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAuthServerArgs']]]] = None,
                 auth_servers_retries: Optional[pulumi.Input[int]] = None,
                 auth_servers_timeout: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] acct_interim_interval: how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        :param pulumi.Input[int] auth_servers_retries: radius auth session retries
        :param pulumi.Input[int] auth_servers_timeout: radius auth session timeout
        :param pulumi.Input[str] network: use `network`or `source_ip`
               which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        :param pulumi.Input[str] source_ip: use `network`or `source_ip`
        """
        if acct_interim_interval is not None:
            pulumi.set(__self__, "acct_interim_interval", acct_interim_interval)
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if auth_servers is not None:
            pulumi.set(__self__, "auth_servers", auth_servers)
        if auth_servers_retries is not None:
            pulumi.set(__self__, "auth_servers_retries", auth_servers_retries)
        if auth_servers_timeout is not None:
            pulumi.set(__self__, "auth_servers_timeout", auth_servers_timeout)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="acctInterimInterval")
    def acct_interim_interval(self) -> Optional[pulumi.Input[int]]:
        """
        how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
        """
        return pulumi.get(self, "acct_interim_interval")

    @acct_interim_interval.setter
    def acct_interim_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "acct_interim_interval", value)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAcctServerArgs']]]]:
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter(name="authServers")
    def auth_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAuthServerArgs']]]]:
        return pulumi.get(self, "auth_servers")

    @auth_servers.setter
    def auth_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRadiusConfigAuthServerArgs']]]]):
        pulumi.set(self, "auth_servers", value)

    @property
    @pulumi.getter(name="authServersRetries")
    def auth_servers_retries(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session retries
        """
        return pulumi.get(self, "auth_servers_retries")

    @auth_servers_retries.setter
    def auth_servers_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_retries", value)

    @property
    @pulumi.getter(name="authServersTimeout")
    def auth_servers_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        radius auth session timeout
        """
        return pulumi.get(self, "auth_servers_timeout")

    @auth_servers_timeout.setter
    def auth_servers_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_servers_timeout", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        use `network`or `source_ip`
        which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        """
        use `network`or `source_ip`
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)


if not MYPY:
    class SwitchRadiusConfigAcctServerArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        ip / hostname of RADIUS server
        """
        secret: pulumi.Input[str]
        """
        secret of RADIUS server
        """
        keywrap_enabled: NotRequired[pulumi.Input[bool]]
        keywrap_format: NotRequired[pulumi.Input[str]]
        """
        enum: `ascii`, `hex`
        """
        keywrap_kek: NotRequired[pulumi.Input[str]]
        keywrap_mack: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        """
        Acct port of RADIUS server
        """
elif False:
    SwitchRadiusConfigAcctServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRadiusConfigAcctServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 keywrap_enabled: Optional[pulumi.Input[bool]] = None,
                 keywrap_format: Optional[pulumi.Input[str]] = None,
                 keywrap_kek: Optional[pulumi.Input[str]] = None,
                 keywrap_mack: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: ip / hostname of RADIUS server
        :param pulumi.Input[str] secret: secret of RADIUS server
        :param pulumi.Input[str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[int] port: Acct port of RADIUS server
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Acct port of RADIUS server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class SwitchRadiusConfigAuthServerArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        ip / hostname of RADIUS server
        """
        secret: pulumi.Input[str]
        """
        secret of RADIUS server
        """
        keywrap_enabled: NotRequired[pulumi.Input[bool]]
        keywrap_format: NotRequired[pulumi.Input[str]]
        """
        enum: `ascii`, `hex`
        """
        keywrap_kek: NotRequired[pulumi.Input[str]]
        keywrap_mack: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        """
        Auth port of RADIUS server
        """
        require_message_authenticator: NotRequired[pulumi.Input[bool]]
        """
        whether to require Message-Authenticator in requests
        """
elif False:
    SwitchRadiusConfigAuthServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRadiusConfigAuthServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 keywrap_enabled: Optional[pulumi.Input[bool]] = None,
                 keywrap_format: Optional[pulumi.Input[str]] = None,
                 keywrap_kek: Optional[pulumi.Input[str]] = None,
                 keywrap_mack: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 require_message_authenticator: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] host: ip / hostname of RADIUS server
        :param pulumi.Input[str] secret: secret of RADIUS server
        :param pulumi.Input[str] keywrap_format: enum: `ascii`, `hex`
        :param pulumi.Input[int] port: Auth port of RADIUS server
        :param pulumi.Input[bool] require_message_authenticator: whether to require Message-Authenticator in requests
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "secret", secret)
        if keywrap_enabled is not None:
            pulumi.set(__self__, "keywrap_enabled", keywrap_enabled)
        if keywrap_format is not None:
            pulumi.set(__self__, "keywrap_format", keywrap_format)
        if keywrap_kek is not None:
            pulumi.set(__self__, "keywrap_kek", keywrap_kek)
        if keywrap_mack is not None:
            pulumi.set(__self__, "keywrap_mack", keywrap_mack)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if require_message_authenticator is not None:
            pulumi.set(__self__, "require_message_authenticator", require_message_authenticator)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        ip / hostname of RADIUS server
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        secret of RADIUS server
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="keywrapEnabled")
    def keywrap_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keywrap_enabled")

    @keywrap_enabled.setter
    def keywrap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keywrap_enabled", value)

    @property
    @pulumi.getter(name="keywrapFormat")
    def keywrap_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `ascii`, `hex`
        """
        return pulumi.get(self, "keywrap_format")

    @keywrap_format.setter
    def keywrap_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_format", value)

    @property
    @pulumi.getter(name="keywrapKek")
    def keywrap_kek(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_kek")

    @keywrap_kek.setter
    def keywrap_kek(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_kek", value)

    @property
    @pulumi.getter(name="keywrapMack")
    def keywrap_mack(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "keywrap_mack")

    @keywrap_mack.setter
    def keywrap_mack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keywrap_mack", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Auth port of RADIUS server
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="requireMessageAuthenticator")
    def require_message_authenticator(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to require Message-Authenticator in requests
        """
        return pulumi.get(self, "require_message_authenticator")

    @require_message_authenticator.setter
    def require_message_authenticator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_message_authenticator", value)


if not MYPY:
    class SwitchRemoteSyslogArgsDict(TypedDict):
        archive: NotRequired[pulumi.Input['SwitchRemoteSyslogArchiveArgsDict']]
        console: NotRequired[pulumi.Input['SwitchRemoteSyslogConsoleArgsDict']]
        enabled: NotRequired[pulumi.Input[bool]]
        files: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileArgsDict']]]]
        network: NotRequired[pulumi.Input[str]]
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        send_to_all_servers: NotRequired[pulumi.Input[bool]]
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerArgsDict']]]]
        time_format: NotRequired[pulumi.Input[str]]
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserArgsDict']]]]
elif False:
    SwitchRemoteSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input['SwitchRemoteSyslogArchiveArgs']] = None,
                 console: Optional[pulumi.Input['SwitchRemoteSyslogConsoleArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 files: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileArgs']]]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 send_to_all_servers: Optional[pulumi.Input[bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerArgs']]]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserArgs']]]] = None):
        """
        :param pulumi.Input[str] network: if source_address is configured, will use the vlan firstly otherwise use source_ip
        :param pulumi.Input[str] time_format: enum: `millisecond`, `year`, `year millisecond`
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if console is not None:
            pulumi.set(__self__, "console", console)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if send_to_all_servers is not None:
            pulumi.set(__self__, "send_to_all_servers", send_to_all_servers)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input['SwitchRemoteSyslogArchiveArgs']]:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input['SwitchRemoteSyslogArchiveArgs']]):
        pulumi.set(self, "archive", value)

    @property
    @pulumi.getter
    def console(self) -> Optional[pulumi.Input['SwitchRemoteSyslogConsoleArgs']]:
        return pulumi.get(self, "console")

    @console.setter
    def console(self, value: Optional[pulumi.Input['SwitchRemoteSyslogConsoleArgs']]):
        pulumi.set(self, "console", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileArgs']]]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileArgs']]]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sendToAllServers")
    def send_to_all_servers(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "send_to_all_servers")

    @send_to_all_servers.setter
    def send_to_all_servers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_to_all_servers", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerArgs']]]]:
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `millisecond`, `year`, `year millisecond`
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserArgs']]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class SwitchRemoteSyslogArchiveArgsDict(TypedDict):
        files: NotRequired[pulumi.Input[int]]
        size: NotRequired[pulumi.Input[str]]
elif False:
    SwitchRemoteSyslogArchiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogArchiveArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[int]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class SwitchRemoteSyslogConsoleArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogConsoleContentArgsDict']]]]
elif False:
    SwitchRemoteSyslogConsoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogConsoleArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogConsoleContentArgs']]]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogConsoleContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogConsoleContentArgs']]]]):
        pulumi.set(self, "contents", value)


if not MYPY:
    class SwitchRemoteSyslogConsoleContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    SwitchRemoteSyslogConsoleContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogConsoleContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class SwitchRemoteSyslogFileArgsDict(TypedDict):
        archive: NotRequired[pulumi.Input['SwitchRemoteSyslogFileArchiveArgsDict']]
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileContentArgsDict']]]]
        explicit_priority: NotRequired[pulumi.Input[bool]]
        file: NotRequired[pulumi.Input[str]]
        match: NotRequired[pulumi.Input[str]]
        structured_data: NotRequired[pulumi.Input[bool]]
elif False:
    SwitchRemoteSyslogFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogFileArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input['SwitchRemoteSyslogFileArchiveArgs']] = None,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileContentArgs']]]] = None,
                 explicit_priority: Optional[pulumi.Input[bool]] = None,
                 file: Optional[pulumi.Input[str]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 structured_data: Optional[pulumi.Input[bool]] = None):
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)

    @property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input['SwitchRemoteSyslogFileArchiveArgs']]:
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input['SwitchRemoteSyslogFileArchiveArgs']]):
        pulumi.set(self, "archive", value)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogFileContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "explicit_priority")

    @explicit_priority.setter
    def explicit_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "explicit_priority", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "structured_data")

    @structured_data.setter
    def structured_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "structured_data", value)


if not MYPY:
    class SwitchRemoteSyslogFileArchiveArgsDict(TypedDict):
        files: NotRequired[pulumi.Input[int]]
        size: NotRequired[pulumi.Input[str]]
elif False:
    SwitchRemoteSyslogFileArchiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogFileArchiveArgs:
    def __init__(__self__, *,
                 files: Optional[pulumi.Input[int]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        if files is not None:
            pulumi.set(__self__, "files", files)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class SwitchRemoteSyslogFileContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    SwitchRemoteSyslogFileContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogFileContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class SwitchRemoteSyslogServerArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerContentArgsDict']]]]
        explicit_priority: NotRequired[pulumi.Input[bool]]
        facility: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        host: NotRequired[pulumi.Input[str]]
        match: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        protocol: NotRequired[pulumi.Input[str]]
        """
        enum: `tcp`, `udp`
        """
        routing_instance: NotRequired[pulumi.Input[str]]
        severity: NotRequired[pulumi.Input[str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        source_address: NotRequired[pulumi.Input[str]]
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        structured_data: NotRequired[pulumi.Input[bool]]
        tag: NotRequired[pulumi.Input[str]]
elif False:
    SwitchRemoteSyslogServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogServerArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerContentArgs']]]] = None,
                 explicit_priority: Optional[pulumi.Input[bool]] = None,
                 facility: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 routing_instance: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 source_address: Optional[pulumi.Input[str]] = None,
                 structured_data: Optional[pulumi.Input[bool]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] protocol: enum: `tcp`, `udp`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        :param pulumi.Input[str] source_address: if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if explicit_priority is not None:
            pulumi.set(__self__, "explicit_priority", explicit_priority)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routing_instance is not None:
            pulumi.set(__self__, "routing_instance", routing_instance)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if structured_data is not None:
            pulumi.set(__self__, "structured_data", structured_data)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogServerContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="explicitPriority")
    def explicit_priority(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "explicit_priority")

    @explicit_priority.setter
    def explicit_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "explicit_priority", value)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `tcp`, `udp`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="routingInstance")
    def routing_instance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "routing_instance")

    @routing_instance.setter
    def routing_instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_instance", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[str]]:
        """
        if source_address is configured, will use the vlan firstly otherwise use source_ip
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_address", value)

    @property
    @pulumi.getter(name="structuredData")
    def structured_data(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "structured_data")

    @structured_data.setter
    def structured_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "structured_data", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class SwitchRemoteSyslogServerContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    SwitchRemoteSyslogServerContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogServerContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class SwitchRemoteSyslogUserArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserContentArgsDict']]]]
        match: NotRequired[pulumi.Input[str]]
        user: NotRequired[pulumi.Input[str]]
elif False:
    SwitchRemoteSyslogUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogUserArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserContentArgs']]]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchRemoteSyslogUserContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class SwitchRemoteSyslogUserContentArgsDict(TypedDict):
        facility: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
elif False:
    SwitchRemoteSyslogUserContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchRemoteSyslogUserContentArgs:
    def __init__(__self__, *,
                 facility: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] facility: enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        :param pulumi.Input[str] severity: enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def facility(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
        """
        return pulumi.get(self, "facility")

    @facility.setter
    def facility(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facility", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class SwitchSnmpConfigArgsDict(TypedDict):
        client_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigClientListArgsDict']]]]
        contact: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        engine_id: NotRequired[pulumi.Input[str]]
        """
        enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        location: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        network: NotRequired[pulumi.Input[str]]
        trap_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigTrapGroupArgsDict']]]]
        v2c_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV2cConfigArgsDict']]]]
        v3_config: NotRequired[pulumi.Input['SwitchSnmpConfigV3ConfigArgsDict']]
        views: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigViewArgsDict']]]]
elif False:
    SwitchSnmpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigArgs:
    def __init__(__self__, *,
                 client_lists: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigClientListArgs']]]] = None,
                 contact: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 engine_id: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 trap_groups: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigTrapGroupArgs']]]] = None,
                 v2c_configs: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV2cConfigArgs']]]] = None,
                 v3_config: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigArgs']] = None,
                 views: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigViewArgs']]]] = None):
        """
        :param pulumi.Input[str] engine_id: enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        if client_lists is not None:
            pulumi.set(__self__, "client_lists", client_lists)
        if contact is not None:
            pulumi.set(__self__, "contact", contact)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if trap_groups is not None:
            pulumi.set(__self__, "trap_groups", trap_groups)
        if v2c_configs is not None:
            pulumi.set(__self__, "v2c_configs", v2c_configs)
        if v3_config is not None:
            pulumi.set(__self__, "v3_config", v3_config)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter(name="clientLists")
    def client_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigClientListArgs']]]]:
        return pulumi.get(self, "client_lists")

    @client_lists.setter
    def client_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigClientListArgs']]]]):
        pulumi.set(self, "client_lists", value)

    @property
    @pulumi.getter
    def contact(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "contact")

    @contact.setter
    def contact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contact", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
        """
        return pulumi.get(self, "engine_id")

    @engine_id.setter
    def engine_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engine_id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="trapGroups")
    def trap_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigTrapGroupArgs']]]]:
        return pulumi.get(self, "trap_groups")

    @trap_groups.setter
    def trap_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigTrapGroupArgs']]]]):
        pulumi.set(self, "trap_groups", value)

    @property
    @pulumi.getter(name="v2cConfigs")
    def v2c_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV2cConfigArgs']]]]:
        return pulumi.get(self, "v2c_configs")

    @v2c_configs.setter
    def v2c_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV2cConfigArgs']]]]):
        pulumi.set(self, "v2c_configs", value)

    @property
    @pulumi.getter(name="v3Config")
    def v3_config(self) -> Optional[pulumi.Input['SwitchSnmpConfigV3ConfigArgs']]:
        return pulumi.get(self, "v3_config")

    @v3_config.setter
    def v3_config(self, value: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigArgs']]):
        pulumi.set(self, "v3_config", value)

    @property
    @pulumi.getter
    def views(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigViewArgs']]]]:
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigViewArgs']]]]):
        pulumi.set(self, "views", value)


if not MYPY:
    class SwitchSnmpConfigClientListArgsDict(TypedDict):
        client_list_name: NotRequired[pulumi.Input[str]]
        clients: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SwitchSnmpConfigClientListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigClientListArgs:
    def __init__(__self__, *,
                 client_list_name: Optional[pulumi.Input[str]] = None,
                 clients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_list_name")

    @client_list_name.setter
    def client_list_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_list_name", value)

    @property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "clients", value)


if not MYPY:
    class SwitchSnmpConfigTrapGroupArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        group_name: NotRequired[pulumi.Input[str]]
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        version: NotRequired[pulumi.Input[str]]
        """
        enum: `all`, `v1`, `v2`
        """
elif False:
    SwitchSnmpConfigTrapGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigTrapGroupArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_name: Optional[pulumi.Input[str]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group_name: Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        :param pulumi.Input[str] version: enum: `all`, `v1`, `v2`
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `all`, `v1`, `v2`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SwitchSnmpConfigV2cConfigArgsDict(TypedDict):
        authorization: NotRequired[pulumi.Input[str]]
        client_list_name: NotRequired[pulumi.Input[str]]
        """
        client_list_name here should refer to client_list above
        """
        community_name: NotRequired[pulumi.Input[str]]
        view: NotRequired[pulumi.Input[str]]
        """
        view name here should be defined in views above
        """
elif False:
    SwitchSnmpConfigV2cConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV2cConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input[str]] = None,
                 client_list_name: Optional[pulumi.Input[str]] = None,
                 community_name: Optional[pulumi.Input[str]] = None,
                 view: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_list_name: client_list_name here should refer to client_list above
        :param pulumi.Input[str] view: view name here should be defined in views above
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if client_list_name is not None:
            pulumi.set(__self__, "client_list_name", client_list_name)
        if community_name is not None:
            pulumi.set(__self__, "community_name", community_name)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="clientListName")
    def client_list_name(self) -> Optional[pulumi.Input[str]]:
        """
        client_list_name here should refer to client_list above
        """
        return pulumi.get(self, "client_list_name")

    @client_list_name.setter
    def client_list_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_list_name", value)

    @property
    @pulumi.getter(name="communityName")
    def community_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "community_name")

    @community_name.setter
    def community_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "community_name", value)

    @property
    @pulumi.getter
    def view(self) -> Optional[pulumi.Input[str]]:
        """
        view name here should be defined in views above
        """
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigArgsDict(TypedDict):
        notifies: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyArgsDict']]]]
        notify_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterArgsDict']]]]
        target_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetAddressArgsDict']]]]
        target_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetParameterArgsDict']]]]
        usm: NotRequired[pulumi.Input['SwitchSnmpConfigV3ConfigUsmArgsDict']]
        vacm: NotRequired[pulumi.Input['SwitchSnmpConfigV3ConfigVacmArgsDict']]
elif False:
    SwitchSnmpConfigV3ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigArgs:
    def __init__(__self__, *,
                 notifies: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyArgs']]]] = None,
                 notify_filters: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterArgs']]]] = None,
                 target_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetAddressArgs']]]] = None,
                 target_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetParameterArgs']]]] = None,
                 usm: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigUsmArgs']] = None,
                 vacm: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigVacmArgs']] = None):
        if notifies is not None:
            pulumi.set(__self__, "notifies", notifies)
        if notify_filters is not None:
            pulumi.set(__self__, "notify_filters", notify_filters)
        if target_addresses is not None:
            pulumi.set(__self__, "target_addresses", target_addresses)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)
        if usm is not None:
            pulumi.set(__self__, "usm", usm)
        if vacm is not None:
            pulumi.set(__self__, "vacm", vacm)

    @property
    @pulumi.getter
    def notifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyArgs']]]]:
        return pulumi.get(self, "notifies")

    @notifies.setter
    def notifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyArgs']]]]):
        pulumi.set(self, "notifies", value)

    @property
    @pulumi.getter(name="notifyFilters")
    def notify_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterArgs']]]]:
        return pulumi.get(self, "notify_filters")

    @notify_filters.setter
    def notify_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterArgs']]]]):
        pulumi.set(self, "notify_filters", value)

    @property
    @pulumi.getter(name="targetAddresses")
    def target_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetAddressArgs']]]]:
        return pulumi.get(self, "target_addresses")

    @target_addresses.setter
    def target_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetAddressArgs']]]]):
        pulumi.set(self, "target_addresses", value)

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetParameterArgs']]]]:
        return pulumi.get(self, "target_parameters")

    @target_parameters.setter
    def target_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigTargetParameterArgs']]]]):
        pulumi.set(self, "target_parameters", value)

    @property
    @pulumi.getter
    def usm(self) -> Optional[pulumi.Input['SwitchSnmpConfigV3ConfigUsmArgs']]:
        return pulumi.get(self, "usm")

    @usm.setter
    def usm(self, value: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigUsmArgs']]):
        pulumi.set(self, "usm", value)

    @property
    @pulumi.getter
    def vacm(self) -> Optional[pulumi.Input['SwitchSnmpConfigV3ConfigVacmArgs']]:
        return pulumi.get(self, "vacm")

    @vacm.setter
    def vacm(self, value: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigVacmArgs']]):
        pulumi.set(self, "vacm", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigNotifyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        tag: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `inform`, `trap`
        """
elif False:
    SwitchSnmpConfigV3ConfigNotifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigNotifyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: enum: `inform`, `trap`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `inform`, `trap`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigNotifyFilterArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterContentArgsDict']]]]
        profile_name: NotRequired[pulumi.Input[str]]
elif False:
    SwitchSnmpConfigV3ConfigNotifyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigNotifyFilterArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterContentArgs']]]] = None,
                 profile_name: Optional[pulumi.Input[str]] = None):
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if profile_name is not None:
            pulumi.set(__self__, "profile_name", profile_name)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigNotifyFilterContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile_name", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigNotifyFilterContentArgsDict(TypedDict):
        include: NotRequired[pulumi.Input[bool]]
        oid: NotRequired[pulumi.Input[str]]
elif False:
    SwitchSnmpConfigV3ConfigNotifyFilterContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigNotifyFilterContentArgs:
    def __init__(__self__, *,
                 include: Optional[pulumi.Input[bool]] = None,
                 oid: Optional[pulumi.Input[str]] = None):
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter
    def oid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oid")

    @oid.setter
    def oid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oid", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigTargetAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        address_mask: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        tag_list: NotRequired[pulumi.Input[str]]
        """
        <refer to notify tag, can be multiple with blank
        """
        target_address_name: NotRequired[pulumi.Input[str]]
        target_parameters: NotRequired[pulumi.Input[str]]
        """
        refer to notify target parameters name
        """
elif False:
    SwitchSnmpConfigV3ConfigTargetAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigTargetAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 address_mask: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 tag_list: Optional[pulumi.Input[str]] = None,
                 target_address_name: Optional[pulumi.Input[str]] = None,
                 target_parameters: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] tag_list: <refer to notify tag, can be multiple with blank
        :param pulumi.Input[str] target_parameters: refer to notify target parameters name
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_mask is not None:
            pulumi.set(__self__, "address_mask", address_mask)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if target_address_name is not None:
            pulumi.set(__self__, "target_address_name", target_address_name)
        if target_parameters is not None:
            pulumi.set(__self__, "target_parameters", target_parameters)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressMask")
    def address_mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address_mask")

    @address_mask.setter
    def address_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_mask", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[pulumi.Input[str]]:
        """
        <refer to notify tag, can be multiple with blank
        """
        return pulumi.get(self, "tag_list")

    @tag_list.setter
    def tag_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_list", value)

    @property
    @pulumi.getter(name="targetAddressName")
    def target_address_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_address_name")

    @target_address_name.setter
    def target_address_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_address_name", value)

    @property
    @pulumi.getter(name="targetParameters")
    def target_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        refer to notify target parameters name
        """
        return pulumi.get(self, "target_parameters")

    @target_parameters.setter
    def target_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_parameters", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigTargetParameterArgsDict(TypedDict):
        message_processing_model: NotRequired[pulumi.Input[str]]
        """
        enum: `v1`, `v2c`, `v3`
        """
        name: NotRequired[pulumi.Input[str]]
        notify_filter: NotRequired[pulumi.Input[str]]
        """
        refer to profile-name in notify_filter
        """
        security_level: NotRequired[pulumi.Input[str]]
        """
        enum: `authentication`, `none`, `privacy`
        """
        security_model: NotRequired[pulumi.Input[str]]
        """
        enum: `usm`, `v1`, `v2c`
        """
        security_name: NotRequired[pulumi.Input[str]]
        """
        refer to security_name in usm
        """
elif False:
    SwitchSnmpConfigV3ConfigTargetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigTargetParameterArgs:
    def __init__(__self__, *,
                 message_processing_model: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 notify_filter: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 security_model: Optional[pulumi.Input[str]] = None,
                 security_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message_processing_model: enum: `v1`, `v2c`, `v3`
        :param pulumi.Input[str] notify_filter: refer to profile-name in notify_filter
        :param pulumi.Input[str] security_level: enum: `authentication`, `none`, `privacy`
        :param pulumi.Input[str] security_model: enum: `usm`, `v1`, `v2c`
        :param pulumi.Input[str] security_name: refer to security_name in usm
        """
        if message_processing_model is not None:
            pulumi.set(__self__, "message_processing_model", message_processing_model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notify_filter is not None:
            pulumi.set(__self__, "notify_filter", notify_filter)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter(name="messageProcessingModel")
    def message_processing_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `v1`, `v2c`, `v3`
        """
        return pulumi.get(self, "message_processing_model")

    @message_processing_model.setter
    def message_processing_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_processing_model", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notifyFilter")
    def notify_filter(self) -> Optional[pulumi.Input[str]]:
        """
        refer to profile-name in notify_filter
        """
        return pulumi.get(self, "notify_filter")

    @notify_filter.setter
    def notify_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_filter", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_model", value)

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[pulumi.Input[str]]:
        """
        refer to security_name in usm
        """
        return pulumi.get(self, "security_name")

    @security_name.setter
    def security_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_name", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigUsmArgsDict(TypedDict):
        engine_type: NotRequired[pulumi.Input[str]]
        """
        enum: `local_engine`, `remote_engine`
        """
        engineid: NotRequired[pulumi.Input[str]]
        """
        required only if `engine_type`==`remote_engine`
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigUsmUserArgsDict']]]]
elif False:
    SwitchSnmpConfigV3ConfigUsmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigUsmArgs:
    def __init__(__self__, *,
                 engine_type: Optional[pulumi.Input[str]] = None,
                 engineid: Optional[pulumi.Input[str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigUsmUserArgs']]]] = None):
        """
        :param pulumi.Input[str] engine_type: enum: `local_engine`, `remote_engine`
        :param pulumi.Input[str] engineid: required only if `engine_type`==`remote_engine`
        """
        if engine_type is not None:
            pulumi.set(__self__, "engine_type", engine_type)
        if engineid is not None:
            pulumi.set(__self__, "engineid", engineid)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `local_engine`, `remote_engine`
        """
        return pulumi.get(self, "engine_type")

    @engine_type.setter
    def engine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engine_type", value)

    @property
    @pulumi.getter
    def engineid(self) -> Optional[pulumi.Input[str]]:
        """
        required only if `engine_type`==`remote_engine`
        """
        return pulumi.get(self, "engineid")

    @engineid.setter
    def engineid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engineid", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigUsmUserArgs']]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigUsmUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigUsmUserArgsDict(TypedDict):
        authentication_password: NotRequired[pulumi.Input[str]]
        """
        Not required if `authentication_type`==`authentication_none`
        include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        authentication_type: NotRequired[pulumi.Input[str]]
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        """
        encryption_password: NotRequired[pulumi.Input[str]]
        """
        Not required if `encryption_type`==`privacy-none`
        include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        encryption_type: NotRequired[pulumi.Input[str]]
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        name: NotRequired[pulumi.Input[str]]
elif False:
    SwitchSnmpConfigV3ConfigUsmUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigUsmUserArgs:
    def __init__(__self__, *,
                 authentication_password: Optional[pulumi.Input[str]] = None,
                 authentication_type: Optional[pulumi.Input[str]] = None,
                 encryption_password: Optional[pulumi.Input[str]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authentication_password: Not required if `authentication_type`==`authentication_none`
               include alphabetic, numeric, and special characters, but it cannot include control characters.
        :param pulumi.Input[str] authentication_type: sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        :param pulumi.Input[str] encryption_password: Not required if `encryption_type`==`privacy-none`
               include alphabetic, numeric, and special characters, but it cannot include control characters
        :param pulumi.Input[str] encryption_type: enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        if authentication_password is not None:
            pulumi.set(__self__, "authentication_password", authentication_password)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if encryption_password is not None:
            pulumi.set(__self__, "encryption_password", encryption_password)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="authenticationPassword")
    def authentication_password(self) -> Optional[pulumi.Input[str]]:
        """
        Not required if `authentication_type`==`authentication_none`
        include alphabetic, numeric, and special characters, but it cannot include control characters.
        """
        return pulumi.get(self, "authentication_password")

    @authentication_password.setter
    def authentication_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_password", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[str]]:
        """
        sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="encryptionPassword")
    def encryption_password(self) -> Optional[pulumi.Input[str]]:
        """
        Not required if `encryption_type`==`privacy-none`
        include alphabetic, numeric, and special characters, but it cannot include control characters
        """
        return pulumi.get(self, "encryption_password")

    @encryption_password.setter
    def encryption_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_password", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigVacmArgsDict(TypedDict):
        accesses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessArgsDict']]]]
        security_to_group: NotRequired[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgsDict']]
elif False:
    SwitchSnmpConfigV3ConfigVacmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigVacmArgs:
    def __init__(__self__, *,
                 accesses: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessArgs']]]] = None,
                 security_to_group: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgs']] = None):
        if accesses is not None:
            pulumi.set(__self__, "accesses", accesses)
        if security_to_group is not None:
            pulumi.set(__self__, "security_to_group", security_to_group)

    @property
    @pulumi.getter
    def accesses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessArgs']]]]:
        return pulumi.get(self, "accesses")

    @accesses.setter
    def accesses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessArgs']]]]):
        pulumi.set(self, "accesses", value)

    @property
    @pulumi.getter(name="securityToGroup")
    def security_to_group(self) -> Optional[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgs']]:
        return pulumi.get(self, "security_to_group")

    @security_to_group.setter
    def security_to_group(self, value: Optional[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgs']]):
        pulumi.set(self, "security_to_group", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigVacmAccessArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[str]]
        prefix_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgsDict']]]]
elif False:
    SwitchSnmpConfigV3ConfigVacmAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigVacmAccessArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[str]] = None,
                 prefix_lists: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]] = None):
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if prefix_lists is not None:
            pulumi.set(__self__, "prefix_lists", prefix_lists)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="prefixLists")
    def prefix_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]]:
        return pulumi.get(self, "prefix_lists")

    @prefix_lists.setter
    def prefix_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgs']]]]):
        pulumi.set(self, "prefix_lists", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgsDict(TypedDict):
        context_prefix: NotRequired[pulumi.Input[str]]
        """
        only required if `type`==`context_prefix`
        """
        notify_view: NotRequired[pulumi.Input[str]]
        """
        refer to view name
        """
        read_view: NotRequired[pulumi.Input[str]]
        """
        refer to view name
        """
        security_level: NotRequired[pulumi.Input[str]]
        """
        enum: `authentication`, `none`, `privacy`
        """
        security_model: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        write_view: NotRequired[pulumi.Input[str]]
        """
        refer to view name
        """
elif False:
    SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigVacmAccessPrefixListArgs:
    def __init__(__self__, *,
                 context_prefix: Optional[pulumi.Input[str]] = None,
                 notify_view: Optional[pulumi.Input[str]] = None,
                 read_view: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 security_model: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 write_view: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context_prefix: only required if `type`==`context_prefix`
        :param pulumi.Input[str] notify_view: refer to view name
        :param pulumi.Input[str] read_view: refer to view name
        :param pulumi.Input[str] security_level: enum: `authentication`, `none`, `privacy`
        :param pulumi.Input[str] security_model: enum: `any`, `usm`, `v1`, `v2c`
        :param pulumi.Input[str] type: enum: `context_prefix`, `default_context_prefix`
        :param pulumi.Input[str] write_view: refer to view name
        """
        if context_prefix is not None:
            pulumi.set(__self__, "context_prefix", context_prefix)
        if notify_view is not None:
            pulumi.set(__self__, "notify_view", notify_view)
        if read_view is not None:
            pulumi.set(__self__, "read_view", read_view)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if write_view is not None:
            pulumi.set(__self__, "write_view", write_view)

    @property
    @pulumi.getter(name="contextPrefix")
    def context_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        only required if `type`==`context_prefix`
        """
        return pulumi.get(self, "context_prefix")

    @context_prefix.setter
    def context_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_prefix", value)

    @property
    @pulumi.getter(name="notifyView")
    def notify_view(self) -> Optional[pulumi.Input[str]]:
        """
        refer to view name
        """
        return pulumi.get(self, "notify_view")

    @notify_view.setter
    def notify_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notify_view", value)

    @property
    @pulumi.getter(name="readView")
    def read_view(self) -> Optional[pulumi.Input[str]]:
        """
        refer to view name
        """
        return pulumi.get(self, "read_view")

    @read_view.setter
    def read_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_view", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `authentication`, `none`, `privacy`
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_model", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `context_prefix`, `default_context_prefix`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="writeView")
    def write_view(self) -> Optional[pulumi.Input[str]]:
        """
        refer to view name
        """
        return pulumi.get(self, "write_view")

    @write_view.setter
    def write_view(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "write_view", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict']]]]
        security_model: NotRequired[pulumi.Input[str]]
        """
        enum: `usm`, `v1`, `v2c`
        """
elif False:
    SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigVacmSecurityToGroupArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]] = None,
                 security_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] security_model: enum: `usm`, `v1`, `v2c`
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if security_model is not None:
            pulumi.set(__self__, "security_model", security_model)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]]:
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter(name="securityModel")
    def security_model(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `usm`, `v1`, `v2c`
        """
        return pulumi.get(self, "security_model")

    @security_model.setter
    def security_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_model", value)


if not MYPY:
    class SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[str]]
        """
        refer to group_name under access
        """
        security_name: NotRequired[pulumi.Input[str]]
elif False:
    SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigV3ConfigVacmSecurityToGroupContentArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 security_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group: refer to group_name under access
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if security_name is not None:
            pulumi.set(__self__, "security_name", security_name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        refer to group_name under access
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="securityName")
    def security_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_name")

    @security_name.setter
    def security_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_name", value)


if not MYPY:
    class SwitchSnmpConfigViewArgsDict(TypedDict):
        include: NotRequired[pulumi.Input[bool]]
        """
        if the root oid configured is included
        """
        oid: NotRequired[pulumi.Input[str]]
        view_name: NotRequired[pulumi.Input[str]]
elif False:
    SwitchSnmpConfigViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSnmpConfigViewArgs:
    def __init__(__self__, *,
                 include: Optional[pulumi.Input[bool]] = None,
                 oid: Optional[pulumi.Input[str]] = None,
                 view_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include: if the root oid configured is included
        """
        if include is not None:
            pulumi.set(__self__, "include", include)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[bool]]:
        """
        if the root oid configured is included
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter
    def oid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "oid")

    @oid.setter
    def oid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oid", value)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "view_name")

    @view_name.setter
    def view_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view_name", value)


if not MYPY:
    class SwitchStpConfigArgsDict(TypedDict):
        bridge_priority: NotRequired[pulumi.Input[str]]
        """
        Switch STP priority: from `0k` to `15k`
        """
elif False:
    SwitchStpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchStpConfigArgs:
    def __init__(__self__, *,
                 bridge_priority: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bridge_priority: Switch STP priority: from `0k` to `15k`
        """
        if bridge_priority is not None:
            pulumi.set(__self__, "bridge_priority", bridge_priority)

    @property
    @pulumi.getter(name="bridgePriority")
    def bridge_priority(self) -> Optional[pulumi.Input[str]]:
        """
        Switch STP priority: from `0k` to `15k`
        """
        return pulumi.get(self, "bridge_priority")

    @bridge_priority.setter
    def bridge_priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge_priority", value)


if not MYPY:
    class SwitchSwitchMgmtArgsDict(TypedDict):
        ap_affinity_threshold: NotRequired[pulumi.Input[int]]
        """
        ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        cli_banner: NotRequired[pulumi.Input[str]]
        """
        Set Banners for switches. Allows markup formatting
        """
        cli_idle_timeout: NotRequired[pulumi.Input[int]]
        """
        Sets timeout for switches
        """
        config_revert_timer: NotRequired[pulumi.Input[int]]
        """
        the rollback timer for commit confirmed
        """
        dhcp_option_fqdn: NotRequired[pulumi.Input[bool]]
        """
        Enable to provide the FQDN with DHCP option 81
        """
        disable_oob_down_alarm: NotRequired[pulumi.Input[bool]]
        local_accounts: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchSwitchMgmtLocalAccountsArgsDict']]]]
        """
        Property key is the user name. For Local user authentication
        """
        mxedge_proxy_host: NotRequired[pulumi.Input[str]]
        mxedge_proxy_port: NotRequired[pulumi.Input[int]]
        protect_re: NotRequired[pulumi.Input['SwitchSwitchMgmtProtectReArgsDict']]
        """
        restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        root_password: NotRequired[pulumi.Input[str]]
        tacacs: NotRequired[pulumi.Input['SwitchSwitchMgmtTacacsArgsDict']]
        use_mxedge_proxy: NotRequired[pulumi.Input[bool]]
        """
        to use mxedge as proxy
        """
elif False:
    SwitchSwitchMgmtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtArgs:
    def __init__(__self__, *,
                 ap_affinity_threshold: Optional[pulumi.Input[int]] = None,
                 cli_banner: Optional[pulumi.Input[str]] = None,
                 cli_idle_timeout: Optional[pulumi.Input[int]] = None,
                 config_revert_timer: Optional[pulumi.Input[int]] = None,
                 dhcp_option_fqdn: Optional[pulumi.Input[bool]] = None,
                 disable_oob_down_alarm: Optional[pulumi.Input[bool]] = None,
                 local_accounts: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchSwitchMgmtLocalAccountsArgs']]]] = None,
                 mxedge_proxy_host: Optional[pulumi.Input[str]] = None,
                 mxedge_proxy_port: Optional[pulumi.Input[int]] = None,
                 protect_re: Optional[pulumi.Input['SwitchSwitchMgmtProtectReArgs']] = None,
                 root_password: Optional[pulumi.Input[str]] = None,
                 tacacs: Optional[pulumi.Input['SwitchSwitchMgmtTacacsArgs']] = None,
                 use_mxedge_proxy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] ap_affinity_threshold: ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        :param pulumi.Input[str] cli_banner: Set Banners for switches. Allows markup formatting
        :param pulumi.Input[int] cli_idle_timeout: Sets timeout for switches
        :param pulumi.Input[int] config_revert_timer: the rollback timer for commit confirmed
        :param pulumi.Input[bool] dhcp_option_fqdn: Enable to provide the FQDN with DHCP option 81
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchSwitchMgmtLocalAccountsArgs']]] local_accounts: Property key is the user name. For Local user authentication
        :param pulumi.Input['SwitchSwitchMgmtProtectReArgs'] protect_re: restrict inbound-traffic to host
               when enabled, all traffic that is not essential to our operation will be dropped 
               e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        :param pulumi.Input[bool] use_mxedge_proxy: to use mxedge as proxy
        """
        if ap_affinity_threshold is not None:
            pulumi.set(__self__, "ap_affinity_threshold", ap_affinity_threshold)
        if cli_banner is not None:
            pulumi.set(__self__, "cli_banner", cli_banner)
        if cli_idle_timeout is not None:
            pulumi.set(__self__, "cli_idle_timeout", cli_idle_timeout)
        if config_revert_timer is not None:
            pulumi.set(__self__, "config_revert_timer", config_revert_timer)
        if dhcp_option_fqdn is not None:
            pulumi.set(__self__, "dhcp_option_fqdn", dhcp_option_fqdn)
        if disable_oob_down_alarm is not None:
            pulumi.set(__self__, "disable_oob_down_alarm", disable_oob_down_alarm)
        if local_accounts is not None:
            pulumi.set(__self__, "local_accounts", local_accounts)
        if mxedge_proxy_host is not None:
            pulumi.set(__self__, "mxedge_proxy_host", mxedge_proxy_host)
        if mxedge_proxy_port is not None:
            pulumi.set(__self__, "mxedge_proxy_port", mxedge_proxy_port)
        if protect_re is not None:
            pulumi.set(__self__, "protect_re", protect_re)
        if root_password is not None:
            pulumi.set(__self__, "root_password", root_password)
        if tacacs is not None:
            pulumi.set(__self__, "tacacs", tacacs)
        if use_mxedge_proxy is not None:
            pulumi.set(__self__, "use_mxedge_proxy", use_mxedge_proxy)

    @property
    @pulumi.getter(name="apAffinityThreshold")
    def ap_affinity_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
        """
        return pulumi.get(self, "ap_affinity_threshold")

    @ap_affinity_threshold.setter
    def ap_affinity_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ap_affinity_threshold", value)

    @property
    @pulumi.getter(name="cliBanner")
    def cli_banner(self) -> Optional[pulumi.Input[str]]:
        """
        Set Banners for switches. Allows markup formatting
        """
        return pulumi.get(self, "cli_banner")

    @cli_banner.setter
    def cli_banner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cli_banner", value)

    @property
    @pulumi.getter(name="cliIdleTimeout")
    def cli_idle_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Sets timeout for switches
        """
        return pulumi.get(self, "cli_idle_timeout")

    @cli_idle_timeout.setter
    def cli_idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cli_idle_timeout", value)

    @property
    @pulumi.getter(name="configRevertTimer")
    def config_revert_timer(self) -> Optional[pulumi.Input[int]]:
        """
        the rollback timer for commit confirmed
        """
        return pulumi.get(self, "config_revert_timer")

    @config_revert_timer.setter
    def config_revert_timer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "config_revert_timer", value)

    @property
    @pulumi.getter(name="dhcpOptionFqdn")
    def dhcp_option_fqdn(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable to provide the FQDN with DHCP option 81
        """
        return pulumi.get(self, "dhcp_option_fqdn")

    @dhcp_option_fqdn.setter
    def dhcp_option_fqdn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp_option_fqdn", value)

    @property
    @pulumi.getter(name="disableOobDownAlarm")
    def disable_oob_down_alarm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_oob_down_alarm")

    @disable_oob_down_alarm.setter
    def disable_oob_down_alarm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_oob_down_alarm", value)

    @property
    @pulumi.getter(name="localAccounts")
    def local_accounts(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchSwitchMgmtLocalAccountsArgs']]]]:
        """
        Property key is the user name. For Local user authentication
        """
        return pulumi.get(self, "local_accounts")

    @local_accounts.setter
    def local_accounts(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchSwitchMgmtLocalAccountsArgs']]]]):
        pulumi.set(self, "local_accounts", value)

    @property
    @pulumi.getter(name="mxedgeProxyHost")
    def mxedge_proxy_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mxedge_proxy_host")

    @mxedge_proxy_host.setter
    def mxedge_proxy_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mxedge_proxy_host", value)

    @property
    @pulumi.getter(name="mxedgeProxyPort")
    def mxedge_proxy_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mxedge_proxy_port")

    @mxedge_proxy_port.setter
    def mxedge_proxy_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mxedge_proxy_port", value)

    @property
    @pulumi.getter(name="protectRe")
    def protect_re(self) -> Optional[pulumi.Input['SwitchSwitchMgmtProtectReArgs']]:
        """
        restrict inbound-traffic to host
        when enabled, all traffic that is not essential to our operation will be dropped 
        e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "protect_re")

    @protect_re.setter
    def protect_re(self, value: Optional[pulumi.Input['SwitchSwitchMgmtProtectReArgs']]):
        pulumi.set(self, "protect_re", value)

    @property
    @pulumi.getter(name="rootPassword")
    def root_password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "root_password")

    @root_password.setter
    def root_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_password", value)

    @property
    @pulumi.getter
    def tacacs(self) -> Optional[pulumi.Input['SwitchSwitchMgmtTacacsArgs']]:
        return pulumi.get(self, "tacacs")

    @tacacs.setter
    def tacacs(self, value: Optional[pulumi.Input['SwitchSwitchMgmtTacacsArgs']]):
        pulumi.set(self, "tacacs", value)

    @property
    @pulumi.getter(name="useMxedgeProxy")
    def use_mxedge_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        to use mxedge as proxy
        """
        return pulumi.get(self, "use_mxedge_proxy")

    @use_mxedge_proxy.setter
    def use_mxedge_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_mxedge_proxy", value)


if not MYPY:
    class SwitchSwitchMgmtLocalAccountsArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        role: NotRequired[pulumi.Input[str]]
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
elif False:
    SwitchSwitchMgmtLocalAccountsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtLocalAccountsArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role: enum: `admin`, `helpdesk`, `none`, `read`
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class SwitchSwitchMgmtProtectReArgsDict(TypedDict):
        allowed_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        optionally, services we'll allow. enum: `icmp`, `ssh`
        """
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtProtectReCustomArgsDict']]]]
        enabled: NotRequired[pulumi.Input[bool]]
        """
        when enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        trusted_hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        host/subnets we'll allow traffic to/from
        """
elif False:
    SwitchSwitchMgmtProtectReArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtProtectReArgs:
    def __init__(__self__, *,
                 allowed_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtProtectReCustomArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 trusted_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_services: optionally, services we'll allow. enum: `icmp`, `ssh`
        :param pulumi.Input[bool] enabled: when enabled, all traffic that is not essential to our operation will be dropped
               e.g. ntp / dns / traffic to mist will be allowed by default
                    if dhcpd is enabled, we'll make sure it works
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trusted_hosts: host/subnets we'll allow traffic to/from
        """
        if allowed_services is not None:
            pulumi.set(__self__, "allowed_services", allowed_services)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if trusted_hosts is not None:
            pulumi.set(__self__, "trusted_hosts", trusted_hosts)

    @property
    @pulumi.getter(name="allowedServices")
    def allowed_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        optionally, services we'll allow. enum: `icmp`, `ssh`
        """
        return pulumi.get(self, "allowed_services")

    @allowed_services.setter
    def allowed_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_services", value)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtProtectReCustomArgs']]]]:
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtProtectReCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        when enabled, all traffic that is not essential to our operation will be dropped
        e.g. ntp / dns / traffic to mist will be allowed by default
             if dhcpd is enabled, we'll make sure it works
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="trustedHosts")
    def trusted_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        host/subnets we'll allow traffic to/from
        """
        return pulumi.get(self, "trusted_hosts")

    @trusted_hosts.setter
    def trusted_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "trusted_hosts", value)


if not MYPY:
    class SwitchSwitchMgmtProtectReCustomArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        port_range: NotRequired[pulumi.Input[str]]
        """
        matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
elif False:
    SwitchSwitchMgmtProtectReCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtProtectReCustomArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port_range: matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        :param pulumi.Input[str] protocol: enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        pulumi.set(__self__, "subnets", subnets)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        matched dst port, "0" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class SwitchSwitchMgmtTacacsArgsDict(TypedDict):
        acct_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsAcctServerArgsDict']]]]
        default_role: NotRequired[pulumi.Input[str]]
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        enabled: NotRequired[pulumi.Input[bool]]
        network: NotRequired[pulumi.Input[str]]
        """
        which network the TACACS server resides
        """
        tacplus_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsTacplusServerArgsDict']]]]
elif False:
    SwitchSwitchMgmtTacacsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtTacacsArgs:
    def __init__(__self__, *,
                 acct_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsAcctServerArgs']]]] = None,
                 default_role: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 tacplus_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsTacplusServerArgs']]]] = None):
        """
        :param pulumi.Input[str] default_role: enum: `admin`, `helpdesk`, `none`, `read`
        :param pulumi.Input[str] network: which network the TACACS server resides
        """
        if acct_servers is not None:
            pulumi.set(__self__, "acct_servers", acct_servers)
        if default_role is not None:
            pulumi.set(__self__, "default_role", default_role)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if tacplus_servers is not None:
            pulumi.set(__self__, "tacplus_servers", tacplus_servers)

    @property
    @pulumi.getter(name="acctServers")
    def acct_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsAcctServerArgs']]]]:
        return pulumi.get(self, "acct_servers")

    @acct_servers.setter
    def acct_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsAcctServerArgs']]]]):
        pulumi.set(self, "acct_servers", value)

    @property
    @pulumi.getter(name="defaultRole")
    def default_role(self) -> Optional[pulumi.Input[str]]:
        """
        enum: `admin`, `helpdesk`, `none`, `read`
        """
        return pulumi.get(self, "default_role")

    @default_role.setter
    def default_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_role", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        which network the TACACS server resides
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="tacplusServers")
    def tacplus_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsTacplusServerArgs']]]]:
        return pulumi.get(self, "tacplus_servers")

    @tacplus_servers.setter
    def tacplus_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchSwitchMgmtTacacsTacplusServerArgs']]]]):
        pulumi.set(self, "tacplus_servers", value)


if not MYPY:
    class SwitchSwitchMgmtTacacsAcctServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[str]]
        secret: NotRequired[pulumi.Input[str]]
        timeout: NotRequired[pulumi.Input[int]]
elif False:
    SwitchSwitchMgmtTacacsAcctServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtTacacsAcctServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class SwitchSwitchMgmtTacacsTacplusServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[str]]
        secret: NotRequired[pulumi.Input[str]]
        timeout: NotRequired[pulumi.Input[int]]
elif False:
    SwitchSwitchMgmtTacacsTacplusServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchSwitchMgmtTacacsTacplusServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class SwitchVirtualChassisArgsDict(TypedDict):
        members: NotRequired[pulumi.Input[Sequence[pulumi.Input['SwitchVirtualChassisMemberArgsDict']]]]
        """
        list of Virtual Chassis members
        """
        preprovisioned: NotRequired[pulumi.Input[bool]]
        """
        to configure whether the VC is preprovisioned or nonprovisioned
        """
elif False:
    SwitchVirtualChassisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVirtualChassisArgs:
    def __init__(__self__, *,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchVirtualChassisMemberArgs']]]] = None,
                 preprovisioned: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SwitchVirtualChassisMemberArgs']]] members: list of Virtual Chassis members
        :param pulumi.Input[bool] preprovisioned: to configure whether the VC is preprovisioned or nonprovisioned
        """
        if members is not None:
            pulumi.set(__self__, "members", members)
        if preprovisioned is not None:
            pulumi.set(__self__, "preprovisioned", preprovisioned)

    @property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SwitchVirtualChassisMemberArgs']]]]:
        """
        list of Virtual Chassis members
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SwitchVirtualChassisMemberArgs']]]]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def preprovisioned(self) -> Optional[pulumi.Input[bool]]:
        """
        to configure whether the VC is preprovisioned or nonprovisioned
        """
        return pulumi.get(self, "preprovisioned")

    @preprovisioned.setter
    def preprovisioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preprovisioned", value)


if not MYPY:
    class SwitchVirtualChassisMemberArgsDict(TypedDict):
        mac: NotRequired[pulumi.Input[str]]
        """
        fpc0, same as the mac of device_id
        """
        member_id: NotRequired[pulumi.Input[int]]
        vc_role: NotRequired[pulumi.Input[str]]
        """
        Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
        """
elif False:
    SwitchVirtualChassisMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVirtualChassisMemberArgs:
    def __init__(__self__, *,
                 mac: Optional[pulumi.Input[str]] = None,
                 member_id: Optional[pulumi.Input[int]] = None,
                 vc_role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mac: fpc0, same as the mac of device_id
        :param pulumi.Input[str] vc_role: Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if member_id is not None:
            pulumi.set(__self__, "member_id", member_id)
        if vc_role is not None:
            pulumi.set(__self__, "vc_role", vc_role)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        """
        fpc0, same as the mac of device_id
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter(name="memberId")
    def member_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "member_id")

    @member_id.setter
    def member_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "member_id", value)

    @property
    @pulumi.getter(name="vcRole")
    def vc_role(self) -> Optional[pulumi.Input[str]]:
        """
        Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
        """
        return pulumi.get(self, "vc_role")

    @vc_role.setter
    def vc_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vc_role", value)


if not MYPY:
    class SwitchVrfConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        whether to enable VRF (when supported on the device)
        """
elif False:
    SwitchVrfConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVrfConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: whether to enable VRF (when supported on the device)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to enable VRF (when supported on the device)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SwitchVrfInstancesArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        vrf_extra_routes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrfInstancesVrfExtraRoutesArgsDict']]]]
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
elif False:
    SwitchVrfInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVrfInstancesArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vrf_extra_routes: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrfInstancesVrfExtraRoutesArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchVrfInstancesVrfExtraRoutesArgs']]] vrf_extra_routes: Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if vrf_extra_routes is not None:
            pulumi.set(__self__, "vrf_extra_routes", vrf_extra_routes)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="vrfExtraRoutes")
    def vrf_extra_routes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrfInstancesVrfExtraRoutesArgs']]]]:
        """
        Property key is the destination CIDR (e.g. "10.0.0.0/8")
        """
        return pulumi.get(self, "vrf_extra_routes")

    @vrf_extra_routes.setter
    def vrf_extra_routes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrfInstancesVrfExtraRoutesArgs']]]]):
        pulumi.set(self, "vrf_extra_routes", value)


if not MYPY:
    class SwitchVrfInstancesVrfExtraRoutesArgsDict(TypedDict):
        via: pulumi.Input[str]
        """
        Next-hop address
        """
elif False:
    SwitchVrfInstancesVrfExtraRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVrfInstancesVrfExtraRoutesArgs:
    def __init__(__self__, *,
                 via: pulumi.Input[str]):
        """
        :param pulumi.Input[str] via: Next-hop address
        """
        pulumi.set(__self__, "via", via)

    @property
    @pulumi.getter
    def via(self) -> pulumi.Input[str]:
        """
        Next-hop address
        """
        return pulumi.get(self, "via")

    @via.setter
    def via(self, value: pulumi.Input[str]):
        pulumi.set(self, "via", value)


if not MYPY:
    class SwitchVrrpConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        groups: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrrpConfigGroupsArgsDict']]]]
        """
        Property key is the VRRP name
        """
elif False:
    SwitchVrrpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVrrpConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrrpConfigGroupsArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['SwitchVrrpConfigGroupsArgs']]] groups: Property key is the VRRP name
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrrpConfigGroupsArgs']]]]:
        """
        Property key is the VRRP name
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SwitchVrrpConfigGroupsArgs']]]]):
        pulumi.set(self, "groups", value)


if not MYPY:
    class SwitchVrrpConfigGroupsArgsDict(TypedDict):
        priority: NotRequired[pulumi.Input[int]]
elif False:
    SwitchVrrpConfigGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwitchVrrpConfigGroupsArgs:
    def __init__(__self__, *,
                 priority: Optional[pulumi.Input[int]] = None):
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class BaseLatlngArgsDict(TypedDict):
        lat: pulumi.Input[float]
        lng: pulumi.Input[float]
elif False:
    BaseLatlngArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BaseLatlngArgs:
    def __init__(__self__, *,
                 lat: pulumi.Input[float],
                 lng: pulumi.Input[float]):
        pulumi.set(__self__, "lat", lat)
        pulumi.set(__self__, "lng", lng)

    @property
    @pulumi.getter
    def lat(self) -> pulumi.Input[float]:
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: pulumi.Input[float]):
        pulumi.set(self, "lat", value)

    @property
    @pulumi.getter
    def lng(self) -> pulumi.Input[float]:
        return pulumi.get(self, "lng")

    @lng.setter
    def lng(self, value: pulumi.Input[float]):
        pulumi.set(self, "lng", value)


