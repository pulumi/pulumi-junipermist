// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetConstAppCategoriesConstAppCategory {
    /**
     * Description of the app category
     */
    display: string;
    filters: outputs.GetConstAppCategoriesConstAppCategoryFilters;
    /**
     * List of other App Categories contained by this one
     */
    includes: string[];
    /**
     * Key name of the app category
     */
    key: string;
}

export interface GetConstAppCategoriesConstAppCategoryFilters {
    srxes: string[];
    ssrs: string[];
}

export interface GetConstAppSubCategoriesConstAppSubCategory {
    /**
     * Description of the app subcategory
     */
    display: string;
    /**
     * Key name of the app subcategory
     */
    key: string;
    /**
     * Type of traffic (QoS) of the app subcategory
     */
    trafficType: string;
}

export interface GetConstApplicationsConstApplication {
    appId: boolean;
    appImageUrl: string;
    appProbe: boolean;
    category: string;
    group: string;
    key: string;
    name: string;
    signatureBased: boolean;
    ssrAppId: boolean;
}

export interface GetConstCountriesConstCountry {
    /**
     * country code, in two-character
     */
    alpha2: string;
    certified: boolean;
    name: string;
    /**
     * country code, ISO 3166-1 numeric
     */
    numeric: number;
}

export interface GetConstTrafficTypesConstTrafficType {
    display: string;
    dscp: number;
    failoverPolicy: string;
    maxJitter: number;
    maxLatency: number;
    maxLoss: number;
    name: string;
    trafficClass: string;
}

export interface GetSitesSite {
    /**
     * full address of the site
     */
    address: string;
    /**
     * Alarm Template ID, this takes precedence over the Org-level alarmtemplate_id
     */
    alarmtemplateId: string;
    /**
     * AP Template ID, used by APs
     */
    aptemplateId: string;
    /**
     * country code for the site (for AP config generation), in two-character
     */
    countryCode: string;
    createdTime: number;
    /**
     * Gateway Template ID, used by gateways
     */
    gatewaytemplateId: string;
    id: string;
    latlng: outputs.GetSitesSiteLatlng;
    modifiedTime: number;
    name: string;
    /**
     * Network Template ID, this takes precedence over Site Settings
     */
    networktemplateId: string;
    /**
     * optional, any notes about the site
     */
    notes: string;
    orgId: string;
    /**
     * RF Template ID, this takes precedence over Site Settings
     */
    rftemplateId: string;
    /**
     * SecPolicy ID
     */
    secpolicyId: string;
    /**
     * sitegroups this site belongs to
     */
    sitegroupIds: string[];
    /**
     * Site Template ID
     */
    sitetemplateId: string;
    /**
     * Timezone the site is at
     */
    timezone: string;
}

export interface GetSitesSiteLatlng {
    lat: number;
    lng: number;
}

export namespace device {
    export interface ApAeroscout {
        /**
         * whether to enable aeroscout config
         */
        enabled: boolean;
        /**
         * required if enabled, aeroscout server host
         */
        host?: string;
        /**
         * whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
         */
        locateConnected: boolean;
    }

    export interface ApBleConfig {
        /**
         * whether Mist beacons is enabled
         */
        beaconEnabled: boolean;
        /**
         * required if `beaconRateMode`==`custom`, 1-10, in number-beacons-per-second
         */
        beaconRate: number;
        /**
         * enum: `custom`, `default`
         */
        beaconRateMode: string;
        /**
         * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
         */
        beamDisableds?: number[];
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send custom packet
         */
        customBlePacketEnabled: boolean;
        /**
         * The custom frame to be sent out in this beacon. The frame must be a hexstring
         */
        customBlePacketFrame: string;
        /**
         * Frequency (msec) of data emitted by custom ble beacon
         */
        customBlePacketFreqMsec: number;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUidAdvPower: number;
        eddystoneUidBeams: string;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-UID beacon is enabled
         */
        eddystoneUidEnabled: boolean;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUidFreqMsec: number;
        /**
         * Eddystone-UID instance for the device
         */
        eddystoneUidInstance: string;
        /**
         * Eddystone-UID namespace
         */
        eddystoneUidNamespace: string;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUrlAdvPower: number;
        eddystoneUrlBeams: string;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-URL beacon is enabled
         */
        eddystoneUrlEnabled: boolean;
        /**
         * Frequency (msec) of data emit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec: number;
        /**
         * URL pointed by Eddystone-URL beacon
         */
        eddystoneUrlUrl: string;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        ibeaconAdvPower: number;
        ibeaconBeams: string;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send iBeacon
         */
        ibeaconEnabled: boolean;
        /**
         * Frequency (msec) of data emmit for iBeacon
         */
        ibeaconFreqMsec: number;
        /**
         * Major number for iBeacon
         */
        ibeaconMajor: number;
        /**
         * Minor number for iBeacon
         */
        ibeaconMinor: number;
        /**
         * optional, if not specified, the same UUID as the beacon will be used
         */
        ibeaconUuid: string;
        /**
         * required if `powerMode`==`custom`
         */
        power: number;
        /**
         * enum: `custom`, `default`
         */
        powerMode: string;
    }

    export interface ApCentrak {
        enabled: boolean;
    }

    export interface ApClientBridge {
        auth?: outputs.device.ApClientBridgeAuth;
        /**
         * when acted as client bridge:
         *   * only 5G radio can be used
         *   * will not serve as AP on any radios
         */
        enabled: boolean;
        ssid?: string;
    }

    export interface ApClientBridgeAuth {
        psk?: string;
        /**
         * wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
         */
        type: string;
    }

    export interface ApEslConfig {
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        cacert?: string;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        channel?: number;
        /**
         * usb_config is ignored if eslConfig enabled
         */
        enabled: boolean;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        host?: string;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        port?: number;
        /**
         * note: bleConfig will be ingored if eslConfig is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
         */
        type?: string;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        verifyCert?: boolean;
        /**
         * Only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId: number;
    }

    export interface ApIpConfig {
        /**
         * if `type`==`static`
         */
        dns: string[];
        /**
         * required if `type`==`static`
         */
        dnsSuffixes: string[];
        /**
         * required if `type`==`static`
         */
        gateway?: string;
        gateway6?: string;
        /**
         * required if `type`==`static`
         */
        ip?: string;
        ip6?: string;
        mtu?: number;
        /**
         * required if `type`==`static`
         */
        netmask?: string;
        netmask6?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        type6: string;
        /**
         * management vlan id, default is 1 (untagged)
         */
        vlanId: number;
    }

    export interface ApLed {
        brightness: number;
        enabled: boolean;
    }

    export interface ApMesh {
        /**
         * whether mesh is enabled on this AP
         */
        enabled: boolean;
        /**
         * mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
         */
        group?: number;
        /**
         * enum: `base`, `remote`
         */
        role?: string;
    }

    export interface ApPwrConfig {
        /**
         * additional power to request during negotiating with PSE over PoE, in mW
         */
        base: number;
        /**
         * whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
         */
        preferUsbOverWifi: boolean;
    }

    export interface ApRadioConfig {
        allowRrmDisable: boolean;
        /**
         * antenna gain for 2.4G - for models with external antenna only
         */
        antGain24?: number;
        /**
         * antenna gain for 5G - for models with external antenna only
         */
        antGain5?: number;
        /**
         * antenna gain for 6G - for models with external antenna only
         */
        antGain6?: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * Radio Band AP settings
         */
        band24?: outputs.device.ApRadioConfigBand24;
        /**
         * enum: `24`, `5`, `6`, `auto`
         */
        band24Usage?: string;
        /**
         * Radio Band AP settings
         */
        band5?: outputs.device.ApRadioConfigBand5;
        /**
         * Radio Band AP settings
         */
        band5On24Radio?: outputs.device.ApRadioConfigBand5On24Radio;
        /**
         * Radio Band AP settings
         */
        band6?: outputs.device.ApRadioConfigBand6;
        /**
         * to make an outdoor operate indoor.
         * for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
         */
        indoorUse: boolean;
        /**
         * whether scanning radio is enabled
         */
        scanningEnabled?: boolean;
    }

    export interface ApRadioConfigBand24 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface ApRadioConfigBand5 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface ApRadioConfigBand5On24Radio {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface ApRadioConfigBand6 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower: boolean;
    }

    export interface ApUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x: boolean;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown: boolean;
    }

    export interface ApUsbConfig {
        /**
         * only if `type`==`imagotag`
         */
        cacert?: string;
        /**
         * only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
         */
        channel?: number;
        /**
         * whether to enable any usb config
         */
        enabled?: boolean;
        /**
         * only if `type`==`imagotag`
         */
        host?: string;
        /**
         * only if `type`==`imagotag`
         */
        port: number;
        /**
         * usb config type. enum: `hanshow`, `imagotag`, `solum`
         */
        type?: string;
        /**
         * only if `type`==`imagotag`, whether to turn on SSL verification
         */
        verifyCert?: boolean;
        /**
         * only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId: number;
    }

    export interface BaseLatlng {
        lat: number;
        lng: number;
    }

    export interface GatewayBgpConfig {
        authKey?: string;
        /**
         * when bfdMultiplier is configured alone. Default:
         *   * 1000 if `type`==`external`
         *   * 350 `type`==`internal`
         */
        bfdMinimumInterval: number;
        /**
         * when bfdMinimumIntervalIsConfigured alone
         */
        bfdMultiplier: number;
        communities?: outputs.device.GatewayBgpConfigCommunity[];
        /**
         * BFD provides faster path failure detection and is enabled by default
         */
        disableBfd: boolean;
        export?: string;
        /**
         * default export policies if no per-neighbor policies defined
         */
        exportPolicy?: string;
        /**
         * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
         * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
         */
        extendedV4Nexthop?: boolean;
        /**
         * `0` means disable
         */
        gracefulRestartTime: number;
        holdTime: number;
        import?: string;
        /**
         * default import policies if no per-neighbor policies defined
         */
        importPolicy?: string;
        localAs?: number;
        neighborAs?: number;
        /**
         * if per-neighbor as is desired. Property key is the neighbor address
         */
        neighbors?: {[key: string]: outputs.device.GatewayBgpConfigNeighbors};
        /**
         * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
         */
        networks: string[];
        /**
         * by default, we'll re-advertise all learned BGP routers toward overlay
         */
        noReadvertiseToOverlay: boolean;
        /**
         * enum: `external`, `internal`
         */
        type?: string;
        /**
         * network name. enum: `lan`, `vpn`, `wan`
         */
        via: string;
        vpnName?: string;
        /**
         * if `via`==`wan`
         */
        wanName?: string;
    }

    export interface GatewayBgpConfigCommunity {
        id?: string;
        localPreference?: number;
        vpnName?: string;
    }

    export interface GatewayBgpConfigNeighbors {
        /**
         * If true, the BGP session to this neighbor will be administratively disabled/shutdown
         */
        disabled: boolean;
        exportPolicy?: string;
        holdTime: number;
        importPolicy?: string;
        /**
         * assuming BGP neighbor is directly connected
         */
        multihopTtl?: number;
        neighborAs?: number;
    }

    export interface GatewayClusterNode {
        /**
         * when replacing a noce, either mac has to remain the same as existing cluster
         */
        mac: string;
    }

    export interface GatewayDhcpdConfig {
        config?: {[key: string]: outputs.device.GatewayDhcpdConfigConfig};
        /**
         * if set to `true`, enable the DHCP server
         */
        enabled: boolean;
    }

    export interface GatewayDhcpdConfigConfig {
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: string[];
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes: string[];
        /**
         * Property key is the MAC Address
         */
        fixedBindings?: {[key: string]: outputs.device.GatewayDhcpdConfigConfigFixedBindings};
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: string;
        /**
         * if `type`==`local`
         */
        ipEnd?: string;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: string;
        /**
         * if `type`==`local`
         */
        ipStart?: string;
        /**
         * if `type6`==`local`
         */
        ipStart6?: string;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime: number;
        /**
         * Property key is the DHCP option number
         */
        options?: {[key: string]: outputs.device.GatewayDhcpdConfigConfigOptions};
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride: boolean;
        /**
         * if `type`==`relay`
         */
        servers: string[];
        /**
         * if `type6`==`relay`
         */
        servers6s: string[];
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type: string;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6: string;
        /**
         * Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapulated?: {[key: string]: outputs.device.GatewayDhcpdConfigConfigVendorEncapulated};
    }

    export interface GatewayDhcpdConfigConfigFixedBindings {
        ip: string;
        name?: string;
    }

    export interface GatewayDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface GatewayDhcpdConfigConfigVendorEncapulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface GatewayExtraRoutes {
        via: string;
    }

    export interface GatewayExtraRoutes6 {
        via: string;
    }

    export interface GatewayIdpProfiles {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile?: string;
        createdTime?: number;
        id?: string;
        modifiedTime?: number;
        name?: string;
        orgId?: string;
        overwrites?: outputs.device.GatewayIdpProfilesOverwrite[];
    }

    export interface GatewayIdpProfilesOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action: string;
        matching?: outputs.device.GatewayIdpProfilesOverwriteMatching;
        name?: string;
    }

    export interface GatewayIdpProfilesOverwriteMatching {
        attackNames?: string[];
        dstSubnets?: string[];
        severities?: string[];
    }

    export interface GatewayIpConfigs {
        ip: string;
        netmask: string;
        /**
         * optional list of secondary IPs in CIDR format
         */
        secondaryIps: string[];
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
    }

    export interface GatewayNetwork {
        createdTime?: number;
        /**
         * whether to disallow Mist Devices in the network
         */
        disallowMistServices: boolean;
        gateway?: string;
        gateway6?: string;
        id?: string;
        internalAccess?: outputs.device.GatewayNetworkInternalAccess;
        /**
         * whether this network has direct internet access
         */
        internetAccess?: outputs.device.GatewayNetworkInternetAccess;
        /**
         * whether to allow clients in the network to talk to each other
         */
        isolation?: boolean;
        modifiedTime?: number;
        name: string;
        orgId?: string;
        /**
         * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
         */
        routedForNetworks?: string[];
        subnet: string;
        subnet6?: string;
        tenants?: {[key: string]: outputs.device.GatewayNetworkTenants};
        vlanId?: string;
        /**
         * Property key is the VPN name. Whether this network can be accessed from vpn
         */
        vpnAccess?: {[key: string]: outputs.device.GatewayNetworkVpnAccess};
    }

    export interface GatewayNetworkInternalAccess {
        enabled?: boolean;
    }

    export interface GatewayNetworkInternetAccess {
        createSimpleServicePolicy: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: {[key: string]: outputs.device.GatewayNetworkInternetAccessDestinationNat};
        enabled?: boolean;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted: boolean;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: {[key: string]: outputs.device.GatewayNetworkInternetAccessStaticNat};
    }

    export interface GatewayNetworkInternetAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface GatewayNetworkInternetAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface GatewayNetworkTenants {
        addresses?: string[];
    }

    export interface GatewayNetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: string;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat: {[key: string]: outputs.device.GatewayNetworkVpnAccessDestinationNat};
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: string;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp: boolean;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf: boolean;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: boolean;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs: string[];
        /**
         * whether this network is routable
         */
        routed?: boolean;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat: outputs.device.GatewayNetworkVpnAccessSourceNat;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat: {[key: string]: outputs.device.GatewayNetworkVpnAccessStaticNat};
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: string;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: string;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: string;
    }

    export interface GatewayNetworkVpnAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface GatewayNetworkVpnAccessSourceNat {
        externalIp?: string;
    }

    export interface GatewayNetworkVpnAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface GatewayOobIpConfig {
        /**
         * if `type`==`static`
         */
        gateway?: string;
        /**
         * if `type`==`static`
         */
        ip?: string;
        /**
         * if `type`==`static`
         */
        netmask?: string;
        /**
         * for HA Cluster, node1 can have different IP Config
         */
        node1?: outputs.device.GatewayOobIpConfigNode1;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
         */
        useMgmtVrfForHostOut: boolean;
        vlanId?: string;
    }

    export interface GatewayOobIpConfigNode1 {
        /**
         * if `type`==`static`
         */
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * whether to use `mgmtJunos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut: boolean;
        vlanId?: string;
    }

    export interface GatewayPathPreferences {
        paths?: outputs.device.GatewayPathPreferencesPath[];
        /**
         * enum: `ecmp`, `ordered`, `weighted`
         */
        strategy: string;
    }

    export interface GatewayPathPreferencesPath {
        cost?: number;
        /**
         * For SSR Only. `true`, if this specific path is undesired
         */
        disabled?: boolean;
        /**
         * only if `type`==`local`, if a different gateway is desired
         */
        gatewayIp?: string;
        /**
         * only if `type`==`vpn`, if this vpn path can be used for internet
         */
        internetAccess?: boolean;
        /**
         * required when 
         *   * `type`==`vpn`: the name of the VPN Path to use 
         *   * `type`==`wan`: the name of the WAN interface to use'
         */
        name?: string;
        /**
         * required when `type`==`local`
         */
        networks: string[];
        /**
         * if `type`==`local`, if destination IP is to be replaced
         */
        targetIps: string[];
        /**
         * enum: `local`, `tunnel`, `vpn`, `wan`
         */
        type?: string;
        /**
         * required when`type`==`tunnel`
         */
        wanName?: string;
    }

    export interface GatewayPortConfig {
        description?: string;
        disableAutoneg: boolean;
        /**
         * port admin up (true) / down (false)
         */
        disabled: boolean;
        /**
         * if `wanType`==`lte`. enum: `adsl`, `vdsl`
         */
        dslType: string;
        /**
         * if `wanType`==`dsl`
         * 16 bit int
         */
        dslVci: number;
        /**
         * if `wanType`==`dsl`
         * 8 bit int
         */
        dslVpi: number;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Junos IP Config
         */
        ipConfig?: outputs.device.GatewayPortConfigIpConfig;
        /**
         * if `wanType`==`lte`
         */
        lteApn?: string;
        /**
         * if `wanType`==`lte`. enum: `chap`, `none`, `pap`
         */
        lteAuth: string;
        lteBackup?: boolean;
        /**
         * if `wanType`==`lte`
         */
        ltePassword?: string;
        /**
         * if `wanType`==`lte`
         */
        lteUsername?: string;
        mtu?: number;
        /**
         * name that we'll use to derive config
         */
        name?: string;
        /**
         * if `usage`==`lan`
         */
        networks: string[];
        /**
         * for Q-in-Q
         */
        outerVlanId?: number;
        poeDisabled: boolean;
        /**
         * if `usage`==`lan`
         */
        portNetwork?: string;
        /**
         * whether to preserve dscp when sending traffic over VPN (SSR-only)
         */
        preserveDscp: boolean;
        /**
         * if HA mode
         */
        redundant?: boolean;
        /**
         * if HA mode
         */
        rethIdx?: number;
        /**
         * if HA mode
         */
        rethNode?: string;
        /**
         * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
         */
        rethNodes: string[];
        speed: string;
        /**
         * when SSR is running as VM, this is required on certain hosting platforms
         */
        ssrNoVirtualMac: boolean;
        /**
         * for SSR only
         */
        svrPortRange: string;
        trafficShaping?: outputs.device.GatewayPortConfigTrafficShaping;
        /**
         * port usage name. enum: `haControl`, `haData`, `lan`, `wan`
         */
        usage: string;
        /**
         * if WAN interface is on a VLAN
         */
        vlanId?: number;
        vpnPaths?: {[key: string]: outputs.device.GatewayPortConfigVpnPaths};
        /**
         * when `wanType`==`broadband`. enum: `default`, `max`, `recommended`
         */
        wanArpPolicer: string;
        /**
         * optional, if spoke should reach this port by a different IP
         */
        wanExtIp?: string;
        /**
         * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
         */
        wanSourceNat?: outputs.device.GatewayPortConfigWanSourceNat;
        /**
         * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
         */
        wanType: string;
    }

    export interface GatewayPortConfigIpConfig {
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dns?: string[];
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dnsSuffixes?: string[];
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * optional, the network to be used for mgmt
         */
        network?: string;
        /**
         * if `type`==`pppoe`
         */
        poserPassword?: string;
        /**
         * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
         */
        pppoeAuth: string;
        /**
         * if `type`==`pppoe`
         */
        pppoeUsername?: string;
        /**
         * enum: `dhcp`, `pppoe`, `static`
         */
        type: string;
    }

    export interface GatewayPortConfigTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: number[];
        enabled: boolean;
    }

    export interface GatewayPortConfigVpnPaths {
        /**
         * enum: `broadband`, `lte`
         */
        bfdProfile: string;
        /**
         * whether to use tunnel mode. SSR only
         */
        bfdUseTunnelMode: boolean;
        /**
         * for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
         */
        preference?: number;
        /**
         * enum: `hub`, `spoke`
         */
        role: string;
        trafficShaping?: outputs.device.GatewayPortConfigVpnPathsTrafficShaping;
    }

    export interface GatewayPortConfigVpnPathsTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: number[];
        enabled: boolean;
    }

    export interface GatewayPortConfigWanSourceNat {
        /**
         * or to disable the source-nat
         */
        disabled: boolean;
        /**
         * if alternative natPool is desired
         */
        natPool?: string;
    }

    export interface GatewayPortMirroring {
        portMirror?: outputs.device.GatewayPortMirroringPortMirror;
    }

    export interface GatewayPortMirroringPortMirror {
        familyType?: string;
        ingressPortIds?: string[];
        outputPortId?: string;
        rate?: number;
        runLength?: number;
    }

    export interface GatewayRoutingPolicies {
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        terms?: outputs.device.GatewayRoutingPoliciesTerm[];
    }

    export interface GatewayRoutingPoliciesTerm {
        /**
         * when used as import policy
         */
        action?: outputs.device.GatewayRoutingPoliciesTermAction;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        matching?: outputs.device.GatewayRoutingPoliciesTermMatching;
    }

    export interface GatewayRoutingPoliciesTermAction {
        accept?: boolean;
        addCommunities?: string[];
        /**
         * for SSR, hub decides how VRF routes are leaked on spoke
         */
        addTargetVrfs?: string[];
        /**
         * when used as export policy, optional
         */
        communities?: string[];
        /**
         * when used as export policy, optional. To exclude certain AS
         */
        excludeAsPaths?: string[];
        excludeCommunities?: string[];
        /**
         * when used as export policy, optional
         */
        exportCommunitites?: string[];
        /**
         * optional, for an import policy, localPreference can be changed
         */
        localPreference?: string;
        /**
         * when used as export policy, optional. By default, the local AS will be prepended, to change it
         */
        prependAsPaths?: string[];
    }

    export interface GatewayRoutingPoliciesTermMatching {
        /**
         * takes regular expression
         */
        asPaths?: string[];
        communities?: string[];
        networks?: string[];
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        prefixes?: string[];
        /**
         * `direct`, `bgp`, `osp`, ...
         */
        protocols?: string[];
        routeExists?: outputs.device.GatewayRoutingPoliciesTermMatchingRouteExists;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         */
        vpnNeighborMacs?: string[];
        vpnPathSla?: outputs.device.GatewayRoutingPoliciesTermMatchingVpnPathSla;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         * ordered-
         */
        vpnPaths?: string[];
    }

    export interface GatewayRoutingPoliciesTermMatchingRouteExists {
        route?: string;
        /**
         * name of the vrf instance
         * it can also be the name of the VPN or wan if they
         */
        vrfName: string;
    }

    export interface GatewayRoutingPoliciesTermMatchingVpnPathSla {
        maxJitter?: number;
        maxLatency?: number;
        maxLoss?: number;
    }

    export interface GatewayServicePolicy {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        /**
         * For SRX Only
         */
        appqoe?: outputs.device.GatewayServicePolicyAppqoe;
        ewfs?: outputs.device.GatewayServicePolicyEwf[];
        idp?: outputs.device.GatewayServicePolicyIdp;
        /**
         * access within the same VRF
         */
        localRouting: boolean;
        name?: string;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference?: string;
        /**
         * used to link servicepolicy defined at org level and overwrite some attributes
         */
        servicepolicyId?: string;
        services: string[];
        tenants: string[];
    }

    export interface GatewayServicePolicyAppqoe {
        enabled: boolean;
    }

    export interface GatewayServicePolicyEwf {
        alertOnly?: boolean;
        blockMessage?: string;
        enabled: boolean;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile: string;
    }

    export interface GatewayServicePolicyIdp {
        alertOnly?: boolean;
        enabled: boolean;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: string;
        /**
         * `strict` (default) / `standard` / or keys from from idp_profiles
         */
        profile: string;
    }

    export interface GatewayTunnelConfigs {
        autoProvision?: outputs.device.GatewayTunnelConfigsAutoProvision;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        ikeLifetime?: number;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
         */
        ikeMode: string;
        /**
         * if `provider`== `custom-ipsec`
         */
        ikeProposals?: outputs.device.GatewayTunnelConfigsIkeProposal[];
        /**
         * if `provider`== `custom-ipsec`
         */
        ipsecLifetime?: number;
        /**
         * Only if  `provider`== `custom-ipsec`
         */
        ipsecProposals?: outputs.device.GatewayTunnelConfigsIpsecProposal[];
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        localId?: string;
        /**
         * enum: `active-active`, `active-standby`
         */
        mode: string;
        primary?: outputs.device.GatewayTunnelConfigsPrimary;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        probe?: outputs.device.GatewayTunnelConfigsProbe;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
         */
        protocol?: string;
        /**
         * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
         */
        provider?: string;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        psk?: string;
        secondary?: outputs.device.GatewayTunnelConfigsSecondary;
        /**
         * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
         */
        version: string;
    }

    export interface GatewayTunnelConfigsAutoProvision {
        enable?: boolean;
        latlng?: outputs.device.GatewayTunnelConfigsAutoProvisionLatlng;
        primary?: outputs.device.GatewayTunnelConfigsAutoProvisionPrimary;
        /**
         * enum: `APAC`, `Americas`, `EMEA`, `auto`
         */
        region: string;
        secondary?: outputs.device.GatewayTunnelConfigsAutoProvisionSecondary;
    }

    export interface GatewayTunnelConfigsAutoProvisionLatlng {
        lat: number;
        lng: number;
    }

    export interface GatewayTunnelConfigsAutoProvisionPrimary {
        numHosts?: string;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: string[];
    }

    export interface GatewayTunnelConfigsAutoProvisionSecondary {
        numHosts?: string;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: string[];
    }

    export interface GatewayTunnelConfigsIkeProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: string;
        /**
         * enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup: string;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo: string;
    }

    export interface GatewayTunnelConfigsIpsecProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: string;
        /**
         * Only if `provider`== `custom-ipsec`. enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup: string;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo: string;
    }

    export interface GatewayTunnelConfigsPrimary {
        hosts?: string[];
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: string[];
        probeIps?: string[];
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: string[];
        wanNames?: string[];
    }

    export interface GatewayTunnelConfigsProbe {
        /**
         * how often to trigger the probe
         */
        interval?: number;
        /**
         * number of consecutive misses before declaring the tunnel down
         */
        threshold?: number;
        /**
         * time within which to complete the connectivity check
         */
        timeout?: number;
        /**
         * enum: `http`, `icmp`
         */
        type: string;
    }

    export interface GatewayTunnelConfigsSecondary {
        hosts?: string[];
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: string[];
        probeIps?: string[];
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: string[];
        wanNames?: string[];
    }

    export interface GatewayTunnelProviderOptions {
        /**
         * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
         */
        jse?: outputs.device.GatewayTunnelProviderOptionsJse;
        /**
         * for zscaler-ipsec and zscaler-gre
         */
        zscaler?: outputs.device.GatewayTunnelProviderOptionsZscaler;
    }

    export interface GatewayTunnelProviderOptionsJse {
        name?: string;
        numUsers?: number;
    }

    export interface GatewayTunnelProviderOptionsZscaler {
        aupAcceptanceRequired: boolean;
        /**
         * days before AUP is requested again
         */
        aupExpire: number;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy: boolean;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: number;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup: boolean;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution: boolean;
        enforceAuthentication: boolean;
        name?: string;
        /**
         * if `useXff`==`true`
         */
        subLocations?: outputs.device.GatewayTunnelProviderOptionsZscalerSubLocation[];
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: number;
        /**
         * location uses proxy chaining to forward traffic
         */
        useXff?: boolean;
    }

    export interface GatewayTunnelProviderOptionsZscalerSubLocation {
        aupAcceptanceRequired: boolean;
        /**
         * days before AUP is requested again
         */
        aupExpire: number;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy: boolean;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: number;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: boolean;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution: boolean;
        enforceAuthentication: boolean;
        subnets?: string[];
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: number;
    }

    export interface GatewayVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: boolean;
    }

    export interface GatewayVrfInstances {
        networks?: string[];
    }

    export interface GetApStatsDeviceApStat {
        autoPlacement: outputs.device.GetApStatsDeviceApStatAutoPlacement;
        autoUpgradeStat: outputs.device.GetApStatsDeviceApStatAutoUpgradeStat;
        bleStat: outputs.device.GetApStatsDeviceApStatBleStat;
        certExpiry: number;
        configReverted: boolean;
        cpuSystem: number;
        cpuUtil: number;
        createdTime: number;
        deviceprofileId: string;
        /**
         * device environment, including CPU temperature, Ambient temperature, Humidity, Attitude, Pressure, Accelerometers, Magnetometers and vCore Voltage
         */
        envStat: outputs.device.GetApStatsDeviceApStatEnvStat;
        eslStat: outputs.device.GetApStatsDeviceApStatEslStat;
        extIp: string;
        fwupdate: outputs.device.GetApStatsDeviceApStatFwupdate;
        hwRev: string;
        id: string;
        inactiveWiredVlans: number[];
        iotStat: {[key: string]: outputs.device.GetApStatsDeviceApStatIotStat};
        ip: string;
        /**
         * IP AP settings
         */
        ipConfig: outputs.device.GetApStatsDeviceApStatIpConfig;
        ipStat: outputs.device.GetApStatsDeviceApStatIpStat;
        /**
         * l2tp tunnel status (key is the wxtunnel*id)
         */
        l2tpStat: {[key: string]: outputs.device.GetApStatsDeviceApStatL2tpStat};
        /**
         * last seen timestamp
         */
        lastSeen: number;
        /**
         * last trouble code of switch
         */
        lastTrouble: outputs.device.GetApStatsDeviceApStatLastTrouble;
        /**
         * LED AP settings
         */
        led: outputs.device.GetApStatsDeviceApStatLed;
        /**
         * LLDP Stat (neighbor information, power negotiations)
         */
        lldpStat: outputs.device.GetApStatsDeviceApStatLldpStat;
        locating: boolean;
        /**
         * whether this AP is considered locked (placement / orientation has been vetted)
         */
        locked: boolean;
        /**
         * device mac
         */
        mac: string;
        mapId: string;
        memUsedKb: number;
        /**
         * Property key is the mesh downlink id (e.g `00000000-0000-0000-1000-5c5b35000010`)
         */
        meshDownlinks: {[key: string]: outputs.device.GetApStatsDeviceApStatMeshDownlinks};
        meshUplink: outputs.device.GetApStatsDeviceApStatMeshUplink;
        /**
         * device model
         */
        model: string;
        modifiedTime: number;
        mount: string;
        name: string;
        notes: string;
        /**
         * how many wireless clients are currently connected
         */
        numClients: number;
        orgId: string;
        /**
         * Property key is the port name (e.g. `eth0`)
         */
        portStat: {[key: string]: outputs.device.GetApStatsDeviceApStatPortStat};
        /**
         * in mW, surplus if positive or deficit if negative
         */
        powerBudget: number;
        /**
         * whether insufficient power
         */
        powerConstrained: boolean;
        /**
         * constrained mode
         */
        powerOpmode: string;
        /**
         * DC Input / PoE 802.3at / PoE 802.3af / LLDP / ? (unknown)
         */
        powerSrc: string;
        radioStat: outputs.device.GetApStatsDeviceApStatRadioStat;
        rxBps: number;
        rxBytes: number;
        rxPkts: number;
        /**
         * serial
         */
        serial: string;
        siteId: string;
        status: string;
        switchRedundancy: outputs.device.GetApStatsDeviceApStatSwitchRedundancy;
        txBps: number;
        txBytes: number;
        txPkts: number;
        /**
         * how long, in seconds, has the device been up (or rebooted)
         */
        uptime: number;
        usbStat: outputs.device.GetApStatsDeviceApStatUsbStat;
        version: string;
        x: number;
        y: number;
    }

    export interface GetApStatsDeviceApStatAutoPlacement {
        /**
         * Additional information about auto placements AP data
         */
        info: outputs.device.GetApStatsDeviceApStatAutoPlacementInfo;
        /**
         * Flag to represent if AP is recommended as an anchor by auto placement service
         */
        recommendedAnchor: boolean;
        /**
         * Basic Placement Status
         */
        status: string;
        /**
         * Additional info about placement status
         */
        statusDetail: string;
        /**
         * Flag to represent if autoPlacement values are currently utilized
         */
        useAutoPlacement: boolean;
        /**
         * X Autoplaced Position in pixels
         */
        x: number;
        /**
         * X Autoplaced Position in meters
         */
        xM: number;
        /**
         * Y Autoplaced Position in pixels
         */
        y: number;
        /**
         * X Autoplaced Position in meters
         */
        yM: number;
    }

    export interface GetApStatsDeviceApStatAutoPlacementInfo {
        /**
         * All APs sharing a given cluster number can be placed relative to each other
         */
        clusterNumber: number;
        /**
         * The orientation of an AP
         */
        orientationStats: number;
        /**
         * Coordinates representing a circle where the AP is most likely exists in the event of an inaccurate placement result
         */
        probabilitySurface: outputs.device.GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurface;
    }

    export interface GetApStatsDeviceApStatAutoPlacementInfoProbabilitySurface {
        /**
         * The radius representing placement uncertainty, measured in pixels
         */
        radius: number;
        /**
         * The radius representing placement uncertainty, measured in meters
         */
        radiusM: number;
        /**
         * Y-coordinate of the potential placement’s center, measured in pixels
         */
        x: number;
    }

    export interface GetApStatsDeviceApStatAutoUpgradeStat {
        lastcheck: number;
    }

    export interface GetApStatsDeviceApStatBleStat {
        beaconEnabled: boolean;
        beaconRate: number;
        eddystoneUidEnabled: boolean;
        eddystoneUidFreqMsec: number;
        eddystoneUidInstance: string;
        eddystoneUidNamespace: string;
        eddystoneUrlEnabled: boolean;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec: number;
        eddystoneUrlUrl: string;
        ibeaconEnabled: boolean;
        ibeaconFreqMsec: number;
        ibeaconMajor: number;
        ibeaconMinor: number;
        ibeaconUuid: string;
        major: number;
        minors: number[];
        power: number;
        rxBytes: number;
        rxPkts: number;
        txBytes: number;
        txPkts: number;
        /**
         * resets due to tx hung
         */
        txResets: number;
        uuid: string;
    }

    export interface GetApStatsDeviceApStatEnvStat {
        accelX: number;
        accelY: number;
        accelZ: number;
        ambientTemp: number;
        attitude: number;
        cpuTemp: number;
        humidity: number;
        magneX: number;
        magneY: number;
        magneZ: number;
        pressure: number;
        vcoreVoltage: number;
    }

    export interface GetApStatsDeviceApStatEslStat {
        channel: number;
        connected: boolean;
        type: string;
        up: boolean;
    }

    export interface GetApStatsDeviceApStatFwupdate {
        progress: number;
        status: string;
        statusId: number;
        timestamp: number;
        willRetry: boolean;
    }

    export interface GetApStatsDeviceApStatIotStat {
        value: number;
    }

    export interface GetApStatsDeviceApStatIpConfig {
        /**
         * if `type`==`static`
         */
        dns: string[];
        /**
         * required if `type`==`static`
         */
        dnsSuffixes: string[];
        /**
         * required if `type`==`static`
         */
        gateway: string;
        gateway6: string;
        /**
         * required if `type`==`static`
         */
        ip: string;
        ip6: string;
        mtu: number;
        /**
         * required if `type`==`static`
         */
        netmask: string;
        netmask6: string;
        type: string;
        type6: string;
        /**
         * management vlan id, default is 1 (untagged)
         */
        vlanId: number;
    }

    export interface GetApStatsDeviceApStatIpStat {
        dhcpServer: string;
        dns: string[];
        dnsSuffixes: string[];
        gateway: string;
        gateway6: string;
        ip: string;
        ip6: string;
        ips: {[key: string]: string};
        netmask: string;
        netmask6: string;
    }

    export interface GetApStatsDeviceApStatL2tpStat {
        /**
         * list of sessions
         */
        sessions: outputs.device.GetApStatsDeviceApStatL2tpStatSession[];
        state: string;
        /**
         * uptime
         */
        uptime: number;
        /**
         * WxlanTunnel ID
         */
        wxtunnelId: string;
    }

    export interface GetApStatsDeviceApStatL2tpStatSession {
        /**
         * remote sessions id (dynamically unless Tunnel is said to be static)
         */
        localSid: number;
        /**
         * WxlanTunnel Remote ID (user-configured)
         */
        remoteId: string;
        /**
         * remote sessions id (dynamically unless Tunnel is said to be static)
         */
        remoteSid: number;
        state: string;
    }

    export interface GetApStatsDeviceApStatLastTrouble {
        /**
         * Code definitions list at /api/v1/consts/ap*led*status
         */
        code: string;
        timestamp: number;
    }

    export interface GetApStatsDeviceApStatLed {
        brightness: number;
        enabled: boolean;
    }

    export interface GetApStatsDeviceApStatLldpStat {
        chassisId: string;
        /**
         * whether it support LLDP-MED
         */
        lldpMedSupported: boolean;
        /**
         * switch’s management address (if advertised), can be IPv4, IPv6, or MAC
         */
        mgmtAddr: string;
        mgmtAddrs: string[];
        /**
         * ge-0/0/4
         */
        portDesc: string;
        portId: string;
        /**
         * in mW, provided/allocated by PSE
         */
        powerAllocated: number;
        /**
         * in mW, total power needed by PD
         */
        powerDraw: number;
        /**
         * number of negotiations, if it keeps increasing, we don’t have a stable power
         */
        powerRequestCount: number;
        /**
         * in mW, the current power requested by PD
         */
        powerRequested: number;
        /**
         * description provided by switch
         */
        systemDesc: string;
        /**
         * name of the switch
         */
        systemName: string;
    }

    export interface GetApStatsDeviceApStatMeshDownlinks {
        band: string;
        channel: number;
        idleTime: number;
        lastSeen: number;
        proto: string;
        rssi: number;
        rxBps: number;
        rxBytes: number;
        rxPackets: number;
        rxRate: number;
        rxRetries: number;
        siteId: string;
        snr: number;
        txBps: number;
        txBytes: number;
        txPackets: number;
        txRate: number;
        txRetries: number;
    }

    export interface GetApStatsDeviceApStatMeshUplink {
        band: string;
        channel: number;
        idleTime: number;
        lastSeen: number;
        proto: string;
        rssi: number;
        rxBps: number;
        rxBytes: number;
        rxPackets: number;
        rxRate: number;
        rxRetries: number;
        siteId: string;
        snr: number;
        txBps: number;
        txBytes: number;
        txPackets: number;
        txRate: number;
        txRetries: number;
        uplinkApId: string;
    }

    export interface GetApStatsDeviceApStatPortStat {
        fullDuplex: boolean;
        rxBytes: number;
        rxErrors: number;
        rxPkts: number;
        speed: number;
        txBytes: number;
        txPkts: number;
        up: boolean;
    }

    export interface GetApStatsDeviceApStatRadioStat {
        /**
         * radio stat
         */
        band24: outputs.device.GetApStatsDeviceApStatRadioStatBand24;
        /**
         * radio stat
         */
        band5: outputs.device.GetApStatsDeviceApStatRadioStatBand5;
        /**
         * radio stat
         */
        band6: outputs.device.GetApStatsDeviceApStatRadioStatBand6;
    }

    export interface GetApStatsDeviceApStatRadioStatBand24 {
        /**
         * channel width for the band * `80` is only applicable for band*5 and band*6 * `160` is only for band_6
         */
        bandwidth: number;
        /**
         * current channel the radio is running on
         */
        channel: number;
        /**
         * Use dynamic chaining for downlink
         */
        dynamicChainingEnalbed: boolean;
        /**
         * radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
         */
        mac: string;
        noiseFloor: number;
        numClients: number;
        /**
         * transmit power (in dBm)
         */
        power: number;
        rxBytes: number;
        rxPkts: number;
        txBytes: number;
        txPkts: number;
        usage: string;
        /**
         * all utilization in percentage
         */
        utilAll: number;
        /**
         * reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
         */
        utilNonWifi: number;
        /**
         * reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS
         */
        utilRxInBss: number;
        /**
         * reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS
         */
        utilRxOtherBss: number;
        /**
         * transmission utilization in percentage
         */
        utilTx: number;
        /**
         * reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
         */
        utilUndecodableWifi: number;
        /**
         * reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver
         */
        utilUnknownWifi: number;
    }

    export interface GetApStatsDeviceApStatRadioStatBand5 {
        /**
         * channel width for the band * `80` is only applicable for band*5 and band*6 * `160` is only for band_6
         */
        bandwidth: number;
        /**
         * current channel the radio is running on
         */
        channel: number;
        /**
         * Use dynamic chaining for downlink
         */
        dynamicChainingEnalbed: boolean;
        /**
         * radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
         */
        mac: string;
        noiseFloor: number;
        numClients: number;
        /**
         * transmit power (in dBm)
         */
        power: number;
        rxBytes: number;
        rxPkts: number;
        txBytes: number;
        txPkts: number;
        usage: string;
        /**
         * all utilization in percentage
         */
        utilAll: number;
        /**
         * reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
         */
        utilNonWifi: number;
        /**
         * reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS
         */
        utilRxInBss: number;
        /**
         * reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS
         */
        utilRxOtherBss: number;
        /**
         * transmission utilization in percentage
         */
        utilTx: number;
        /**
         * reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
         */
        utilUndecodableWifi: number;
        /**
         * reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver
         */
        utilUnknownWifi: number;
    }

    export interface GetApStatsDeviceApStatRadioStatBand6 {
        /**
         * channel width for the band * `80` is only applicable for band*5 and band*6 * `160` is only for band_6
         */
        bandwidth: number;
        /**
         * current channel the radio is running on
         */
        channel: number;
        /**
         * Use dynamic chaining for downlink
         */
        dynamicChainingEnalbed: boolean;
        /**
         * radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
         */
        mac: string;
        noiseFloor: number;
        numClients: number;
        /**
         * transmit power (in dBm)
         */
        power: number;
        rxBytes: number;
        rxPkts: number;
        txBytes: number;
        txPkts: number;
        usage: string;
        /**
         * all utilization in percentage
         */
        utilAll: number;
        /**
         * reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
         */
        utilNonWifi: number;
        /**
         * reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS
         */
        utilRxInBss: number;
        /**
         * reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS
         */
        utilRxOtherBss: number;
        /**
         * transmission utilization in percentage
         */
        utilTx: number;
        /**
         * reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
         */
        utilUndecodableWifi: number;
        /**
         * reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver
         */
        utilUnknownWifi: number;
    }

    export interface GetApStatsDeviceApStatSwitchRedundancy {
        numRedundantAps: number;
    }

    export interface GetApStatsDeviceApStatUsbStat {
        channel: number;
        connected: boolean;
        lastActivity: number;
        type: string;
        up: boolean;
    }

    export interface GetGatewayStatsDeviceGatewayStat {
        apRedundancy: outputs.device.GetGatewayStatsDeviceGatewayStatApRedundancy;
        arpTableStats: outputs.device.GetGatewayStatsDeviceGatewayStatArpTableStats;
        certExpiry: number;
        clusterConfig: outputs.device.GetGatewayStatsDeviceGatewayStatClusterConfig;
        clusterStat: outputs.device.GetGatewayStatsDeviceGatewayStatClusterStat;
        conductorName: string;
        configStatus: string;
        cpu2Stat: outputs.device.GetGatewayStatsDeviceGatewayStatCpu2Stat;
        cpuStat: outputs.device.GetGatewayStatsDeviceGatewayStatCpuStat;
        createdTime: number;
        deviceprofileId: string;
        /**
         * Property key is the network name
         */
        dhcpd2Stat: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatDhcpd2Stat};
        /**
         * Property key is the network name
         */
        dhcpdStat: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatDhcpdStat};
        /**
         * IP address
         */
        extIp: string;
        fwupdate: outputs.device.GetGatewayStatsDeviceGatewayStatFwupdate;
        hasPcap: boolean;
        /**
         * hostname reported by the device
         */
        hostname: string;
        /**
         * serial
         */
        id: string;
        /**
         * Property key is the interface name
         */
        if2Stat: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatIf2Stat};
        /**
         * Property key is the interface name
         */
        ifStat: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatIfStat};
        /**
         * IP address
         */
        ip: string;
        ip2Stat: outputs.device.GetGatewayStatsDeviceGatewayStatIp2Stat;
        ipStat: outputs.device.GetGatewayStatsDeviceGatewayStatIpStat;
        isHa: boolean;
        /**
         * last seen timestamp
         */
        lastSeen: number;
        /**
         * device mac
         */
        mac: string;
        /**
         * serial
         */
        mapId: string;
        /**
         * memory usage stat (for virtual chassis, memory usage of master RE)
         */
        memory2Stat: outputs.device.GetGatewayStatsDeviceGatewayStatMemory2Stat;
        /**
         * memory usage stat (for virtual chassis, memory usage of master RE)
         */
        memoryStat: outputs.device.GetGatewayStatsDeviceGatewayStatMemoryStat;
        /**
         * device model
         */
        model: string;
        modifiedTime: number;
        module2Stats: outputs.device.GetGatewayStatsDeviceGatewayStatModule2Stat[];
        moduleStats: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStat[];
        /**
         * device name if configured
         */
        name: string;
        nodeName: string;
        /**
         * serial
         */
        orgId: string;
        routeSummaryStats: outputs.device.GetGatewayStatsDeviceGatewayStatRouteSummaryStats;
        /**
         * device name if configured
         */
        routerName: string;
        /**
         * serial
         */
        serial: string;
        service2Stat: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatService2Stat};
        serviceStat: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatServiceStat};
        serviceStatus: outputs.device.GetGatewayStatsDeviceGatewayStatServiceStatus;
        /**
         * serial
         */
        siteId: string;
        spu2Stats: outputs.device.GetGatewayStatsDeviceGatewayStatSpu2Stat[];
        spuStats: outputs.device.GetGatewayStatsDeviceGatewayStatSpuStat[];
        status: string;
        uptime: number;
        version: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatApRedundancy {
        /**
         * Property key is the node id
         */
        modules: {[key: string]: outputs.device.GetGatewayStatsDeviceGatewayStatApRedundancyModules};
        numAps: number;
        numApsWithSwitchRedundancy: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatApRedundancyModules {
        numAps: number;
        numApsWithSwitchRedundancy: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatArpTableStats {
        arpTableCount: number;
        maxEntriesSupported: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatClusterConfig {
        configuration: string;
        controlLinkInfo: outputs.device.GetGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfo;
        ethernetConnections: outputs.device.GetGatewayStatsDeviceGatewayStatClusterConfigEthernetConnection[];
        fabricLinkInfo: outputs.device.GetGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfo;
        lastStatusChangeReason: string;
        operational: string;
        primaryNodeHealth: string;
        redundancyGroupInformations: outputs.device.GetGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformation[];
        secondaryNodeHealth: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfo {
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatClusterConfigEthernetConnection {
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfo {
        dataPlaneNotifiedStatus: string;
        interfaces: string[];
        internalStatus: string;
        state: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformation {
        id: number;
        monitoringFailure: string;
        threshold: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatClusterStat {
        state: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatCpu2Stat {
        /**
         * Percentage of CPU time that is idle
         */
        idle: number;
        /**
         * Percentage of CPU time being used by interrupts
         */
        interrupt: number;
        /**
         * Load averages for the last 1, 5, and 15 minutes
         */
        loadAvgs: number[];
        /**
         * Percentage of CPU time being used by system processes
         */
        system: number;
        /**
         * Percentage of CPU time being used by user processe
         */
        user: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatCpuStat {
        /**
         * Percentage of CPU time that is idle
         */
        idle: number;
        /**
         * Percentage of CPU time being used by interrupts
         */
        interrupt: number;
        /**
         * Load averages for the last 1, 5, and 15 minutes
         */
        loadAvgs: number[];
        /**
         * Percentage of CPU time being used by system processes
         */
        system: number;
        /**
         * Percentage of CPU time being used by user processe
         */
        user: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatDhcpd2Stat {
        numIps: number;
        numLeased: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatDhcpdStat {
        numIps: number;
        numLeased: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatFwupdate {
        progress: number;
        status: string;
        statusId: number;
        timestamp: number;
        willRetry: boolean;
    }

    export interface GetGatewayStatsDeviceGatewayStatIf2Stat {
        addressMode: string;
        ips: string[];
        natAddresses: string[];
        networkName: string;
        portId: string;
        portUsage: string;
        redundancyState: string;
        rxBytes: number;
        rxPkts: number;
        servpInfo: outputs.device.GetGatewayStatsDeviceGatewayStatIf2StatServpInfo;
        txBytes: number;
        txPkts: number;
        up: boolean;
        vlan: number;
        wanName: string;
        wanType: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatIf2StatServpInfo {
        asn: string;
        city: string;
        countryCode: string;
        latitude: number;
        longitude: number;
        org: string;
        regionCode: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatIfStat {
        addressMode: string;
        ips: string[];
        natAddresses: string[];
        networkName: string;
        portId: string;
        portUsage: string;
        redundancyState: string;
        rxBytes: number;
        rxPkts: number;
        servpInfo: outputs.device.GetGatewayStatsDeviceGatewayStatIfStatServpInfo;
        txBytes: number;
        txPkts: number;
        up: boolean;
        vlan: number;
        wanName: string;
        wanType: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatIfStatServpInfo {
        asn: string;
        city: string;
        countryCode: string;
        latitude: number;
        longitude: number;
        org: string;
        regionCode: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatIp2Stat {
        dhcpServer: string;
        dns: string[];
        dnsSuffixes: string[];
        gateway: string;
        gateway6: string;
        ip: string;
        ip6: string;
        ips: {[key: string]: string};
        netmask: string;
        netmask6: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatIpStat {
        dhcpServer: string;
        dns: string[];
        dnsSuffixes: string[];
        gateway: string;
        gateway6: string;
        ip: string;
        ip6: string;
        ips: {[key: string]: string};
        netmask: string;
        netmask6: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatMemory2Stat {
        usage: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatMemoryStat {
        usage: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2Stat {
        backupVersion: string;
        biosVersion: string;
        cpldVersion: string;
        /**
         * used to report all error states the device node is running into.
         * An error should always have `type` and `since` fields, and could have some other fields specific to that type.
         */
        errors: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatError[];
        fans: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatFan[];
        fpgaVersion: string;
        lastSeen: number;
        model: string;
        opticsCpldVersion: string;
        pendingVersion: string;
        pics: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatPic[];
        poe: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatPoe;
        poeVersion: string;
        powerCpldVersion: string;
        psuses: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatPsus[];
        reFpgaVersion: string;
        recoveryVersion: string;
        serial: string;
        status: string;
        temperatures: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatTemperature[];
        tmcFpgaVersion: string;
        ubootVersion: string;
        uptime: number;
        vcLinks: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatVcLink[];
        vcMode: string;
        /**
         * master / backup / linecard
         */
        vcRole: string;
        vcState: string;
        version: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatError {
        feature: string;
        minimumVersion: string;
        reason: string;
        since: number;
        type: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatFan {
        airflow: string;
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatPic {
        index: number;
        modelNumber: string;
        portGroups: outputs.device.GetGatewayStatsDeviceGatewayStatModule2StatPicPortGroup[];
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatPicPortGroup {
        count: number;
        type: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatPoe {
        maxPower: number;
        powerDraw: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatPsus {
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatTemperature {
        celsius: number;
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModule2StatVcLink {
        neighborModuleIdx: number;
        neighborPortId: string;
        portId: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStat {
        backupVersion: string;
        biosVersion: string;
        cpldVersion: string;
        /**
         * used to report all error states the device node is running into.
         * An error should always have `type` and `since` fields, and could have some other fields specific to that type.
         */
        errors: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatError[];
        fans: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatFan[];
        fpgaVersion: string;
        lastSeen: number;
        model: string;
        opticsCpldVersion: string;
        pendingVersion: string;
        pics: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatPic[];
        poe: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatPoe;
        poeVersion: string;
        powerCpldVersion: string;
        psuses: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatPsus[];
        reFpgaVersion: string;
        recoveryVersion: string;
        serial: string;
        status: string;
        temperatures: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatTemperature[];
        tmcFpgaVersion: string;
        ubootVersion: string;
        uptime: number;
        vcLinks: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatVcLink[];
        vcMode: string;
        /**
         * master / backup / linecard
         */
        vcRole: string;
        vcState: string;
        version: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatError {
        feature: string;
        minimumVersion: string;
        reason: string;
        since: number;
        type: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatFan {
        airflow: string;
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatPic {
        index: number;
        modelNumber: string;
        portGroups: outputs.device.GetGatewayStatsDeviceGatewayStatModuleStatPicPortGroup[];
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatPicPortGroup {
        count: number;
        type: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatPoe {
        maxPower: number;
        powerDraw: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatPsus {
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatTemperature {
        celsius: number;
        name: string;
        status: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatModuleStatVcLink {
        neighborModuleIdx: number;
        neighborPortId: string;
        portId: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatRouteSummaryStats {
        fibRoutes: number;
        maxUnicastRoutesSupported: number;
        ribRoutes: number;
        totalRoutes: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatService2Stat {
        ashVersion: string;
        ciaVersion: string;
        emberVersion: string;
        ipsecClientVersion: string;
        mistAgentVersion: string;
        packageVersion: string;
        testingToolsVersion: string;
        wheeljackVersion: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatServiceStat {
        ashVersion: string;
        ciaVersion: string;
        emberVersion: string;
        ipsecClientVersion: string;
        mistAgentVersion: string;
        packageVersion: string;
        testingToolsVersion: string;
        wheeljackVersion: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatServiceStatus {
        appidInstallResult: string;
        appidInstallTimestamp: string;
        appidStatus: string;
        appidVersion: number;
        ewfStatus: string;
        idpInstallResult: string;
        idpInstallTimestamp: string;
        idpPolicy: string;
        idpStatus: string;
        idpUpdateTimestamp: string;
    }

    export interface GetGatewayStatsDeviceGatewayStatSpu2Stat {
        spuCpu: number;
        spuCurrentSession: number;
        spuMaxSession: number;
        spuMemory: number;
        spuPendingSession: number;
        spuValidSession: number;
    }

    export interface GetGatewayStatsDeviceGatewayStatSpuStat {
        spuCpu: number;
        spuCurrentSession: number;
        spuMaxSession: number;
        spuMemory: number;
        spuPendingSession: number;
        spuValidSession: number;
    }

    export interface GetSwitchStatsDeviceSwitchStat {
        apRedundancy: outputs.device.GetSwitchStatsDeviceSwitchStatApRedundancy;
        arpTableStats: outputs.device.GetSwitchStatsDeviceSwitchStatArpTableStats;
        certExpiry: number;
        clients: outputs.device.GetSwitchStatsDeviceSwitchStatClient[];
        clientsStats: outputs.device.GetSwitchStatsDeviceSwitchStatClientsStats;
        configStatus: string;
        cpuStat: outputs.device.GetSwitchStatsDeviceSwitchStatCpuStat;
        createdTime: number;
        deviceprofileId: string;
        /**
         * Property key is the network name
         */
        dhcpdStat: {[key: string]: outputs.device.GetSwitchStatsDeviceSwitchStatDhcpdStat};
        evpntopoId: string;
        fwVersionsOutofsync: boolean;
        fwupdate: outputs.device.GetSwitchStatsDeviceSwitchStatFwupdate;
        /**
         * whether the switch supports packet capture
         */
        hasPcap: boolean;
        /**
         * hostname reported by the device
         */
        hostname: string;
        /**
         * device hardware revision number
         */
        hwRev: string;
        id: string;
        /**
         * Property key is the interface name
         */
        ifStat: {[key: string]: outputs.device.GetSwitchStatsDeviceSwitchStatIfStat};
        ip: string;
        ipStat: outputs.device.GetSwitchStatsDeviceSwitchStatIpStat;
        lastSeen: number;
        /**
         * last trouble code of switch
         */
        lastTrouble: outputs.device.GetSwitchStatsDeviceSwitchStatLastTrouble;
        mac: string;
        macTableStats: outputs.device.GetSwitchStatsDeviceSwitchStatMacTableStats;
        mapId: string;
        /**
         * memory usage stat (for virtual chassis, memory usage of master RE)
         */
        memoryStat: outputs.device.GetSwitchStatsDeviceSwitchStatMemoryStat;
        model: string;
        modifiedTime: number;
        moduleStats: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStat[];
        /**
         * device name if configured
         */
        name: string;
        orgId: string;
        routeSummaryStats: outputs.device.GetSwitchStatsDeviceSwitchStatRouteSummaryStats;
        serial: string;
        serviceStat: {[key: string]: outputs.device.GetSwitchStatsDeviceSwitchStatServiceStat};
        siteId: string;
        status: string;
        uptime: number;
        vcMac: string;
        vcSetupInfo: outputs.device.GetSwitchStatsDeviceSwitchStatVcSetupInfo;
        version: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatApRedundancy {
        /**
         * for a VC / stacked switches.
         */
        modules: {[key: string]: outputs.device.GetSwitchStatsDeviceSwitchStatApRedundancyModules};
        numAps: number;
        numApsWithSwitchRedundancy: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatApRedundancyModules {
        numAps: number;
        numApsWithSwitchRedundancy: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatArpTableStats {
        arpTableCount: number;
        maxEntriesSupported: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatClient {
        deviceMac: string;
        hostname: string;
        mac: string;
        portId: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatClientsStats {
        total: outputs.device.GetSwitchStatsDeviceSwitchStatClientsStatsTotal;
    }

    export interface GetSwitchStatsDeviceSwitchStatClientsStatsTotal {
        numAps: number[];
        numWiredClients: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatCpuStat {
        /**
         * Percentage of CPU time that is idle
         */
        idle: number;
        /**
         * Percentage of CPU time being used by interrupts
         */
        interrupt: number;
        /**
         * Load averages for the last 1, 5, and 15 minutes
         */
        loadAvgs: number[];
        /**
         * Percentage of CPU time being used by system processes
         */
        system: number;
        /**
         * Percentage of CPU time being used by user processe
         */
        user: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatDhcpdStat {
        numIps: number;
        numLeased: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatFwupdate {
        progress: number;
        status: string;
        statusId: number;
        timestamp: number;
        willRetry: boolean;
    }

    export interface GetSwitchStatsDeviceSwitchStatIfStat {
        addressMode: string;
        ips: string[];
        natAddresses: string[];
        networkName: string;
        portId: string;
        portUsage: string;
        redundancyState: string;
        rxBytes: number;
        rxPkts: number;
        servpInfo: outputs.device.GetSwitchStatsDeviceSwitchStatIfStatServpInfo;
        txBytes: number;
        txPkts: number;
        up: boolean;
        vlan: number;
        wanName: string;
        wanType: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatIfStatServpInfo {
        asn: string;
        city: string;
        countryCode: string;
        latitude: number;
        longitude: number;
        org: string;
        regionCode: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatIpStat {
        dhcpServer: string;
        dns: string[];
        dnsSuffixes: string[];
        gateway: string;
        gateway6: string;
        ip: string;
        ip6: string;
        ips: {[key: string]: string};
        netmask: string;
        netmask6: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatLastTrouble {
        /**
         * Code definitions list at /api/v1/consts/ap*led*status
         */
        code: string;
        timestamp: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatMacTableStats {
        macTableCount: number;
        maxMacEntriesSupported: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatMemoryStat {
        usage: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStat {
        backupVersion: string;
        biosVersion: string;
        cpldVersion: string;
        /**
         * used to report all error states the device node is running into.
         * An error should always have `type` and `since` fields, and could have some other fields specific to that type.
         */
        errors: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatError[];
        fans: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatFan[];
        fpcIdx: number;
        fpgaVersion: string;
        lastSeen: number;
        model: string;
        opticsCpldVersion: string;
        pendingVersion: string;
        pics: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatPic[];
        poe: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatPoe;
        poeVersion: string;
        powerCpldVersion: string;
        psuses: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatPsus[];
        reFpgaVersion: string;
        recoveryVersion: string;
        serial: string;
        status: string;
        temperatures: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatTemperature[];
        tmcFpgaVersion: string;
        ubootVersion: string;
        uptime: number;
        vcLinks: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatVcLink[];
        vcMode: string;
        /**
         * master / backup / linecard
         */
        vcRole: string;
        vcState: string;
        version: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatError {
        feature: string;
        minimumVersion: string;
        reason: string;
        since: number;
        type: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatFan {
        airflow: string;
        name: string;
        status: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatPic {
        index: number;
        modelNumber: string;
        portGroups: outputs.device.GetSwitchStatsDeviceSwitchStatModuleStatPicPortGroup[];
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatPicPortGroup {
        count: number;
        type: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatPoe {
        maxPower: number;
        powerDraw: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatPsus {
        name: string;
        status: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatTemperature {
        celsius: number;
        name: string;
        status: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatModuleStatVcLink {
        neighborModuleIdx: number;
        neighborPortId: string;
        portId: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatRouteSummaryStats {
        fibRoutes: number;
        maxUnicastRoutesSupported: number;
        ribRoutes: number;
        totalRoutes: number;
    }

    export interface GetSwitchStatsDeviceSwitchStatServiceStat {
        ashVersion: string;
        ciaVersion: string;
        emberVersion: string;
        ipsecClientVersion: string;
        mistAgentVersion: string;
        packageVersion: string;
        testingToolsVersion: string;
        wheeljackVersion: string;
    }

    export interface GetSwitchStatsDeviceSwitchStatVcSetupInfo {
        configType: string;
        errMissingDevIdFpc: boolean;
    }

    export interface SwitchAclPolicy {
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        actions?: outputs.device.SwitchAclPolicyAction[];
        name?: string;
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        srcTags?: string[];
    }

    export interface SwitchAclPolicyAction {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        dstTag?: string;
    }

    export interface SwitchAclTags {
        /**
         * required if
         * - `type`==`dynamicGbp` (gbp_tag received from RADIUS)
         * - `type`==`staticGbp` (applying gbp tag against matching conditions)
         */
        gbpTag?: number;
        /**
         * required if 
         * - `type`==`mac`
         * - `type`==`staticGbp` if from matching mac
         */
        macs?: string[];
        /**
         * if:
         *   * `type`==`mac` (optional. default is `any`)
         *   * `type`==`subnet` (optional. default is `any`)
         *   * `type`==`network`
         *   * `type`==`resource` (optional. default is `any`)
         *   * `type`==`staticGbp` if from matching network (vlan)'
         */
        network?: string;
        /**
         * required if:
         *   * `type`==`radiusGroup`
         *   * `type`==`staticGbp`
         * if from matching radius_group
         */
        radiusGroup?: string;
        /**
         * if `type`==`resource`
         * empty means unrestricted, i.e. any
         */
        specs?: outputs.device.SwitchAclTagsSpec[];
        /**
         * if 
         * - `type`==`subnet` 
         * - `type`==`resource` (optional. default is `any`)
         * - `type`==`staticGbp` if from matching subnet
         */
        subnets?: string[];
        /**
         * enum: `any`, `dynamicGbp`, `mac`, `network`, `radiusGroup`, `resource`, `staticGbp`, `subnet`
         */
        type: string;
    }

    export interface SwitchAclTagsSpec {
        /**
         * matched dst port, "0" means any
         */
        portRange: string;
        /**
         * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocolNumber` is between 1-254
         */
        protocol: string;
    }

    export interface SwitchDhcpSnooping {
        allNetworks?: boolean;
        /**
         * Enable for dynamic ARP inspection check
         */
        enableArpSpoofCheck?: boolean;
        /**
         * Enable for check for forging source IP address
         */
        enableIpSourceGuard?: boolean;
        enabled?: boolean;
        /**
         * if `allNetworks`==`false`, list of network with DHCP snooping enabled
         */
        networks?: string[];
    }

    export interface SwitchDhcpdConfig {
        config?: {[key: string]: outputs.device.SwitchDhcpdConfigConfig};
        /**
         * if set to `true`, enable the DHCP server
         */
        enabled: boolean;
    }

    export interface SwitchDhcpdConfigConfig {
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: string[];
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes?: string[];
        /**
         * Property key is the MAC Address
         */
        fixedBindings?: {[key: string]: outputs.device.SwitchDhcpdConfigConfigFixedBindings};
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: string;
        /**
         * if `type`==`local`
         */
        ipEnd?: string;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: string;
        /**
         * if `type`==`local`
         */
        ipStart?: string;
        /**
         * if `type6`==`local`
         */
        ipStart6?: string;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime: number;
        /**
         * Property key is the DHCP option number
         */
        options?: {[key: string]: outputs.device.SwitchDhcpdConfigConfigOptions};
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride: boolean;
        /**
         * if `type`==`relay`
         */
        servers?: string[];
        /**
         * if `type6`==`relay`
         */
        servers6s?: string[];
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type: string;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6: string;
        /**
         * Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapulated?: {[key: string]: outputs.device.SwitchDhcpdConfigConfigVendorEncapulated};
    }

    export interface SwitchDhcpdConfigConfigFixedBindings {
        ip: string;
        name?: string;
    }

    export interface SwitchDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface SwitchDhcpdConfigConfigVendorEncapulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface SwitchEvpnConfig {
        enabled?: boolean;
        /**
         * enum: `access`, `core`, `distribution`
         */
        role?: string;
    }

    export interface SwitchExtraRoutes {
        /**
         * this takes precedence
         */
        discard: boolean;
        metric?: number;
        nextQualified?: {[key: string]: outputs.device.SwitchExtraRoutesNextQualified};
        noResolve: boolean;
        preference?: number;
        /**
         * next-hop IP Address
         */
        via: string;
    }

    export interface SwitchExtraRoutes6 {
        /**
         * this takes precedence
         */
        discard: boolean;
        metric?: number;
        nextQualified?: {[key: string]: outputs.device.SwitchExtraRoutes6NextQualified};
        noResolve: boolean;
        preference?: number;
        /**
         * next-hop IP Address
         */
        via: string;
    }

    export interface SwitchExtraRoutes6NextQualified {
        metric?: number;
        preference?: number;
    }

    export interface SwitchExtraRoutesNextQualified {
        metric?: number;
        preference?: number;
    }

    export interface SwitchIpConfig {
        dns: string[];
        dnsSuffixes: string[];
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
         */
        network?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
    }

    export interface SwitchMistNac {
        enabled?: boolean;
        network?: string;
    }

    export interface SwitchNetworks {
        /**
         * whether to stop clients to talk to each other, default is false (when enabled, a unique isolationVlanId is required)
         * NOTE: this features requires uplink device to also a be Juniper device and `interSwitchLink` to be set
         */
        isolation: boolean;
        isolationVlanId?: string;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet?: string;
        vlanId: string;
    }

    export interface SwitchOobIpConfig {
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * optional, the network to be used for mgmt
         */
        network?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * f supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
         */
        useMgmtVrfForHostOut: boolean;
    }

    export interface SwitchOspfConfig {
        /**
         * OSPF areas to run on this device and the corresponding per-area-specific configs. Property key is the area
         */
        areas?: {[key: string]: outputs.device.SwitchOspfConfigAreas};
        /**
         * whether to rung OSPF on this device
         */
        enabled?: boolean;
        /**
         * Bandwidth for calculating metric defaults (9600..4000000000000)
         */
        referenceBandwidth: string;
    }

    export interface SwitchOspfConfigAreas {
        /**
         * for a stub/nssa area, where to avoid forwarding type-3 LSA to this area
         */
        noSummary?: boolean;
    }

    export interface SwitchOtherIpConfigs {
        /**
         * for EVPN, if anycast is desired
         */
        evpnAnycast: boolean;
        /**
         * required if `type`==`static`
         */
        ip?: string;
        /**
         * required if `type6`==`static`
         */
        ip6?: string;
        /**
         * optional, `subnet` from `network` definition will be used if defined
         */
        netmask?: string;
        /**
         * optional, `subnet` from `network` definition will be used if defined
         */
        netmask6?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        type6: string;
    }

    export interface SwitchPortConfig {
        /**
         * To disable LACP support for the AE interface
         */
        aeDisableLacp?: boolean;
        /**
         * Users could force to use the designated AE name
         */
        aeIdx?: number;
        /**
         * to use fast timeout
         */
        aeLacpSlow: boolean;
        aggregated: boolean;
        /**
         * if want to generate port up/down alarm
         */
        critical?: boolean;
        description?: string;
        /**
         * if `speed` and `duplex` are specified, whether to disable autonegotiation
         */
        disableAutoneg: boolean;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Enable dynamic usage for this port. Set to `dynamic` to enable.
         */
        dynamicUsage?: string;
        esilag?: boolean;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
         */
        mtu: number;
        /**
         * prevent helpdesk to override the port config
         */
        noLocalOverwrite?: boolean;
        poeDisabled: boolean;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
         */
        speed: string;
        /**
         * port usage name. 
         *
         * If EVPN is used, use `evpnUplink`or `evpnDownlink`
         */
        usage: string;
    }

    export interface SwitchPortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses: string[];
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: string;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: string;
    }

    export interface SwitchPortUsages {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks: boolean;
        /**
         * Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         *
         * When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        allowMultipleSupplicants: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        description?: string;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg: boolean;
        /**
         * Only if `mode`!=`dynamic` whether the port is disabled
         */
        disabled: boolean;
        /**
         * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks: string[];
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        enableQos: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: string;
        /**
         * Only if `mode`!=`dynamic` interSwitchLink is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink: boolean;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         */
        macAuthOnly?: boolean;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol: string;
        /**
         * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit: number;
        /**
         * `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         */
        mode?: string;
        /**
         * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: number;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks: string[];
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac: boolean;
        /**
         * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         */
        poeDisabled: boolean;
        /**
         * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: string;
        /**
         * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         */
        portNetwork?: string;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval: number;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` when radius server reject / fails
         */
        rejectedNetwork?: string;
        /**
         * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         */
        resetDefaultWhen: string;
        /**
         * Only if `mode`==`dynamic`
         */
        rules?: outputs.device.SwitchPortUsagesRule[];
        /**
         * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
         */
        speed?: string;
        /**
         * Switch storm control
         * Only if `mode`!=`dynamic`
         */
        stormControl?: outputs.device.SwitchPortUsagesStormControl;
        /**
         * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge: boolean;
        /**
         * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: string;
    }

    export interface SwitchPortUsagesRule {
        equals?: string;
        /**
         * use `equalsAny` to match any item in a list
         */
        equalsAnies?: string[];
        /**
         * "[0:3]":"abcdef" > "abc"
         * "split(.)[1]": "a.b.c" > "b"
         * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
         */
        expression?: string;
        /**
         * enum: `linkPeermac`, `lldpChassisId`, `lldpHardwareRevision`, `lldpManufacturerName`, `lldpOui`, `lldpSerialNumber`, `lldpSystemName`, `radiusDynamicfilter`, `radiusUsermac`, `radiusUsername`
         */
        src: string;
        /**
         * `portUsage` name
         */
        usage?: string;
    }

    export interface SwitchPortUsagesStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast: boolean;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast: boolean;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast: boolean;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast: boolean;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage: number;
    }

    export interface SwitchRadiusConfig {
        /**
         * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
         */
        acctInterimInterval: number;
        acctServers?: outputs.device.SwitchRadiusConfigAcctServer[];
        authServers?: outputs.device.SwitchRadiusConfigAuthServer[];
        /**
         * radius auth session retries
         */
        authServersRetries: number;
        /**
         * radius auth session timeout
         */
        authServersTimeout: number;
        coaEnabled: boolean;
        coaPort: number;
        /**
         * use `network`or `sourceIp`
         * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
         */
        network?: string;
        /**
         * use `network`or `sourceIp`
         */
        sourceIp?: string;
    }

    export interface SwitchRadiusConfigAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Acct port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface SwitchRadiusConfigAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Auth port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface SwitchRemoteSyslog {
        archive?: outputs.device.SwitchRemoteSyslogArchive;
        console?: outputs.device.SwitchRemoteSyslogConsole;
        enabled: boolean;
        files?: outputs.device.SwitchRemoteSyslogFile[];
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        network?: string;
        sendToAllServers: boolean;
        servers?: outputs.device.SwitchRemoteSyslogServer[];
        /**
         * enum: `millisecond`, `year`, `year millisecond`
         */
        timeFormat?: string;
        users?: outputs.device.SwitchRemoteSyslogUser[];
    }

    export interface SwitchRemoteSyslogArchive {
        files?: number;
        size?: string;
    }

    export interface SwitchRemoteSyslogConsole {
        contents?: outputs.device.SwitchRemoteSyslogConsoleContent[];
    }

    export interface SwitchRemoteSyslogConsoleContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface SwitchRemoteSyslogFile {
        archive?: outputs.device.SwitchRemoteSyslogFileArchive;
        contents?: outputs.device.SwitchRemoteSyslogFileContent[];
        explicitPriority?: boolean;
        file?: string;
        match?: string;
        structuredData?: boolean;
    }

    export interface SwitchRemoteSyslogFileArchive {
        files?: number;
        size?: string;
    }

    export interface SwitchRemoteSyslogFileContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface SwitchRemoteSyslogServer {
        contents?: outputs.device.SwitchRemoteSyslogServerContent[];
        explicitPriority?: boolean;
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        host?: string;
        match?: string;
        port: number;
        /**
         * enum: `tcp`, `udp`
         */
        protocol: string;
        routingInstance?: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        sourceAddress?: string;
        structuredData?: boolean;
        tag?: string;
    }

    export interface SwitchRemoteSyslogServerContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface SwitchRemoteSyslogUser {
        contents?: outputs.device.SwitchRemoteSyslogUserContent[];
        match?: string;
        user?: string;
    }

    export interface SwitchRemoteSyslogUserContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface SwitchSnmpConfig {
        clientLists?: outputs.device.SwitchSnmpConfigClientList[];
        contact?: string;
        description?: string;
        enabled: boolean;
        /**
         * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
         */
        engineId?: string;
        location?: string;
        name?: string;
        network: string;
        trapGroups?: outputs.device.SwitchSnmpConfigTrapGroup[];
        v2cConfigs?: outputs.device.SwitchSnmpConfigV2cConfig[];
        v3Config?: outputs.device.SwitchSnmpConfigV3Config;
        views?: outputs.device.SwitchSnmpConfigView[];
    }

    export interface SwitchSnmpConfigClientList {
        clientListName?: string;
        clients?: string[];
    }

    export interface SwitchSnmpConfigTrapGroup {
        categories?: string[];
        /**
         * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
         */
        groupName?: string;
        targets?: string[];
        /**
         * enum: `all`, `v1`, `v2`
         */
        version: string;
    }

    export interface SwitchSnmpConfigV2cConfig {
        authorization?: string;
        /**
         * client_list_name here should refer to clientList above
         */
        clientListName?: string;
        communityName?: string;
        /**
         * view name here should be defined in views above
         */
        view?: string;
    }

    export interface SwitchSnmpConfigV3Config {
        notifies?: outputs.device.SwitchSnmpConfigV3ConfigNotify[];
        notifyFilters?: outputs.device.SwitchSnmpConfigV3ConfigNotifyFilter[];
        targetAddresses?: outputs.device.SwitchSnmpConfigV3ConfigTargetAddress[];
        targetParameters?: outputs.device.SwitchSnmpConfigV3ConfigTargetParameter[];
        usm?: outputs.device.SwitchSnmpConfigV3ConfigUsm;
        vacm?: outputs.device.SwitchSnmpConfigV3ConfigVacm;
    }

    export interface SwitchSnmpConfigV3ConfigNotify {
        name?: string;
        tag?: string;
        /**
         * enum: `inform`, `trap`
         */
        type?: string;
    }

    export interface SwitchSnmpConfigV3ConfigNotifyFilter {
        contents?: outputs.device.SwitchSnmpConfigV3ConfigNotifyFilterContent[];
        profileName?: string;
    }

    export interface SwitchSnmpConfigV3ConfigNotifyFilterContent {
        include?: boolean;
        oid?: string;
    }

    export interface SwitchSnmpConfigV3ConfigTargetAddress {
        address?: string;
        addressMask?: string;
        port: number;
        /**
         * <refer to notify tag, can be multiple with blank
         */
        tagList?: string;
        targetAddressName?: string;
        /**
         * refer to notify target parameters name
         */
        targetParameters?: string;
    }

    export interface SwitchSnmpConfigV3ConfigTargetParameter {
        /**
         * enum: `v1`, `v2c`, `v3`
         */
        messageProcessingModel?: string;
        name?: string;
        /**
         * refer to profile-name in notify_filter
         */
        notifyFilter?: string;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: string;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: string;
        /**
         * refer to securityName in usm
         */
        securityName?: string;
    }

    export interface SwitchSnmpConfigV3ConfigUsm {
        /**
         * enum: `localEngine`, `remoteEngine`
         */
        engineType?: string;
        /**
         * required only if `engineType`==`remoteEngine`
         */
        engineid?: string;
        users?: outputs.device.SwitchSnmpConfigV3ConfigUsmUser[];
    }

    export interface SwitchSnmpConfigV3ConfigUsmUser {
        /**
         * Not required if `authenticationType`==`authenticationNone`
         * include alphabetic, numeric, and special characters, but it cannot include control characters.
         */
        authenticationPassword?: string;
        /**
         * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authenticationMd5`, `authenticationNone`, `authenticationSha`, `authenticationSha224`, `authenticationSha256`, `authenticationSha384`, `authenticationSha512`
         */
        authenticationType?: string;
        /**
         * Not required if `encryptionType`==`privacy-none`
         * include alphabetic, numeric, and special characters, but it cannot include control characters
         */
        encryptionPassword?: string;
        /**
         * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
         */
        encryptionType?: string;
        name?: string;
    }

    export interface SwitchSnmpConfigV3ConfigVacm {
        accesses?: outputs.device.SwitchSnmpConfigV3ConfigVacmAccess[];
        securityToGroup?: outputs.device.SwitchSnmpConfigV3ConfigVacmSecurityToGroup;
    }

    export interface SwitchSnmpConfigV3ConfigVacmAccess {
        groupName?: string;
        prefixLists?: outputs.device.SwitchSnmpConfigV3ConfigVacmAccessPrefixList[];
    }

    export interface SwitchSnmpConfigV3ConfigVacmAccessPrefixList {
        /**
         * only required if `type`==`contextPrefix`
         */
        contextPrefix?: string;
        /**
         * refer to view name
         */
        notifyView?: string;
        /**
         * refer to view name
         */
        readView?: string;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: string;
        /**
         * enum: `any`, `usm`, `v1`, `v2c`
         */
        securityModel?: string;
        /**
         * enum: `contextPrefix`, `defaultContextPrefix`
         */
        type?: string;
        /**
         * refer to view name
         */
        writeView?: string;
    }

    export interface SwitchSnmpConfigV3ConfigVacmSecurityToGroup {
        contents?: outputs.device.SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent[];
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: string;
    }

    export interface SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent {
        /**
         * refer to groupName under access
         */
        group?: string;
        securityName?: string;
    }

    export interface SwitchSnmpConfigView {
        /**
         * if the root oid configured is included
         */
        include?: boolean;
        oid?: string;
        viewName?: string;
    }

    export interface SwitchStpConfig {
        /**
         * enum: `rstp`, `vstp`
         */
        type: string;
    }

    export interface SwitchSwitchMgmt {
        configRevert: number;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: outputs.device.SwitchSwitchMgmtProtectRe;
        rootPassword?: string;
        tacacs?: outputs.device.SwitchSwitchMgmtTacacs;
    }

    export interface SwitchSwitchMgmtProtectRe {
        /**
         * optionally, services we'll allow
         */
        allowedServices: string[];
        customs?: outputs.device.SwitchSwitchMgmtProtectReCustom[];
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled: boolean;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts: string[];
    }

    export interface SwitchSwitchMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any
         */
        portRange: string;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`
         */
        protocol: string;
        subnets?: string[];
    }

    export interface SwitchSwitchMgmtTacacs {
        acctServers?: outputs.device.SwitchSwitchMgmtTacacsAcctServer[];
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        defaultRole: string;
        enabled?: boolean;
        /**
         * which network the TACACS server resides
         */
        network?: string;
        tacplusServers?: outputs.device.SwitchSwitchMgmtTacacsTacplusServer[];
    }

    export interface SwitchSwitchMgmtTacacsAcctServer {
        host?: string;
        port?: string;
        secret?: string;
        timeout: number;
    }

    export interface SwitchSwitchMgmtTacacsTacplusServer {
        host?: string;
        port?: string;
        secret?: string;
        timeout: number;
    }

    export interface SwitchVirtualChassis {
        /**
         * list of Virtual Chassis members
         */
        members?: outputs.device.SwitchVirtualChassisMember[];
        /**
         * to configure whether the VC is preprovisioned or nonprovisioned
         */
        preprovisioned: boolean;
    }

    export interface SwitchVirtualChassisMember {
        /**
         * fpc0, same as the mac of device_id
         */
        mac?: string;
        memberId?: number;
        /**
         * Both vcRole master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
         */
        vcRole?: string;
    }

    export interface SwitchVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: boolean;
    }

    export interface SwitchVrfInstances {
        networks?: string[];
        /**
         * Property key is the destination CIDR (e.g. "10.0.0.0/8")
         */
        vrfExtraRoutes?: {[key: string]: outputs.device.SwitchVrfInstancesVrfExtraRoutes};
    }

    export interface SwitchVrfInstancesVrfExtraRoutes {
        /**
         * Next-hop address
         */
        via: string;
    }

    export interface SwitchVrrpConfig {
        enabled?: boolean;
        /**
         * Property key is the VRRP name
         */
        groups?: {[key: string]: outputs.device.SwitchVrrpConfigGroups};
    }

    export interface SwitchVrrpConfigGroups {
        priority?: number;
    }

}

export namespace org {
    export interface DeviceprofileApAeroscout {
        /**
         * whether to enable aeroscout config
         */
        enabled: boolean;
        /**
         * required if enabled, aeroscout server host
         */
        host?: string;
        /**
         * whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
         */
        locateConnected: boolean;
    }

    export interface DeviceprofileApBleConfig {
        /**
         * whether Mist beacons is enabled
         */
        beaconEnabled: boolean;
        /**
         * required if `beaconRateMode`==`custom`, 1-10, in number-beacons-per-second
         */
        beaconRate: number;
        /**
         * enum: `custom`, `default`
         */
        beaconRateMode: string;
        /**
         * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
         */
        beamDisableds?: number[];
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send custom packet
         */
        customBlePacketEnabled: boolean;
        /**
         * The custom frame to be sent out in this beacon. The frame must be a hexstring
         */
        customBlePacketFrame: string;
        /**
         * Frequency (msec) of data emitted by custom ble beacon
         */
        customBlePacketFreqMsec: number;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUidAdvPower: number;
        eddystoneUidBeams: string;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-UID beacon is enabled
         */
        eddystoneUidEnabled: boolean;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUidFreqMsec: number;
        /**
         * Eddystone-UID instance for the device
         */
        eddystoneUidInstance: string;
        /**
         * Eddystone-UID namespace
         */
        eddystoneUidNamespace: string;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUrlAdvPower: number;
        eddystoneUrlBeams: string;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-URL beacon is enabled
         */
        eddystoneUrlEnabled: boolean;
        /**
         * Frequency (msec) of data emit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec: number;
        /**
         * URL pointed by Eddystone-URL beacon
         */
        eddystoneUrlUrl: string;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        ibeaconAdvPower: number;
        ibeaconBeams: string;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send iBeacon
         */
        ibeaconEnabled: boolean;
        /**
         * Frequency (msec) of data emmit for iBeacon
         */
        ibeaconFreqMsec: number;
        /**
         * Major number for iBeacon
         */
        ibeaconMajor: number;
        /**
         * Minor number for iBeacon
         */
        ibeaconMinor: number;
        /**
         * optional, if not specified, the same UUID as the beacon will be used
         */
        ibeaconUuid: string;
        /**
         * required if `powerMode`==`custom`
         */
        power: number;
        /**
         * enum: `custom`, `default`
         */
        powerMode: string;
    }

    export interface DeviceprofileApEslConfig {
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        cacert?: string;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        channel?: number;
        /**
         * usb*config is ignored if esl*config enabled
         */
        enabled: boolean;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        host?: string;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        port?: number;
        /**
         * note: ble*config will be ingored if esl*config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
         */
        type?: string;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        verifyCert?: boolean;
        /**
         * Only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId: number;
    }

    export interface DeviceprofileApIpConfig {
        /**
         * if `type`==`static`
         */
        dns: string[];
        /**
         * required if `type`==`static`
         */
        dnsSuffixes: string[];
        /**
         * required if `type`==`static`
         */
        gateway?: string;
        gateway6?: string;
        /**
         * required if `type`==`static`
         */
        ip?: string;
        ip6?: string;
        mtu?: number;
        /**
         * required if `type`==`static`
         */
        netmask?: string;
        netmask6?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        type6: string;
        /**
         * management vlan id, default is 1 (untagged)
         */
        vlanId: number;
    }

    export interface DeviceprofileApLed {
        brightness: number;
        enabled: boolean;
    }

    export interface DeviceprofileApMesh {
        /**
         * whether mesh is enabled on this AP
         */
        enabled: boolean;
        /**
         * mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
         */
        group?: number;
        /**
         * enum: `base`, `remote`
         */
        role?: string;
    }

    export interface DeviceprofileApPwrConfig {
        /**
         * additional power to request during negotiating with PSE over PoE, in mW
         */
        base: number;
        /**
         * whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
         */
        preferUsbOverWifi: boolean;
    }

    export interface DeviceprofileApRadioConfig {
        allowRrmDisable: boolean;
        /**
         * antenna gain for 2.4G - for models with external antenna only
         */
        antGain24?: number;
        /**
         * antenna gain for 5G - for models with external antenna only
         */
        antGain5?: number;
        /**
         * antenna gain for 6G - for models with external antenna only
         */
        antGain6?: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * Radio Band AP settings
         */
        band24?: outputs.org.DeviceprofileApRadioConfigBand24;
        /**
         * enum: `24`, `5`, `6`, `auto`
         */
        band24Usage?: string;
        /**
         * Radio Band AP settings
         */
        band5?: outputs.org.DeviceprofileApRadioConfigBand5;
        /**
         * Radio Band AP settings
         */
        band5On24Radio?: outputs.org.DeviceprofileApRadioConfigBand5On24Radio;
        /**
         * Radio Band AP settings
         */
        band6?: outputs.org.DeviceprofileApRadioConfigBand6;
        /**
         * to make an outdoor operate indoor.
         * for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
         */
        indoorUse: boolean;
        /**
         * whether scanning radio is enabled
         */
        scanningEnabled?: boolean;
    }

    export interface DeviceprofileApRadioConfigBand24 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface DeviceprofileApRadioConfigBand5 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface DeviceprofileApRadioConfigBand5On24Radio {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface DeviceprofileApRadioConfigBand6 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth: number;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower: boolean;
    }

    export interface DeviceprofileApUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x: boolean;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown: boolean;
    }

    export interface DeviceprofileApUsbConfig {
        /**
         * only if `type`==`imagotag`
         */
        cacert?: string;
        /**
         * only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
         */
        channel?: number;
        /**
         * whether to enable any usb config
         */
        enabled?: boolean;
        /**
         * only if `type`==`imagotag`
         */
        host?: string;
        /**
         * only if `type`==`imagotag`
         */
        port: number;
        /**
         * usb config type. enum: `hanshow`, `imagotag`, `solum`
         */
        type?: string;
        /**
         * only if `type`==`imagotag`, whether to turn on SSL verification
         */
        verifyCert?: boolean;
        /**
         * only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId: number;
    }

    export interface DeviceprofileGatewayBgpConfig {
        authKey?: string;
        /**
         * when bfdMultiplier is configured alone. Default:
         *   * 1000 if `type`==`external`
         *   * 350 `type`==`internal`
         */
        bfdMinimumInterval: number;
        /**
         * when bfdMinimumIntervalIsConfigured alone
         */
        bfdMultiplier: number;
        communities?: outputs.org.DeviceprofileGatewayBgpConfigCommunity[];
        /**
         * BFD provides faster path failure detection and is enabled by default
         */
        disableBfd: boolean;
        export?: string;
        /**
         * default export policies if no per-neighbor policies defined
         */
        exportPolicy?: string;
        /**
         * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
         * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
         */
        extendedV4Nexthop?: boolean;
        /**
         * `0` means disable
         */
        gracefulRestartTime: number;
        holdTime: number;
        import?: string;
        /**
         * default import policies if no per-neighbor policies defined
         */
        importPolicy?: string;
        localAs?: number;
        neighborAs?: number;
        /**
         * if per-neighbor as is desired. Property key is the neighbor address
         */
        neighbors?: {[key: string]: outputs.org.DeviceprofileGatewayBgpConfigNeighbors};
        /**
         * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
         */
        networks: string[];
        /**
         * by default, we'll re-advertise all learned BGP routers toward overlay
         */
        noReadvertiseToOverlay: boolean;
        /**
         * enum: `external`, `internal`
         */
        type?: string;
        /**
         * network name. enum: `lan`, `vpn`, `wan`
         */
        via: string;
        vpnName?: string;
        /**
         * if `via`==`wan`
         */
        wanName?: string;
    }

    export interface DeviceprofileGatewayBgpConfigCommunity {
        id?: string;
        localPreference?: number;
        vpnName?: string;
    }

    export interface DeviceprofileGatewayBgpConfigNeighbors {
        /**
         * If true, the BGP session to this neighbor will be administratively disabled/shutdown
         */
        disabled: boolean;
        exportPolicy?: string;
        holdTime: number;
        importPolicy?: string;
        /**
         * assuming BGP neighbor is directly connected
         */
        multihopTtl?: number;
        neighborAs?: number;
    }

    export interface DeviceprofileGatewayDhcpdConfig {
        config?: {[key: string]: outputs.org.DeviceprofileGatewayDhcpdConfigConfig};
        /**
         * if set to `true`, enable the DHCP server
         */
        enabled: boolean;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfig {
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: string[];
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes: string[];
        /**
         * Property key is the MAC Address
         */
        fixedBindings?: {[key: string]: outputs.org.DeviceprofileGatewayDhcpdConfigConfigFixedBindings};
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: string;
        /**
         * if `type`==`local`
         */
        ipEnd?: string;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: string;
        /**
         * if `type`==`local`
         */
        ipStart?: string;
        /**
         * if `type6`==`local`
         */
        ipStart6?: string;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime: number;
        /**
         * Property key is the DHCP option number
         */
        options?: {[key: string]: outputs.org.DeviceprofileGatewayDhcpdConfigConfigOptions};
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride: boolean;
        /**
         * if `type`==`relay`
         */
        servers: string[];
        /**
         * if `type6`==`relay`
         */
        servers6s: string[];
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type: string;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6: string;
        /**
         * Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapulated?: {[key: string]: outputs.org.DeviceprofileGatewayDhcpdConfigConfigVendorEncapulated};
    }

    export interface DeviceprofileGatewayDhcpdConfigConfigFixedBindings {
        ip: string;
        name?: string;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfigVendorEncapulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface DeviceprofileGatewayExtraRoutes {
        via: string;
    }

    export interface DeviceprofileGatewayExtraRoutes6 {
        via: string;
    }

    export interface DeviceprofileGatewayIdpProfiles {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile?: string;
        name?: string;
        orgId?: string;
        overwrites?: outputs.org.DeviceprofileGatewayIdpProfilesOverwrite[];
    }

    export interface DeviceprofileGatewayIdpProfilesOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action: string;
        matching?: outputs.org.DeviceprofileGatewayIdpProfilesOverwriteMatching;
        name?: string;
    }

    export interface DeviceprofileGatewayIdpProfilesOverwriteMatching {
        attackNames?: string[];
        dstSubnets?: string[];
        severities?: string[];
    }

    export interface DeviceprofileGatewayIpConfigs {
        ip: string;
        netmask: string;
        /**
         * optional list of secondary IPs in CIDR format
         */
        secondaryIps: string[];
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
    }

    export interface DeviceprofileGatewayNetwork {
        /**
         * whether to disallow Mist Devices in the network
         */
        disallowMistServices: boolean;
        gateway?: string;
        gateway6?: string;
        internalAccess?: outputs.org.DeviceprofileGatewayNetworkInternalAccess;
        /**
         * whether this network has direct internet access
         */
        internetAccess?: outputs.org.DeviceprofileGatewayNetworkInternetAccess;
        /**
         * whether to allow clients in the network to talk to each other
         */
        isolation?: boolean;
        name: string;
        /**
         * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
         */
        routedForNetworks?: string[];
        subnet: string;
        subnet6?: string;
        tenants?: {[key: string]: outputs.org.DeviceprofileGatewayNetworkTenants};
        vlanId?: string;
        /**
         * Property key is the VPN name. Whether this network can be accessed from vpn
         */
        vpnAccess?: {[key: string]: outputs.org.DeviceprofileGatewayNetworkVpnAccess};
    }

    export interface DeviceprofileGatewayNetworkInternalAccess {
        enabled?: boolean;
    }

    export interface DeviceprofileGatewayNetworkInternetAccess {
        createSimpleServicePolicy: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: {[key: string]: outputs.org.DeviceprofileGatewayNetworkInternetAccessDestinationNat};
        enabled?: boolean;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted: boolean;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: {[key: string]: outputs.org.DeviceprofileGatewayNetworkInternetAccessStaticNat};
    }

    export interface DeviceprofileGatewayNetworkInternetAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface DeviceprofileGatewayNetworkInternetAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface DeviceprofileGatewayNetworkTenants {
        addresses?: string[];
    }

    export interface DeviceprofileGatewayNetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: string;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat: {[key: string]: outputs.org.DeviceprofileGatewayNetworkVpnAccessDestinationNat};
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: string;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp: boolean;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf: boolean;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: boolean;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs: string[];
        /**
         * whether this network is routable
         */
        routed?: boolean;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat: outputs.org.DeviceprofileGatewayNetworkVpnAccessSourceNat;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat: {[key: string]: outputs.org.DeviceprofileGatewayNetworkVpnAccessStaticNat};
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: string;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: string;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: string;
    }

    export interface DeviceprofileGatewayNetworkVpnAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface DeviceprofileGatewayNetworkVpnAccessSourceNat {
        externalIp?: string;
    }

    export interface DeviceprofileGatewayNetworkVpnAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface DeviceprofileGatewayOobIpConfig {
        /**
         * if `type`==`static`
         */
        gateway?: string;
        /**
         * if `type`==`static`
         */
        ip?: string;
        /**
         * if `type`==`static`
         */
        netmask?: string;
        /**
         * for HA Cluster, node1 can have different IP Config
         */
        node1?: outputs.org.DeviceprofileGatewayOobIpConfigNode1;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
         */
        useMgmtVrfForHostOut: boolean;
        vlanId?: string;
    }

    export interface DeviceprofileGatewayOobIpConfigNode1 {
        /**
         * if `type`==`static`
         */
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * whether to use `mgmtJunos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut: boolean;
        vlanId?: string;
    }

    export interface DeviceprofileGatewayPathPreferences {
        paths?: outputs.org.DeviceprofileGatewayPathPreferencesPath[];
        /**
         * enum: `ecmp`, `ordered`, `weighted`
         */
        strategy: string;
    }

    export interface DeviceprofileGatewayPathPreferencesPath {
        cost?: number;
        /**
         * For SSR Only. `true`, if this specific path is undesired
         */
        disabled?: boolean;
        /**
         * only if `type`==`local`, if a different gateway is desired
         */
        gatewayIp?: string;
        /**
         * only if `type`==`vpn`, if this vpn path can be used for internet
         */
        internetAccess?: boolean;
        /**
         * required when 
         *   * `type`==`vpn`: the name of the VPN Path to use 
         *   * `type`==`wan`: the name of the WAN interface to use'
         */
        name?: string;
        /**
         * required when `type`==`local`
         */
        networks: string[];
        /**
         * if `type`==`local`, if destination IP is to be replaced
         */
        targetIps: string[];
        /**
         * enum: `local`, `tunnel`, `vpn`, `wan`
         */
        type?: string;
        /**
         * required when`type`==`tunnel`
         */
        wanName?: string;
    }

    export interface DeviceprofileGatewayPortConfig {
        description?: string;
        disableAutoneg: boolean;
        /**
         * port admin up (true) / down (false)
         */
        disabled: boolean;
        /**
         * if `wanType`==`lte`. enum: `adsl`, `vdsl`
         */
        dslType: string;
        /**
         * if `wanType`==`dsl`
         * 16 bit int
         */
        dslVci: number;
        /**
         * if `wanType`==`dsl`
         * 8 bit int
         */
        dslVpi: number;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Junos IP Config
         */
        ipConfig?: outputs.org.DeviceprofileGatewayPortConfigIpConfig;
        /**
         * if `wanType`==`lte`
         */
        lteApn?: string;
        /**
         * if `wanType`==`lte`. enum: `chap`, `none`, `pap`
         */
        lteAuth: string;
        lteBackup?: boolean;
        /**
         * if `wanType`==`lte`
         */
        ltePassword?: string;
        /**
         * if `wanType`==`lte`
         */
        lteUsername?: string;
        mtu?: number;
        /**
         * name that we'll use to derive config
         */
        name?: string;
        /**
         * if `usage`==`lan`
         */
        networks: string[];
        /**
         * for Q-in-Q
         */
        outerVlanId?: number;
        poeDisabled: boolean;
        /**
         * if `usage`==`lan`
         */
        portNetwork?: string;
        /**
         * whether to preserve dscp when sending traffic over VPN (SSR-only)
         */
        preserveDscp: boolean;
        /**
         * if HA mode
         */
        redundant?: boolean;
        /**
         * if HA mode
         */
        rethIdx?: number;
        /**
         * if HA mode
         */
        rethNode?: string;
        /**
         * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
         */
        rethNodes: string[];
        speed: string;
        /**
         * when SSR is running as VM, this is required on certain hosting platforms
         */
        ssrNoVirtualMac: boolean;
        /**
         * for SSR only
         */
        svrPortRange: string;
        trafficShaping?: outputs.org.DeviceprofileGatewayPortConfigTrafficShaping;
        /**
         * port usage name. enum: `haControl`, `haData`, `lan`, `wan`
         */
        usage: string;
        /**
         * if WAN interface is on a VLAN
         */
        vlanId?: number;
        vpnPaths?: {[key: string]: outputs.org.DeviceprofileGatewayPortConfigVpnPaths};
        /**
         * when `wanType`==`broadband`. enum: `default`, `max`, `recommended`
         */
        wanArpPolicer: string;
        /**
         * optional, if spoke should reach this port by a different IP
         */
        wanExtIp?: string;
        /**
         * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
         */
        wanSourceNat?: outputs.org.DeviceprofileGatewayPortConfigWanSourceNat;
        /**
         * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
         */
        wanType: string;
    }

    export interface DeviceprofileGatewayPortConfigIpConfig {
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dns?: string[];
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dnsSuffixes?: string[];
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * optional, the network to be used for mgmt
         */
        network?: string;
        /**
         * if `type`==`pppoe`
         */
        poserPassword?: string;
        /**
         * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
         */
        pppoeAuth: string;
        /**
         * if `type`==`pppoe`
         */
        pppoeUsername?: string;
        /**
         * enum: `dhcp`, `pppoe`, `static`
         */
        type: string;
    }

    export interface DeviceprofileGatewayPortConfigTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: number[];
        enabled: boolean;
    }

    export interface DeviceprofileGatewayPortConfigVpnPaths {
        /**
         * enum: `broadband`, `lte`
         */
        bfdProfile: string;
        /**
         * whether to use tunnel mode. SSR only
         */
        bfdUseTunnelMode: boolean;
        /**
         * for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
         */
        preference?: number;
        /**
         * enum: `hub`, `spoke`
         */
        role: string;
        trafficShaping?: outputs.org.DeviceprofileGatewayPortConfigVpnPathsTrafficShaping;
    }

    export interface DeviceprofileGatewayPortConfigVpnPathsTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: number[];
        enabled: boolean;
    }

    export interface DeviceprofileGatewayPortConfigWanSourceNat {
        /**
         * or to disable the source-nat
         */
        disabled: boolean;
        /**
         * if alternative natPool is desired
         */
        natPool?: string;
    }

    export interface DeviceprofileGatewayRoutingPolicies {
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        terms?: outputs.org.DeviceprofileGatewayRoutingPoliciesTerm[];
    }

    export interface DeviceprofileGatewayRoutingPoliciesTerm {
        /**
         * when used as import policy
         */
        action?: outputs.org.DeviceprofileGatewayRoutingPoliciesTermAction;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        matching?: outputs.org.DeviceprofileGatewayRoutingPoliciesTermMatching;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermAction {
        accept?: boolean;
        addCommunities?: string[];
        /**
         * for SSR, hub decides how VRF routes are leaked on spoke
         */
        addTargetVrfs?: string[];
        /**
         * when used as export policy, optional
         */
        communities?: string[];
        /**
         * when used as export policy, optional. To exclude certain AS
         */
        excludeAsPaths?: string[];
        excludeCommunities?: string[];
        /**
         * when used as export policy, optional
         */
        exportCommunitites?: string[];
        /**
         * optional, for an import policy, localPreference can be changed
         */
        localPreference?: string;
        /**
         * when used as export policy, optional. By default, the local AS will be prepended, to change it
         */
        prependAsPaths?: string[];
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermMatching {
        /**
         * takes regular expression
         */
        asPaths?: string[];
        communities?: string[];
        networks?: string[];
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        prefixes?: string[];
        /**
         * `direct`, `bgp`, `osp`, ...
         */
        protocols?: string[];
        routeExists?: outputs.org.DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         */
        vpnNeighborMacs?: string[];
        vpnPathSla?: outputs.org.DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         * ordered-
         */
        vpnPaths?: string[];
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists {
        route?: string;
        /**
         * name of the vrf instance
         * it can also be the name of the VPN or wan if they
         */
        vrfName: string;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla {
        maxJitter?: number;
        maxLatency?: number;
        maxLoss?: number;
    }

    export interface DeviceprofileGatewayServicePolicy {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        /**
         * For SRX Only
         */
        appqoe?: outputs.org.DeviceprofileGatewayServicePolicyAppqoe;
        ewfs?: outputs.org.DeviceprofileGatewayServicePolicyEwf[];
        idp?: outputs.org.DeviceprofileGatewayServicePolicyIdp;
        /**
         * access within the same VRF
         */
        localRouting: boolean;
        name?: string;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference?: string;
        /**
         * used to link servicepolicy defined at org level and overwrite some attributes
         */
        servicepolicyId?: string;
        services: string[];
        tenants: string[];
    }

    export interface DeviceprofileGatewayServicePolicyAppqoe {
        enabled: boolean;
    }

    export interface DeviceprofileGatewayServicePolicyEwf {
        alertOnly?: boolean;
        blockMessage?: string;
        enabled: boolean;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile: string;
    }

    export interface DeviceprofileGatewayServicePolicyIdp {
        alertOnly?: boolean;
        enabled: boolean;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: string;
        /**
         * `strict` (default) / `standard` / or keys from from idp_profiles
         */
        profile: string;
    }

    export interface DeviceprofileGatewayTunnelConfigs {
        autoProvision?: outputs.org.DeviceprofileGatewayTunnelConfigsAutoProvision;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        ikeLifetime?: number;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
         */
        ikeMode: string;
        /**
         * if `provider`== `custom-ipsec`
         */
        ikeProposals?: outputs.org.DeviceprofileGatewayTunnelConfigsIkeProposal[];
        /**
         * if `provider`== `custom-ipsec`
         */
        ipsecLifetime?: number;
        /**
         * Only if  `provider`== `custom-ipsec`
         */
        ipsecProposals?: outputs.org.DeviceprofileGatewayTunnelConfigsIpsecProposal[];
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        localId?: string;
        /**
         * enum: `active-active`, `active-standby`
         */
        mode: string;
        primary?: outputs.org.DeviceprofileGatewayTunnelConfigsPrimary;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        probe?: outputs.org.DeviceprofileGatewayTunnelConfigsProbe;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
         */
        protocol?: string;
        /**
         * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
         */
        provider?: string;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        psk?: string;
        secondary?: outputs.org.DeviceprofileGatewayTunnelConfigsSecondary;
        /**
         * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
         */
        version: string;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvision {
        enable?: boolean;
        latlng?: outputs.org.DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng;
        primary?: outputs.org.DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary;
        /**
         * enum: `APAC`, `Americas`, `EMEA`, `auto`
         */
        region: string;
        secondary?: outputs.org.DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng {
        lat: number;
        lng: number;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary {
        numHosts?: string;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: string[];
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary {
        numHosts?: string;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: string[];
    }

    export interface DeviceprofileGatewayTunnelConfigsIkeProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: string;
        /**
         * enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup: string;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo: string;
    }

    export interface DeviceprofileGatewayTunnelConfigsIpsecProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: string;
        /**
         * Only if `provider`== `custom-ipsec`. enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup: string;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo: string;
    }

    export interface DeviceprofileGatewayTunnelConfigsPrimary {
        hosts?: string[];
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: string[];
        probeIps?: string[];
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: string[];
        wanNames?: string[];
    }

    export interface DeviceprofileGatewayTunnelConfigsProbe {
        /**
         * how often to trigger the probe
         */
        interval?: number;
        /**
         * number of consecutive misses before declaring the tunnel down
         */
        threshold?: number;
        /**
         * time within which to complete the connectivity check
         */
        timeout?: number;
        /**
         * enum: `http`, `icmp`
         */
        type: string;
    }

    export interface DeviceprofileGatewayTunnelConfigsSecondary {
        hosts?: string[];
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: string[];
        probeIps?: string[];
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: string[];
        wanNames?: string[];
    }

    export interface DeviceprofileGatewayTunnelProviderOptions {
        /**
         * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
         */
        jse?: outputs.org.DeviceprofileGatewayTunnelProviderOptionsJse;
        /**
         * for zscaler-ipsec and zscaler-gre
         */
        zscaler?: outputs.org.DeviceprofileGatewayTunnelProviderOptionsZscaler;
    }

    export interface DeviceprofileGatewayTunnelProviderOptionsJse {
        name?: string;
        numUsers?: number;
    }

    export interface DeviceprofileGatewayTunnelProviderOptionsZscaler {
        aupAcceptanceRequired: boolean;
        /**
         * days before AUP is requested again
         */
        aupExpire: number;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy: boolean;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: number;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup: boolean;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution: boolean;
        enforceAuthentication: boolean;
        name?: string;
        /**
         * if `useXff`==`true`
         */
        subLocations?: outputs.org.DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation[];
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: number;
        /**
         * location uses proxy chaining to forward traffic
         */
        useXff?: boolean;
    }

    export interface DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation {
        aupAcceptanceRequired: boolean;
        /**
         * days before AUP is requested again
         */
        aupExpire: number;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy: boolean;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: number;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: boolean;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution: boolean;
        enforceAuthentication: boolean;
        subnets?: string[];
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: number;
    }

    export interface DeviceprofileGatewayVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: boolean;
    }

    export interface DeviceprofileGatewayVrfInstances {
        networks?: string[];
    }

    export interface GatewaytemplateBgpConfig {
        authKey?: string;
        /**
         * when bfdMultiplier is configured alone. Default:
         *   * 1000 if `type`==`external`
         *   * 350 `type`==`internal`
         */
        bfdMinimumInterval: number;
        /**
         * when bfdMinimumIntervalIsConfigured alone
         */
        bfdMultiplier: number;
        communities?: outputs.org.GatewaytemplateBgpConfigCommunity[];
        /**
         * BFD provides faster path failure detection and is enabled by default
         */
        disableBfd: boolean;
        export?: string;
        /**
         * default export policies if no per-neighbor policies defined
         */
        exportPolicy?: string;
        /**
         * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
         * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
         */
        extendedV4Nexthop?: boolean;
        /**
         * `0` means disable
         */
        gracefulRestartTime: number;
        holdTime: number;
        import?: string;
        /**
         * default import policies if no per-neighbor policies defined
         */
        importPolicy?: string;
        localAs?: number;
        neighborAs?: number;
        /**
         * if per-neighbor as is desired. Property key is the neighbor address
         */
        neighbors?: {[key: string]: outputs.org.GatewaytemplateBgpConfigNeighbors};
        /**
         * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
         */
        networks: string[];
        /**
         * by default, we'll re-advertise all learned BGP routers toward overlay
         */
        noReadvertiseToOverlay: boolean;
        /**
         * enum: `external`, `internal`
         */
        type?: string;
        /**
         * network name. enum: `lan`, `vpn`, `wan`
         */
        via: string;
        vpnName?: string;
        /**
         * if `via`==`wan`
         */
        wanName?: string;
    }

    export interface GatewaytemplateBgpConfigCommunity {
        id?: string;
        localPreference?: number;
        vpnName?: string;
    }

    export interface GatewaytemplateBgpConfigNeighbors {
        /**
         * If true, the BGP session to this neighbor will be administratively disabled/shutdown
         */
        disabled: boolean;
        exportPolicy?: string;
        holdTime: number;
        importPolicy?: string;
        /**
         * assuming BGP neighbor is directly connected
         */
        multihopTtl?: number;
        neighborAs?: number;
    }

    export interface GatewaytemplateDhcpdConfig {
        config?: {[key: string]: outputs.org.GatewaytemplateDhcpdConfigConfig};
        /**
         * if set to `true`, enable the DHCP server
         */
        enabled: boolean;
    }

    export interface GatewaytemplateDhcpdConfigConfig {
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: string[];
        /**
         * if `type`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes: string[];
        /**
         * Property key is the MAC Address
         */
        fixedBindings?: {[key: string]: outputs.org.GatewaytemplateDhcpdConfigConfigFixedBindings};
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: string;
        /**
         * if `type`==`local`
         */
        ipEnd?: string;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: string;
        /**
         * if `type`==`local`
         */
        ipStart?: string;
        /**
         * if `type6`==`local`
         */
        ipStart6?: string;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime: number;
        /**
         * Property key is the DHCP option number
         */
        options?: {[key: string]: outputs.org.GatewaytemplateDhcpdConfigConfigOptions};
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride: boolean;
        /**
         * if `type`==`relay`
         */
        servers: string[];
        /**
         * if `type6`==`relay`
         */
        servers6s: string[];
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type: string;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6: string;
        /**
         * Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapulated?: {[key: string]: outputs.org.GatewaytemplateDhcpdConfigConfigVendorEncapulated};
    }

    export interface GatewaytemplateDhcpdConfigConfigFixedBindings {
        ip: string;
        name?: string;
    }

    export interface GatewaytemplateDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface GatewaytemplateDhcpdConfigConfigVendorEncapulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: string;
        value?: string;
    }

    export interface GatewaytemplateExtraRoutes {
        via: string;
    }

    export interface GatewaytemplateExtraRoutes6 {
        via: string;
    }

    export interface GatewaytemplateIdpProfiles {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile?: string;
        name?: string;
        orgId?: string;
        overwrites?: outputs.org.GatewaytemplateIdpProfilesOverwrite[];
    }

    export interface GatewaytemplateIdpProfilesOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action: string;
        matching?: outputs.org.GatewaytemplateIdpProfilesOverwriteMatching;
        name?: string;
    }

    export interface GatewaytemplateIdpProfilesOverwriteMatching {
        attackNames?: string[];
        dstSubnets?: string[];
        severities?: string[];
    }

    export interface GatewaytemplateIpConfigs {
        ip: string;
        netmask: string;
        /**
         * optional list of secondary IPs in CIDR format
         */
        secondaryIps: string[];
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
    }

    export interface GatewaytemplateNetwork {
        /**
         * whether to disallow Mist Devices in the network
         */
        disallowMistServices: boolean;
        gateway?: string;
        gateway6?: string;
        internalAccess?: outputs.org.GatewaytemplateNetworkInternalAccess;
        /**
         * whether this network has direct internet access
         */
        internetAccess?: outputs.org.GatewaytemplateNetworkInternetAccess;
        /**
         * whether to allow clients in the network to talk to each other
         */
        isolation?: boolean;
        name: string;
        /**
         * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
         */
        routedForNetworks?: string[];
        subnet: string;
        subnet6?: string;
        tenants?: {[key: string]: outputs.org.GatewaytemplateNetworkTenants};
        vlanId?: string;
        /**
         * Property key is the VPN name. Whether this network can be accessed from vpn
         */
        vpnAccess?: {[key: string]: outputs.org.GatewaytemplateNetworkVpnAccess};
    }

    export interface GatewaytemplateNetworkInternalAccess {
        enabled?: boolean;
    }

    export interface GatewaytemplateNetworkInternetAccess {
        createSimpleServicePolicy: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: {[key: string]: outputs.org.GatewaytemplateNetworkInternetAccessDestinationNat};
        enabled?: boolean;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted: boolean;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: {[key: string]: outputs.org.GatewaytemplateNetworkInternetAccessStaticNat};
    }

    export interface GatewaytemplateNetworkInternetAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface GatewaytemplateNetworkInternetAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface GatewaytemplateNetworkTenants {
        addresses?: string[];
    }

    export interface GatewaytemplateNetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: string;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat: {[key: string]: outputs.org.GatewaytemplateNetworkVpnAccessDestinationNat};
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: string;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp: boolean;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf: boolean;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: boolean;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs: string[];
        /**
         * whether this network is routable
         */
        routed?: boolean;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat: outputs.org.GatewaytemplateNetworkVpnAccessSourceNat;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat: {[key: string]: outputs.org.GatewaytemplateNetworkVpnAccessStaticNat};
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: string;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: string;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: string;
    }

    export interface GatewaytemplateNetworkVpnAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface GatewaytemplateNetworkVpnAccessSourceNat {
        externalIp?: string;
    }

    export interface GatewaytemplateNetworkVpnAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface GatewaytemplateOobIpConfig {
        /**
         * if `type`==`static`
         */
        gateway?: string;
        /**
         * if `type`==`static`
         */
        ip?: string;
        /**
         * if `type`==`static`
         */
        netmask?: string;
        /**
         * for HA Cluster, node1 can have different IP Config
         */
        node1?: outputs.org.GatewaytemplateOobIpConfigNode1;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
         */
        useMgmtVrfForHostOut: boolean;
        vlanId?: string;
    }

    export interface GatewaytemplateOobIpConfigNode1 {
        /**
         * if `type`==`static`
         */
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * enum: `dhcp`, `static`
         */
        type: string;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf: boolean;
        /**
         * whether to use `mgmtJunos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut: boolean;
        vlanId?: string;
    }

    export interface GatewaytemplatePathPreferences {
        paths?: outputs.org.GatewaytemplatePathPreferencesPath[];
        /**
         * enum: `ecmp`, `ordered`, `weighted`
         */
        strategy: string;
    }

    export interface GatewaytemplatePathPreferencesPath {
        cost?: number;
        /**
         * For SSR Only. `true`, if this specific path is undesired
         */
        disabled?: boolean;
        /**
         * only if `type`==`local`, if a different gateway is desired
         */
        gatewayIp?: string;
        /**
         * only if `type`==`vpn`, if this vpn path can be used for internet
         */
        internetAccess?: boolean;
        /**
         * required when 
         *   * `type`==`vpn`: the name of the VPN Path to use 
         *   * `type`==`wan`: the name of the WAN interface to use'
         */
        name?: string;
        /**
         * required when `type`==`local`
         */
        networks: string[];
        /**
         * if `type`==`local`, if destination IP is to be replaced
         */
        targetIps: string[];
        /**
         * enum: `local`, `tunnel`, `vpn`, `wan`
         */
        type?: string;
        /**
         * required when`type`==`tunnel`
         */
        wanName?: string;
    }

    export interface GatewaytemplatePortConfig {
        description?: string;
        disableAutoneg: boolean;
        /**
         * port admin up (true) / down (false)
         */
        disabled: boolean;
        /**
         * if `wanType`==`lte`. enum: `adsl`, `vdsl`
         */
        dslType: string;
        /**
         * if `wanType`==`dsl`
         * 16 bit int
         */
        dslVci: number;
        /**
         * if `wanType`==`dsl`
         * 8 bit int
         */
        dslVpi: number;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Junos IP Config
         */
        ipConfig?: outputs.org.GatewaytemplatePortConfigIpConfig;
        /**
         * if `wanType`==`lte`
         */
        lteApn?: string;
        /**
         * if `wanType`==`lte`. enum: `chap`, `none`, `pap`
         */
        lteAuth: string;
        lteBackup?: boolean;
        /**
         * if `wanType`==`lte`
         */
        ltePassword?: string;
        /**
         * if `wanType`==`lte`
         */
        lteUsername?: string;
        mtu?: number;
        /**
         * name that we'll use to derive config
         */
        name?: string;
        /**
         * if `usage`==`lan`
         */
        networks: string[];
        /**
         * for Q-in-Q
         */
        outerVlanId?: number;
        poeDisabled: boolean;
        /**
         * if `usage`==`lan`
         */
        portNetwork?: string;
        /**
         * whether to preserve dscp when sending traffic over VPN (SSR-only)
         */
        preserveDscp: boolean;
        /**
         * if HA mode
         */
        redundant?: boolean;
        /**
         * if HA mode
         */
        rethIdx?: number;
        /**
         * if HA mode
         */
        rethNode?: string;
        /**
         * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
         */
        rethNodes: string[];
        speed: string;
        /**
         * when SSR is running as VM, this is required on certain hosting platforms
         */
        ssrNoVirtualMac: boolean;
        /**
         * for SSR only
         */
        svrPortRange: string;
        trafficShaping?: outputs.org.GatewaytemplatePortConfigTrafficShaping;
        /**
         * port usage name. enum: `haControl`, `haData`, `lan`, `wan`
         */
        usage: string;
        /**
         * if WAN interface is on a VLAN
         */
        vlanId?: number;
        vpnPaths?: {[key: string]: outputs.org.GatewaytemplatePortConfigVpnPaths};
        /**
         * when `wanType`==`broadband`. enum: `default`, `max`, `recommended`
         */
        wanArpPolicer: string;
        /**
         * optional, if spoke should reach this port by a different IP
         */
        wanExtIp?: string;
        /**
         * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
         */
        wanSourceNat?: outputs.org.GatewaytemplatePortConfigWanSourceNat;
        /**
         * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
         */
        wanType: string;
    }

    export interface GatewaytemplatePortConfigIpConfig {
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dns?: string[];
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dnsSuffixes?: string[];
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        gateway?: string;
        ip?: string;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: string;
        /**
         * optional, the network to be used for mgmt
         */
        network?: string;
        /**
         * if `type`==`pppoe`
         */
        poserPassword?: string;
        /**
         * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
         */
        pppoeAuth: string;
        /**
         * if `type`==`pppoe`
         */
        pppoeUsername?: string;
        /**
         * enum: `dhcp`, `pppoe`, `static`
         */
        type: string;
    }

    export interface GatewaytemplatePortConfigTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: number[];
        enabled: boolean;
    }

    export interface GatewaytemplatePortConfigVpnPaths {
        /**
         * enum: `broadband`, `lte`
         */
        bfdProfile: string;
        /**
         * whether to use tunnel mode. SSR only
         */
        bfdUseTunnelMode: boolean;
        /**
         * for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
         */
        preference?: number;
        /**
         * enum: `hub`, `spoke`
         */
        role: string;
        trafficShaping?: outputs.org.GatewaytemplatePortConfigVpnPathsTrafficShaping;
    }

    export interface GatewaytemplatePortConfigVpnPathsTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: number[];
        enabled: boolean;
    }

    export interface GatewaytemplatePortConfigWanSourceNat {
        /**
         * or to disable the source-nat
         */
        disabled: boolean;
        /**
         * if alternative natPool is desired
         */
        natPool?: string;
    }

    export interface GatewaytemplateRoutingPolicies {
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        terms?: outputs.org.GatewaytemplateRoutingPoliciesTerm[];
    }

    export interface GatewaytemplateRoutingPoliciesTerm {
        /**
         * when used as import policy
         */
        action?: outputs.org.GatewaytemplateRoutingPoliciesTermAction;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        matching?: outputs.org.GatewaytemplateRoutingPoliciesTermMatching;
    }

    export interface GatewaytemplateRoutingPoliciesTermAction {
        accept?: boolean;
        addCommunities?: string[];
        /**
         * for SSR, hub decides how VRF routes are leaked on spoke
         */
        addTargetVrfs?: string[];
        /**
         * when used as export policy, optional
         */
        communities?: string[];
        /**
         * when used as export policy, optional. To exclude certain AS
         */
        excludeAsPaths?: string[];
        excludeCommunities?: string[];
        /**
         * when used as export policy, optional
         */
        exportCommunitites?: string[];
        /**
         * optional, for an import policy, localPreference can be changed
         */
        localPreference?: string;
        /**
         * when used as export policy, optional. By default, the local AS will be prepended, to change it
         */
        prependAsPaths?: string[];
    }

    export interface GatewaytemplateRoutingPoliciesTermMatching {
        /**
         * takes regular expression
         */
        asPaths?: string[];
        communities?: string[];
        networks?: string[];
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        prefixes?: string[];
        /**
         * `direct`, `bgp`, `osp`, ...
         */
        protocols?: string[];
        routeExists?: outputs.org.GatewaytemplateRoutingPoliciesTermMatchingRouteExists;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         */
        vpnNeighborMacs?: string[];
        vpnPathSla?: outputs.org.GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         * ordered-
         */
        vpnPaths?: string[];
    }

    export interface GatewaytemplateRoutingPoliciesTermMatchingRouteExists {
        route?: string;
        /**
         * name of the vrf instance
         * it can also be the name of the VPN or wan if they
         */
        vrfName: string;
    }

    export interface GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla {
        maxJitter?: number;
        maxLatency?: number;
        maxLoss?: number;
    }

    export interface GatewaytemplateServicePolicy {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        /**
         * For SRX Only
         */
        appqoe?: outputs.org.GatewaytemplateServicePolicyAppqoe;
        ewfs?: outputs.org.GatewaytemplateServicePolicyEwf[];
        idp?: outputs.org.GatewaytemplateServicePolicyIdp;
        /**
         * access within the same VRF
         */
        localRouting: boolean;
        name?: string;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference?: string;
        /**
         * used to link servicepolicy defined at org level and overwrite some attributes
         */
        servicepolicyId?: string;
        services: string[];
        tenants: string[];
    }

    export interface GatewaytemplateServicePolicyAppqoe {
        enabled: boolean;
    }

    export interface GatewaytemplateServicePolicyEwf {
        alertOnly?: boolean;
        blockMessage?: string;
        enabled: boolean;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile: string;
    }

    export interface GatewaytemplateServicePolicyIdp {
        alertOnly?: boolean;
        enabled: boolean;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: string;
        /**
         * `strict` (default) / `standard` / or keys from from idp_profiles
         */
        profile: string;
    }

    export interface GatewaytemplateTunnelConfigs {
        autoProvision?: outputs.org.GatewaytemplateTunnelConfigsAutoProvision;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        ikeLifetime?: number;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
         */
        ikeMode: string;
        /**
         * if `provider`== `custom-ipsec`
         */
        ikeProposals?: outputs.org.GatewaytemplateTunnelConfigsIkeProposal[];
        /**
         * if `provider`== `custom-ipsec`
         */
        ipsecLifetime?: number;
        /**
         * Only if  `provider`== `custom-ipsec`
         */
        ipsecProposals?: outputs.org.GatewaytemplateTunnelConfigsIpsecProposal[];
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        localId?: string;
        /**
         * enum: `active-active`, `active-standby`
         */
        mode: string;
        primary?: outputs.org.GatewaytemplateTunnelConfigsPrimary;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        probe?: outputs.org.GatewaytemplateTunnelConfigsProbe;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
         */
        protocol?: string;
        /**
         * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
         */
        provider?: string;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        psk?: string;
        secondary?: outputs.org.GatewaytemplateTunnelConfigsSecondary;
        /**
         * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
         */
        version: string;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvision {
        enable?: boolean;
        latlng?: outputs.org.GatewaytemplateTunnelConfigsAutoProvisionLatlng;
        primary?: outputs.org.GatewaytemplateTunnelConfigsAutoProvisionPrimary;
        /**
         * enum: `APAC`, `Americas`, `EMEA`, `auto`
         */
        region: string;
        secondary?: outputs.org.GatewaytemplateTunnelConfigsAutoProvisionSecondary;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvisionLatlng {
        lat: number;
        lng: number;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvisionPrimary {
        numHosts?: string;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: string[];
    }

    export interface GatewaytemplateTunnelConfigsAutoProvisionSecondary {
        numHosts?: string;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: string[];
    }

    export interface GatewaytemplateTunnelConfigsIkeProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: string;
        /**
         * enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup: string;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo: string;
    }

    export interface GatewaytemplateTunnelConfigsIpsecProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: string;
        /**
         * Only if `provider`== `custom-ipsec`. enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup: string;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo: string;
    }

    export interface GatewaytemplateTunnelConfigsPrimary {
        hosts?: string[];
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: string[];
        probeIps?: string[];
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: string[];
        wanNames?: string[];
    }

    export interface GatewaytemplateTunnelConfigsProbe {
        /**
         * how often to trigger the probe
         */
        interval?: number;
        /**
         * number of consecutive misses before declaring the tunnel down
         */
        threshold?: number;
        /**
         * time within which to complete the connectivity check
         */
        timeout?: number;
        /**
         * enum: `http`, `icmp`
         */
        type: string;
    }

    export interface GatewaytemplateTunnelConfigsSecondary {
        hosts?: string[];
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: string[];
        probeIps?: string[];
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: string[];
        wanNames?: string[];
    }

    export interface GatewaytemplateTunnelProviderOptions {
        /**
         * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
         */
        jse?: outputs.org.GatewaytemplateTunnelProviderOptionsJse;
        /**
         * for zscaler-ipsec and zscaler-gre
         */
        zscaler?: outputs.org.GatewaytemplateTunnelProviderOptionsZscaler;
    }

    export interface GatewaytemplateTunnelProviderOptionsJse {
        name?: string;
        numUsers?: number;
    }

    export interface GatewaytemplateTunnelProviderOptionsZscaler {
        aupAcceptanceRequired: boolean;
        /**
         * days before AUP is requested again
         */
        aupExpire: number;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy: boolean;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: number;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup: boolean;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution: boolean;
        enforceAuthentication: boolean;
        name?: string;
        /**
         * if `useXff`==`true`
         */
        subLocations?: outputs.org.GatewaytemplateTunnelProviderOptionsZscalerSubLocation[];
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: number;
        /**
         * location uses proxy chaining to forward traffic
         */
        useXff?: boolean;
    }

    export interface GatewaytemplateTunnelProviderOptionsZscalerSubLocation {
        aupAcceptanceRequired: boolean;
        /**
         * days before AUP is requested again
         */
        aupExpire: number;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy: boolean;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: number;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: boolean;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution: boolean;
        enforceAuthentication: boolean;
        subnets?: string[];
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: number;
    }

    export interface GatewaytemplateVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: boolean;
    }

    export interface GatewaytemplateVrfInstances {
        networks?: string[];
    }

    export interface GetDeviceprofilesApDeviceprofile {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetDeviceprofilesGatewayDeviceprofile {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetGatewaytemplatesOrgGatewaytemplate {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetIdpprofilesOrgIdpprofile {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile: string;
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
        overwrites: outputs.org.GetIdpprofilesOrgIdpprofileOverwrite[];
    }

    export interface GetIdpprofilesOrgIdpprofileOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action: string;
        matching: outputs.org.GetIdpprofilesOrgIdpprofileOverwriteMatching;
        name: string;
    }

    export interface GetIdpprofilesOrgIdpprofileOverwriteMatching {
        attackNames: string[];
        dstSubnets: string[];
        severities: string[];
    }

    export interface GetInventoryOrgInventory {
        /**
         * only if `type`==`switch` or `type`==`gateway`
         * whether the switch/gateway is adopted
         */
        adopted: boolean;
        /**
         * device claim code
         */
        claimCode: string;
        /**
         * whether the device is connected
         */
        connected: boolean;
        /**
         * inventory created time, in epoch
         */
        createdTime: number;
        /**
         * deviceprofile id if assigned, null if not assigned
         */
        deviceprofileId: string;
        /**
         * hostname reported by the device
         */
        hostname: string;
        /**
         * device hardware revision number
         */
        hwRev: string;
        /**
         * device id
         */
        id: string;
        jsi: boolean;
        /**
         * device MAC address
         */
        mac: string;
        /**
         * device model
         */
        model: string;
        /**
         * inventory last modified time, in epoch
         */
        modifiedTime: number;
        /**
         * device name if configured
         */
        name: string;
        orgId: string;
        /**
         * device serial
         */
        serial: string;
        siteId: string;
        /**
         * device stock keeping unit
         */
        sku: string;
        /**
         * only if `type`==`switch`, MAC Address of the Virtual Chassis
         */
        vcMac: string;
    }

    export interface GetNacrulesOrgNacrule {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetNactagsOrgNactag {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetNetworksOrgNetwork {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetNetworktemplatesOrgNetworktemplate {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetRftemplatesOrgRftemplate {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetServicepoliciesOrgServicepolicy {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        /**
         * For SRX Only
         */
        appqoe: outputs.org.GetServicepoliciesOrgServicepolicyAppqoe;
        createdTime: number;
        ewfs: outputs.org.GetServicepoliciesOrgServicepolicyEwf[];
        id: string;
        idp: outputs.org.GetServicepoliciesOrgServicepolicyIdp;
        /**
         * access within the same VRF
         */
        localRouting: boolean;
        modifiedTime: number;
        name: string;
        orgId: string;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference: string;
        services: string[];
        tenants: string[];
    }

    export interface GetServicepoliciesOrgServicepolicyAppqoe {
        enabled: boolean;
    }

    export interface GetServicepoliciesOrgServicepolicyEwf {
        alertOnly: boolean;
        blockMessage: string;
        enabled: boolean;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile: string;
    }

    export interface GetServicepoliciesOrgServicepolicyIdp {
        alertOnly: boolean;
        enabled: boolean;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId: string;
        /**
         * `strict` (default) / `standard` / or keys from from idp_profiles
         */
        profile: string;
    }

    export interface GetServicesOrgService {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetSitegroupsOrgSitegroup {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
        siteIds: string[];
    }

    export interface GetVpnsOrgVpn {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
        paths: {[key: string]: outputs.org.GetVpnsOrgVpnPaths};
    }

    export interface GetVpnsOrgVpnPaths {
        /**
         * enum: `broadband`, `lte`
         */
        bfdProfile: string;
        /**
         * if different from the wan port
         */
        ip: string;
        pod: number;
    }

    export interface GetWlantemplatesOrgWlantemplate {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface GetWxtagsOrgWxtag {
        createdTime: number;
        id: string;
        modifiedTime: number;
        name: string;
        orgId: string;
    }

    export interface IdpprofileOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action: string;
        matching?: outputs.org.IdpprofileOverwriteMatching;
        name: string;
    }

    export interface IdpprofileOverwriteMatching {
        attackNames?: string[];
        dstSubnets?: string[];
        severities?: string[];
    }

    export interface InventoryDevice {
        claimCode: string;
        /**
         * Device Hostname
         */
        hostname: string;
        /**
         * Mist Device ID
         */
        id: string;
        /**
         * MAC address
         */
        mac: string;
        /**
         * device model
         */
        model: string;
        orgId: string;
        /**
         * device serial
         */
        serial: string;
        /**
         * site id if assigned, null if not assigned
         */
        siteId: string;
        type: string;
        /**
         * Virtual Chassis MAC Address
         */
        vcMac: string;
    }

    export interface NacruleMatching {
        /**
         * enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `psk`
         */
        authType?: string;
        nactags: string[];
        portTypes: string[];
        /**
         * list of site ids to match
         */
        siteIds: string[];
        /**
         * list of sitegroup ids to match
         */
        sitegroupIds: string[];
        /**
         * list of vendors to match
         */
        vendors: string[];
    }

    export interface NacruleNotMatching {
        /**
         * enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `psk`
         */
        authType?: string;
        nactags: string[];
        portTypes: string[];
        /**
         * list of site ids to match
         */
        siteIds: string[];
        /**
         * list of sitegroup ids to match
         */
        sitegroupIds: string[];
        /**
         * list of vendors to match
         */
        vendors: string[];
    }

    export interface NetworkInternalAccess {
        enabled?: boolean;
    }

    export interface NetworkInternetAccess {
        createSimpleServicePolicy: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: {[key: string]: outputs.org.NetworkInternetAccessDestinationNat};
        enabled?: boolean;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted: boolean;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: {[key: string]: outputs.org.NetworkInternetAccessStaticNat};
    }

    export interface NetworkInternetAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface NetworkInternetAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface NetworkTenants {
        addresses?: string[];
    }

    export interface NetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: string;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: boolean;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat: {[key: string]: outputs.org.NetworkVpnAccessDestinationNat};
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: string;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp: boolean;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf: boolean;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: boolean;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs: string[];
        /**
         * whether this network is routable
         */
        routed?: boolean;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat: outputs.org.NetworkVpnAccessSourceNat;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat: {[key: string]: outputs.org.NetworkVpnAccessStaticNat};
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: string;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: string;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: string;
    }

    export interface NetworkVpnAccessDestinationNat {
        internalIp?: string;
        name?: string;
        port?: number;
    }

    export interface NetworkVpnAccessSourceNat {
        externalIp?: string;
    }

    export interface NetworkVpnAccessStaticNat {
        internalIp?: string;
        name?: string;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: string;
    }

    export interface NetworktemplateAclPolicy {
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        actions?: outputs.org.NetworktemplateAclPolicyAction[];
        name?: string;
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        srcTags?: string[];
    }

    export interface NetworktemplateAclPolicyAction {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        dstTag?: string;
    }

    export interface NetworktemplateAclTags {
        /**
         * required if
         * - `type`==`dynamicGbp` (gbp_tag received from RADIUS)
         * - `type`==`staticGbp` (applying gbp tag against matching conditions)
         */
        gbpTag?: number;
        /**
         * required if 
         * - `type`==`mac`
         * - `type`==`staticGbp` if from matching mac
         */
        macs?: string[];
        /**
         * if:
         *   * `type`==`mac` (optional. default is `any`)
         *   * `type`==`subnet` (optional. default is `any`)
         *   * `type`==`network`
         *   * `type`==`resource` (optional. default is `any`)
         *   * `type`==`staticGbp` if from matching network (vlan)'
         */
        network?: string;
        /**
         * required if:
         *   * `type`==`radiusGroup`
         *   * `type`==`staticGbp`
         * if from matching radius_group
         */
        radiusGroup?: string;
        /**
         * if `type`==`resource`
         * empty means unrestricted, i.e. any
         */
        specs?: outputs.org.NetworktemplateAclTagsSpec[];
        /**
         * if 
         * - `type`==`subnet` 
         * - `type`==`resource` (optional. default is `any`)
         * - `type`==`staticGbp` if from matching subnet
         */
        subnets?: string[];
        /**
         * enum: `any`, `dynamicGbp`, `mac`, `network`, `radiusGroup`, `resource`, `staticGbp`, `subnet`
         */
        type: string;
    }

    export interface NetworktemplateAclTagsSpec {
        /**
         * matched dst port, "0" means any
         */
        portRange: string;
        /**
         * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocolNumber` is between 1-254
         */
        protocol: string;
    }

    export interface NetworktemplateDhcpSnooping {
        allNetworks?: boolean;
        /**
         * Enable for dynamic ARP inspection check
         */
        enableArpSpoofCheck?: boolean;
        /**
         * Enable for check for forging source IP address
         */
        enableIpSourceGuard?: boolean;
        enabled?: boolean;
        /**
         * if `allNetworks`==`false`, list of network with DHCP snooping enabled
         */
        networks?: string[];
    }

    export interface NetworktemplateExtraRoutes {
        /**
         * this takes precedence
         */
        discard: boolean;
        metric?: number;
        nextQualified?: {[key: string]: outputs.org.NetworktemplateExtraRoutesNextQualified};
        noResolve: boolean;
        preference?: number;
        /**
         * next-hop IP Address
         */
        via: string;
    }

    export interface NetworktemplateExtraRoutes6 {
        /**
         * this takes precedence
         */
        discard: boolean;
        metric?: number;
        nextQualified?: {[key: string]: outputs.org.NetworktemplateExtraRoutes6NextQualified};
        noResolve: boolean;
        preference?: number;
        /**
         * next-hop IP Address
         */
        via: string;
    }

    export interface NetworktemplateExtraRoutes6NextQualified {
        metric?: number;
        preference?: number;
    }

    export interface NetworktemplateExtraRoutesNextQualified {
        metric?: number;
        preference?: number;
    }

    export interface NetworktemplateMistNac {
        enabled?: boolean;
        network?: string;
    }

    export interface NetworktemplateNetworks {
        /**
         * whether to stop clients to talk to each other, default is false (when enabled, a unique isolationVlanId is required)
         * NOTE: this features requires uplink device to also a be Juniper device and `interSwitchLink` to be set
         */
        isolation: boolean;
        isolationVlanId?: string;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet?: string;
        vlanId: string;
    }

    export interface NetworktemplatePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses: string[];
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: string;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: string;
    }

    export interface NetworktemplatePortUsages {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks: boolean;
        /**
         * Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         *
         * When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        allowMultipleSupplicants: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        description?: string;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg: boolean;
        /**
         * Only if `mode`!=`dynamic` whether the port is disabled
         */
        disabled: boolean;
        /**
         * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks: string[];
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        enableQos: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: string;
        /**
         * Only if `mode`!=`dynamic` interSwitchLink is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink: boolean;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         */
        macAuthOnly?: boolean;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol: string;
        /**
         * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit: number;
        /**
         * `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         */
        mode?: string;
        /**
         * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: number;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks: string[];
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac: boolean;
        /**
         * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         */
        poeDisabled: boolean;
        /**
         * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: string;
        /**
         * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         */
        portNetwork?: string;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval: number;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` when radius server reject / fails
         */
        rejectedNetwork?: string;
        /**
         * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         */
        resetDefaultWhen: string;
        /**
         * Only if `mode`==`dynamic`
         */
        rules?: outputs.org.NetworktemplatePortUsagesRule[];
        /**
         * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
         */
        speed?: string;
        /**
         * Switch storm control
         * Only if `mode`!=`dynamic`
         */
        stormControl?: outputs.org.NetworktemplatePortUsagesStormControl;
        /**
         * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge: boolean;
        /**
         * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: string;
    }

    export interface NetworktemplatePortUsagesRule {
        equals?: string;
        /**
         * use `equalsAny` to match any item in a list
         */
        equalsAnies?: string[];
        /**
         * "[0:3]":"abcdef" > "abc"
         * "split(.)[1]": "a.b.c" > "b"
         * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
         */
        expression?: string;
        /**
         * enum: `linkPeermac`, `lldpChassisId`, `lldpHardwareRevision`, `lldpManufacturerName`, `lldpOui`, `lldpSerialNumber`, `lldpSystemName`, `radiusDynamicfilter`, `radiusUsermac`, `radiusUsername`
         */
        src: string;
        /**
         * `portUsage` name
         */
        usage?: string;
    }

    export interface NetworktemplatePortUsagesStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast: boolean;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast: boolean;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast: boolean;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast: boolean;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage: number;
    }

    export interface NetworktemplateRadiusConfig {
        /**
         * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
         */
        acctInterimInterval: number;
        acctServers?: outputs.org.NetworktemplateRadiusConfigAcctServer[];
        authServers?: outputs.org.NetworktemplateRadiusConfigAuthServer[];
        /**
         * radius auth session retries
         */
        authServersRetries: number;
        /**
         * radius auth session timeout
         */
        authServersTimeout: number;
        coaEnabled: boolean;
        coaPort: number;
        /**
         * use `network`or `sourceIp`
         * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
         */
        network?: string;
        /**
         * use `network`or `sourceIp`
         */
        sourceIp?: string;
    }

    export interface NetworktemplateRadiusConfigAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Acct port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface NetworktemplateRadiusConfigAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Auth port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface NetworktemplateRemoteSyslog {
        archive?: outputs.org.NetworktemplateRemoteSyslogArchive;
        console?: outputs.org.NetworktemplateRemoteSyslogConsole;
        enabled: boolean;
        files?: outputs.org.NetworktemplateRemoteSyslogFile[];
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        network?: string;
        sendToAllServers: boolean;
        servers?: outputs.org.NetworktemplateRemoteSyslogServer[];
        /**
         * enum: `millisecond`, `year`, `year millisecond`
         */
        timeFormat?: string;
        users?: outputs.org.NetworktemplateRemoteSyslogUser[];
    }

    export interface NetworktemplateRemoteSyslogArchive {
        files?: number;
        size?: string;
    }

    export interface NetworktemplateRemoteSyslogConsole {
        contents?: outputs.org.NetworktemplateRemoteSyslogConsoleContent[];
    }

    export interface NetworktemplateRemoteSyslogConsoleContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateRemoteSyslogFile {
        archive?: outputs.org.NetworktemplateRemoteSyslogFileArchive;
        contents?: outputs.org.NetworktemplateRemoteSyslogFileContent[];
        explicitPriority?: boolean;
        file?: string;
        match?: string;
        structuredData?: boolean;
    }

    export interface NetworktemplateRemoteSyslogFileArchive {
        files?: number;
        size?: string;
    }

    export interface NetworktemplateRemoteSyslogFileContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateRemoteSyslogServer {
        contents?: outputs.org.NetworktemplateRemoteSyslogServerContent[];
        explicitPriority?: boolean;
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        host?: string;
        match?: string;
        port: number;
        /**
         * enum: `tcp`, `udp`
         */
        protocol: string;
        routingInstance?: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        sourceAddress?: string;
        structuredData?: boolean;
        tag?: string;
    }

    export interface NetworktemplateRemoteSyslogServerContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateRemoteSyslogUser {
        contents?: outputs.org.NetworktemplateRemoteSyslogUserContent[];
        match?: string;
        user?: string;
    }

    export interface NetworktemplateRemoteSyslogUserContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateSnmpConfig {
        clientLists?: outputs.org.NetworktemplateSnmpConfigClientList[];
        contact?: string;
        description?: string;
        enabled: boolean;
        /**
         * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
         */
        engineId?: string;
        location?: string;
        name?: string;
        network: string;
        trapGroups?: outputs.org.NetworktemplateSnmpConfigTrapGroup[];
        v2cConfigs?: outputs.org.NetworktemplateSnmpConfigV2cConfig[];
        v3Config?: outputs.org.NetworktemplateSnmpConfigV3Config;
        views?: outputs.org.NetworktemplateSnmpConfigView[];
    }

    export interface NetworktemplateSnmpConfigClientList {
        clientListName?: string;
        clients?: string[];
    }

    export interface NetworktemplateSnmpConfigTrapGroup {
        categories?: string[];
        /**
         * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
         */
        groupName?: string;
        targets?: string[];
        /**
         * enum: `all`, `v1`, `v2`
         */
        version: string;
    }

    export interface NetworktemplateSnmpConfigV2cConfig {
        authorization?: string;
        /**
         * client_list_name here should refer to clientList above
         */
        clientListName?: string;
        communityName?: string;
        /**
         * view name here should be defined in views above
         */
        view?: string;
    }

    export interface NetworktemplateSnmpConfigV3Config {
        notifies?: outputs.org.NetworktemplateSnmpConfigV3ConfigNotify[];
        notifyFilters?: outputs.org.NetworktemplateSnmpConfigV3ConfigNotifyFilter[];
        targetAddresses?: outputs.org.NetworktemplateSnmpConfigV3ConfigTargetAddress[];
        targetParameters?: outputs.org.NetworktemplateSnmpConfigV3ConfigTargetParameter[];
        usm?: outputs.org.NetworktemplateSnmpConfigV3ConfigUsm;
        vacm?: outputs.org.NetworktemplateSnmpConfigV3ConfigVacm;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotify {
        name?: string;
        tag?: string;
        /**
         * enum: `inform`, `trap`
         */
        type?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilter {
        contents?: outputs.org.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent[];
        profileName?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilterContent {
        include?: boolean;
        oid?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetAddress {
        address?: string;
        addressMask?: string;
        port: number;
        /**
         * <refer to notify tag, can be multiple with blank
         */
        tagList?: string;
        targetAddressName?: string;
        /**
         * refer to notify target parameters name
         */
        targetParameters?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetParameter {
        /**
         * enum: `v1`, `v2c`, `v3`
         */
        messageProcessingModel?: string;
        name?: string;
        /**
         * refer to profile-name in notify_filter
         */
        notifyFilter?: string;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: string;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: string;
        /**
         * refer to securityName in usm
         */
        securityName?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsm {
        /**
         * enum: `localEngine`, `remoteEngine`
         */
        engineType?: string;
        /**
         * required only if `engineType`==`remoteEngine`
         */
        engineid?: string;
        users?: outputs.org.NetworktemplateSnmpConfigV3ConfigUsmUser[];
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsmUser {
        /**
         * Not required if `authenticationType`==`authenticationNone`
         * include alphabetic, numeric, and special characters, but it cannot include control characters.
         */
        authenticationPassword?: string;
        /**
         * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authenticationMd5`, `authenticationNone`, `authenticationSha`, `authenticationSha224`, `authenticationSha256`, `authenticationSha384`, `authenticationSha512`
         */
        authenticationType?: string;
        /**
         * Not required if `encryptionType`==`privacy-none`
         * include alphabetic, numeric, and special characters, but it cannot include control characters
         */
        encryptionPassword?: string;
        /**
         * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
         */
        encryptionType?: string;
        name?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacm {
        accesses?: outputs.org.NetworktemplateSnmpConfigV3ConfigVacmAccess[];
        securityToGroup?: outputs.org.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccess {
        groupName?: string;
        prefixLists?: outputs.org.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList[];
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList {
        /**
         * only required if `type`==`contextPrefix`
         */
        contextPrefix?: string;
        /**
         * refer to view name
         */
        notifyView?: string;
        /**
         * refer to view name
         */
        readView?: string;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: string;
        /**
         * enum: `any`, `usm`, `v1`, `v2c`
         */
        securityModel?: string;
        /**
         * enum: `contextPrefix`, `defaultContextPrefix`
         */
        type?: string;
        /**
         * refer to view name
         */
        writeView?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup {
        contents?: outputs.org.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent[];
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent {
        /**
         * refer to groupName under access
         */
        group?: string;
        securityName?: string;
    }

    export interface NetworktemplateSnmpConfigView {
        /**
         * if the root oid configured is included
         */
        include?: boolean;
        oid?: string;
        viewName?: string;
    }

    export interface NetworktemplateSwitchMatching {
        enable?: boolean;
        rules?: outputs.org.NetworktemplateSwitchMatchingRule[];
    }

    export interface NetworktemplateSwitchMatchingRule {
        /**
         * additional CLI commands to append to the generated Junos config
         *
         * **Note**: no check is done
         */
        additionalConfigCmds?: string[];
        /**
         * role to match
         */
        matchRole?: string;
        /**
         * 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `matchModel`,  `match_model[0-6]`
         */
        matchType?: string;
        matchValue?: string;
        name?: string;
        /**
         * Propery key is the interface name or interface range
         */
        portConfig?: {[key: string]: outputs.org.NetworktemplateSwitchMatchingRulePortConfig};
        /**
         * Property key is the port mirroring instance name
         * portMirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
         */
        portMirroring?: {[key: string]: outputs.org.NetworktemplateSwitchMatchingRulePortMirroring};
    }

    export interface NetworktemplateSwitchMatchingRulePortConfig {
        /**
         * To disable LACP support for the AE interface
         */
        aeDisableLacp?: boolean;
        /**
         * Users could force to use the designated AE name
         */
        aeIdx?: number;
        /**
         * to use fast timeout
         */
        aeLacpSlow: boolean;
        aggregated: boolean;
        /**
         * if want to generate port up/down alarm
         */
        critical?: boolean;
        description?: string;
        /**
         * if `speed` and `duplex` are specified, whether to disable autonegotiation
         */
        disableAutoneg: boolean;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Enable dynamic usage for this port. Set to `dynamic` to enable.
         */
        dynamicUsage?: string;
        esilag?: boolean;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
         */
        mtu: number;
        /**
         * prevent helpdesk to override the port config
         */
        noLocalOverwrite?: boolean;
        poeDisabled: boolean;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
         */
        speed: string;
        /**
         * port usage name. 
         *
         * If EVPN is used, use `evpnUplink`or `evpnDownlink`
         */
        usage: string;
    }

    export interface NetworktemplateSwitchMatchingRulePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: string[];
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: string;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: string;
    }

    export interface NetworktemplateSwitchMgmt {
        configRevert: number;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: outputs.org.NetworktemplateSwitchMgmtProtectRe;
        rootPassword?: string;
        tacacs?: outputs.org.NetworktemplateSwitchMgmtTacacs;
    }

    export interface NetworktemplateSwitchMgmtProtectRe {
        /**
         * optionally, services we'll allow
         */
        allowedServices: string[];
        customs?: outputs.org.NetworktemplateSwitchMgmtProtectReCustom[];
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled: boolean;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts: string[];
    }

    export interface NetworktemplateSwitchMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any
         */
        portRange: string;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`
         */
        protocol: string;
        subnets?: string[];
    }

    export interface NetworktemplateSwitchMgmtTacacs {
        acctServers?: outputs.org.NetworktemplateSwitchMgmtTacacsAcctServer[];
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        defaultRole: string;
        enabled?: boolean;
        /**
         * which network the TACACS server resides
         */
        network?: string;
        tacplusServers?: outputs.org.NetworktemplateSwitchMgmtTacacsTacplusServer[];
    }

    export interface NetworktemplateSwitchMgmtTacacsAcctServer {
        host?: string;
        port?: string;
        secret?: string;
        timeout: number;
    }

    export interface NetworktemplateSwitchMgmtTacacsTacplusServer {
        host?: string;
        port?: string;
        secret?: string;
        timeout: number;
    }

    export interface NetworktemplateVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: boolean;
    }

    export interface NetworktemplateVrfInstances {
        /**
         * Property key is the destination CIDR (e.g. "10.0.0.0/8")
         */
        extraRoutes?: {[key: string]: outputs.org.NetworktemplateVrfInstancesExtraRoutes};
        networks?: string[];
    }

    export interface NetworktemplateVrfInstancesExtraRoutes {
        /**
         * Next-hop address
         */
        via: string;
    }

    export interface RftemplateBand24 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface RftemplateBand5 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface RftemplateBand5On24Radio {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface RftemplateBand6 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower: boolean;
    }

    export interface RftemplateModelSpecific {
        antGain24?: number;
        antGain5?: number;
        antGain6?: number;
        /**
         * Radio Band AP settings
         */
        band24?: outputs.org.RftemplateModelSpecificBand24;
        /**
         * enum: `24`, `5`, `6`, `auto`
         */
        band24Usage?: string;
        /**
         * Radio Band AP settings
         */
        band5?: outputs.org.RftemplateModelSpecificBand5;
        /**
         * Radio Band AP settings
         */
        band5On24Radio?: outputs.org.RftemplateModelSpecificBand5On24Radio;
        /**
         * Radio Band AP settings
         */
        band6?: outputs.org.RftemplateModelSpecificBand6;
    }

    export interface RftemplateModelSpecificBand24 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface RftemplateModelSpecificBand5 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface RftemplateModelSpecificBand5On24Radio {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
    }

    export interface RftemplateModelSpecificBand6 {
        allowRrmDisable: boolean;
        antGain: number;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode: string;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth: number;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: number[];
        /**
         * whether to disable the radio
         */
        disabled: boolean;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power: number;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax: number;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin: number;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble: string;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower: boolean;
    }

    export interface ServiceSpec {
        /**
         * port number, port range, or variable
         */
        portRange?: string;
        /**
         * `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`.
         * `protocolNumber` is between 1-254
         */
        protocol: string;
    }

    export interface ServicepolicyAppqoe {
        enabled: boolean;
    }

    export interface ServicepolicyEwf {
        alertOnly?: boolean;
        blockMessage?: string;
        enabled: boolean;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile: string;
    }

    export interface ServicepolicyIdp {
        alertOnly?: boolean;
        enabled: boolean;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: string;
        /**
         * `strict` (default) / `standard` / or keys from from idp_profiles
         */
        profile: string;
    }

    export interface SettingApiPolicy {
        /**
         * by default, API hides password/secrets when the user doesn't have write access
         *   * `true`: API will hide passwords/secrets for all users
         *   * `false`: API will hide passwords/secrets for read-only users
         */
        noReveal: boolean;
    }

    export interface SettingCelona {
        apiKey: string;
        apiPrefix: string;
    }

    export interface SettingCloudshark {
        apitoken: string;
        /**
         * if using CS Enteprise
         */
        url?: string;
    }

    export interface SettingCradlepoint {
        cpApiId: string;
        cpApiKey: string;
        ecmApiId: string;
        ecmApiKey: string;
    }

    export interface SettingDeviceCert {
        cert: string;
        key: string;
    }

    export interface SettingInstaller {
        allowAllDevices?: boolean;
        allowAllSites?: boolean;
        extraSiteIds: string[];
        gracePeriod?: number;
    }

    export interface SettingJcloud {
        /**
         * JCloud Org Token
         */
        orgApitoken: string;
        /**
         * JCloud Org Token Name
         */
        orgApitokenName: string;
        /**
         * JCloud Org ID
         */
        orgId: string;
    }

    export interface SettingJuniper {
        accounts: outputs.org.SettingJuniperAccount[];
    }

    export interface SettingJuniperAccount {
        linkedBy: string;
        name: string;
    }

    export interface SettingMgmt {
        /**
         * list of Mist Tunnels
         */
        mxtunnelIds: string[];
        /**
         * whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
         */
        useMxtunnel: boolean;
        /**
         * whether to use wxtunnel for mgmt connectivity
         */
        useWxtunnel: boolean;
    }

    export interface SettingMistNac {
        /**
         * list of PEM-encoded ca certs
         */
        cacerts: string[];
        /**
         * use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
         */
        defaultIdpId?: string;
        /**
         * eap ssl security level
         * see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
         */
        eapSslSecurityLevel: number;
        /**
         * By default NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site.
         * For strict GDPR compliancy NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mistNac enabled
         */
        euOnly: boolean;
        idps: outputs.org.SettingMistNacIdp[];
        /**
         * radius server cert to be presented in EAP TLS
         */
        serverCert?: outputs.org.SettingMistNacServerCert;
        /**
         * by default NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
         */
        useIpVersion: string;
        /**
         * By default NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(radsec) to reach mist-nac. 
         * Set `useSslPort`==`true` to override that port with TCP43 (ssl), 
         * This is a org level setting that is applicable to wlans, switch_templates, and mxedgeClusters that have mist-nac enabled
         */
        useSslPort: boolean;
    }

    export interface SettingMistNacIdp {
        /**
         * when the IDP of mxedgeProxy type, exclude the following realms from proxying in addition to other valid home realms in this org
         */
        excludeRealms: string[];
        id?: string;
        /**
         * which realm should trigger this IDP. User Realm is extracted from:
         *   * Username-AVP (`mist.com` from john@mist.com)
         *   * Cert CN
         */
        userRealms: string[];
    }

    export interface SettingMistNacServerCert {
        cert?: string;
        key?: string;
        /**
         * private key password (optional)
         */
        password?: string;
    }

    export interface SettingMxedgeMgmt {
        fipsEnabled: boolean;
        mistPassword?: string;
        /**
         * enum: `dhcp`, `disabled`, `static`
         */
        oobIpType: string;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        oobIpType6: string;
        rootPassword?: string;
    }

    export interface SettingPasswordPolicy {
        /**
         * whether the policy is enabled
         */
        enabled: boolean;
        /**
         * days, required if password policy is enabled
         */
        freshness?: number;
        /**
         * required password length
         */
        minLength: number;
        /**
         * whether to require special character
         */
        requiresSpecialChar: boolean;
        /**
         * whether to require two-factor auth
         */
        requiresTwoFactorAuth: boolean;
    }

    export interface SettingPcap {
        bucket?: string;
        /**
         * max_len of non-management packets to capture
         */
        maxPktLen: number;
    }

    export interface SettingSecurity {
        /**
         * whether to disable local SSH (by default, local SSH is enabled with allowMist in Org is enabled
         */
        disableLocalSsh?: boolean;
        /**
         * password required to zeroize devices (FIPS) on site level
         */
        fipsZeroizePassword?: string;
        /**
         * whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
         */
        limitSshAccess: boolean;
    }

    export interface SettingSwitchMgmt {
        /**
         * If the field is set in both site/setting and org/setting, the value from site/setting will be used.
         */
        apAffinityThreshold: number;
    }

    export interface SettingSyntheticTest {
        disabled: boolean;
        vlans?: outputs.org.SettingSyntheticTestVlan[];
        wanSpeedtest?: outputs.org.SettingSyntheticTestWanSpeedtest;
    }

    export interface SettingSyntheticTestVlan {
        customTestUrls: string[];
        /**
         * for some vlans where we don't want this to run
         */
        disabled: boolean;
        vlanIds: string[];
    }

    export interface SettingSyntheticTestWanSpeedtest {
        enabled?: boolean;
        /**
         * any / HH:MM (24-hour format)
         */
        timeOdFay: string;
    }

    export interface SettingVpnOptions {
        asBase?: number;
        /**
         * equiring /12 or bigger to support 16 private IPs for 65535 gateways
         */
        stSubnet: string;
    }

    export interface VpnPaths {
        /**
         * enum: `broadband`, `lte`
         */
        bfdProfile: string;
        /**
         * if different from the wan port
         */
        ip?: string;
        pod: number;
    }

    export interface WlanAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Acct port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface WlanAirwatch {
        /**
         * API Key
         */
        apiKey: string;
        /**
         * console URL
         */
        consoleUrl: string;
        enabled: boolean;
        /**
         * password
         */
        password: string;
        /**
         * username
         */
        username: string;
    }

    export interface WlanAppLimit {
        /**
         * Map from app key to bandwidth in kbps. 
         * Property key is the app key, defined in Get Application List
         */
        apps?: {[key: string]: number};
        enabled: boolean;
        /**
         * Map from wxtagId of Hostname Wxlan Tags to bandwidth in kbps
         * Property key is the wxtag id
         */
        wxtagIds: {[key: string]: number};
    }

    export interface WlanAppQos {
        apps?: {[key: string]: outputs.org.WlanAppQosApps};
        enabled: boolean;
        others?: outputs.org.WlanAppQosOther[];
    }

    export interface WlanAppQosApps {
        dscp?: number;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        dstSubnet?: string;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        srcSubnet?: string;
    }

    export interface WlanAppQosOther {
        dscp?: number;
        dstSubnet?: string;
        portRanges?: string;
        protocol?: string;
        srcSubnet?: string;
    }

    export interface WlanAuth {
        /**
         * SAE anti-clogging token threshold
         */
        anticlogThreshold: number;
        /**
         * whether to trigger EAP reauth when the session ends
         */
        eapReauth: boolean;
        /**
         * whether to enable MAC Auth, uses the same auth_servers
         */
        enableMacAuth: boolean;
        /**
         * when `type`==`wep`
         */
        keyIdx: number;
        /**
         * when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
         */
        keys: string[];
        /**
         * when `type`==`psk`, whether to only use multi_psk
         */
        multiPskOnly: boolean;
        /**
         * if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
         */
        owe: string;
        /**
         * when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
         */
        pairwises: string[];
        /**
         * when `multiPskOnly`==`true`, whether private wlan is enabled
         */
        privateWlan: boolean;
        /**
         * when `type`==`psk`, 8-64 characters, or 64 hex characters
         */
        psk: string;
        /**
         * enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
         */
        type: string;
        /**
         * enable WEP as secondary auth
         */
        wepAsSecondaryAuth: boolean;
    }

    export interface WlanAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Auth port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface WlanBonjour {
        /**
         * additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
         */
        additionalVlanIds: string[];
        /**
         * whether to enable bonjour for this WLAN. Once enabled, limitBcast is assumed true, allowMdns is assumed false
         */
        enabled: boolean;
        /**
         * what services are allowed. 
         * Property key is the service name
         */
        services: {[key: string]: outputs.org.WlanBonjourServices};
    }

    export interface WlanBonjourServices {
        /**
         * whether to prevent wireless clients to discover bonjour devices on the same WLAN
         */
        disableLocal: boolean;
        /**
         * optional, if the service is further restricted for certain RADIUS groups
         */
        radiusGroups?: string[];
        /**
         * how bonjour services should be discovered for the same WLAN. enum: `sameAp`, `sameMap`, `sameSite`
         */
        scope: string;
    }

    export interface WlanCiscoCwa {
        /**
         * list of hostnames without http(s):// (matched by substring)
         */
        allowedHostnames?: string[];
        /**
         * list of CIDRs
         */
        allowedSubnets?: string[];
        /**
         * list of blocked CIDRs
         */
        blockedSubnets?: string[];
        enabled: boolean;
    }

    export interface WlanCoaServer {
        /**
         * whether to disable Event-Timestamp Check
         */
        disableEventTimestampCheck: boolean;
        enabled: boolean;
        ip: string;
        port: number;
        secret: string;
    }

    export interface WlanDnsServerRewrite {
        enabled: boolean;
        /**
         * map between radiusGroup and the desired DNS server (IPv4 only)
         * Property key is the RADIUS group, property value is the desired DNS Server
         */
        radiusGroups?: {[key: string]: string};
    }

    export interface WlanDynamicPsk {
        /**
         * default PSK to use if cloud WLC is not available, 8-63 characters
         */
        defaultPsk?: string;
        defaultVlanId?: string;
        enabled: boolean;
        /**
         * when 11r is enabled, we'll try to use the cached PMK, this can be disabled
         * `false` means auto
         */
        forceLookup: boolean;
        /**
         * enum: `cloudPsks`, `radius`
         */
        source: string;
        vlanIds?: string[];
    }

    export interface WlanDynamicVlan {
        /**
         * Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
         */
        defaultVlanIds: string[];
        /**
         * whether to enable dynamic vlan
         */
        enabled: boolean;
        /**
         * vlan_ids to be locally bridged
         */
        localVlanIds: string[];
        /**
         * standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
         */
        type: string;
        /**
         * map between vlanId (as string) to airespace interface names (comma-separated) or null for stndard mapping
         *   * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"
         *   * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
         */
        vlans?: {[key: string]: string};
    }

    export interface WlanHotspot20 {
        domainNames?: string[];
        /**
         * whether to enable hotspot 2.0 config
         */
        enabled?: boolean;
        naiRealms?: string[];
        /**
         * list of operators to support
         */
        operators?: string[];
        rcois?: string[];
        /**
         * venue name, default is site name
         */
        venueName?: string;
    }

    export interface WlanInjectDhcpOption82 {
        circuitId?: string;
        /**
         * whether to inject option 82 when forwarding DHCP packets
         */
        enabled: boolean;
    }

    export interface WlanMistNac {
        /**
         * when enabled:
         *   * `authServers` is ignored
         *   * `acctServers` is ignored
         *   * `auth_servers_*` are ignored
         *   * `coaServers` is ignored
         *   * `radsec` is ignored
         *   * `coaEnabled` is assumed'
         */
        enabled: boolean;
    }

    export interface WlanPortal {
        /**
         * amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        amazonClientId: string;
        /**
         * amazon OAuth2 client secret. If amazonClientId was provided, provide a correspoinding value. Else leave blank.
         */
        amazonClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        amazonEmailDomains: string[];
        /**
         * whether amazon is enabled as a login method
         */
        amazonEnabled: boolean;
        /**
         * interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
         */
        amazonExpire: number;
        /**
         * authentication scheme. enum: `external`, `none`, `sso`
         */
        auth: string;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client id
         */
        azureClientId: string;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client secret
         */
        azureClientSecret: string;
        /**
         * whether Azure Active Directory is enabled as a login method
         */
        azureEnabled: boolean;
        /**
         * interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
         */
        azureExpire: number;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory tenant id.
         */
        azureTenantId: string;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetPassword: string;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetSid: string;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetUserId: string;
        /**
         * whether to bypass the guest portal when cloud not reachable (and apply the default policies)
         */
        bypassWhenCloudDown: boolean;
        /**
         * when `smsProvider`==`clickatell`
         */
        clickatellApiKey: string;
        /**
         * whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable randomMac for seamless roaming)
         */
        crossSite: boolean;
        /**
         * whether email (access code verification) is enabled as a login method
         */
        emailEnabled?: boolean;
        /**
         * whether guest portal is enabled
         */
        enabled: boolean;
        /**
         * how long to remain authorized, in minutes
         */
        expire: number;
        /**
         * external portal URL (e.g. https://host/url) where we can append our query parameters to
         */
        externalPortalUrl: string;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        facebookClientId: string;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app secret. If facebookClientId was provided, provide a correspoinding value. Else leave blank.
         */
        facebookClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        facebookEmailDomains: string[];
        /**
         * whether facebook is enabled as a login method
         */
        facebookEnabled: boolean;
        /**
         * interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
         */
        facebookExpire: number;
        /**
         * whether to forward the user to another URL after authorized
         */
        forward: boolean;
        /**
         * the URL to forward the user to
         */
        forwardUrl: string;
        /**
         * Google OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        googleClientId: string;
        /**
         * Google OAuth2 app secret. If googleClientId was provided, provide a correspoinding value. Else leave blank.
         */
        googleClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        googleEmailDomains: string[];
        /**
         * whether google is enabled as login method
         */
        googleEnabled: boolean;
        /**
         * interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
         */
        googleExpire: number;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupPassword: string;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupUserid: string;
        /**
         * microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        microsoftClientId: string;
        /**
         * microsoft 365 OAuth2 client secret. If microsoftClientId was provided, provide a correspoinding value. Else leave blank.
         */
        microsoftClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        microsoftEmailDomains: string[];
        /**
         * whether microsoft 365 is enabled as a login method
         */
        microsoftEnabled: boolean;
        /**
         * interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
         */
        microsoftExpire: number;
        /**
         * whether password is enabled
         */
        passphraseEnabled: boolean;
        /**
         * interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
         */
        passphraseExpire: number;
        /**
         * passphrase
         */
        password: string;
        /**
         * whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsorNotifyAll` and `predefinedSponsorsEnabled` are false, behaviour is acc to `sponsorEmailDomains`
         */
        predefinedSponsorsEnabled: boolean;
        privacy: boolean;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelPassword: string;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelServiceId: string;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelUsername: string;
        /**
         * whether sms is enabled as a login method
         */
        smsEnabled: boolean;
        /**
         * interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
         */
        smsExpire: number;
        smsMessageFormat: string;
        /**
         * enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
         */
        smsProvider: string;
        /**
         * whether to automatically approve guest and allow sponsor to revoke guest access, needs predefinedSponsorsEnabled enabled and sponsorNotifyAll disabled
         */
        sponsorAutoApprove: boolean;
        /**
         * list of domain allowed for sponsor email. Required if `sponsorEnabled` is `true` and `sponsors` is empty.
         */
        sponsorEmailDomains: string[];
        /**
         * whether sponsor is enabled
         */
        sponsorEnabled: boolean;
        /**
         * interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
         */
        sponsorExpire: number;
        /**
         * how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
         */
        sponsorLinkValidityDuration: number;
        /**
         * whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsorNotifyAll` and `predefinedSponsorsEnabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
         */
        sponsorNotifyAll: boolean;
        /**
         * if enabled, guest will get email about sponsor's action (approve/deny)
         */
        sponsorStatusNotify: boolean;
        /**
         * object of allowed sponsors email with name. Required if `sponsorEnabled` is `true` and `sponsorEmailDomains` is empty.
         * Property key is the sponsor email, Property value is the sponsor name
         */
        sponsors: {[key: string]: string};
        /**
         * default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
         */
        ssoDefaultRole: string;
        ssoForcedRole: string;
        /**
         * IDP Cert (used to verify the signed response)
         */
        ssoIdpCert: string;
        /**
         * signing algorithm for SAML Assertion
         */
        ssoIdpSignAlgo: string;
        /**
         * IDP Single-Sign-On URL
         */
        ssoIdpSsoUrl: string;
        /**
         * IDP issuer URL
         */
        ssoIssuer: string;
        /**
         * enum: `email`, `unspecified`
         */
        ssoNameidFormat: string;
        /**
         * when `smsProvider`==`telstra`, Client ID provided by Telstra
         */
        telstraClientId: string;
        /**
         * when `smsProvider`==`telstra`, Client secret provided by Telstra
         */
        telstraClientSecret: string;
        /**
         * when `smsProvider`==`twilio`, Auth token account with twilio account
         */
        twilioAuthToken: string;
        /**
         * when `smsProvider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
         */
        twilioPhoneNumber: string;
        /**
         * when `smsProvider`==`twilio`, Account SID provided by Twilio
         */
        twilioSid: string;
    }

    export interface WlanQos {
        /**
         * enum: `background`, `bestEffort`, `video`, `voice`
         */
        class: string;
        /**
         * whether to overwrite QoS
         */
        overwrite: boolean;
    }

    export interface WlanRadsec {
        coaEnabled: boolean;
        enabled?: boolean;
        idleTimeout?: number;
        /**
         * To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
         * Org mxedge(s) identified by mxcluster_ids
         */
        mxclusterIds: string[];
        /**
         * default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
         * when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
         */
        proxyHosts: string[];
        /**
         * name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
         */
        serverName?: string;
        /**
         * List of Radsec Servers. Only if not Mist Edge.
         */
        servers?: outputs.org.WlanRadsecServer[];
        /**
         * use mxedge(s) as radsecproxy
         */
        useMxedge?: boolean;
        /**
         * To use Site mxedges when this WLAN does not use mxtunnel
         */
        useSiteMxedge: boolean;
    }

    export interface WlanRadsecServer {
        host?: string;
        port?: number;
    }

    export interface WlanSchedule {
        enabled: boolean;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
         *
         * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
         */
        hours?: outputs.org.WlanScheduleHours;
    }

    export interface WlanScheduleHours {
        fri: string;
        mon: string;
        sat: string;
        sun: string;
        thu: string;
        tue: string;
        wed: string;
    }

    export interface WlantemplateApplies {
        orgId?: string;
        /**
         * list of site ids
         */
        siteIds: string[];
        /**
         * list of sitegroup ids
         */
        sitegroupIds: string[];
    }

    export interface WlantemplateExceptions {
        /**
         * list of site ids
         */
        siteIds: string[];
        /**
         * list of sitegroup ids
         */
        sitegroupIds: string[];
    }

    export interface WxtagSpec {
        /**
         * matched destination port, "0" means any
         */
        portRange: string;
        /**
         * tcp / udp / icmp / gre / any / ":protocol_number", `protocolNumber` is between 1-254
         */
        protocol: string;
        /**
         * matched destination subnets and/or IP Addresses
         */
        subnets: string[];
    }

}

export namespace site {
    export interface BaseLatlng {
        lat: number;
        lng: number;
    }

    export interface NetworktemplateAclPolicy {
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        actions?: outputs.site.NetworktemplateAclPolicyAction[];
        name?: string;
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        srcTags?: string[];
    }

    export interface NetworktemplateAclPolicyAction {
        /**
         * enum: `allow`, `deny`
         */
        action: string;
        dstTag?: string;
    }

    export interface NetworktemplateAclTags {
        /**
         * required if
         * - `type`==`dynamicGbp` (gbp_tag received from RADIUS)
         * - `type`==`staticGbp` (applying gbp tag against matching conditions)
         */
        gbpTag?: number;
        /**
         * required if 
         * - `type`==`mac`
         * - `type`==`staticGbp` if from matching mac
         */
        macs?: string[];
        /**
         * if:
         *   * `type`==`mac` (optional. default is `any`)
         *   * `type`==`subnet` (optional. default is `any`)
         *   * `type`==`network`
         *   * `type`==`resource` (optional. default is `any`)
         *   * `type`==`staticGbp` if from matching network (vlan)'
         */
        network?: string;
        /**
         * required if:
         *   * `type`==`radiusGroup`
         *   * `type`==`staticGbp`
         * if from matching radius_group
         */
        radiusGroup?: string;
        /**
         * if `type`==`resource`
         * empty means unrestricted, i.e. any
         */
        specs?: outputs.site.NetworktemplateAclTagsSpec[];
        /**
         * if 
         * - `type`==`subnet` 
         * - `type`==`resource` (optional. default is `any`)
         * - `type`==`staticGbp` if from matching subnet
         */
        subnets?: string[];
        /**
         * enum: `any`, `dynamicGbp`, `mac`, `network`, `radiusGroup`, `resource`, `staticGbp`, `subnet`
         */
        type: string;
    }

    export interface NetworktemplateAclTagsSpec {
        /**
         * matched dst port, "0" means any
         */
        portRange: string;
        /**
         * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocolNumber` is between 1-254
         */
        protocol: string;
    }

    export interface NetworktemplateDhcpSnooping {
        allNetworks?: boolean;
        /**
         * Enable for dynamic ARP inspection check
         */
        enableArpSpoofCheck?: boolean;
        /**
         * Enable for check for forging source IP address
         */
        enableIpSourceGuard?: boolean;
        enabled?: boolean;
        /**
         * if `allNetworks`==`false`, list of network with DHCP snooping enabled
         */
        networks?: string[];
    }

    export interface NetworktemplateExtraRoutes {
        /**
         * this takes precedence
         */
        discard: boolean;
        metric?: number;
        nextQualified?: {[key: string]: outputs.site.NetworktemplateExtraRoutesNextQualified};
        noResolve: boolean;
        preference?: number;
        /**
         * next-hop IP Address
         */
        via: string;
    }

    export interface NetworktemplateExtraRoutes6 {
        /**
         * this takes precedence
         */
        discard: boolean;
        metric?: number;
        nextQualified?: {[key: string]: outputs.site.NetworktemplateExtraRoutes6NextQualified};
        noResolve: boolean;
        preference?: number;
        /**
         * next-hop IP Address
         */
        via: string;
    }

    export interface NetworktemplateExtraRoutes6NextQualified {
        metric?: number;
        preference?: number;
    }

    export interface NetworktemplateExtraRoutesNextQualified {
        metric?: number;
        preference?: number;
    }

    export interface NetworktemplateMistNac {
        enabled?: boolean;
        network?: string;
    }

    export interface NetworktemplateNetworks {
        /**
         * whether to stop clients to talk to each other, default is false (when enabled, a unique isolationVlanId is required)
         * NOTE: this features requires uplink device to also a be Juniper device and `interSwitchLink` to be set
         */
        isolation: boolean;
        isolationVlanId?: string;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet?: string;
        vlanId: string;
    }

    export interface NetworktemplatePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses: string[];
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: string;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: string;
    }

    export interface NetworktemplatePortUsages {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks: boolean;
        /**
         * Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         *
         * When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        allowMultipleSupplicants: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        description?: string;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg: boolean;
        /**
         * Only if `mode`!=`dynamic` whether the port is disabled
         */
        disabled: boolean;
        /**
         * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks: string[];
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth: boolean;
        /**
         * Only if `mode`!=`dynamic`
         */
        enableQos: boolean;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: string;
        /**
         * Only if `mode`!=`dynamic` interSwitchLink is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink: boolean;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         */
        macAuthOnly?: boolean;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol: string;
        /**
         * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit: number;
        /**
         * `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         */
        mode?: string;
        /**
         * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: number;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks: string[];
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac: boolean;
        /**
         * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         */
        poeDisabled: boolean;
        /**
         * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: string;
        /**
         * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         */
        portNetwork?: string;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval: number;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` when radius server reject / fails
         */
        rejectedNetwork?: string;
        /**
         * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         */
        resetDefaultWhen: string;
        /**
         * Only if `mode`==`dynamic`
         */
        rules?: outputs.site.NetworktemplatePortUsagesRule[];
        /**
         * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
         */
        speed?: string;
        /**
         * Switch storm control
         * Only if `mode`!=`dynamic`
         */
        stormControl?: outputs.site.NetworktemplatePortUsagesStormControl;
        /**
         * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge: boolean;
        /**
         * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: string;
    }

    export interface NetworktemplatePortUsagesRule {
        equals?: string;
        /**
         * use `equalsAny` to match any item in a list
         */
        equalsAnies?: string[];
        /**
         * "[0:3]":"abcdef" > "abc"
         * "split(.)[1]": "a.b.c" > "b"
         * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
         */
        expression?: string;
        /**
         * enum: `linkPeermac`, `lldpChassisId`, `lldpHardwareRevision`, `lldpManufacturerName`, `lldpOui`, `lldpSerialNumber`, `lldpSystemName`, `radiusDynamicfilter`, `radiusUsermac`, `radiusUsername`
         */
        src: string;
        /**
         * `portUsage` name
         */
        usage?: string;
    }

    export interface NetworktemplatePortUsagesStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast: boolean;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast: boolean;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast: boolean;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast: boolean;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage: number;
    }

    export interface NetworktemplateRadiusConfig {
        /**
         * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
         */
        acctInterimInterval: number;
        acctServers?: outputs.site.NetworktemplateRadiusConfigAcctServer[];
        authServers?: outputs.site.NetworktemplateRadiusConfigAuthServer[];
        /**
         * radius auth session retries
         */
        authServersRetries: number;
        /**
         * radius auth session timeout
         */
        authServersTimeout: number;
        coaEnabled: boolean;
        coaPort: number;
        /**
         * use `network`or `sourceIp`
         * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
         */
        network?: string;
        /**
         * use `network`or `sourceIp`
         */
        sourceIp?: string;
    }

    export interface NetworktemplateRadiusConfigAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Acct port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface NetworktemplateRadiusConfigAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Auth port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface NetworktemplateRemoteSyslog {
        archive?: outputs.site.NetworktemplateRemoteSyslogArchive;
        console?: outputs.site.NetworktemplateRemoteSyslogConsole;
        enabled: boolean;
        files?: outputs.site.NetworktemplateRemoteSyslogFile[];
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        network?: string;
        sendToAllServers: boolean;
        servers?: outputs.site.NetworktemplateRemoteSyslogServer[];
        /**
         * enum: `millisecond`, `year`, `year millisecond`
         */
        timeFormat?: string;
        users?: outputs.site.NetworktemplateRemoteSyslogUser[];
    }

    export interface NetworktemplateRemoteSyslogArchive {
        files?: number;
        size?: string;
    }

    export interface NetworktemplateRemoteSyslogConsole {
        contents?: outputs.site.NetworktemplateRemoteSyslogConsoleContent[];
    }

    export interface NetworktemplateRemoteSyslogConsoleContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateRemoteSyslogFile {
        archive?: outputs.site.NetworktemplateRemoteSyslogFileArchive;
        contents?: outputs.site.NetworktemplateRemoteSyslogFileContent[];
        explicitPriority?: boolean;
        file?: string;
        match?: string;
        structuredData?: boolean;
    }

    export interface NetworktemplateRemoteSyslogFileArchive {
        files?: number;
        size?: string;
    }

    export interface NetworktemplateRemoteSyslogFileContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateRemoteSyslogServer {
        contents?: outputs.site.NetworktemplateRemoteSyslogServerContent[];
        explicitPriority?: boolean;
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        host?: string;
        match?: string;
        port: number;
        /**
         * enum: `tcp`, `udp`
         */
        protocol: string;
        routingInstance?: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        sourceAddress?: string;
        structuredData?: boolean;
        tag?: string;
    }

    export interface NetworktemplateRemoteSyslogServerContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateRemoteSyslogUser {
        contents?: outputs.site.NetworktemplateRemoteSyslogUserContent[];
        match?: string;
        user?: string;
    }

    export interface NetworktemplateRemoteSyslogUserContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility: string;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity: string;
    }

    export interface NetworktemplateSnmpConfig {
        clientLists?: outputs.site.NetworktemplateSnmpConfigClientList[];
        contact?: string;
        description?: string;
        enabled: boolean;
        /**
         * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
         */
        engineId?: string;
        location?: string;
        name?: string;
        network: string;
        trapGroups?: outputs.site.NetworktemplateSnmpConfigTrapGroup[];
        v2cConfigs?: outputs.site.NetworktemplateSnmpConfigV2cConfig[];
        v3Config?: outputs.site.NetworktemplateSnmpConfigV3Config;
        views?: outputs.site.NetworktemplateSnmpConfigView[];
    }

    export interface NetworktemplateSnmpConfigClientList {
        clientListName?: string;
        clients?: string[];
    }

    export interface NetworktemplateSnmpConfigTrapGroup {
        categories?: string[];
        /**
         * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
         */
        groupName?: string;
        targets?: string[];
        /**
         * enum: `all`, `v1`, `v2`
         */
        version: string;
    }

    export interface NetworktemplateSnmpConfigV2cConfig {
        authorization?: string;
        /**
         * client_list_name here should refer to clientList above
         */
        clientListName?: string;
        communityName?: string;
        /**
         * view name here should be defined in views above
         */
        view?: string;
    }

    export interface NetworktemplateSnmpConfigV3Config {
        notifies?: outputs.site.NetworktemplateSnmpConfigV3ConfigNotify[];
        notifyFilters?: outputs.site.NetworktemplateSnmpConfigV3ConfigNotifyFilter[];
        targetAddresses?: outputs.site.NetworktemplateSnmpConfigV3ConfigTargetAddress[];
        targetParameters?: outputs.site.NetworktemplateSnmpConfigV3ConfigTargetParameter[];
        usm?: outputs.site.NetworktemplateSnmpConfigV3ConfigUsm;
        vacm?: outputs.site.NetworktemplateSnmpConfigV3ConfigVacm;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotify {
        name?: string;
        tag?: string;
        /**
         * enum: `inform`, `trap`
         */
        type?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilter {
        contents?: outputs.site.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent[];
        profileName?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilterContent {
        include?: boolean;
        oid?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetAddress {
        address?: string;
        addressMask?: string;
        port: number;
        /**
         * <refer to notify tag, can be multiple with blank
         */
        tagList?: string;
        targetAddressName?: string;
        /**
         * refer to notify target parameters name
         */
        targetParameters?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetParameter {
        /**
         * enum: `v1`, `v2c`, `v3`
         */
        messageProcessingModel?: string;
        name?: string;
        /**
         * refer to profile-name in notify_filter
         */
        notifyFilter?: string;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: string;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: string;
        /**
         * refer to securityName in usm
         */
        securityName?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsm {
        /**
         * enum: `localEngine`, `remoteEngine`
         */
        engineType?: string;
        /**
         * required only if `engineType`==`remoteEngine`
         */
        engineid?: string;
        users?: outputs.site.NetworktemplateSnmpConfigV3ConfigUsmUser[];
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsmUser {
        /**
         * Not required if `authenticationType`==`authenticationNone`
         * include alphabetic, numeric, and special characters, but it cannot include control characters.
         */
        authenticationPassword?: string;
        /**
         * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authenticationMd5`, `authenticationNone`, `authenticationSha`, `authenticationSha224`, `authenticationSha256`, `authenticationSha384`, `authenticationSha512`
         */
        authenticationType?: string;
        /**
         * Not required if `encryptionType`==`privacy-none`
         * include alphabetic, numeric, and special characters, but it cannot include control characters
         */
        encryptionPassword?: string;
        /**
         * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
         */
        encryptionType?: string;
        name?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacm {
        accesses?: outputs.site.NetworktemplateSnmpConfigV3ConfigVacmAccess[];
        securityToGroup?: outputs.site.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccess {
        groupName?: string;
        prefixLists?: outputs.site.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList[];
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList {
        /**
         * only required if `type`==`contextPrefix`
         */
        contextPrefix?: string;
        /**
         * refer to view name
         */
        notifyView?: string;
        /**
         * refer to view name
         */
        readView?: string;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: string;
        /**
         * enum: `any`, `usm`, `v1`, `v2c`
         */
        securityModel?: string;
        /**
         * enum: `contextPrefix`, `defaultContextPrefix`
         */
        type?: string;
        /**
         * refer to view name
         */
        writeView?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup {
        contents?: outputs.site.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent[];
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: string;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent {
        /**
         * refer to groupName under access
         */
        group?: string;
        securityName?: string;
    }

    export interface NetworktemplateSnmpConfigView {
        /**
         * if the root oid configured is included
         */
        include?: boolean;
        oid?: string;
        viewName?: string;
    }

    export interface NetworktemplateSwitchMatching {
        enable?: boolean;
        rules?: outputs.site.NetworktemplateSwitchMatchingRule[];
    }

    export interface NetworktemplateSwitchMatchingRule {
        /**
         * additional CLI commands to append to the generated Junos config
         *
         * **Note**: no check is done
         */
        additionalConfigCmds?: string[];
        /**
         * role to match
         */
        matchRole?: string;
        /**
         * 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `matchModel`,  `match_model[0-6]`
         */
        matchType?: string;
        matchValue?: string;
        name?: string;
        /**
         * Propery key is the interface name or interface range
         */
        portConfig?: {[key: string]: outputs.site.NetworktemplateSwitchMatchingRulePortConfig};
        /**
         * Property key is the port mirroring instance name
         * portMirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
         */
        portMirroring?: {[key: string]: outputs.site.NetworktemplateSwitchMatchingRulePortMirroring};
    }

    export interface NetworktemplateSwitchMatchingRulePortConfig {
        /**
         * To disable LACP support for the AE interface
         */
        aeDisableLacp?: boolean;
        /**
         * Users could force to use the designated AE name
         */
        aeIdx?: number;
        /**
         * to use fast timeout
         */
        aeLacpSlow: boolean;
        aggregated: boolean;
        /**
         * if want to generate port up/down alarm
         */
        critical?: boolean;
        description?: string;
        /**
         * if `speed` and `duplex` are specified, whether to disable autonegotiation
         */
        disableAutoneg: boolean;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex: string;
        /**
         * Enable dynamic usage for this port. Set to `dynamic` to enable.
         */
        dynamicUsage?: string;
        esilag?: boolean;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
         */
        mtu: number;
        /**
         * prevent helpdesk to override the port config
         */
        noLocalOverwrite?: boolean;
        poeDisabled: boolean;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
         */
        speed: string;
        /**
         * port usage name. 
         *
         * If EVPN is used, use `evpnUplink`or `evpnDownlink`
         */
        usage: string;
    }

    export interface NetworktemplateSwitchMatchingRulePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: string[];
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: string[];
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: string;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: string;
    }

    export interface NetworktemplateSwitchMgmt {
        configRevert: number;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: outputs.site.NetworktemplateSwitchMgmtProtectRe;
        rootPassword?: string;
        tacacs?: outputs.site.NetworktemplateSwitchMgmtTacacs;
    }

    export interface NetworktemplateSwitchMgmtProtectRe {
        /**
         * optionally, services we'll allow
         */
        allowedServices: string[];
        customs?: outputs.site.NetworktemplateSwitchMgmtProtectReCustom[];
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled: boolean;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts: string[];
    }

    export interface NetworktemplateSwitchMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any
         */
        portRange: string;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`
         */
        protocol: string;
        subnets?: string[];
    }

    export interface NetworktemplateSwitchMgmtTacacs {
        acctServers?: outputs.site.NetworktemplateSwitchMgmtTacacsAcctServer[];
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        defaultRole: string;
        enabled?: boolean;
        /**
         * which network the TACACS server resides
         */
        network?: string;
        tacplusServers?: outputs.site.NetworktemplateSwitchMgmtTacacsTacplusServer[];
    }

    export interface NetworktemplateSwitchMgmtTacacsAcctServer {
        host?: string;
        port?: string;
        secret?: string;
        timeout: number;
    }

    export interface NetworktemplateSwitchMgmtTacacsTacplusServer {
        host?: string;
        port?: string;
        secret?: string;
        timeout: number;
    }

    export interface NetworktemplateUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x: boolean;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown: boolean;
    }

    export interface NetworktemplateVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: boolean;
    }

    export interface NetworktemplateVrfInstances {
        networks?: string[];
        /**
         * Property key is the destination CIDR (e.g. "10.0.0.0/8")
         */
        vrfExtraRoutes?: {[key: string]: outputs.site.NetworktemplateVrfInstancesVrfExtraRoutes};
    }

    export interface NetworktemplateVrfInstancesVrfExtraRoutes {
        /**
         * Next-hop address
         */
        via: string;
    }

    export interface SettingAnalytic {
        /**
         * enable Advanced Analytic feature (using SUB-ANA license)
         */
        enabled: boolean;
    }

    export interface SettingAutoUpgrade {
        /**
         * custom versions for different models. Property key is the model name (e.g. "AP41")
         */
        customVersions: {[key: string]: string};
        /**
         * enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
         */
        dayOfWeek?: string;
        /**
         * whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
         */
        enabled: boolean;
        /**
         * any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
         */
        timeOfDay?: string;
        /**
         * desired version. enum: `beta`, `custom`, `stable`
         */
        version: string;
    }

    export interface SettingBleConfig {
        /**
         * whether Mist beacons is enabled
         */
        beaconEnabled: boolean;
        /**
         * required if `beaconRateMode`==`custom`, 1-10, in number-beacons-per-second
         */
        beaconRate: number;
        /**
         * enum: `custom`, `default`
         */
        beaconRateMode: string;
        /**
         * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
         */
        beamDisableds?: number[];
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send custom packet
         */
        customBlePacketEnabled: boolean;
        /**
         * The custom frame to be sent out in this beacon. The frame must be a hexstring
         */
        customBlePacketFrame: string;
        /**
         * Frequency (msec) of data emitted by custom ble beacon
         */
        customBlePacketFreqMsec: number;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUidAdvPower: number;
        eddystoneUidBeams: string;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-UID beacon is enabled
         */
        eddystoneUidEnabled: boolean;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUidFreqMsec: number;
        /**
         * Eddystone-UID instance for the device
         */
        eddystoneUidInstance: string;
        /**
         * Eddystone-UID namespace
         */
        eddystoneUidNamespace: string;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUrlAdvPower: number;
        eddystoneUrlBeams: string;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-URL beacon is enabled
         */
        eddystoneUrlEnabled: boolean;
        /**
         * Frequency (msec) of data emit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec: number;
        /**
         * URL pointed by Eddystone-URL beacon
         */
        eddystoneUrlUrl: string;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        ibeaconAdvPower: number;
        ibeaconBeams: string;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send iBeacon
         */
        ibeaconEnabled: boolean;
        /**
         * Frequency (msec) of data emmit for iBeacon
         */
        ibeaconFreqMsec: number;
        /**
         * Major number for iBeacon
         */
        ibeaconMajor: number;
        /**
         * Minor number for iBeacon
         */
        ibeaconMinor: number;
        /**
         * optional, if not specified, the same UUID as the beacon will be used
         */
        ibeaconUuid: string;
        /**
         * required if `powerMode`==`custom`
         */
        power: number;
        /**
         * enum: `custom`, `default`
         */
        powerMode: string;
    }

    export interface SettingConfigPushPolicy {
        /**
         * stop any new config from being pushed to the device
         */
        noPush: boolean;
        /**
         * if enabled, new config will only be pushed to device within the specified time window
         */
        pushWindow?: outputs.site.SettingConfigPushPolicyPushWindow;
    }

    export interface SettingConfigPushPolicyPushWindow {
        enabled: boolean;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun).
         */
        hours?: outputs.site.SettingConfigPushPolicyPushWindowHours;
    }

    export interface SettingConfigPushPolicyPushWindowHours {
        fri: string;
        mon: string;
        sat: string;
        sun: string;
        thu: string;
        tue: string;
        wed: string;
    }

    export interface SettingCriticalUrlMonitoring {
        enabled: boolean;
        monitors: outputs.site.SettingCriticalUrlMonitoringMonitor[];
    }

    export interface SettingCriticalUrlMonitoringMonitor {
        url?: string;
        vlanId?: string;
    }

    export interface SettingEngagement {
        dwellTagNames?: outputs.site.SettingEngagementDwellTagNames;
        /**
         * add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
         */
        dwellTags?: outputs.site.SettingEngagementDwellTags;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun).
         */
        hours?: outputs.site.SettingEngagementHours;
        /**
         * max time, default is 43200(12h), max is 68400 (18h)
         */
        maxDwell: number;
        /**
         * min time
         */
        minDwell?: number;
    }

    export interface SettingEngagementDwellTagNames {
        bounce?: string;
        engaged?: string;
        passerby?: string;
        stationed?: string;
    }

    export interface SettingEngagementDwellTags {
        bounce?: string;
        engaged?: string;
        passerby?: string;
        stationed?: string;
    }

    export interface SettingEngagementHours {
        fri: string;
        mon: string;
        sat: string;
        sun: string;
        thu: string;
        tue: string;
        wed: string;
    }

    export interface SettingGatewayMgmt {
        /**
         * for SSR only, as direct root access is not allowed
         */
        adminSshkeys: string[];
        appProbing?: outputs.site.SettingGatewayMgmtAppProbing;
        /**
         * consumes uplink bandwidth, requires WA license
         */
        appUsage?: boolean;
        autoSignatureUpdate?: outputs.site.SettingGatewayMgmtAutoSignatureUpdate;
        /**
         * he rollback timer for commit confirmed
         */
        configRevertTimer: number;
        probeHosts: string[];
        /**
         * for SRX only
         */
        rootPassword?: string;
        securityLogSourceAddress?: string;
        securityLogSourceInterface?: string;
    }

    export interface SettingGatewayMgmtAppProbing {
        /**
         * app-keys from /api/v1/const/applications
         */
        apps?: string[];
        customApps?: outputs.site.SettingGatewayMgmtAppProbingCustomApp[];
        enabled?: boolean;
    }

    export interface SettingGatewayMgmtAppProbingCustomApp {
        /**
         * if `protocol`==`icmp`
         */
        address: string;
        appType?: string;
        /**
         * if `protocol`==`http`
         */
        hostnames?: string[];
        name?: string;
        network?: string;
        /**
         * enum: `http`, `udp`
         */
        protocol: string;
        /**
         * if `protocol`==`http`
         */
        url?: string;
        vrf?: string;
    }

    export interface SettingGatewayMgmtAutoSignatureUpdate {
        /**
         * enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
         */
        dayOfWeek?: string;
        enable: boolean;
        /**
         * optional, Mist will decide the timing
         */
        timeOfDay?: string;
    }

    export interface SettingLed {
        brightness: number;
        enabled: boolean;
    }

    export interface SettingOccupancy {
        /**
         * indicate whether named BLE assets should be included in the zone occupancy calculation
         */
        assetsEnabled: boolean;
        /**
         * indicate whether connected WiFi clients should be included in the zone occupancy calculation
         */
        clientsEnabled: boolean;
        /**
         * minimum duration
         */
        minDuration: number;
        /**
         * indicate whether SDK clients should be included in the zone occupancy calculation
         */
        sdkclientsEnabled: boolean;
        /**
         * indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
         */
        unconnectedClientsEnabled: boolean;
    }

    export interface SettingProxy {
        url?: string;
    }

    export interface SettingRogue {
        /**
         * whether or not rogue detection is enabled
         */
        enabled: boolean;
        /**
         * whether or not honeypot detection is enabled
         */
        honeypotEnabled: boolean;
        /**
         * minimum duration for a bssid to be considered rogue
         */
        minDuration: number;
        /**
         * minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
         */
        minRssi: number;
        /**
         * list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
         */
        whitelistedBssids: string[];
        /**
         * list of SSIDs to whitelist
         */
        whitelistedSsids: string[];
    }

    export interface SettingRtsa {
        appWaking: boolean;
        disableDeadReckoning?: boolean;
        disablePressureSensor: boolean;
        enabled?: boolean;
        /**
         * asset tracking related
         */
        trackAsset: boolean;
    }

    export interface SettingSimpleAlert {
        arpFailure?: outputs.site.SettingSimpleAlertArpFailure;
        dhcpFailure?: outputs.site.SettingSimpleAlertDhcpFailure;
        dnsFailure?: outputs.site.SettingSimpleAlertDnsFailure;
    }

    export interface SettingSimpleAlertArpFailure {
        clientCount: number;
        /**
         * failing within minutes
         */
        duration: number;
        incidentCount: number;
    }

    export interface SettingSimpleAlertDhcpFailure {
        clientCount: number;
        /**
         * failing within minutes
         */
        duration: number;
        incidentCount: number;
    }

    export interface SettingSimpleAlertDnsFailure {
        clientCount: number;
        /**
         * failing within minutes
         */
        duration: number;
        incidentCount: number;
    }

    export interface SettingSkyatp {
        enabled?: boolean;
        /**
         * whether to send IP-MAC mapping to SkyATP
         */
        sendIpMacMapping: boolean;
    }

    export interface SettingSrxApp {
        enabled: boolean;
    }

    export interface SettingSsr {
        conductorHosts?: string[];
        disableStats?: boolean;
    }

    export interface SettingSyntheticTest {
        disabled: boolean;
        vlans?: outputs.site.SettingSyntheticTestVlan[];
        wanSpeedtest?: outputs.site.SettingSyntheticTestWanSpeedtest;
    }

    export interface SettingSyntheticTestVlan {
        customTestUrls: string[];
        /**
         * for some vlans where we don't want this to run
         */
        disabled: boolean;
        vlanIds: string[];
    }

    export interface SettingSyntheticTestWanSpeedtest {
        enabled?: boolean;
        /**
         * any / HH:MM (24-hour format)
         */
        timeOdFay: string;
    }

    export interface SettingUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x: boolean;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown: boolean;
    }

    export interface SettingVna {
        /**
         * enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
         */
        enabled: boolean;
    }

    export interface SettingVsInstance {
        networks: string[];
    }

    export interface SettingWanVna {
        enabled: boolean;
    }

    export interface SettingWids {
        repeatedAuthFailures?: outputs.site.SettingWidsRepeatedAuthFailures;
    }

    export interface SettingWidsRepeatedAuthFailures {
        /**
         * window where a trigger will be detected and action to be taken (in seconds)
         */
        duration?: number;
        /**
         * count of events to trigger
         */
        threshold?: number;
    }

    export interface SettingWifi {
        ciscoEnabled: boolean;
        /**
         * whether to disable 11k
         */
        disable11k: boolean;
        disableRadiosWhenPowerConstrained: boolean;
        /**
         * when proxyArp is enabled, check for arp spoofing.
         */
        enableArpSpoofCheck: boolean;
        enableSharedRadioScanning: boolean;
        /**
         * enable WIFI feature (using SUB-MAN license)
         */
        enabled: boolean;
        /**
         * whether to locate connected clients
         */
        locateConnected: boolean;
        /**
         * whether to locate unconnected clients
         */
        locateUnconnected: boolean;
        /**
         * whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
         */
        meshAllowDfs: boolean;
        /**
         * used to enable/disable CRM
         */
        meshEnableCrm: boolean;
        /**
         * whether to enable Mesh feature for the site
         */
        meshEnabled: boolean;
        /**
         * optional passphrase of mesh networking, default is generated randomly
         */
        meshPsk?: string;
        /**
         * optional ssid of mesh networking, default is based on site_id
         */
        meshSsid?: string;
        /**
         * enum: `default`, `disabled`, `enabled`
         */
        proxyArp?: string;
    }

    export interface SettingWiredVna {
        enabled: boolean;
    }

    export interface SettingZoneOccupancyAlert {
        /**
         * list of email addresses to send email notifications when the alert threshold is reached
         */
        emailNotifiers?: string[];
        /**
         * indicate whether zone occupancy alert is enabled for the site
         */
        enabled: boolean;
        /**
         * sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
         */
        threshold: number;
    }

    export interface WlanAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Acct port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface WlanAirwatch {
        /**
         * API Key
         */
        apiKey: string;
        /**
         * console URL
         */
        consoleUrl: string;
        enabled: boolean;
        /**
         * password
         */
        password: string;
        /**
         * username
         */
        username: string;
    }

    export interface WlanAppLimit {
        /**
         * Map from app key to bandwidth in kbps. 
         * Property key is the app key, defined in Get Application List
         */
        apps?: {[key: string]: number};
        enabled: boolean;
        /**
         * Map from wxtagId of Hostname Wxlan Tags to bandwidth in kbps
         * Property key is the wxtag id
         */
        wxtagIds: {[key: string]: number};
    }

    export interface WlanAppQos {
        apps?: {[key: string]: outputs.site.WlanAppQosApps};
        enabled: boolean;
        others?: outputs.site.WlanAppQosOther[];
    }

    export interface WlanAppQosApps {
        dscp?: number;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        dstSubnet?: string;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        srcSubnet?: string;
    }

    export interface WlanAppQosOther {
        dscp?: number;
        dstSubnet?: string;
        portRanges?: string;
        protocol?: string;
        srcSubnet?: string;
    }

    export interface WlanAuth {
        /**
         * SAE anti-clogging token threshold
         */
        anticlogThreshold: number;
        /**
         * whether to trigger EAP reauth when the session ends
         */
        eapReauth: boolean;
        /**
         * whether to enable MAC Auth, uses the same auth_servers
         */
        enableMacAuth: boolean;
        /**
         * when `type`==`wep`
         */
        keyIdx: number;
        /**
         * when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
         */
        keys: string[];
        /**
         * when `type`==`psk`, whether to only use multi_psk
         */
        multiPskOnly: boolean;
        /**
         * if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
         */
        owe: string;
        /**
         * when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
         */
        pairwises: string[];
        /**
         * when `multiPskOnly`==`true`, whether private wlan is enabled
         */
        privateWlan: boolean;
        /**
         * when `type`==`psk`, 8-64 characters, or 64 hex characters
         */
        psk: string;
        /**
         * enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
         */
        type: string;
        /**
         * enable WEP as secondary auth
         */
        wepAsSecondaryAuth: boolean;
    }

    export interface WlanAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: string;
        keywrapEnabled?: boolean;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: string;
        keywrapKek?: string;
        keywrapMack?: string;
        /**
         * Auth port of RADIUS server
         */
        port: number;
        /**
         * secret of RADIUS server
         */
        secret: string;
    }

    export interface WlanBonjour {
        /**
         * additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
         */
        additionalVlanIds: string[];
        /**
         * whether to enable bonjour for this WLAN. Once enabled, limitBcast is assumed true, allowMdns is assumed false
         */
        enabled: boolean;
        /**
         * what services are allowed. 
         * Property key is the service name
         */
        services: {[key: string]: outputs.site.WlanBonjourServices};
    }

    export interface WlanBonjourServices {
        /**
         * whether to prevent wireless clients to discover bonjour devices on the same WLAN
         */
        disableLocal: boolean;
        /**
         * optional, if the service is further restricted for certain RADIUS groups
         */
        radiusGroups?: string[];
        /**
         * how bonjour services should be discovered for the same WLAN. enum: `sameAp`, `sameMap`, `sameSite`
         */
        scope: string;
    }

    export interface WlanCiscoCwa {
        /**
         * list of hostnames without http(s):// (matched by substring)
         */
        allowedHostnames?: string[];
        /**
         * list of CIDRs
         */
        allowedSubnets?: string[];
        /**
         * list of blocked CIDRs
         */
        blockedSubnets?: string[];
        enabled: boolean;
    }

    export interface WlanCoaServer {
        /**
         * whether to disable Event-Timestamp Check
         */
        disableEventTimestampCheck: boolean;
        enabled: boolean;
        ip: string;
        port: number;
        secret: string;
    }

    export interface WlanDnsServerRewrite {
        enabled: boolean;
        /**
         * map between radiusGroup and the desired DNS server (IPv4 only)
         * Property key is the RADIUS group, property value is the desired DNS Server
         */
        radiusGroups?: {[key: string]: string};
    }

    export interface WlanDynamicPsk {
        /**
         * default PSK to use if cloud WLC is not available, 8-63 characters
         */
        defaultPsk?: string;
        defaultVlanId?: string;
        enabled: boolean;
        /**
         * when 11r is enabled, we'll try to use the cached PMK, this can be disabled
         * `false` means auto
         */
        forceLookup: boolean;
        /**
         * enum: `cloudPsks`, `radius`
         */
        source: string;
        vlanIds?: string[];
    }

    export interface WlanDynamicVlan {
        /**
         * Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
         */
        defaultVlanIds: string[];
        /**
         * whether to enable dynamic vlan
         */
        enabled: boolean;
        /**
         * vlan_ids to be locally bridged
         */
        localVlanIds: string[];
        /**
         * standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
         */
        type: string;
        /**
         * map between vlanId (as string) to airespace interface names (comma-separated) or null for stndard mapping
         *   * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"
         *   * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
         */
        vlans?: {[key: string]: string};
    }

    export interface WlanHotspot20 {
        domainNames?: string[];
        /**
         * whether to enable hotspot 2.0 config
         */
        enabled?: boolean;
        naiRealms?: string[];
        /**
         * list of operators to support
         */
        operators?: string[];
        rcois?: string[];
        /**
         * venue name, default is site name
         */
        venueName?: string;
    }

    export interface WlanInjectDhcpOption82 {
        circuitId?: string;
        /**
         * whether to inject option 82 when forwarding DHCP packets
         */
        enabled: boolean;
    }

    export interface WlanMistNac {
        /**
         * when enabled:
         *   * `authServers` is ignored
         *   * `acctServers` is ignored
         *   * `auth_servers_*` are ignored
         *   * `coaServers` is ignored
         *   * `radsec` is ignored
         *   * `coaEnabled` is assumed'
         */
        enabled: boolean;
    }

    export interface WlanPortal {
        /**
         * amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        amazonClientId: string;
        /**
         * amazon OAuth2 client secret. If amazonClientId was provided, provide a correspoinding value. Else leave blank.
         */
        amazonClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        amazonEmailDomains: string[];
        /**
         * whether amazon is enabled as a login method
         */
        amazonEnabled: boolean;
        /**
         * interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
         */
        amazonExpire: number;
        /**
         * authentication scheme. enum: `external`, `none`, `sso`
         */
        auth: string;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client id
         */
        azureClientId: string;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client secret
         */
        azureClientSecret: string;
        /**
         * whether Azure Active Directory is enabled as a login method
         */
        azureEnabled: boolean;
        /**
         * interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
         */
        azureExpire: number;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory tenant id.
         */
        azureTenantId: string;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetPassword: string;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetSid: string;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetUserId: string;
        /**
         * whether to bypass the guest portal when cloud not reachable (and apply the default policies)
         */
        bypassWhenCloudDown: boolean;
        /**
         * when `smsProvider`==`clickatell`
         */
        clickatellApiKey: string;
        /**
         * whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable randomMac for seamless roaming)
         */
        crossSite: boolean;
        /**
         * whether email (access code verification) is enabled as a login method
         */
        emailEnabled?: boolean;
        /**
         * whether guest portal is enabled
         */
        enabled: boolean;
        /**
         * how long to remain authorized, in minutes
         */
        expire: number;
        /**
         * external portal URL (e.g. https://host/url) where we can append our query parameters to
         */
        externalPortalUrl: string;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        facebookClientId: string;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app secret. If facebookClientId was provided, provide a correspoinding value. Else leave blank.
         */
        facebookClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        facebookEmailDomains: string[];
        /**
         * whether facebook is enabled as a login method
         */
        facebookEnabled: boolean;
        /**
         * interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
         */
        facebookExpire: number;
        /**
         * whether to forward the user to another URL after authorized
         */
        forward: boolean;
        /**
         * the URL to forward the user to
         */
        forwardUrl: string;
        /**
         * Google OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        googleClientId: string;
        /**
         * Google OAuth2 app secret. If googleClientId was provided, provide a correspoinding value. Else leave blank.
         */
        googleClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        googleEmailDomains: string[];
        /**
         * whether google is enabled as login method
         */
        googleEnabled: boolean;
        /**
         * interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
         */
        googleExpire: number;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupPassword: string;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupUserid: string;
        /**
         * microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        microsoftClientId: string;
        /**
         * microsoft 365 OAuth2 client secret. If microsoftClientId was provided, provide a correspoinding value. Else leave blank.
         */
        microsoftClientSecret: string;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        microsoftEmailDomains: string[];
        /**
         * whether microsoft 365 is enabled as a login method
         */
        microsoftEnabled: boolean;
        /**
         * interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
         */
        microsoftExpire: number;
        /**
         * whether password is enabled
         */
        passphraseEnabled: boolean;
        /**
         * interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
         */
        passphraseExpire: number;
        /**
         * passphrase
         */
        password: string;
        /**
         * whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsorNotifyAll` and `predefinedSponsorsEnabled` are false, behaviour is acc to `sponsorEmailDomains`
         */
        predefinedSponsorsEnabled: boolean;
        privacy: boolean;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelPassword: string;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelServiceId: string;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelUsername: string;
        /**
         * whether sms is enabled as a login method
         */
        smsEnabled: boolean;
        /**
         * interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
         */
        smsExpire: number;
        smsMessageFormat: string;
        /**
         * enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
         */
        smsProvider: string;
        /**
         * whether to automatically approve guest and allow sponsor to revoke guest access, needs predefinedSponsorsEnabled enabled and sponsorNotifyAll disabled
         */
        sponsorAutoApprove: boolean;
        /**
         * list of domain allowed for sponsor email. Required if `sponsorEnabled` is `true` and `sponsors` is empty.
         */
        sponsorEmailDomains: string[];
        /**
         * whether sponsor is enabled
         */
        sponsorEnabled: boolean;
        /**
         * interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
         */
        sponsorExpire: number;
        /**
         * how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
         */
        sponsorLinkValidityDuration: number;
        /**
         * whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsorNotifyAll` and `predefinedSponsorsEnabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
         */
        sponsorNotifyAll: boolean;
        /**
         * if enabled, guest will get email about sponsor's action (approve/deny)
         */
        sponsorStatusNotify: boolean;
        /**
         * object of allowed sponsors email with name. Required if `sponsorEnabled` is `true` and `sponsorEmailDomains` is empty.
         * Property key is the sponsor email, Property value is the sponsor name
         */
        sponsors: {[key: string]: string};
        /**
         * default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
         */
        ssoDefaultRole: string;
        ssoForcedRole: string;
        /**
         * IDP Cert (used to verify the signed response)
         */
        ssoIdpCert: string;
        /**
         * signing algorithm for SAML Assertion
         */
        ssoIdpSignAlgo: string;
        /**
         * IDP Single-Sign-On URL
         */
        ssoIdpSsoUrl: string;
        /**
         * IDP issuer URL
         */
        ssoIssuer: string;
        /**
         * enum: `email`, `unspecified`
         */
        ssoNameidFormat: string;
        /**
         * when `smsProvider`==`telstra`, Client ID provided by Telstra
         */
        telstraClientId: string;
        /**
         * when `smsProvider`==`telstra`, Client secret provided by Telstra
         */
        telstraClientSecret: string;
        /**
         * when `smsProvider`==`twilio`, Auth token account with twilio account
         */
        twilioAuthToken: string;
        /**
         * when `smsProvider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
         */
        twilioPhoneNumber: string;
        /**
         * when `smsProvider`==`twilio`, Account SID provided by Twilio
         */
        twilioSid: string;
    }

    export interface WlanQos {
        /**
         * enum: `background`, `bestEffort`, `video`, `voice`
         */
        class: string;
        /**
         * whether to overwrite QoS
         */
        overwrite: boolean;
    }

    export interface WlanRadsec {
        coaEnabled: boolean;
        enabled?: boolean;
        idleTimeout?: number;
        /**
         * To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
         * Org mxedge(s) identified by mxcluster_ids
         */
        mxclusterIds: string[];
        /**
         * default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
         * when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
         */
        proxyHosts: string[];
        /**
         * name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
         */
        serverName?: string;
        /**
         * List of Radsec Servers. Only if not Mist Edge.
         */
        servers?: outputs.site.WlanRadsecServer[];
        /**
         * use mxedge(s) as radsecproxy
         */
        useMxedge?: boolean;
        /**
         * To use Site mxedges when this WLAN does not use mxtunnel
         */
        useSiteMxedge: boolean;
    }

    export interface WlanRadsecServer {
        host?: string;
        port?: number;
    }

    export interface WlanSchedule {
        enabled: boolean;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
         *
         * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
         */
        hours?: outputs.site.WlanScheduleHours;
    }

    export interface WlanScheduleHours {
        fri: string;
        mon: string;
        sat: string;
        sun: string;
        thu: string;
        tue: string;
        wed: string;
    }

    export interface WxtagSpec {
        /**
         * matched destination port, "0" means any
         */
        portRange: string;
        /**
         * tcp / udp / icmp / gre / any / ":protocol_number", `protocolNumber` is between 1-254
         */
        protocol: string;
        /**
         * matched destination subnets and/or IP Addresses
         */
        subnets: string[];
    }

}
