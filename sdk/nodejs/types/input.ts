// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace device {
    export interface ApAeroscout {
        /**
         * whether to enable aeroscout config
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * required if enabled, aeroscout server host
         */
        host?: pulumi.Input<string>;
        /**
         * whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
         */
        locateConnected?: pulumi.Input<boolean>;
    }

    export interface ApBleConfig {
        /**
         * whether Mist beacons is enabled
         */
        beaconEnabled?: pulumi.Input<boolean>;
        /**
         * required if `beaconRateMode`==`custom`, 1-10, in number-beacons-per-second
         */
        beaconRate?: pulumi.Input<number>;
        /**
         * enum: `custom`, `default`
         */
        beaconRateMode?: pulumi.Input<string>;
        /**
         * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
         */
        beamDisableds?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send custom packet
         */
        customBlePacketEnabled?: pulumi.Input<boolean>;
        /**
         * The custom frame to be sent out in this beacon. The frame must be a hexstring
         */
        customBlePacketFrame?: pulumi.Input<string>;
        /**
         * Frequency (msec) of data emitted by custom ble beacon
         */
        customBlePacketFreqMsec?: pulumi.Input<number>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUidAdvPower?: pulumi.Input<number>;
        eddystoneUidBeams?: pulumi.Input<string>;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-UID beacon is enabled
         */
        eddystoneUidEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUidFreqMsec?: pulumi.Input<number>;
        /**
         * Eddystone-UID instance for the device
         */
        eddystoneUidInstance?: pulumi.Input<string>;
        /**
         * Eddystone-UID namespace
         */
        eddystoneUidNamespace?: pulumi.Input<string>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUrlAdvPower?: pulumi.Input<number>;
        eddystoneUrlBeams?: pulumi.Input<string>;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-URL beacon is enabled
         */
        eddystoneUrlEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec?: pulumi.Input<number>;
        /**
         * URL pointed by Eddystone-URL beacon
         */
        eddystoneUrlUrl?: pulumi.Input<string>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        ibeaconAdvPower?: pulumi.Input<number>;
        ibeaconBeams?: pulumi.Input<string>;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send iBeacon
         */
        ibeaconEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emmit for iBeacon
         */
        ibeaconFreqMsec?: pulumi.Input<number>;
        /**
         * Major number for iBeacon
         */
        ibeaconMajor?: pulumi.Input<number>;
        /**
         * Minor number for iBeacon
         */
        ibeaconMinor?: pulumi.Input<number>;
        /**
         * optional, if not specified, the same UUID as the beacon will be used
         */
        ibeaconUuid?: pulumi.Input<string>;
        /**
         * required if `powerMode`==`custom`
         */
        power?: pulumi.Input<number>;
        /**
         * enum: `custom`, `default`
         */
        powerMode?: pulumi.Input<string>;
    }

    export interface ApCentrak {
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApClientBridge {
        auth?: pulumi.Input<inputs.device.ApClientBridgeAuth>;
        /**
         * when acted as client bridge:
         *   * only 5G radio can be used
         *   * will not serve as AP on any radios
         */
        enabled?: pulumi.Input<boolean>;
        ssid?: pulumi.Input<string>;
    }

    export interface ApClientBridgeAuth {
        psk?: pulumi.Input<string>;
        /**
         * wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
         */
        type?: pulumi.Input<string>;
    }

    export interface ApEslConfig {
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        cacert?: pulumi.Input<string>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        channel?: pulumi.Input<number>;
        /**
         * usb_config is ignored if eslConfig enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        host?: pulumi.Input<string>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        port?: pulumi.Input<number>;
        /**
         * note: bleConfig will be ingored if eslConfig is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
         */
        type?: pulumi.Input<string>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        verifyCert?: pulumi.Input<boolean>;
        /**
         * Only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface ApIpConfig {
        /**
         * if `type`==`static`
         */
        dns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * required if `type`==`static`
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * required if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        gateway6?: pulumi.Input<string>;
        /**
         * required if `type`==`static`
         */
        ip?: pulumi.Input<string>;
        ip6?: pulumi.Input<string>;
        mtu?: pulumi.Input<number>;
        /**
         * required if `type`==`static`
         */
        netmask?: pulumi.Input<string>;
        netmask6?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        type6?: pulumi.Input<string>;
        /**
         * management vlan id, default is 1 (untagged)
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface ApLed {
        brightness?: pulumi.Input<number>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApMesh {
        /**
         * whether mesh is enabled on this AP
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
         */
        group?: pulumi.Input<number>;
        /**
         * enum: `base`, `remote`
         */
        role?: pulumi.Input<string>;
    }

    export interface ApPwrConfig {
        /**
         * additional power to request during negotiating with PSE over PoE, in mW
         */
        base?: pulumi.Input<number>;
        /**
         * whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
         */
        preferUsbOverWifi?: pulumi.Input<boolean>;
    }

    export interface ApRadioConfig {
        allowRrmDisable?: pulumi.Input<boolean>;
        /**
         * antenna gain for 2.4G - for models with external antenna only
         */
        antGain24?: pulumi.Input<number>;
        /**
         * antenna gain for 5G - for models with external antenna only
         */
        antGain5?: pulumi.Input<number>;
        /**
         * antenna gain for 6G - for models with external antenna only
         */
        antGain6?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * Radio Band AP settings
         */
        band24?: pulumi.Input<inputs.device.ApRadioConfigBand24>;
        /**
         * enum: `24`, `5`, `6`, `auto`
         */
        band24Usage?: pulumi.Input<string>;
        /**
         * Radio Band AP settings
         */
        band5?: pulumi.Input<inputs.device.ApRadioConfigBand5>;
        /**
         * Radio Band AP settings
         */
        band5On24Radio?: pulumi.Input<inputs.device.ApRadioConfigBand5On24Radio>;
        /**
         * Radio Band AP settings
         */
        band6?: pulumi.Input<inputs.device.ApRadioConfigBand6>;
        /**
         * to make an outdoor operate indoor.
         * for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
         */
        indoorUse?: pulumi.Input<boolean>;
        /**
         * whether scanning radio is enabled
         */
        scanningEnabled?: pulumi.Input<boolean>;
    }

    export interface ApRadioConfigBand24 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface ApRadioConfigBand5 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface ApRadioConfigBand5On24Radio {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface ApRadioConfigBand6 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower?: pulumi.Input<boolean>;
    }

    export interface ApUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x?: pulumi.Input<boolean>;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown?: pulumi.Input<boolean>;
    }

    export interface ApUsbConfig {
        /**
         * only if `type`==`imagotag`
         */
        cacert?: pulumi.Input<string>;
        /**
         * only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
         */
        channel?: pulumi.Input<number>;
        /**
         * whether to enable any usb config
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * only if `type`==`imagotag`
         */
        host?: pulumi.Input<string>;
        /**
         * only if `type`==`imagotag`
         */
        port?: pulumi.Input<number>;
        /**
         * usb config type. enum: `hanshow`, `imagotag`, `solum`
         */
        type?: pulumi.Input<string>;
        /**
         * only if `type`==`imagotag`, whether to turn on SSL verification
         */
        verifyCert?: pulumi.Input<boolean>;
        /**
         * only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface BaseLatlng {
        lat: pulumi.Input<number>;
        lng: pulumi.Input<number>;
    }

    export interface GatewayBgpConfig {
        authKey?: pulumi.Input<string>;
        /**
         * when bfdMultiplier is configured alone. Default:
         *   * 1000 if `type`==`external`
         *   * 350 `type`==`internal`
         */
        bfdMinimumInterval?: pulumi.Input<number>;
        /**
         * when bfdMinimumIntervalIsConfigured alone
         */
        bfdMultiplier?: pulumi.Input<number>;
        /**
         * BFD provides faster path failure detection and is enabled by default
         */
        disableBfd?: pulumi.Input<boolean>;
        export?: pulumi.Input<string>;
        /**
         * default export policies if no per-neighbor policies defined
         */
        exportPolicy?: pulumi.Input<string>;
        /**
         * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
         * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
         */
        extendedV4Nexthop?: pulumi.Input<boolean>;
        /**
         * `0` means disable
         */
        gracefulRestartTime?: pulumi.Input<number>;
        holdTime?: pulumi.Input<number>;
        import?: pulumi.Input<string>;
        /**
         * default import policies if no per-neighbor policies defined
         */
        importPolicy?: pulumi.Input<string>;
        localAs?: pulumi.Input<number>;
        neighborAs?: pulumi.Input<number>;
        /**
         * if per-neighbor as is desired. Property key is the neighbor address
         */
        neighbors?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayBgpConfigNeighbors>}>;
        /**
         * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * by default, we'll re-advertise all learned BGP routers toward overlay
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * if `type`==`tunnel`
         */
        tunnelName?: pulumi.Input<string>;
        /**
         * enum: `external`, `internal`
         */
        type?: pulumi.Input<string>;
        /**
         * network name. enum: `lan`, `tunnel`, `vpn`, `wan`
         */
        via?: pulumi.Input<string>;
        vpnName?: pulumi.Input<string>;
        /**
         * if `via`==`wan`
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewayBgpConfigNeighbors {
        /**
         * If true, the BGP session to this neighbor will be administratively disabled/shutdown
         */
        disabled?: pulumi.Input<boolean>;
        exportPolicy?: pulumi.Input<string>;
        holdTime?: pulumi.Input<number>;
        importPolicy?: pulumi.Input<string>;
        /**
         * assuming BGP neighbor is directly connected
         */
        multihopTtl?: pulumi.Input<number>;
        neighborAs?: pulumi.Input<number>;
    }

    export interface GatewayClusterNode {
        /**
         * Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
         */
        mac: pulumi.Input<string>;
    }

    export interface GatewayDhcpdConfig {
        /**
         * Property key is the network name
         */
        config?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayDhcpdConfigConfig>}>;
        /**
         * if set to `false`, disable the DHCP server
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewayDhcpdConfigConfig {
        /**
         * if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
         */
        fixedBindings?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayDhcpdConfigConfigFixedBindings>}>;
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`local`
         */
        ipEnd?: pulumi.Input<string>;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: pulumi.Input<string>;
        /**
         * if `type`==`local`
         */
        ipStart?: pulumi.Input<string>;
        /**
         * if `type6`==`local`
         */
        ipStart6?: pulumi.Input<string>;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime?: pulumi.Input<number>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is the DHCP option number
         */
        options?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayDhcpdConfigConfigOptions>}>;
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride?: pulumi.Input<boolean>;
        /**
         * if `type`==`relay`
         */
        servers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type6`==`relay`
         */
        servers6s?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6?: pulumi.Input<string>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapsulated?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayDhcpdConfigConfigVendorEncapsulated>}>;
    }

    export interface GatewayDhcpdConfigConfigFixedBindings {
        ip: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface GatewayDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GatewayDhcpdConfigConfigVendorEncapsulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GatewayExtraRoutes {
        via: pulumi.Input<string>;
    }

    export interface GatewayExtraRoutes6 {
        via: pulumi.Input<string>;
    }

    export interface GatewayIdpProfiles {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile?: pulumi.Input<string>;
        /**
         * Unique ID of the object instance in the Mist Organnization
         */
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        orgId?: pulumi.Input<string>;
        overwrites?: pulumi.Input<pulumi.Input<inputs.device.GatewayIdpProfilesOverwrite>[]>;
    }

    export interface GatewayIdpProfilesOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action?: pulumi.Input<string>;
        matching?: pulumi.Input<inputs.device.GatewayIdpProfilesOverwriteMatching>;
        name?: pulumi.Input<string>;
    }

    export interface GatewayIdpProfilesOverwriteMatching {
        attackNames?: pulumi.Input<pulumi.Input<string>[]>;
        dstSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        severities?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayIpConfigs {
        ip: pulumi.Input<string>;
        netmask: pulumi.Input<string>;
        /**
         * optional list of secondary IPs in CIDR format
         */
        secondaryIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface GatewayNetwork {
        /**
         * whether to disallow Mist Devices in the network
         */
        disallowMistServices?: pulumi.Input<boolean>;
        gateway?: pulumi.Input<string>;
        gateway6?: pulumi.Input<string>;
        internalAccess?: pulumi.Input<inputs.device.GatewayNetworkInternalAccess>;
        /**
         * whether this network has direct internet access
         */
        internetAccess?: pulumi.Input<inputs.device.GatewayNetworkInternetAccess>;
        /**
         * whether to allow clients in the network to talk to each other
         */
        isolation?: pulumi.Input<boolean>;
        /**
         * whether to enable multicast support (only PIM-sparse mode is supported)
         */
        multicast?: pulumi.Input<inputs.device.GatewayNetworkMulticast>;
        name: pulumi.Input<string>;
        /**
         * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
         */
        routedForNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        subnet: pulumi.Input<string>;
        subnet6?: pulumi.Input<string>;
        tenants?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkTenants>}>;
        vlanId?: pulumi.Input<string>;
        /**
         * Property key is the VPN name. Whether this network can be accessed from vpn
         */
        vpnAccess?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkVpnAccess>}>;
    }

    export interface GatewayNetworkInternalAccess {
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewayNetworkInternetAccess {
        createSimpleServicePolicy?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkInternetAccessDestinationNat>}>;
        enabled?: pulumi.Input<boolean>;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkInternetAccessStaticNat>}>;
    }

    export interface GatewayNetworkInternetAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface GatewayNetworkInternetAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewayNetworkMulticast {
        /**
         * if the network will only be the soruce of the multicast traffic, IGMP can be disabled
         */
        disableIgmp?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
         */
        groups?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkMulticastGroups>}>;
    }

    export interface GatewayNetworkMulticastGroups {
        /**
         * RP (rendezvous point) IP Address
         */
        rpIp?: pulumi.Input<string>;
    }

    export interface GatewayNetworkTenants {
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayNetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: pulumi.Input<string>;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkVpnAccessDestinationNat>}>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp?: pulumi.Input<boolean>;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf?: pulumi.Input<boolean>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether this network is routable
         */
        routed?: pulumi.Input<boolean>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat?: pulumi.Input<inputs.device.GatewayNetworkVpnAccessSourceNat>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayNetworkVpnAccessStaticNat>}>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: pulumi.Input<string>;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: pulumi.Input<string>;
    }

    export interface GatewayNetworkVpnAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface GatewayNetworkVpnAccessSourceNat {
        externalIp?: pulumi.Input<string>;
    }

    export interface GatewayNetworkVpnAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewayOobIpConfig {
        /**
         * if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`static`
         */
        ip?: pulumi.Input<string>;
        /**
         * if `type`==`static`
         */
        netmask?: pulumi.Input<string>;
        /**
         * for HA Cluster, node1 can have different IP Config
         */
        node1?: pulumi.Input<inputs.device.GatewayOobIpConfigNode1>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
        vlanId?: pulumi.Input<string>;
    }

    export interface GatewayOobIpConfigNode1 {
        /**
         * if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * whether to use `mgmtJunos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
        vlanId?: pulumi.Input<string>;
    }

    export interface GatewayPathPreferences {
        paths?: pulumi.Input<pulumi.Input<inputs.device.GatewayPathPreferencesPath>[]>;
        /**
         * enum: `ecmp`, `ordered`, `weighted`
         */
        strategy?: pulumi.Input<string>;
    }

    export interface GatewayPathPreferencesPath {
        cost?: pulumi.Input<number>;
        /**
         * For SSR Only. `true`, if this specific path is undesired
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * only if `type`==`local`, if a different gateway is desired
         */
        gatewayIp?: pulumi.Input<string>;
        /**
         * only if `type`==`vpn`, if this vpn path can be used for internet
         */
        internetAccess?: pulumi.Input<boolean>;
        /**
         * required when 
         *   * `type`==`vpn`: the name of the VPN Path to use 
         *   * `type`==`wan`: the name of the WAN interface to use'
         */
        name?: pulumi.Input<string>;
        /**
         * required when `type`==`local`
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local`, if destination IP is to be replaced
         */
        targetIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `local`, `tunnel`, `vpn`, `wan`
         */
        type?: pulumi.Input<string>;
        /**
         * optional if `type`==`vpn`
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewayPortConfig {
        /**
         * if `aggregated`==`true`. To disable LCP support for the AE interface
         */
        aeDisableLacp?: pulumi.Input<boolean>;
        /**
         * if `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
         */
        aeIdx?: pulumi.Input<string>;
        /**
         * For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability.\n
         * Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end\n
         * Note: Turning this on will enable force-up on one of the interfaces in the bundle only
         */
        aeLacpForceUp?: pulumi.Input<boolean>;
        aggregated?: pulumi.Input<boolean>;
        /**
         * if want to generate port up/down alarm, set it to true
         */
        critical?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * port admin up (true) / down (false)
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * if `wanType`==`dsl`. enum: `adsl`, `vdsl`
         */
        dslType?: pulumi.Input<string>;
        /**
         * if `wanType`==`dsl`
         * 16 bit int
         */
        dslVci?: pulumi.Input<number>;
        /**
         * if `wanType`==`dsl`
         * 8 bit int
         */
        dslVpi?: pulumi.Input<number>;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Junos IP Config
         */
        ipConfig?: pulumi.Input<inputs.device.GatewayPortConfigIpConfig>;
        /**
         * if `wanType`==`lte`
         */
        lteApn?: pulumi.Input<string>;
        /**
         * if `wanType`==`lte`. enum: `chap`, `none`, `pap`
         */
        lteAuth?: pulumi.Input<string>;
        lteBackup?: pulumi.Input<boolean>;
        /**
         * if `wanType`==`lte`
         */
        ltePassword?: pulumi.Input<string>;
        /**
         * if `wanType`==`lte`
         */
        lteUsername?: pulumi.Input<string>;
        mtu?: pulumi.Input<number>;
        /**
         * name that we'll use to derive config
         */
        name?: pulumi.Input<string>;
        /**
         * if `usage`==`lan`
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for Q-in-Q
         */
        outerVlanId?: pulumi.Input<number>;
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * if `usage`==`lan`
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * whether to preserve dscp when sending traffic over VPN (SSR-only)
         */
        preserveDscp?: pulumi.Input<boolean>;
        /**
         * if HA mode
         */
        redundant?: pulumi.Input<boolean>;
        /**
         * if HA mode
         */
        rethIdx?: pulumi.Input<number>;
        /**
         * if HA mode
         */
        rethNode?: pulumi.Input<string>;
        /**
         * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
         */
        rethNodes?: pulumi.Input<pulumi.Input<string>[]>;
        speed?: pulumi.Input<string>;
        /**
         * when SSR is running as VM, this is required on certain hosting platforms
         */
        ssrNoVirtualMac?: pulumi.Input<boolean>;
        /**
         * for SSR only
         */
        svrPortRange?: pulumi.Input<string>;
        trafficShaping?: pulumi.Input<inputs.device.GatewayPortConfigTrafficShaping>;
        /**
         * port usage name. enum: `haControl`, `haData`, `lan`, `wan`
         */
        usage: pulumi.Input<string>;
        /**
         * if WAN interface is on a VLAN
         */
        vlanId?: pulumi.Input<number>;
        /**
         * Property key is the VPN name
         */
        vpnPaths?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayPortConfigVpnPaths>}>;
        /**
         * when `wanType`==`broadband`. enum: `default`, `max`, `recommended`
         */
        wanArpPolicer?: pulumi.Input<string>;
        /**
         * optional, if spoke should reach this port by a different IP
         */
        wanExtIp?: pulumi.Input<string>;
        /**
         * Property Key is the destianation CIDR (e.g "100.100.100.0/24")
         */
        wanExtraRoutes?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.GatewayPortConfigWanExtraRoutes>}>;
        /**
         * if `usage`==`wan`
         */
        wanProbeOverride?: pulumi.Input<inputs.device.GatewayPortConfigWanProbeOverride>;
        /**
         * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
         */
        wanSourceNat?: pulumi.Input<inputs.device.GatewayPortConfigWanSourceNat>;
        /**
         * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
         */
        wanType?: pulumi.Input<string>;
    }

    export interface GatewayPortConfigIpConfig {
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * optional, the network to be used for mgmt
         */
        network?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`
         */
        poserPassword?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
         */
        pppoeAuth?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`
         */
        pppoeUsername?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `pppoe`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface GatewayPortConfigTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: pulumi.Input<pulumi.Input<number>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewayPortConfigVpnPaths {
        /**
         * Only if the VPN `type`==`hubSpoke`. enum: `broadband`, `lte`
         */
        bfdProfile?: pulumi.Input<string>;
        /**
         * Only if the VPN `type`==`hubSpoke`. Whether to use tunnel mode. SSR only
         */
        bfdUseTunnelMode?: pulumi.Input<boolean>;
        /**
         * Only if the VPN `type`==`mesh`
         */
        linkName?: pulumi.Input<string>;
        /**
         * Only if the VPN `type`==`hubSpoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
         */
        preference?: pulumi.Input<number>;
        /**
         * Only if the VPN `type`==`hubSpoke`. enum: `hub`, `spoke`
         */
        role?: pulumi.Input<string>;
        trafficShaping?: pulumi.Input<inputs.device.GatewayPortConfigVpnPathsTrafficShaping>;
    }

    export interface GatewayPortConfigVpnPathsTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: pulumi.Input<pulumi.Input<number>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewayPortConfigWanExtraRoutes {
        via?: pulumi.Input<string>;
    }

    export interface GatewayPortConfigWanProbeOverride {
        ips?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `broadband`, `lte`
         */
        probeProfile?: pulumi.Input<string>;
    }

    export interface GatewayPortConfigWanSourceNat {
        /**
         * or to disable the source-nat
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * if alternative natPool is desired
         */
        natPool?: pulumi.Input<string>;
    }

    export interface GatewayPortMirroring {
        portMirror?: pulumi.Input<inputs.device.GatewayPortMirroringPortMirror>;
    }

    export interface GatewayPortMirroringPortMirror {
        familyType?: pulumi.Input<string>;
        ingressPortIds?: pulumi.Input<pulumi.Input<string>[]>;
        outputPortId?: pulumi.Input<string>;
        rate?: pulumi.Input<number>;
        runLength?: pulumi.Input<number>;
    }

    export interface GatewayRoutingPolicies {
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        terms?: pulumi.Input<pulumi.Input<inputs.device.GatewayRoutingPoliciesTerm>[]>;
    }

    export interface GatewayRoutingPoliciesTerm {
        /**
         * when used as import policy
         */
        action?: pulumi.Input<inputs.device.GatewayRoutingPoliciesTermAction>;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        matching?: pulumi.Input<inputs.device.GatewayRoutingPoliciesTermMatching>;
    }

    export interface GatewayRoutingPoliciesTermAction {
        accept?: pulumi.Input<boolean>;
        addCommunities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for SSR, hub decides how VRF routes are leaked on spoke
         */
        addTargetVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional
         */
        communities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional. To exclude certain AS
         */
        excludeAsPaths?: pulumi.Input<pulumi.Input<string>[]>;
        excludeCommunities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional
         */
        exportCommunitites?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * optional, for an import policy, localPreference can be changed
         */
        localPreference?: pulumi.Input<string>;
        /**
         * when used as export policy, optional. By default, the local AS will be prepended, to change it
         */
        prependAsPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayRoutingPoliciesTermMatching {
        /**
         * takes regular expression
         */
        asPaths?: pulumi.Input<pulumi.Input<string>[]>;
        communities?: pulumi.Input<pulumi.Input<string>[]>;
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        prefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * `direct`, `bgp`, `osp`, ...
         */
        protocols?: pulumi.Input<pulumi.Input<string>[]>;
        routeExists?: pulumi.Input<inputs.device.GatewayRoutingPoliciesTermMatchingRouteExists>;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         */
        vpnNeighborMacs?: pulumi.Input<pulumi.Input<string>[]>;
        vpnPathSla?: pulumi.Input<inputs.device.GatewayRoutingPoliciesTermMatchingVpnPathSla>;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         * ordered-
         */
        vpnPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayRoutingPoliciesTermMatchingRouteExists {
        route?: pulumi.Input<string>;
        /**
         * name of the vrf instance
         * it can also be the name of the VPN or wan if they
         */
        vrfName?: pulumi.Input<string>;
    }

    export interface GatewayRoutingPoliciesTermMatchingVpnPathSla {
        maxJitter?: pulumi.Input<number>;
        maxLatency?: pulumi.Input<number>;
        maxLoss?: pulumi.Input<number>;
    }

    export interface GatewayServicePolicy {
        /**
         * Required when `servicepolicyId` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
         */
        action?: pulumi.Input<string>;
        /**
         * For SRX Only
         */
        appqoe?: pulumi.Input<inputs.device.GatewayServicePolicyAppqoe>;
        ewfs?: pulumi.Input<pulumi.Input<inputs.device.GatewayServicePolicyEwf>[]>;
        idp?: pulumi.Input<inputs.device.GatewayServicePolicyIdp>;
        /**
         * access within the same VRF
         */
        localRouting?: pulumi.Input<boolean>;
        /**
         * Required when `servicepolicyId` is not defined, optional otherwise (override the servicepolicy name)
         */
        name?: pulumi.Input<string>;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference?: pulumi.Input<string>;
        /**
         * used to link servicepolicy defined at org level and overwrite some attributes
         */
        servicepolicyId?: pulumi.Input<string>;
        /**
         * Required when `servicepolicyId` is not defined. List of Applications / Desctinations
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required when `servicepolicyId` is not defined. List of Networks / Users
         */
        tenants?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayServicePolicyAppqoe {
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewayServicePolicyEwf {
        alertOnly?: pulumi.Input<boolean>;
        blockMessage?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile?: pulumi.Input<string>;
    }

    export interface GatewayServicePolicyIdp {
        alertOnly?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: pulumi.Input<string>;
        /**
         * enum: `Custom`, `strict` (default), `standard` or keys from from idp_profiles
         */
        profile?: pulumi.Input<string>;
    }

    export interface GatewayTunnelConfigs {
        autoProvision?: pulumi.Input<inputs.device.GatewayTunnelConfigsAutoProvision>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        ikeLifetime?: pulumi.Input<number>;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
         */
        ikeMode?: pulumi.Input<string>;
        /**
         * if `provider`== `custom-ipsec`
         */
        ikeProposals?: pulumi.Input<pulumi.Input<inputs.device.GatewayTunnelConfigsIkeProposal>[]>;
        /**
         * if `provider`== `custom-ipsec`
         */
        ipsecLifetime?: pulumi.Input<number>;
        /**
         * Only if  `provider`== `custom-ipsec`
         */
        ipsecProposals?: pulumi.Input<pulumi.Input<inputs.device.GatewayTunnelConfigsIpsecProposal>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        localId?: pulumi.Input<string>;
        /**
         * enum: `active-active`, `active-standby`
         */
        mode?: pulumi.Input<string>;
        /**
         * networks reachable via this tunnel
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        primary?: pulumi.Input<inputs.device.GatewayTunnelConfigsPrimary>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        probe?: pulumi.Input<inputs.device.GatewayTunnelConfigsProbe>;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
         */
        protocol?: pulumi.Input<string>;
        /**
         * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
         */
        provider?: pulumi.Input<string>;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        psk?: pulumi.Input<string>;
        secondary?: pulumi.Input<inputs.device.GatewayTunnelConfigsSecondary>;
        /**
         * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
         */
        version?: pulumi.Input<string>;
    }

    export interface GatewayTunnelConfigsAutoProvision {
        enable?: pulumi.Input<boolean>;
        latlng?: pulumi.Input<inputs.device.GatewayTunnelConfigsAutoProvisionLatlng>;
        primary?: pulumi.Input<inputs.device.GatewayTunnelConfigsAutoProvisionPrimary>;
        secondary?: pulumi.Input<inputs.device.GatewayTunnelConfigsAutoProvisionSecondary>;
    }

    export interface GatewayTunnelConfigsAutoProvisionLatlng {
        lat: pulumi.Input<number>;
        lng: pulumi.Input<number>;
    }

    export interface GatewayTunnelConfigsAutoProvisionPrimary {
        numHosts?: pulumi.Input<string>;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayTunnelConfigsAutoProvisionSecondary {
        numHosts?: pulumi.Input<string>;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayTunnelConfigsIkeProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: pulumi.Input<string>;
        /**
         * enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup?: pulumi.Input<string>;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo?: pulumi.Input<string>;
    }

    export interface GatewayTunnelConfigsIpsecProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: pulumi.Input<string>;
        /**
         * Only if `provider`== `custom-ipsec`. enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup?: pulumi.Input<string>;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo?: pulumi.Input<string>;
    }

    export interface GatewayTunnelConfigsPrimary {
        hosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: pulumi.Input<pulumi.Input<string>[]>;
        probeIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: pulumi.Input<pulumi.Input<string>[]>;
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayTunnelConfigsProbe {
        /**
         * how often to trigger the probe
         */
        interval?: pulumi.Input<number>;
        /**
         * number of consecutive misses before declaring the tunnel down
         */
        threshold?: pulumi.Input<number>;
        /**
         * time within which to complete the connectivity check
         */
        timeout?: pulumi.Input<number>;
        /**
         * enum: `http`, `icmp`
         */
        type?: pulumi.Input<string>;
    }

    export interface GatewayTunnelConfigsSecondary {
        hosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: pulumi.Input<pulumi.Input<string>[]>;
        probeIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: pulumi.Input<pulumi.Input<string>[]>;
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewayTunnelProviderOptions {
        /**
         * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
         */
        jse?: pulumi.Input<inputs.device.GatewayTunnelProviderOptionsJse>;
        /**
         * for zscaler-ipsec and zscaler-gre
         */
        zscaler?: pulumi.Input<inputs.device.GatewayTunnelProviderOptionsZscaler>;
    }

    export interface GatewayTunnelProviderOptionsJse {
        name?: pulumi.Input<string>;
        numUsers?: pulumi.Input<number>;
    }

    export interface GatewayTunnelProviderOptionsZscaler {
        aupAcceptanceRequired?: pulumi.Input<boolean>;
        /**
         * days before AUP is requested again
         */
        aupExpire?: pulumi.Input<number>;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy?: pulumi.Input<boolean>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: pulumi.Input<number>;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: pulumi.Input<boolean>;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution?: pulumi.Input<boolean>;
        enforceAuthentication?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        /**
         * if `useXff`==`true`
         */
        subLocations?: pulumi.Input<pulumi.Input<inputs.device.GatewayTunnelProviderOptionsZscalerSubLocation>[]>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: pulumi.Input<number>;
        /**
         * location uses proxy chaining to forward traffic
         */
        useXff?: pulumi.Input<boolean>;
    }

    export interface GatewayTunnelProviderOptionsZscalerSubLocation {
        aupAcceptanceRequired?: pulumi.Input<boolean>;
        /**
         * days before AUP is requested again
         */
        aupExpire?: pulumi.Input<number>;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy?: pulumi.Input<boolean>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: pulumi.Input<number>;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: pulumi.Input<boolean>;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution?: pulumi.Input<boolean>;
        enforceAuthentication?: pulumi.Input<boolean>;
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: pulumi.Input<number>;
    }

    export interface GatewayVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewayVrfInstances {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchAclPolicy {
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        actions?: pulumi.Input<pulumi.Input<inputs.device.SwitchAclPolicyAction>[]>;
        name?: pulumi.Input<string>;
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        srcTags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchAclPolicyAction {
        /**
         * enum: `allow`, `deny`
         */
        action?: pulumi.Input<string>;
        dstTag: pulumi.Input<string>;
    }

    export interface SwitchAclTags {
        /**
         * required if
         * - `type`==`dynamicGbp` (gbp_tag received from RADIUS)
         * - `type`==`gbpResource`
         * - `type`==`staticGbp` (applying gbp tag against matching conditions)
         */
        gbpTag?: pulumi.Input<number>;
        /**
         * required if 
         * - `type`==`mac`
         * - `type`==`staticGbp` if from matching mac
         */
        macs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if:
         *   * `type`==`mac` (optional. default is `any`)
         *   * `type`==`subnet` (optional. default is `any`)
         *   * `type`==`network`
         *   * `type`==`resource` (optional. default is `any`)
         *   * `type`==`staticGbp` if from matching network (vlan)'
         */
        network?: pulumi.Input<string>;
        /**
         * required if:
         *   * `type`==`radiusGroup`
         *   * `type`==`staticGbp`
         * if from matching radius_group
         */
        radiusGroup?: pulumi.Input<string>;
        /**
         * if `type`==`resource` or `type`==`gbpResource`
         * empty means unrestricted, i.e. any
         */
        specs?: pulumi.Input<pulumi.Input<inputs.device.SwitchAclTagsSpec>[]>;
        /**
         * if 
         * - `type`==`subnet` 
         * - `type`==`resource` (optional. default is `any`)
         * - `type`==`staticGbp` if from matching subnet
         */
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: 
         *   * `any`: matching anything not identified
         *   * `dynamicGbp`: from the gbpTag received from RADIUS
         *   * `gbpResource`: can only be used in `dstTags`
         *   * `mac`
         *   * `network`
         *   * `radiusGroup`
         *   * `resource`: can only be used in `dstTags`
         *   * `staticGbp`: applying gbp tag against matching conditions
         *   * `subnet`'
         */
        type: pulumi.Input<string>;
    }

    export interface SwitchAclTagsSpec {
        /**
         * matched dst port, "0" means any
         */
        portRange?: pulumi.Input<string>;
        /**
         * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocolNumber` is between 1-254
         */
        protocol?: pulumi.Input<string>;
    }

    export interface SwitchDhcpSnooping {
        allNetworks?: pulumi.Input<boolean>;
        /**
         * Enable for dynamic ARP inspection check
         */
        enableArpSpoofCheck?: pulumi.Input<boolean>;
        /**
         * Enable for check for forging source IP address
         */
        enableIpSourceGuard?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * if `allNetworks`==`false`, list of network with DHCP snooping enabled
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchDhcpdConfig {
        /**
         * Property key is the network name
         */
        config?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchDhcpdConfigConfig>}>;
        /**
         * if set to `true`, enable the DHCP server
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SwitchDhcpdConfigConfig {
        /**
         * if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
         */
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`server` or `type6`==`server` - optional, if not defined, system one will be used
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`server` or `type6`==`server`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
         */
        fixedBindings?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchDhcpdConfigConfigFixedBindings>}>;
        /**
         * if `type`==`server`  - optional, `ip` will be used if not provided
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`server`
         */
        ipEnd?: pulumi.Input<string>;
        /**
         * if `type6`==`server`
         */
        ipEnd6?: pulumi.Input<string>;
        /**
         * if `type`==`server`
         */
        ipStart?: pulumi.Input<string>;
        /**
         * if `type6`==`server`
         */
        ipStart6?: pulumi.Input<string>;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime?: pulumi.Input<number>;
        /**
         * if `type`==`server` or `type6`==`server`. Property key is the DHCP option number
         */
        options?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchDhcpdConfigConfigOptions>}>;
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride?: pulumi.Input<boolean>;
        /**
         * if `type`==`relay`
         */
        servers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type6`==`relay`
         */
        servers6s?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `none`, `relay` (DHCP Relay), `server` (DHCP Server)
         */
        type6?: pulumi.Input<string>;
        /**
         * if `type`==`server` or `type6`==`server`. Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapsulated?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchDhcpdConfigConfigVendorEncapsulated>}>;
    }

    export interface SwitchDhcpdConfigConfigFixedBindings {
        ip: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface SwitchDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface SwitchDhcpdConfigConfigVendorEncapsulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface SwitchEvpnConfig {
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
         */
        role?: pulumi.Input<string>;
    }

    export interface SwitchExtraRoutes {
        /**
         * this takes precedence
         */
        discard?: pulumi.Input<boolean>;
        metric?: pulumi.Input<number>;
        nextQualified?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchExtraRoutesNextQualified>}>;
        noResolve?: pulumi.Input<boolean>;
        preference?: pulumi.Input<number>;
        /**
         * next-hop IP Address
         */
        via: pulumi.Input<string>;
    }

    export interface SwitchExtraRoutes6 {
        /**
         * this takes precedence
         */
        discard?: pulumi.Input<boolean>;
        metric?: pulumi.Input<number>;
        nextQualified?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchExtraRoutes6NextQualified>}>;
        noResolve?: pulumi.Input<boolean>;
        preference?: pulumi.Input<number>;
        /**
         * next-hop IP Address
         */
        via: pulumi.Input<string>;
    }

    export interface SwitchExtraRoutes6NextQualified {
        metric?: pulumi.Input<number>;
        preference?: pulumi.Input<number>;
    }

    export interface SwitchExtraRoutesNextQualified {
        metric?: pulumi.Input<number>;
        preference?: pulumi.Input<number>;
    }

    export interface SwitchIpConfig {
        /**
         * Required when `type`==`static`
         */
        dns?: pulumi.Input<pulumi.Input<string>[]>;
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
         */
        network?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface SwitchLocalPortConfig {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks?: pulumi.Input<boolean>;
        /**
         * If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
         * All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         * When it is not defined, it means using the system's default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: pulumi.Input<boolean>;
        allowMultipleSupplicants?: pulumi.Input<boolean>;
        /**
         * Only if `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown?: pulumi.Input<boolean>;
        /**
         * Only if `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * whether the port is disabled
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * link connection mode. enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Only if `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth?: pulumi.Input<boolean>;
        enableQos?: pulumi.Input<boolean>;
        /**
         * Only if `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: pulumi.Input<string>;
        /**
         * inter_switch_link is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink?: pulumi.Input<boolean>;
        /**
         * Only if `enableMacAuth`==`true`
         */
        macAuthOnly?: pulumi.Input<boolean>;
        /**
         * Only if `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
         */
        macAuthPreferred?: pulumi.Input<boolean>;
        /**
         * Only if `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol?: pulumi.Input<string>;
        /**
         * max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit?: pulumi.Input<number>;
        /**
         * enum: `access`, `inet`, `trunk`
         */
        mode?: pulumi.Input<string>;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: pulumi.Input<number>;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac?: pulumi.Input<boolean>;
        /**
         * whether PoE capabilities are disabled for a port
         */
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: pulumi.Input<string>;
        /**
         * native network/vlan for untagged traffic
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * Only if `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval?: pulumi.Input<number>;
        /**
         * Only if `portAuth`==`dot1x` sets server fail fallback vlan
         */
        serverFailNetwork?: pulumi.Input<string>;
        /**
         * Only if `portAuth`==`dot1x` when radius server reject / fails
         */
        serverRejectNetwork?: pulumi.Input<string>;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * Switch storm control
         */
        stormControl?: pulumi.Input<inputs.device.SwitchLocalPortConfigStormControl>;
        /**
         * when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge?: pulumi.Input<boolean>;
        stpNoRootPort?: pulumi.Input<boolean>;
        stpP2p?: pulumi.Input<boolean>;
        /**
         * port usage name.
         */
        usage: pulumi.Input<string>;
        /**
         * if this is connected to a vstp network
         */
        useVstp?: pulumi.Input<boolean>;
        /**
         * network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: pulumi.Input<string>;
    }

    export interface SwitchLocalPortConfigStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast?: pulumi.Input<boolean>;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage?: pulumi.Input<number>;
    }

    export interface SwitchMistNac {
        enabled?: pulumi.Input<boolean>;
        network?: pulumi.Input<string>;
    }

    export interface SwitchNetworks {
        /**
         * only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
         */
        gateway?: pulumi.Input<string>;
        /**
         * only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
         */
        gateway6?: pulumi.Input<string>;
        /**
         * whether to stop clients to talk to each other, default is false (when enabled, a unique isolationVlanId is required)
         * NOTE: this features requires uplink device to also a be Juniper device and `interSwitchLink` to be set
         */
        isolation?: pulumi.Input<boolean>;
        isolationVlanId?: pulumi.Input<string>;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet?: pulumi.Input<string>;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet6?: pulumi.Input<string>;
        vlanId: pulumi.Input<string>;
    }

    export interface SwitchOobIpConfig {
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * optional, the network to be used for mgmt
         */
        network?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
    }

    export interface SwitchOspfAreas {
        includeLoopback?: pulumi.Input<boolean>;
        networks: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchOspfAreasNetworks>}>;
        /**
         * OSPF type. enum: `default`, `nssa`, `stub`
         */
        type?: pulumi.Input<string>;
    }

    export interface SwitchOspfAreasNetworks {
        /**
         * Required if `authType`==`md5`. Property key is the key number
         */
        authKeys?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Required if `authType`==`password`, the password, max length is 8
         */
        authPassword?: pulumi.Input<string>;
        /**
         * auth type. enum: `md5`, `none`, `password`
         */
        authType?: pulumi.Input<string>;
        bfdMinimumInterval?: pulumi.Input<number>;
        deadInterval?: pulumi.Input<number>;
        exportPolicy?: pulumi.Input<string>;
        helloInterval?: pulumi.Input<number>;
        importPolicy?: pulumi.Input<string>;
        /**
         * interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
         */
        interfaceType?: pulumi.Input<string>;
        metric?: pulumi.Input<number>;
        /**
         * by default, we'll re-advertise all learned OSPF routes toward overlay
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * whether to send OSPF-Hello
         */
        passive?: pulumi.Input<boolean>;
    }

    export interface SwitchOtherIpConfigs {
        /**
         * for EVPN, if anycast is desired
         */
        evpnAnycast?: pulumi.Input<boolean>;
        /**
         * required if `type`==`static`
         */
        ip?: pulumi.Input<string>;
        /**
         * required if `type6`==`static`
         */
        ip6?: pulumi.Input<string>;
        /**
         * optional, `subnet` from `network` definition will be used if defined
         */
        netmask?: pulumi.Input<string>;
        /**
         * optional, `subnet` from `network` definition will be used if defined
         */
        netmask6?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        type6?: pulumi.Input<string>;
    }

    export interface SwitchPortConfig {
        /**
         * To disable LACP support for the AE interface
         */
        aeDisableLacp?: pulumi.Input<boolean>;
        /**
         * Users could force to use the designated AE name
         */
        aeIdx?: pulumi.Input<number>;
        /**
         * to use fast timeout
         */
        aeLacpSlow?: pulumi.Input<boolean>;
        aggregated?: pulumi.Input<boolean>;
        /**
         * if want to generate port up/down alarm
         */
        critical?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        /**
         * if `speed` and `duplex` are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Enable dynamic usage for this port. Set to `dynamic` to enable.
         */
        dynamicUsage?: pulumi.Input<string>;
        esilag?: pulumi.Input<boolean>;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
         */
        mtu?: pulumi.Input<number>;
        /**
         * prevent helpdesk to override the port config
         */
        noLocalOverwrite?: pulumi.Input<boolean>;
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * port usage name. If EVPN is used, use `evpnUplink`or `evpnDownlink`
         */
        usage: pulumi.Input<string>;
    }

    export interface SwitchPortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: pulumi.Input<string>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: pulumi.Input<string>;
    }

    export interface SwitchPortUsages {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
         * All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         * When it is not defined, it means using the system's default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        allowMultipleSupplicants?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        description?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` whether the port is disabled
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        enableQos?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` interSwitchLink is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         */
        macAuthOnly?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
         */
        macAuthPreferred?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit?: pulumi.Input<number>;
        /**
         * `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         */
        mode?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: pulumi.Input<number>;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         */
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval?: pulumi.Input<number>;
        /**
         * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         */
        resetDefaultWhen?: pulumi.Input<string>;
        /**
         * Only if `mode`==`dynamic`
         */
        rules?: pulumi.Input<pulumi.Input<inputs.device.SwitchPortUsagesRule>[]>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` sets server fail fallback vlan
         */
        serverFailNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` when radius server reject / fails
         */
        serverRejectNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * Switch storm control
         * Only if `mode`!=`dynamic`
         */
        stormControl?: pulumi.Input<inputs.device.SwitchPortUsagesStormControl>;
        /**
         * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge?: pulumi.Input<boolean>;
        stpNoRootPort?: pulumi.Input<boolean>;
        stpP2p?: pulumi.Input<boolean>;
        /**
         * if this is connected to a vstp network
         */
        useVstp?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: pulumi.Input<string>;
    }

    export interface SwitchPortUsagesRule {
        equals?: pulumi.Input<string>;
        /**
         * use `equalsAny` to match any item in a list
         */
        equalsAnies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * "[0:3]":"abcdef" > "abc"
         * "split(.)[1]": "a.b.c" > "b"
         * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
         */
        expression?: pulumi.Input<string>;
        /**
         * enum: `linkPeermac`, `lldpChassisId`, `lldpHardwareRevision`, `lldpManufacturerName`, `lldpOui`, `lldpSerialNumber`, `lldpSystemName`, `radiusDynamicfilter`, `radiusUsermac`, `radiusUsername`
         */
        src: pulumi.Input<string>;
        /**
         * `portUsage` name
         */
        usage?: pulumi.Input<string>;
    }

    export interface SwitchPortUsagesStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast?: pulumi.Input<boolean>;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage?: pulumi.Input<number>;
    }

    export interface SwitchRadiusConfig {
        /**
         * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
         */
        acctInterimInterval?: pulumi.Input<number>;
        acctServers?: pulumi.Input<pulumi.Input<inputs.device.SwitchRadiusConfigAcctServer>[]>;
        authServers?: pulumi.Input<pulumi.Input<inputs.device.SwitchRadiusConfigAuthServer>[]>;
        /**
         * radius auth session retries
         */
        authServersRetries?: pulumi.Input<number>;
        /**
         * radius auth session timeout
         */
        authServersTimeout?: pulumi.Input<number>;
        /**
         * use `network`or `sourceIp`
         * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
         */
        network?: pulumi.Input<string>;
        /**
         * use `network`or `sourceIp`
         */
        sourceIp?: pulumi.Input<string>;
    }

    export interface SwitchRadiusConfigAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Acct port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface SwitchRadiusConfigAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Auth port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * whether to require Message-Authenticator in requests
         */
        requireMessageAuthenticator?: pulumi.Input<boolean>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslog {
        archive?: pulumi.Input<inputs.device.SwitchRemoteSyslogArchive>;
        console?: pulumi.Input<inputs.device.SwitchRemoteSyslogConsole>;
        enabled?: pulumi.Input<boolean>;
        files?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogFile>[]>;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        network?: pulumi.Input<string>;
        sendToAllServers?: pulumi.Input<boolean>;
        servers?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogServer>[]>;
        /**
         * enum: `millisecond`, `year`, `year millisecond`
         */
        timeFormat?: pulumi.Input<string>;
        users?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogUser>[]>;
    }

    export interface SwitchRemoteSyslogArchive {
        files?: pulumi.Input<number>;
        size?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogConsole {
        contents?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogConsoleContent>[]>;
    }

    export interface SwitchRemoteSyslogConsoleContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogFile {
        archive?: pulumi.Input<inputs.device.SwitchRemoteSyslogFileArchive>;
        contents?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogFileContent>[]>;
        explicitPriority?: pulumi.Input<boolean>;
        file?: pulumi.Input<string>;
        match?: pulumi.Input<string>;
        structuredData?: pulumi.Input<boolean>;
    }

    export interface SwitchRemoteSyslogFileArchive {
        files?: pulumi.Input<number>;
        size?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogFileContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogServer {
        contents?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogServerContent>[]>;
        explicitPriority?: pulumi.Input<boolean>;
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        host?: pulumi.Input<string>;
        match?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        /**
         * enum: `tcp`, `udp`
         */
        protocol?: pulumi.Input<string>;
        routingInstance?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        sourceAddress?: pulumi.Input<string>;
        structuredData?: pulumi.Input<boolean>;
        tag?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogServerContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogUser {
        contents?: pulumi.Input<pulumi.Input<inputs.device.SwitchRemoteSyslogUserContent>[]>;
        match?: pulumi.Input<string>;
        user?: pulumi.Input<string>;
    }

    export interface SwitchRemoteSyslogUserContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfig {
        clientLists?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigClientList>[]>;
        contact?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
         */
        engineId?: pulumi.Input<string>;
        location?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        trapGroups?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigTrapGroup>[]>;
        v2cConfigs?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV2cConfig>[]>;
        v3Config?: pulumi.Input<inputs.device.SwitchSnmpConfigV3Config>;
        views?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigView>[]>;
    }

    export interface SwitchSnmpConfigClientList {
        clientListName?: pulumi.Input<string>;
        clients?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchSnmpConfigTrapGroup {
        categories?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
         */
        groupName?: pulumi.Input<string>;
        targets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `all`, `v1`, `v2`
         */
        version?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV2cConfig {
        authorization?: pulumi.Input<string>;
        /**
         * client_list_name here should refer to clientList above
         */
        clientListName?: pulumi.Input<string>;
        communityName?: pulumi.Input<string>;
        /**
         * view name here should be defined in views above
         */
        view?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3Config {
        notifies?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigNotify>[]>;
        notifyFilters?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigNotifyFilter>[]>;
        targetAddresses?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigTargetAddress>[]>;
        targetParameters?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigTargetParameter>[]>;
        usm?: pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigUsm>;
        vacm?: pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigVacm>;
    }

    export interface SwitchSnmpConfigV3ConfigNotify {
        name?: pulumi.Input<string>;
        tag?: pulumi.Input<string>;
        /**
         * enum: `inform`, `trap`
         */
        type?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigNotifyFilter {
        contents?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigNotifyFilterContent>[]>;
        profileName?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigNotifyFilterContent {
        include?: pulumi.Input<boolean>;
        oid?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigTargetAddress {
        address?: pulumi.Input<string>;
        addressMask?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        /**
         * <refer to notify tag, can be multiple with blank
         */
        tagList?: pulumi.Input<string>;
        targetAddressName?: pulumi.Input<string>;
        /**
         * refer to notify target parameters name
         */
        targetParameters?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigTargetParameter {
        /**
         * enum: `v1`, `v2c`, `v3`
         */
        messageProcessingModel?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * refer to profile-name in notify_filter
         */
        notifyFilter?: pulumi.Input<string>;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
        /**
         * refer to securityName in usm
         */
        securityName?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigUsm {
        /**
         * enum: `localEngine`, `remoteEngine`
         */
        engineType?: pulumi.Input<string>;
        /**
         * required only if `engineType`==`remoteEngine`
         */
        engineid?: pulumi.Input<string>;
        users?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigUsmUser>[]>;
    }

    export interface SwitchSnmpConfigV3ConfigUsmUser {
        /**
         * Not required if `authenticationType`==`authenticationNone`
         * include alphabetic, numeric, and special characters, but it cannot include control characters.
         */
        authenticationPassword?: pulumi.Input<string>;
        /**
         * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authenticationMd5`, `authenticationNone`, `authenticationSha`, `authenticationSha224`, `authenticationSha256`, `authenticationSha384`, `authenticationSha512`
         */
        authenticationType?: pulumi.Input<string>;
        /**
         * Not required if `encryptionType`==`privacy-none`
         * include alphabetic, numeric, and special characters, but it cannot include control characters
         */
        encryptionPassword?: pulumi.Input<string>;
        /**
         * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
         */
        encryptionType?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigVacm {
        accesses?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigVacmAccess>[]>;
        securityToGroup?: pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigVacmSecurityToGroup>;
    }

    export interface SwitchSnmpConfigV3ConfigVacmAccess {
        groupName?: pulumi.Input<string>;
        prefixLists?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigVacmAccessPrefixList>[]>;
    }

    export interface SwitchSnmpConfigV3ConfigVacmAccessPrefixList {
        /**
         * only required if `type`==`contextPrefix`
         */
        contextPrefix?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        notifyView?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        readView?: pulumi.Input<string>;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * enum: `any`, `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
        /**
         * enum: `contextPrefix`, `defaultContextPrefix`
         */
        type?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        writeView?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigVacmSecurityToGroup {
        contents?: pulumi.Input<pulumi.Input<inputs.device.SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent>[]>;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigV3ConfigVacmSecurityToGroupContent {
        /**
         * refer to groupName under access
         */
        group?: pulumi.Input<string>;
        securityName?: pulumi.Input<string>;
    }

    export interface SwitchSnmpConfigView {
        /**
         * if the root oid configured is included
         */
        include?: pulumi.Input<boolean>;
        oid?: pulumi.Input<string>;
        viewName?: pulumi.Input<string>;
    }

    export interface SwitchStpConfig {
        /**
         * Switch STP priority: from `0k` to `15k`
         */
        bridgePriority?: pulumi.Input<string>;
    }

    export interface SwitchSwitchMgmt {
        /**
         * ap_affinity_threshold apAffinityThreshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
         */
        apAffinityThreshold?: pulumi.Input<number>;
        /**
         * Set Banners for switches. Allows markup formatting
         */
        cliBanner?: pulumi.Input<string>;
        /**
         * Sets timeout for switches
         */
        cliIdleTimeout?: pulumi.Input<number>;
        /**
         * the rollback timer for commit confirmed
         */
        configRevertTimer?: pulumi.Input<number>;
        /**
         * Enable to provide the FQDN with DHCP option 81
         */
        dhcpOptionFqdn?: pulumi.Input<boolean>;
        disableOobDownAlarm?: pulumi.Input<boolean>;
        /**
         * Property key is the user name. For Local user authentication
         */
        localAccounts?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchSwitchMgmtLocalAccounts>}>;
        mxedgeProxyHost?: pulumi.Input<string>;
        mxedgeProxyPort?: pulumi.Input<number>;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: pulumi.Input<inputs.device.SwitchSwitchMgmtProtectRe>;
        rootPassword?: pulumi.Input<string>;
        tacacs?: pulumi.Input<inputs.device.SwitchSwitchMgmtTacacs>;
        /**
         * to use mxedge as proxy
         */
        useMxedgeProxy?: pulumi.Input<boolean>;
    }

    export interface SwitchSwitchMgmtLocalAccounts {
        password?: pulumi.Input<string>;
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        role?: pulumi.Input<string>;
    }

    export interface SwitchSwitchMgmtProtectRe {
        /**
         * optionally, services we'll allow. enum: `icmp`, `ssh`
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        customs?: pulumi.Input<pulumi.Input<inputs.device.SwitchSwitchMgmtProtectReCustom>[]>;
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchSwitchMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        portRange?: pulumi.Input<string>;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        protocol?: pulumi.Input<string>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchSwitchMgmtTacacs {
        acctServers?: pulumi.Input<pulumi.Input<inputs.device.SwitchSwitchMgmtTacacsAcctServer>[]>;
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        defaultRole?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * which network the TACACS server resides
         */
        network?: pulumi.Input<string>;
        tacplusServers?: pulumi.Input<pulumi.Input<inputs.device.SwitchSwitchMgmtTacacsTacplusServer>[]>;
    }

    export interface SwitchSwitchMgmtTacacsAcctServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        secret?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface SwitchSwitchMgmtTacacsTacplusServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        secret?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface SwitchVirtualChassis {
        /**
         * list of Virtual Chassis members
         */
        members?: pulumi.Input<pulumi.Input<inputs.device.SwitchVirtualChassisMember>[]>;
        /**
         * to configure whether the VC is preprovisioned or nonprovisioned
         */
        preprovisioned?: pulumi.Input<boolean>;
    }

    export interface SwitchVirtualChassisMember {
        /**
         * fpc0, same as the mac of device_id
         */
        mac?: pulumi.Input<string>;
        memberId?: pulumi.Input<number>;
        /**
         * Both vcRole master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
         */
        vcRole?: pulumi.Input<string>;
    }

    export interface SwitchVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SwitchVrfInstances {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Property key is the destination CIDR (e.g. "10.0.0.0/8")
         */
        vrfExtraRoutes?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchVrfInstancesVrfExtraRoutes>}>;
    }

    export interface SwitchVrfInstancesVrfExtraRoutes {
        /**
         * Next-hop address
         */
        via: pulumi.Input<string>;
    }

    export interface SwitchVrrpConfig {
        enabled?: pulumi.Input<boolean>;
        /**
         * Property key is the VRRP name
         */
        groups?: pulumi.Input<{[key: string]: pulumi.Input<inputs.device.SwitchVrrpConfigGroups>}>;
    }

    export interface SwitchVrrpConfigGroups {
        priority?: pulumi.Input<number>;
    }
}

export namespace org {
    export interface AlarmtemplateDelivery {
        /**
         * List of additional email string to deliver the alarms via emails
         */
        additionalEmails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to enable the alarm delivery via emails or not
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Whether to deliver the alarms via emails to Org admins or not
         */
        toOrgAdmins?: pulumi.Input<boolean>;
        /**
         * Whether to deliver the alarms via emails to Site admins or not
         */
        toSiteAdmins?: pulumi.Input<boolean>;
    }

    export interface AlarmtemplateRules {
        /**
         * Delivery object to configure the alarm delivery
         */
        delivery?: pulumi.Input<inputs.org.AlarmtemplateRulesDelivery>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface AlarmtemplateRulesDelivery {
        /**
         * List of additional email string to deliver the alarms via emails
         */
        additionalEmails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to enable the alarm delivery via emails or not
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Whether to deliver the alarms via emails to Org admins or not
         */
        toOrgAdmins?: pulumi.Input<boolean>;
        /**
         * Whether to deliver the alarms via emails to Site admins or not
         */
        toSiteAdmins?: pulumi.Input<boolean>;
    }

    export interface ApitokenPrivilege {
        /**
         * access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
         */
        role: pulumi.Input<string>;
        /**
         * enum: `org`, `site`, `sitegroup`
         */
        scope: pulumi.Input<string>;
        /**
         * Required if `scope`==`site`
         */
        siteId?: pulumi.Input<string>;
        /**
         * Required if `scope`==`sitegroup`
         */
        sitegroupId?: pulumi.Input<string>;
    }

    export interface DeviceprofileApAeroscout {
        /**
         * whether to enable aeroscout config
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * required if enabled, aeroscout server host
         */
        host?: pulumi.Input<string>;
        /**
         * whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
         */
        locateConnected?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileApBleConfig {
        /**
         * whether Mist beacons is enabled
         */
        beaconEnabled?: pulumi.Input<boolean>;
        /**
         * required if `beaconRateMode`==`custom`, 1-10, in number-beacons-per-second
         */
        beaconRate?: pulumi.Input<number>;
        /**
         * enum: `custom`, `default`
         */
        beaconRateMode?: pulumi.Input<string>;
        /**
         * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
         */
        beamDisableds?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send custom packet
         */
        customBlePacketEnabled?: pulumi.Input<boolean>;
        /**
         * The custom frame to be sent out in this beacon. The frame must be a hexstring
         */
        customBlePacketFrame?: pulumi.Input<string>;
        /**
         * Frequency (msec) of data emitted by custom ble beacon
         */
        customBlePacketFreqMsec?: pulumi.Input<number>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUidAdvPower?: pulumi.Input<number>;
        eddystoneUidBeams?: pulumi.Input<string>;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-UID beacon is enabled
         */
        eddystoneUidEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUidFreqMsec?: pulumi.Input<number>;
        /**
         * Eddystone-UID instance for the device
         */
        eddystoneUidInstance?: pulumi.Input<string>;
        /**
         * Eddystone-UID namespace
         */
        eddystoneUidNamespace?: pulumi.Input<string>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUrlAdvPower?: pulumi.Input<number>;
        eddystoneUrlBeams?: pulumi.Input<string>;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-URL beacon is enabled
         */
        eddystoneUrlEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec?: pulumi.Input<number>;
        /**
         * URL pointed by Eddystone-URL beacon
         */
        eddystoneUrlUrl?: pulumi.Input<string>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        ibeaconAdvPower?: pulumi.Input<number>;
        ibeaconBeams?: pulumi.Input<string>;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send iBeacon
         */
        ibeaconEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emmit for iBeacon
         */
        ibeaconFreqMsec?: pulumi.Input<number>;
        /**
         * Major number for iBeacon
         */
        ibeaconMajor?: pulumi.Input<number>;
        /**
         * Minor number for iBeacon
         */
        ibeaconMinor?: pulumi.Input<number>;
        /**
         * optional, if not specified, the same UUID as the beacon will be used
         */
        ibeaconUuid?: pulumi.Input<string>;
        /**
         * required if `powerMode`==`custom`
         */
        power?: pulumi.Input<number>;
        /**
         * enum: `custom`, `default`
         */
        powerMode?: pulumi.Input<string>;
    }

    export interface DeviceprofileApEslConfig {
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        cacert?: pulumi.Input<string>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        channel?: pulumi.Input<number>;
        /**
         * usb*config is ignored if esl*config enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        host?: pulumi.Input<string>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        port?: pulumi.Input<number>;
        /**
         * note: ble*config will be ingored if esl*config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
         */
        type?: pulumi.Input<string>;
        /**
         * Only if `type`==`imagotag` or `type`==`native`
         */
        verifyCert?: pulumi.Input<boolean>;
        /**
         * Only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface DeviceprofileApIpConfig {
        /**
         * if `type`==`static`
         */
        dns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * required if `type`==`static`
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * required if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        gateway6?: pulumi.Input<string>;
        /**
         * required if `type`==`static`
         */
        ip?: pulumi.Input<string>;
        ip6?: pulumi.Input<string>;
        mtu?: pulumi.Input<number>;
        /**
         * required if `type`==`static`
         */
        netmask?: pulumi.Input<string>;
        netmask6?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        type6?: pulumi.Input<string>;
        /**
         * management vlan id, default is 1 (untagged)
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface DeviceprofileApLed {
        brightness?: pulumi.Input<number>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileApMesh {
        /**
         * whether mesh is enabled on this AP
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
         */
        group?: pulumi.Input<number>;
        /**
         * enum: `base`, `remote`
         */
        role?: pulumi.Input<string>;
    }

    export interface DeviceprofileApPwrConfig {
        /**
         * additional power to request during negotiating with PSE over PoE, in mW
         */
        base?: pulumi.Input<number>;
        /**
         * whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
         */
        preferUsbOverWifi?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileApRadioConfig {
        allowRrmDisable?: pulumi.Input<boolean>;
        /**
         * antenna gain for 2.4G - for models with external antenna only
         */
        antGain24?: pulumi.Input<number>;
        /**
         * antenna gain for 5G - for models with external antenna only
         */
        antGain5?: pulumi.Input<number>;
        /**
         * antenna gain for 6G - for models with external antenna only
         */
        antGain6?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * Radio Band AP settings
         */
        band24?: pulumi.Input<inputs.org.DeviceprofileApRadioConfigBand24>;
        /**
         * enum: `24`, `5`, `6`, `auto`
         */
        band24Usage?: pulumi.Input<string>;
        /**
         * Radio Band AP settings
         */
        band5?: pulumi.Input<inputs.org.DeviceprofileApRadioConfigBand5>;
        /**
         * Radio Band AP settings
         */
        band5On24Radio?: pulumi.Input<inputs.org.DeviceprofileApRadioConfigBand5On24Radio>;
        /**
         * Radio Band AP settings
         */
        band6?: pulumi.Input<inputs.org.DeviceprofileApRadioConfigBand6>;
        /**
         * to make an outdoor operate indoor.
         * for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
         */
        indoorUse?: pulumi.Input<boolean>;
        /**
         * whether scanning radio is enabled
         */
        scanningEnabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileApRadioConfigBand24 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface DeviceprofileApRadioConfigBand5 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface DeviceprofileApRadioConfigBand5On24Radio {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface DeviceprofileApRadioConfigBand6 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For Device. (primary) channel for the band, 0 means using the Site Setting
         */
        channel?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileApUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x?: pulumi.Input<boolean>;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileApUsbConfig {
        /**
         * only if `type`==`imagotag`
         */
        cacert?: pulumi.Input<string>;
        /**
         * only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
         */
        channel?: pulumi.Input<number>;
        /**
         * whether to enable any usb config
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * only if `type`==`imagotag`
         */
        host?: pulumi.Input<string>;
        /**
         * only if `type`==`imagotag`
         */
        port?: pulumi.Input<number>;
        /**
         * usb config type. enum: `hanshow`, `imagotag`, `solum`
         */
        type?: pulumi.Input<string>;
        /**
         * only if `type`==`imagotag`, whether to turn on SSL verification
         */
        verifyCert?: pulumi.Input<boolean>;
        /**
         * only if `type`==`solum` or `type`==`hanshow`
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayBgpConfig {
        authKey?: pulumi.Input<string>;
        /**
         * when bfdMultiplier is configured alone. Default:
         *   * 1000 if `type`==`external`
         *   * 350 `type`==`internal`
         */
        bfdMinimumInterval?: pulumi.Input<number>;
        /**
         * when bfdMinimumIntervalIsConfigured alone
         */
        bfdMultiplier?: pulumi.Input<number>;
        /**
         * BFD provides faster path failure detection and is enabled by default
         */
        disableBfd?: pulumi.Input<boolean>;
        export?: pulumi.Input<string>;
        /**
         * default export policies if no per-neighbor policies defined
         */
        exportPolicy?: pulumi.Input<string>;
        /**
         * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
         * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
         */
        extendedV4Nexthop?: pulumi.Input<boolean>;
        /**
         * `0` means disable
         */
        gracefulRestartTime?: pulumi.Input<number>;
        holdTime?: pulumi.Input<number>;
        import?: pulumi.Input<string>;
        /**
         * default import policies if no per-neighbor policies defined
         */
        importPolicy?: pulumi.Input<string>;
        localAs?: pulumi.Input<number>;
        neighborAs?: pulumi.Input<number>;
        /**
         * if per-neighbor as is desired. Property key is the neighbor address
         */
        neighbors?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayBgpConfigNeighbors>}>;
        /**
         * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * by default, we'll re-advertise all learned BGP routers toward overlay
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * if `type`==`tunnel`
         */
        tunnelName?: pulumi.Input<string>;
        /**
         * enum: `external`, `internal`
         */
        type?: pulumi.Input<string>;
        /**
         * network name. enum: `lan`, `tunnel`, `vpn`, `wan`
         */
        via?: pulumi.Input<string>;
        vpnName?: pulumi.Input<string>;
        /**
         * if `via`==`wan`
         */
        wanName?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayBgpConfigNeighbors {
        /**
         * If true, the BGP session to this neighbor will be administratively disabled/shutdown
         */
        disabled?: pulumi.Input<boolean>;
        exportPolicy?: pulumi.Input<string>;
        holdTime?: pulumi.Input<number>;
        importPolicy?: pulumi.Input<string>;
        /**
         * assuming BGP neighbor is directly connected
         */
        multihopTtl?: pulumi.Input<number>;
        neighborAs?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayDhcpdConfig {
        /**
         * Property key is the network name
         */
        config?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayDhcpdConfigConfig>}>;
        /**
         * if set to `false`, disable the DHCP server
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfig {
        /**
         * if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
         */
        fixedBindings?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayDhcpdConfigConfigFixedBindings>}>;
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`local`
         */
        ipEnd?: pulumi.Input<string>;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: pulumi.Input<string>;
        /**
         * if `type`==`local`
         */
        ipStart?: pulumi.Input<string>;
        /**
         * if `type6`==`local`
         */
        ipStart6?: pulumi.Input<string>;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime?: pulumi.Input<number>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is the DHCP option number
         */
        options?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayDhcpdConfigConfigOptions>}>;
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride?: pulumi.Input<boolean>;
        /**
         * if `type`==`relay`
         */
        servers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type6`==`relay`
         */
        servers6s?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6?: pulumi.Input<string>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapsulated?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulated>}>;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfigFixedBindings {
        ip: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayDhcpdConfigConfigVendorEncapsulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayExtraRoutes {
        via: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayExtraRoutes6 {
        via: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayIdpProfiles {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        orgId?: pulumi.Input<string>;
        overwrites?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayIdpProfilesOverwrite>[]>;
    }

    export interface DeviceprofileGatewayIdpProfilesOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action?: pulumi.Input<string>;
        matching?: pulumi.Input<inputs.org.DeviceprofileGatewayIdpProfilesOverwriteMatching>;
        name?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayIdpProfilesOverwriteMatching {
        attackNames?: pulumi.Input<pulumi.Input<string>[]>;
        dstSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        severities?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayIpConfigs {
        ip: pulumi.Input<string>;
        netmask: pulumi.Input<string>;
        /**
         * optional list of secondary IPs in CIDR format
         */
        secondaryIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayNetwork {
        /**
         * whether to disallow Mist Devices in the network
         */
        disallowMistServices?: pulumi.Input<boolean>;
        gateway?: pulumi.Input<string>;
        gateway6?: pulumi.Input<string>;
        internalAccess?: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkInternalAccess>;
        /**
         * whether this network has direct internet access
         */
        internetAccess?: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkInternetAccess>;
        /**
         * whether to allow clients in the network to talk to each other
         */
        isolation?: pulumi.Input<boolean>;
        /**
         * whether to enable multicast support (only PIM-sparse mode is supported)
         */
        multicast?: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkMulticast>;
        name: pulumi.Input<string>;
        /**
         * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
         */
        routedForNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        subnet: pulumi.Input<string>;
        subnet6?: pulumi.Input<string>;
        tenants?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkTenants>}>;
        vlanId?: pulumi.Input<string>;
        /**
         * Property key is the VPN name. Whether this network can be accessed from vpn
         */
        vpnAccess?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkVpnAccess>}>;
    }

    export interface DeviceprofileGatewayNetworkInternalAccess {
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayNetworkInternetAccess {
        createSimpleServicePolicy?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkInternetAccessDestinationNat>}>;
        enabled?: pulumi.Input<boolean>;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkInternetAccessStaticNat>}>;
    }

    export interface DeviceprofileGatewayNetworkInternetAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayNetworkInternetAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayNetworkMulticast {
        /**
         * if the network will only be the soruce of the multicast traffic, IGMP can be disabled
         */
        disableIgmp?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
         */
        groups?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkMulticastGroups>}>;
    }

    export interface DeviceprofileGatewayNetworkMulticastGroups {
        /**
         * RP (rendezvous point) IP Address
         */
        rpIp?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayNetworkTenants {
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayNetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: pulumi.Input<string>;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkVpnAccessDestinationNat>}>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp?: pulumi.Input<boolean>;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf?: pulumi.Input<boolean>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether this network is routable
         */
        routed?: pulumi.Input<boolean>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat?: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkVpnAccessSourceNat>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayNetworkVpnAccessStaticNat>}>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: pulumi.Input<string>;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayNetworkVpnAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayNetworkVpnAccessSourceNat {
        externalIp?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayNetworkVpnAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayOobIpConfig {
        /**
         * if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`static`
         */
        ip?: pulumi.Input<string>;
        /**
         * if `type`==`static`
         */
        netmask?: pulumi.Input<string>;
        /**
         * for HA Cluster, node1 can have different IP Config
         */
        node1?: pulumi.Input<inputs.org.DeviceprofileGatewayOobIpConfigNode1>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
        vlanId?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayOobIpConfigNode1 {
        /**
         * if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * whether to use `mgmtJunos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
        vlanId?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPathPreferences {
        paths?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayPathPreferencesPath>[]>;
        /**
         * enum: `ecmp`, `ordered`, `weighted`
         */
        strategy?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPathPreferencesPath {
        cost?: pulumi.Input<number>;
        /**
         * For SSR Only. `true`, if this specific path is undesired
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * only if `type`==`local`, if a different gateway is desired
         */
        gatewayIp?: pulumi.Input<string>;
        /**
         * only if `type`==`vpn`, if this vpn path can be used for internet
         */
        internetAccess?: pulumi.Input<boolean>;
        /**
         * required when 
         *   * `type`==`vpn`: the name of the VPN Path to use 
         *   * `type`==`wan`: the name of the WAN interface to use'
         */
        name?: pulumi.Input<string>;
        /**
         * required when `type`==`local`
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local`, if destination IP is to be replaced
         */
        targetIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `local`, `tunnel`, `vpn`, `wan`
         */
        type?: pulumi.Input<string>;
        /**
         * optional if `type`==`vpn`
         */
        wanName?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPortConfig {
        /**
         * if `aggregated`==`true`. To disable LCP support for the AE interface
         */
        aeDisableLacp?: pulumi.Input<boolean>;
        /**
         * if `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
         */
        aeIdx?: pulumi.Input<string>;
        /**
         * For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability.\n
         * Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end\n
         * Note: Turning this on will enable force-up on one of the interfaces in the bundle only
         */
        aeLacpForceUp?: pulumi.Input<boolean>;
        aggregated?: pulumi.Input<boolean>;
        /**
         * if want to generate port up/down alarm, set it to true
         */
        critical?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * port admin up (true) / down (false)
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * if `wanType`==`dsl`. enum: `adsl`, `vdsl`
         */
        dslType?: pulumi.Input<string>;
        /**
         * if `wanType`==`dsl`
         * 16 bit int
         */
        dslVci?: pulumi.Input<number>;
        /**
         * if `wanType`==`dsl`
         * 8 bit int
         */
        dslVpi?: pulumi.Input<number>;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Junos IP Config
         */
        ipConfig?: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigIpConfig>;
        /**
         * if `wanType`==`lte`
         */
        lteApn?: pulumi.Input<string>;
        /**
         * if `wanType`==`lte`. enum: `chap`, `none`, `pap`
         */
        lteAuth?: pulumi.Input<string>;
        lteBackup?: pulumi.Input<boolean>;
        /**
         * if `wanType`==`lte`
         */
        ltePassword?: pulumi.Input<string>;
        /**
         * if `wanType`==`lte`
         */
        lteUsername?: pulumi.Input<string>;
        mtu?: pulumi.Input<number>;
        /**
         * name that we'll use to derive config
         */
        name?: pulumi.Input<string>;
        /**
         * if `usage`==`lan`
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for Q-in-Q
         */
        outerVlanId?: pulumi.Input<number>;
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * if `usage`==`lan`
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * whether to preserve dscp when sending traffic over VPN (SSR-only)
         */
        preserveDscp?: pulumi.Input<boolean>;
        /**
         * if HA mode
         */
        redundant?: pulumi.Input<boolean>;
        /**
         * if HA mode
         */
        rethIdx?: pulumi.Input<number>;
        /**
         * if HA mode
         */
        rethNode?: pulumi.Input<string>;
        /**
         * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
         */
        rethNodes?: pulumi.Input<pulumi.Input<string>[]>;
        speed?: pulumi.Input<string>;
        /**
         * when SSR is running as VM, this is required on certain hosting platforms
         */
        ssrNoVirtualMac?: pulumi.Input<boolean>;
        /**
         * for SSR only
         */
        svrPortRange?: pulumi.Input<string>;
        trafficShaping?: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigTrafficShaping>;
        /**
         * port usage name. enum: `haControl`, `haData`, `lan`, `wan`
         */
        usage: pulumi.Input<string>;
        /**
         * if WAN interface is on a VLAN
         */
        vlanId?: pulumi.Input<number>;
        /**
         * Property key is the VPN name
         */
        vpnPaths?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigVpnPaths>}>;
        /**
         * when `wanType`==`broadband`. enum: `default`, `max`, `recommended`
         */
        wanArpPolicer?: pulumi.Input<string>;
        /**
         * optional, if spoke should reach this port by a different IP
         */
        wanExtIp?: pulumi.Input<string>;
        /**
         * Property Key is the destianation CIDR (e.g "100.100.100.0/24")
         */
        wanExtraRoutes?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigWanExtraRoutes>}>;
        /**
         * if `usage`==`wan`
         */
        wanProbeOverride?: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigWanProbeOverride>;
        /**
         * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
         */
        wanSourceNat?: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigWanSourceNat>;
        /**
         * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
         */
        wanType?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPortConfigIpConfig {
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * optional, the network to be used for mgmt
         */
        network?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`
         */
        poserPassword?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
         */
        pppoeAuth?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`
         */
        pppoeUsername?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `pppoe`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPortConfigTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: pulumi.Input<pulumi.Input<number>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayPortConfigVpnPaths {
        /**
         * Only if the VPN `type`==`hubSpoke`. enum: `broadband`, `lte`
         */
        bfdProfile?: pulumi.Input<string>;
        /**
         * Only if the VPN `type`==`hubSpoke`. Whether to use tunnel mode. SSR only
         */
        bfdUseTunnelMode?: pulumi.Input<boolean>;
        /**
         * Only if the VPN `type`==`mesh`
         */
        linkName?: pulumi.Input<string>;
        /**
         * Only if the VPN `type`==`hubSpoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
         */
        preference?: pulumi.Input<number>;
        /**
         * Only if the VPN `type`==`hubSpoke`. enum: `hub`, `spoke`
         */
        role?: pulumi.Input<string>;
        trafficShaping?: pulumi.Input<inputs.org.DeviceprofileGatewayPortConfigVpnPathsTrafficShaping>;
    }

    export interface DeviceprofileGatewayPortConfigVpnPathsTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: pulumi.Input<pulumi.Input<number>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayPortConfigWanExtraRoutes {
        via?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPortConfigWanProbeOverride {
        ips?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `broadband`, `lte`
         */
        probeProfile?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayPortConfigWanSourceNat {
        /**
         * or to disable the source-nat
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * if alternative natPool is desired
         */
        natPool?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayRoutingPolicies {
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        terms?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayRoutingPoliciesTerm>[]>;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTerm {
        /**
         * when used as import policy
         */
        action?: pulumi.Input<inputs.org.DeviceprofileGatewayRoutingPoliciesTermAction>;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        matching?: pulumi.Input<inputs.org.DeviceprofileGatewayRoutingPoliciesTermMatching>;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermAction {
        accept?: pulumi.Input<boolean>;
        addCommunities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for SSR, hub decides how VRF routes are leaked on spoke
         */
        addTargetVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional
         */
        communities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional. To exclude certain AS
         */
        excludeAsPaths?: pulumi.Input<pulumi.Input<string>[]>;
        excludeCommunities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional
         */
        exportCommunitites?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * optional, for an import policy, localPreference can be changed
         */
        localPreference?: pulumi.Input<string>;
        /**
         * when used as export policy, optional. By default, the local AS will be prepended, to change it
         */
        prependAsPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermMatching {
        /**
         * takes regular expression
         */
        asPaths?: pulumi.Input<pulumi.Input<string>[]>;
        communities?: pulumi.Input<pulumi.Input<string>[]>;
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        prefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * `direct`, `bgp`, `osp`, ...
         */
        protocols?: pulumi.Input<pulumi.Input<string>[]>;
        routeExists?: pulumi.Input<inputs.org.DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists>;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         */
        vpnNeighborMacs?: pulumi.Input<pulumi.Input<string>[]>;
        vpnPathSla?: pulumi.Input<inputs.org.DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla>;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         * ordered-
         */
        vpnPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists {
        route?: pulumi.Input<string>;
        /**
         * name of the vrf instance
         * it can also be the name of the VPN or wan if they
         */
        vrfName?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla {
        maxJitter?: pulumi.Input<number>;
        maxLatency?: pulumi.Input<number>;
        maxLoss?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayServicePolicy {
        /**
         * Required when `servicepolicyId` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
         */
        action?: pulumi.Input<string>;
        /**
         * For SRX Only
         */
        appqoe?: pulumi.Input<inputs.org.DeviceprofileGatewayServicePolicyAppqoe>;
        ewfs?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayServicePolicyEwf>[]>;
        idp?: pulumi.Input<inputs.org.DeviceprofileGatewayServicePolicyIdp>;
        /**
         * access within the same VRF
         */
        localRouting?: pulumi.Input<boolean>;
        /**
         * Required when `servicepolicyId` is not defined, optional otherwise (override the servicepolicy name)
         */
        name?: pulumi.Input<string>;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference?: pulumi.Input<string>;
        /**
         * used to link servicepolicy defined at org level and overwrite some attributes
         */
        servicepolicyId?: pulumi.Input<string>;
        /**
         * Required when `servicepolicyId` is not defined. List of Applications / Desctinations
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required when `servicepolicyId` is not defined. List of Networks / Users
         */
        tenants?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayServicePolicyAppqoe {
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayServicePolicyEwf {
        alertOnly?: pulumi.Input<boolean>;
        blockMessage?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayServicePolicyIdp {
        alertOnly?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: pulumi.Input<string>;
        /**
         * enum: `Custom`, `strict` (default), `standard` or keys from from idp_profiles
         */
        profile?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayTunnelConfigs {
        autoProvision?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsAutoProvision>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        ikeLifetime?: pulumi.Input<number>;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
         */
        ikeMode?: pulumi.Input<string>;
        /**
         * if `provider`== `custom-ipsec`
         */
        ikeProposals?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsIkeProposal>[]>;
        /**
         * if `provider`== `custom-ipsec`
         */
        ipsecLifetime?: pulumi.Input<number>;
        /**
         * Only if  `provider`== `custom-ipsec`
         */
        ipsecProposals?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsIpsecProposal>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        localId?: pulumi.Input<string>;
        /**
         * enum: `active-active`, `active-standby`
         */
        mode?: pulumi.Input<string>;
        /**
         * networks reachable via this tunnel
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        primary?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsPrimary>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        probe?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsProbe>;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
         */
        protocol?: pulumi.Input<string>;
        /**
         * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
         */
        provider?: pulumi.Input<string>;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        psk?: pulumi.Input<string>;
        secondary?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsSecondary>;
        /**
         * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
         */
        version?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvision {
        enable?: pulumi.Input<boolean>;
        latlng?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng>;
        primary?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary>;
        secondary?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary>;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvisionLatlng {
        lat: pulumi.Input<number>;
        lng: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvisionPrimary {
        numHosts?: pulumi.Input<string>;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayTunnelConfigsAutoProvisionSecondary {
        numHosts?: pulumi.Input<string>;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayTunnelConfigsIkeProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: pulumi.Input<string>;
        /**
         * enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup?: pulumi.Input<string>;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayTunnelConfigsIpsecProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: pulumi.Input<string>;
        /**
         * Only if `provider`== `custom-ipsec`. enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup?: pulumi.Input<string>;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayTunnelConfigsPrimary {
        hosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: pulumi.Input<pulumi.Input<string>[]>;
        probeIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: pulumi.Input<pulumi.Input<string>[]>;
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayTunnelConfigsProbe {
        /**
         * how often to trigger the probe
         */
        interval?: pulumi.Input<number>;
        /**
         * number of consecutive misses before declaring the tunnel down
         */
        threshold?: pulumi.Input<number>;
        /**
         * time within which to complete the connectivity check
         */
        timeout?: pulumi.Input<number>;
        /**
         * enum: `http`, `icmp`
         */
        type?: pulumi.Input<string>;
    }

    export interface DeviceprofileGatewayTunnelConfigsSecondary {
        hosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: pulumi.Input<pulumi.Input<string>[]>;
        probeIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: pulumi.Input<pulumi.Input<string>[]>;
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeviceprofileGatewayTunnelProviderOptions {
        /**
         * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
         */
        jse?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelProviderOptionsJse>;
        /**
         * for zscaler-ipsec and zscaler-gre
         */
        zscaler?: pulumi.Input<inputs.org.DeviceprofileGatewayTunnelProviderOptionsZscaler>;
    }

    export interface DeviceprofileGatewayTunnelProviderOptionsJse {
        name?: pulumi.Input<string>;
        numUsers?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayTunnelProviderOptionsZscaler {
        aupAcceptanceRequired?: pulumi.Input<boolean>;
        /**
         * days before AUP is requested again
         */
        aupExpire?: pulumi.Input<number>;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy?: pulumi.Input<boolean>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: pulumi.Input<number>;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: pulumi.Input<boolean>;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution?: pulumi.Input<boolean>;
        enforceAuthentication?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        /**
         * if `useXff`==`true`
         */
        subLocations?: pulumi.Input<pulumi.Input<inputs.org.DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation>[]>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: pulumi.Input<number>;
        /**
         * location uses proxy chaining to forward traffic
         */
        useXff?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation {
        aupAcceptanceRequired?: pulumi.Input<boolean>;
        /**
         * days before AUP is requested again
         */
        aupExpire?: pulumi.Input<number>;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy?: pulumi.Input<boolean>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: pulumi.Input<number>;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: pulumi.Input<boolean>;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution?: pulumi.Input<boolean>;
        enforceAuthentication?: pulumi.Input<boolean>;
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: pulumi.Input<number>;
    }

    export interface DeviceprofileGatewayVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface DeviceprofileGatewayVrfInstances {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EvpnTopologyEvpnOptions {
        /**
         * optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
         */
        autoLoopbackSubnet?: pulumi.Input<string>;
        /**
         * optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
         */
        autoLoopbackSubnet6?: pulumi.Input<string>;
        /**
         * optional, this generates routerId automatically, if specified, `routerIdPrefix` is ignored
         */
        autoRouterIdSubnet?: pulumi.Input<string>;
        /**
         * optional, this generates routerId automatically, if specified, `routerIdPrefix` is ignored
         */
        autoRouterIdSubnet6?: pulumi.Input<string>;
        /**
         * optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway
         * when `routedAt` != `core`, whether to do virtual-gateway at core as well
         */
        coreAsBorder?: pulumi.Input<boolean>;
        overlay?: pulumi.Input<inputs.org.EvpnTopologyEvpnOptionsOverlay>;
        /**
         * by default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4Mac
         * if enabled, 00-00-5e-00-XX-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
         */
        perVlanVgaV4Mac?: pulumi.Input<boolean>;
        /**
         * optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
         */
        routedAt?: pulumi.Input<string>;
        underlay?: pulumi.Input<inputs.org.EvpnTopologyEvpnOptionsUnderlay>;
        /**
         * optional, for EX9200 only to seggregate virtual-switches
         */
        vsInstances?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.EvpnTopologyEvpnOptionsVsInstances>}>;
    }

    export interface EvpnTopologyEvpnOptionsOverlay {
        /**
         * Overlay BGP Local AS Number
         */
        as?: pulumi.Input<number>;
    }

    export interface EvpnTopologyEvpnOptionsUnderlay {
        /**
         * Underlay BGP Base AS Number
         */
        asBase?: pulumi.Input<number>;
        routedIdPrefix?: pulumi.Input<string>;
        /**
         * underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
         */
        subnet?: pulumi.Input<string>;
        /**
         * if v6 is desired for underlay
         */
        useIpv6?: pulumi.Input<boolean>;
    }

    export interface EvpnTopologyEvpnOptionsVsInstances {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EvpnTopologySwitches {
        deviceprofileId?: pulumi.Input<string>;
        evpnId?: pulumi.Input<number>;
        mac?: pulumi.Input<string>;
        model?: pulumi.Input<string>;
        /**
         * optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
         *   * for CLOS, to group dist / access switches into pods
         *   * for ERB/CRB, to group dist / esilag-access into pods
         */
        pod?: pulumi.Input<number>;
        /**
         * by default, core switches are assumed to be connecting all pods. 
         * if you want to limit the pods, you can specify pods.
         */
        pods?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
         */
        role: pulumi.Input<string>;
        routerId?: pulumi.Input<string>;
        siteId?: pulumi.Input<string>;
    }

    export interface GatewaytemplateBgpConfig {
        authKey?: pulumi.Input<string>;
        /**
         * when bfdMultiplier is configured alone. Default:
         *   * 1000 if `type`==`external`
         *   * 350 `type`==`internal`
         */
        bfdMinimumInterval?: pulumi.Input<number>;
        /**
         * when bfdMinimumIntervalIsConfigured alone
         */
        bfdMultiplier?: pulumi.Input<number>;
        /**
         * BFD provides faster path failure detection and is enabled by default
         */
        disableBfd?: pulumi.Input<boolean>;
        export?: pulumi.Input<string>;
        /**
         * default export policies if no per-neighbor policies defined
         */
        exportPolicy?: pulumi.Input<string>;
        /**
         * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
         * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
         */
        extendedV4Nexthop?: pulumi.Input<boolean>;
        /**
         * `0` means disable
         */
        gracefulRestartTime?: pulumi.Input<number>;
        holdTime?: pulumi.Input<number>;
        import?: pulumi.Input<string>;
        /**
         * default import policies if no per-neighbor policies defined
         */
        importPolicy?: pulumi.Input<string>;
        localAs?: pulumi.Input<number>;
        neighborAs?: pulumi.Input<number>;
        /**
         * if per-neighbor as is desired. Property key is the neighbor address
         */
        neighbors?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateBgpConfigNeighbors>}>;
        /**
         * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * by default, we'll re-advertise all learned BGP routers toward overlay
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * if `type`==`tunnel`
         */
        tunnelName?: pulumi.Input<string>;
        /**
         * enum: `external`, `internal`
         */
        type?: pulumi.Input<string>;
        /**
         * network name. enum: `lan`, `tunnel`, `vpn`, `wan`
         */
        via?: pulumi.Input<string>;
        vpnName?: pulumi.Input<string>;
        /**
         * if `via`==`wan`
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewaytemplateBgpConfigNeighbors {
        /**
         * If true, the BGP session to this neighbor will be administratively disabled/shutdown
         */
        disabled?: pulumi.Input<boolean>;
        exportPolicy?: pulumi.Input<string>;
        holdTime?: pulumi.Input<number>;
        importPolicy?: pulumi.Input<string>;
        /**
         * assuming BGP neighbor is directly connected
         */
        multihopTtl?: pulumi.Input<number>;
        neighborAs?: pulumi.Input<number>;
    }

    export interface GatewaytemplateDhcpdConfig {
        /**
         * Property key is the network name
         */
        config?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateDhcpdConfigConfig>}>;
        /**
         * if set to `false`, disable the DHCP server
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplateDhcpdConfigConfig {
        /**
         * if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
         */
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
         */
        fixedBindings?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateDhcpdConfigConfigFixedBindings>}>;
        /**
         * if `type`==`local` - optional, `ip` will be used if not provided
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`local`
         */
        ipEnd?: pulumi.Input<string>;
        /**
         * if `type6`==`local`
         */
        ipEnd6?: pulumi.Input<string>;
        /**
         * if `type`==`local`
         */
        ipStart?: pulumi.Input<string>;
        /**
         * if `type6`==`local`
         */
        ipStart6?: pulumi.Input<string>;
        /**
         * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
         */
        leaseTime?: pulumi.Input<number>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is the DHCP option number
         */
        options?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateDhcpdConfigConfigOptions>}>;
        /**
         * `serverIdOverride`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
         * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
         */
        serverIdOverride?: pulumi.Input<boolean>;
        /**
         * if `type`==`relay`
         */
        servers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type6`==`relay`
         */
        servers6s?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type?: pulumi.Input<string>;
        /**
         * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
         */
        type6?: pulumi.Input<string>;
        /**
         * if `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with
         *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
         *   * sub option code: 1-255, sub-option code'
         */
        vendorEncapsulated?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateDhcpdConfigConfigVendorEncapsulated>}>;
    }

    export interface GatewaytemplateDhcpdConfigConfigFixedBindings {
        ip: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface GatewaytemplateDhcpdConfigConfigOptions {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GatewaytemplateDhcpdConfigConfigVendorEncapsulated {
        /**
         * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
         */
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GatewaytemplateExtraRoutes {
        via: pulumi.Input<string>;
    }

    export interface GatewaytemplateExtraRoutes6 {
        via: pulumi.Input<string>;
    }

    export interface GatewaytemplateIdpProfiles {
        /**
         * enum: `critical`, `standard`, `strict`
         */
        baseProfile?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        orgId?: pulumi.Input<string>;
        overwrites?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplateIdpProfilesOverwrite>[]>;
    }

    export interface GatewaytemplateIdpProfilesOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action?: pulumi.Input<string>;
        matching?: pulumi.Input<inputs.org.GatewaytemplateIdpProfilesOverwriteMatching>;
        name?: pulumi.Input<string>;
    }

    export interface GatewaytemplateIdpProfilesOverwriteMatching {
        attackNames?: pulumi.Input<pulumi.Input<string>[]>;
        dstSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        severities?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateIpConfigs {
        ip: pulumi.Input<string>;
        netmask: pulumi.Input<string>;
        /**
         * optional list of secondary IPs in CIDR format
         */
        secondaryIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface GatewaytemplateNetwork {
        /**
         * whether to disallow Mist Devices in the network
         */
        disallowMistServices?: pulumi.Input<boolean>;
        gateway?: pulumi.Input<string>;
        gateway6?: pulumi.Input<string>;
        internalAccess?: pulumi.Input<inputs.org.GatewaytemplateNetworkInternalAccess>;
        /**
         * whether this network has direct internet access
         */
        internetAccess?: pulumi.Input<inputs.org.GatewaytemplateNetworkInternetAccess>;
        /**
         * whether to allow clients in the network to talk to each other
         */
        isolation?: pulumi.Input<boolean>;
        /**
         * whether to enable multicast support (only PIM-sparse mode is supported)
         */
        multicast?: pulumi.Input<inputs.org.GatewaytemplateNetworkMulticast>;
        name: pulumi.Input<string>;
        /**
         * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
         */
        routedForNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        subnet: pulumi.Input<string>;
        subnet6?: pulumi.Input<string>;
        tenants?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkTenants>}>;
        vlanId?: pulumi.Input<string>;
        /**
         * Property key is the VPN name. Whether this network can be accessed from vpn
         */
        vpnAccess?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkVpnAccess>}>;
    }

    export interface GatewaytemplateNetworkInternalAccess {
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplateNetworkInternetAccess {
        createSimpleServicePolicy?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkInternetAccessDestinationNat>}>;
        enabled?: pulumi.Input<boolean>;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkInternetAccessStaticNat>}>;
    }

    export interface GatewaytemplateNetworkInternetAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface GatewaytemplateNetworkInternetAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewaytemplateNetworkMulticast {
        /**
         * if the network will only be the soruce of the multicast traffic, IGMP can be disabled
         */
        disableIgmp?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example "225.1.0.3/32")
         */
        groups?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkMulticastGroups>}>;
    }

    export interface GatewaytemplateNetworkMulticastGroups {
        /**
         * RP (rendezvous point) IP Address
         */
        rpIp?: pulumi.Input<string>;
    }

    export interface GatewaytemplateNetworkTenants {
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateNetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: pulumi.Input<string>;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkVpnAccessDestinationNat>}>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp?: pulumi.Input<boolean>;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf?: pulumi.Input<boolean>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether this network is routable
         */
        routed?: pulumi.Input<boolean>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat?: pulumi.Input<inputs.org.GatewaytemplateNetworkVpnAccessSourceNat>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplateNetworkVpnAccessStaticNat>}>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: pulumi.Input<string>;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: pulumi.Input<string>;
    }

    export interface GatewaytemplateNetworkVpnAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface GatewaytemplateNetworkVpnAccessSourceNat {
        externalIp?: pulumi.Input<string>;
    }

    export interface GatewaytemplateNetworkVpnAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewaytemplateOobIpConfig {
        /**
         * if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        /**
         * if `type`==`static`
         */
        ip?: pulumi.Input<string>;
        /**
         * if `type`==`static`
         */
        netmask?: pulumi.Input<string>;
        /**
         * for HA Cluster, node1 can have different IP Config
         */
        node1?: pulumi.Input<inputs.org.GatewaytemplateOobIpConfigNode1>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
        vlanId?: pulumi.Input<string>;
    }

    export interface GatewaytemplateOobIpConfigNode1 {
        /**
         * if `type`==`static`
         */
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * whether to use `mgmtJunos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
        vlanId?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePathPreferences {
        paths?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplatePathPreferencesPath>[]>;
        /**
         * enum: `ecmp`, `ordered`, `weighted`
         */
        strategy?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePathPreferencesPath {
        cost?: pulumi.Input<number>;
        /**
         * For SSR Only. `true`, if this specific path is undesired
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * only if `type`==`local`, if a different gateway is desired
         */
        gatewayIp?: pulumi.Input<string>;
        /**
         * only if `type`==`vpn`, if this vpn path can be used for internet
         */
        internetAccess?: pulumi.Input<boolean>;
        /**
         * required when 
         *   * `type`==`vpn`: the name of the VPN Path to use 
         *   * `type`==`wan`: the name of the WAN interface to use'
         */
        name?: pulumi.Input<string>;
        /**
         * required when `type`==`local`
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if `type`==`local`, if destination IP is to be replaced
         */
        targetIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `local`, `tunnel`, `vpn`, `wan`
         */
        type?: pulumi.Input<string>;
        /**
         * optional if `type`==`vpn`
         */
        wanName?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePortConfig {
        /**
         * if `aggregated`==`true`. To disable LCP support for the AE interface
         */
        aeDisableLacp?: pulumi.Input<boolean>;
        /**
         * if `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)
         */
        aeIdx?: pulumi.Input<string>;
        /**
         * For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability.\n
         * Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end\n
         * Note: Turning this on will enable force-up on one of the interfaces in the bundle only
         */
        aeLacpForceUp?: pulumi.Input<boolean>;
        aggregated?: pulumi.Input<boolean>;
        /**
         * if want to generate port up/down alarm, set it to true
         */
        critical?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * port admin up (true) / down (false)
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * if `wanType`==`dsl`. enum: `adsl`, `vdsl`
         */
        dslType?: pulumi.Input<string>;
        /**
         * if `wanType`==`dsl`
         * 16 bit int
         */
        dslVci?: pulumi.Input<number>;
        /**
         * if `wanType`==`dsl`
         * 8 bit int
         */
        dslVpi?: pulumi.Input<number>;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Junos IP Config
         */
        ipConfig?: pulumi.Input<inputs.org.GatewaytemplatePortConfigIpConfig>;
        /**
         * if `wanType`==`lte`
         */
        lteApn?: pulumi.Input<string>;
        /**
         * if `wanType`==`lte`. enum: `chap`, `none`, `pap`
         */
        lteAuth?: pulumi.Input<string>;
        lteBackup?: pulumi.Input<boolean>;
        /**
         * if `wanType`==`lte`
         */
        ltePassword?: pulumi.Input<string>;
        /**
         * if `wanType`==`lte`
         */
        lteUsername?: pulumi.Input<string>;
        mtu?: pulumi.Input<number>;
        /**
         * name that we'll use to derive config
         */
        name?: pulumi.Input<string>;
        /**
         * if `usage`==`lan`
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for Q-in-Q
         */
        outerVlanId?: pulumi.Input<number>;
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * if `usage`==`lan`
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * whether to preserve dscp when sending traffic over VPN (SSR-only)
         */
        preserveDscp?: pulumi.Input<boolean>;
        /**
         * if HA mode
         */
        redundant?: pulumi.Input<boolean>;
        /**
         * if HA mode
         */
        rethIdx?: pulumi.Input<number>;
        /**
         * if HA mode
         */
        rethNode?: pulumi.Input<string>;
        /**
         * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
         */
        rethNodes?: pulumi.Input<pulumi.Input<string>[]>;
        speed?: pulumi.Input<string>;
        /**
         * when SSR is running as VM, this is required on certain hosting platforms
         */
        ssrNoVirtualMac?: pulumi.Input<boolean>;
        /**
         * for SSR only
         */
        svrPortRange?: pulumi.Input<string>;
        trafficShaping?: pulumi.Input<inputs.org.GatewaytemplatePortConfigTrafficShaping>;
        /**
         * port usage name. enum: `haControl`, `haData`, `lan`, `wan`
         */
        usage: pulumi.Input<string>;
        /**
         * if WAN interface is on a VLAN
         */
        vlanId?: pulumi.Input<number>;
        /**
         * Property key is the VPN name
         */
        vpnPaths?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplatePortConfigVpnPaths>}>;
        /**
         * when `wanType`==`broadband`. enum: `default`, `max`, `recommended`
         */
        wanArpPolicer?: pulumi.Input<string>;
        /**
         * optional, if spoke should reach this port by a different IP
         */
        wanExtIp?: pulumi.Input<string>;
        /**
         * Property Key is the destianation CIDR (e.g "100.100.100.0/24")
         */
        wanExtraRoutes?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.GatewaytemplatePortConfigWanExtraRoutes>}>;
        /**
         * if `usage`==`wan`
         */
        wanProbeOverride?: pulumi.Input<inputs.org.GatewaytemplatePortConfigWanProbeOverride>;
        /**
         * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
         */
        wanSourceNat?: pulumi.Input<inputs.org.GatewaytemplatePortConfigWanSourceNat>;
        /**
         * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
         */
        wanType?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePortConfigIpConfig {
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        dnsSuffixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * except for out-of_band interface (vme/em0/fxp0)
         */
        gateway?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        /**
         * used only if `subnet` is not specified in `networks`
         */
        netmask?: pulumi.Input<string>;
        /**
         * optional, the network to be used for mgmt
         */
        network?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`
         */
        poserPassword?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
         */
        pppoeAuth?: pulumi.Input<string>;
        /**
         * if `type`==`pppoe`
         */
        pppoeUsername?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `pppoe`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePortConfigTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: pulumi.Input<pulumi.Input<number>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplatePortConfigVpnPaths {
        /**
         * Only if the VPN `type`==`hubSpoke`. enum: `broadband`, `lte`
         */
        bfdProfile?: pulumi.Input<string>;
        /**
         * Only if the VPN `type`==`hubSpoke`. Whether to use tunnel mode. SSR only
         */
        bfdUseTunnelMode?: pulumi.Input<boolean>;
        /**
         * Only if the VPN `type`==`mesh`
         */
        linkName?: pulumi.Input<string>;
        /**
         * Only if the VPN `type`==`hubSpoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
         */
        preference?: pulumi.Input<number>;
        /**
         * Only if the VPN `type`==`hubSpoke`. enum: `hub`, `spoke`
         */
        role?: pulumi.Input<string>;
        trafficShaping?: pulumi.Input<inputs.org.GatewaytemplatePortConfigVpnPathsTrafficShaping>;
    }

    export interface GatewaytemplatePortConfigVpnPathsTrafficShaping {
        /**
         * percentages for differet class of traffic: high / medium / low / best-effort
         * sum must be equal to 100
         */
        classPercentages?: pulumi.Input<pulumi.Input<number>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplatePortConfigWanExtraRoutes {
        via?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePortConfigWanProbeOverride {
        ips?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `broadband`, `lte`
         */
        probeProfile?: pulumi.Input<string>;
    }

    export interface GatewaytemplatePortConfigWanSourceNat {
        /**
         * or to disable the source-nat
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * if alternative natPool is desired
         */
        natPool?: pulumi.Input<string>;
    }

    export interface GatewaytemplateRoutingPolicies {
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        terms?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplateRoutingPoliciesTerm>[]>;
    }

    export interface GatewaytemplateRoutingPoliciesTerm {
        /**
         * when used as import policy
         */
        action?: pulumi.Input<inputs.org.GatewaytemplateRoutingPoliciesTermAction>;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        matching?: pulumi.Input<inputs.org.GatewaytemplateRoutingPoliciesTermMatching>;
    }

    export interface GatewaytemplateRoutingPoliciesTermAction {
        accept?: pulumi.Input<boolean>;
        addCommunities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for SSR, hub decides how VRF routes are leaked on spoke
         */
        addTargetVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional
         */
        communities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional. To exclude certain AS
         */
        excludeAsPaths?: pulumi.Input<pulumi.Input<string>[]>;
        excludeCommunities?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when used as export policy, optional
         */
        exportCommunitites?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * optional, for an import policy, localPreference can be changed
         */
        localPreference?: pulumi.Input<string>;
        /**
         * when used as export policy, optional. By default, the local AS will be prepended, to change it
         */
        prependAsPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateRoutingPoliciesTermMatching {
        /**
         * takes regular expression
         */
        asPaths?: pulumi.Input<pulumi.Input<string>[]>;
        communities?: pulumi.Input<pulumi.Input<string>[]>;
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * zero or more criteria/filter can be specified to match the term, all criteria have to be met
         */
        prefixes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * `direct`, `bgp`, `osp`, ...
         */
        protocols?: pulumi.Input<pulumi.Input<string>[]>;
        routeExists?: pulumi.Input<inputs.org.GatewaytemplateRoutingPoliciesTermMatchingRouteExists>;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         */
        vpnNeighborMacs?: pulumi.Input<pulumi.Input<string>[]>;
        vpnPathSla?: pulumi.Input<inputs.org.GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla>;
        /**
         * overlay-facing criteria (used for bgpConfig where via=vpn)
         * ordered-
         */
        vpnPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateRoutingPoliciesTermMatchingRouteExists {
        route?: pulumi.Input<string>;
        /**
         * name of the vrf instance
         * it can also be the name of the VPN or wan if they
         */
        vrfName?: pulumi.Input<string>;
    }

    export interface GatewaytemplateRoutingPoliciesTermMatchingVpnPathSla {
        maxJitter?: pulumi.Input<number>;
        maxLatency?: pulumi.Input<number>;
        maxLoss?: pulumi.Input<number>;
    }

    export interface GatewaytemplateServicePolicy {
        /**
         * Required when `servicepolicyId` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`
         */
        action?: pulumi.Input<string>;
        /**
         * For SRX Only
         */
        appqoe?: pulumi.Input<inputs.org.GatewaytemplateServicePolicyAppqoe>;
        ewfs?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplateServicePolicyEwf>[]>;
        idp?: pulumi.Input<inputs.org.GatewaytemplateServicePolicyIdp>;
        /**
         * access within the same VRF
         */
        localRouting?: pulumi.Input<boolean>;
        /**
         * Required when `servicepolicyId` is not defined, optional otherwise (override the servicepolicy name)
         */
        name?: pulumi.Input<string>;
        /**
         * by default, we derive all paths available and use them
         * optionally, you can customize by using `pathPreference`
         */
        pathPreference?: pulumi.Input<string>;
        /**
         * used to link servicepolicy defined at org level and overwrite some attributes
         */
        servicepolicyId?: pulumi.Input<string>;
        /**
         * Required when `servicepolicyId` is not defined. List of Applications / Desctinations
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Required when `servicepolicyId` is not defined. List of Networks / Users
         */
        tenants?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateServicePolicyAppqoe {
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplateServicePolicyEwf {
        alertOnly?: pulumi.Input<boolean>;
        blockMessage?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile?: pulumi.Input<string>;
    }

    export interface GatewaytemplateServicePolicyIdp {
        alertOnly?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: pulumi.Input<string>;
        /**
         * enum: `Custom`, `strict` (default), `standard` or keys from from idp_profiles
         */
        profile?: pulumi.Input<string>;
    }

    export interface GatewaytemplateTunnelConfigs {
        autoProvision?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsAutoProvision>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        ikeLifetime?: pulumi.Input<number>;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
         */
        ikeMode?: pulumi.Input<string>;
        /**
         * if `provider`== `custom-ipsec`
         */
        ikeProposals?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsIkeProposal>[]>;
        /**
         * if `provider`== `custom-ipsec`
         */
        ipsecLifetime?: pulumi.Input<number>;
        /**
         * Only if  `provider`== `custom-ipsec`
         */
        ipsecProposals?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsIpsecProposal>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        localId?: pulumi.Input<string>;
        /**
         * enum: `active-active`, `active-standby`
         */
        mode?: pulumi.Input<string>;
        /**
         * networks reachable via this tunnel
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        primary?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsPrimary>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        probe?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsProbe>;
        /**
         * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
         */
        protocol?: pulumi.Input<string>;
        /**
         * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
         */
        provider?: pulumi.Input<string>;
        /**
         * Only if:
         *   * `provider`== `zscaler-ipsec`
         *   * `provider`==`jse-ipsec`
         *   * `provider`== `custom-ipsec`
         */
        psk?: pulumi.Input<string>;
        secondary?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsSecondary>;
        /**
         * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
         */
        version?: pulumi.Input<string>;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvision {
        enable?: pulumi.Input<boolean>;
        latlng?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsAutoProvisionLatlng>;
        primary?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsAutoProvisionPrimary>;
        secondary?: pulumi.Input<inputs.org.GatewaytemplateTunnelConfigsAutoProvisionSecondary>;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvisionLatlng {
        lat: pulumi.Input<number>;
        lng: pulumi.Input<number>;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvisionPrimary {
        numHosts?: pulumi.Input<string>;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateTunnelConfigsAutoProvisionSecondary {
        numHosts?: pulumi.Input<string>;
        /**
         * optional, only needed if `varsOnly`==`false`
         */
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateTunnelConfigsIkeProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: pulumi.Input<string>;
        /**
         * enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup?: pulumi.Input<string>;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo?: pulumi.Input<string>;
    }

    export interface GatewaytemplateTunnelConfigsIpsecProposal {
        /**
         * enum: `md5`, `sha1`, `sha2`
         */
        authAlgo?: pulumi.Input<string>;
        /**
         * Only if `provider`== `custom-ipsec`. enum:
         *   * 1
         *   * 2 (1024-bit)
         *   * 5
         *   * 14 (default, 2048-bit)
         *   * 15 (3072-bit)
         *   * 16 (4096-bit)
         *   * 19 (256-bit ECP)
         *   * 20 (384-bit ECP)
         *   * 21 (521-bit ECP)
         *   * 24 (2048-bit ECP)
         */
        dhGroup?: pulumi.Input<string>;
        /**
         * enum: `3des`, `aes128`, `aes256`, `aesGcm128`, `aesGcm256`
         */
        encAlgo?: pulumi.Input<string>;
    }

    export interface GatewaytemplateTunnelConfigsPrimary {
        hosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: pulumi.Input<pulumi.Input<string>[]>;
        probeIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: pulumi.Input<pulumi.Input<string>[]>;
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateTunnelConfigsProbe {
        /**
         * how often to trigger the probe
         */
        interval?: pulumi.Input<number>;
        /**
         * number of consecutive misses before declaring the tunnel down
         */
        threshold?: pulumi.Input<number>;
        /**
         * time within which to complete the connectivity check
         */
        timeout?: pulumi.Input<number>;
        /**
         * enum: `http`, `icmp`
         */
        type?: pulumi.Input<string>;
    }

    export interface GatewaytemplateTunnelConfigsSecondary {
        hosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if:
         *   * `provider`== `zscaler-gre`
         *   * `provider`== `custom-gre`
         */
        internalIps?: pulumi.Input<pulumi.Input<string>[]>;
        probeIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `provider`== `custom-ipsec`
         */
        remoteIds?: pulumi.Input<pulumi.Input<string>[]>;
        wanNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GatewaytemplateTunnelProviderOptions {
        /**
         * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
         */
        jse?: pulumi.Input<inputs.org.GatewaytemplateTunnelProviderOptionsJse>;
        /**
         * for zscaler-ipsec and zscaler-gre
         */
        zscaler?: pulumi.Input<inputs.org.GatewaytemplateTunnelProviderOptionsZscaler>;
    }

    export interface GatewaytemplateTunnelProviderOptionsJse {
        name?: pulumi.Input<string>;
        numUsers?: pulumi.Input<number>;
    }

    export interface GatewaytemplateTunnelProviderOptionsZscaler {
        aupAcceptanceRequired?: pulumi.Input<boolean>;
        /**
         * days before AUP is requested again
         */
        aupExpire?: pulumi.Input<number>;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy?: pulumi.Input<boolean>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: pulumi.Input<number>;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: pulumi.Input<boolean>;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution?: pulumi.Input<boolean>;
        enforceAuthentication?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        /**
         * if `useXff`==`true`
         */
        subLocations?: pulumi.Input<pulumi.Input<inputs.org.GatewaytemplateTunnelProviderOptionsZscalerSubLocation>[]>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: pulumi.Input<number>;
        /**
         * location uses proxy chaining to forward traffic
         */
        useXff?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplateTunnelProviderOptionsZscalerSubLocation {
        aupAcceptanceRequired?: pulumi.Input<boolean>;
        /**
         * days before AUP is requested again
         */
        aupExpire?: pulumi.Input<number>;
        /**
         * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
         */
        aupSslProxy?: pulumi.Input<boolean>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        downloadMbps?: pulumi.Input<number>;
        /**
         * if `useXff`==`true`, display Acceptable Use Policy (AUP)
         */
        enableAup?: pulumi.Input<boolean>;
        /**
         * when `enforceAuthentication`==`false`, display caution notification for non-authenticated users
         */
        enableCaution?: pulumi.Input<boolean>;
        enforceAuthentication?: pulumi.Input<boolean>;
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * the download bandwidth cap of the link, in Mbps
         */
        uploadMbps?: pulumi.Input<number>;
    }

    export interface GatewaytemplateVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface GatewaytemplateVrfInstances {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface IdpprofileOverwrite {
        /**
         * enum:
         *   * alert (default)
         *   * drop: siliently dropping packets
         *   * close: notify client/server to close connection
         */
        action?: pulumi.Input<string>;
        matching?: pulumi.Input<inputs.org.IdpprofileOverwriteMatching>;
        name: pulumi.Input<string>;
    }

    export interface IdpprofileOverwriteMatching {
        attackNames?: pulumi.Input<pulumi.Input<string>[]>;
        dstSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        severities?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InventoryDevice {
        /**
         * used to claim the device to the Mist Organization and manage it. Format is `[0-9A-Z]{15}` (e.g `01234ABCDE56789`)
         */
        claimCode?: pulumi.Input<string>;
        /**
         * deviceprofile id if assigned, null if not assigned
         */
        deviceprofileId?: pulumi.Input<string>;
        /**
         * hostname reported by the device
         */
        hostname?: pulumi.Input<string>;
        /**
         * device id
         */
        id?: pulumi.Input<string>;
        /**
         * used to managed a device already in the Mist Organization (claimed or adopted devices). Format is `[0-9a-f]{12}` (e.g `5684dae9ac8b`)
         */
        mac?: pulumi.Input<string>;
        /**
         * device model
         */
        model?: pulumi.Input<string>;
        orgId?: pulumi.Input<string>;
        /**
         * device serial
         */
        serial?: pulumi.Input<string>;
        /**
         * Site ID. Used to assign device to a Site
         */
        siteId?: pulumi.Input<string>;
        /**
         * enum: `ap`, `gateway`, `switch`
         */
        type?: pulumi.Input<string>;
        /**
         * Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
         */
        unclaimWhenDestroyed?: pulumi.Input<boolean>;
        /**
         * if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Clust, MAC Address of the Cluster
         */
        vcMac?: pulumi.Input<string>;
    }

    export interface InventoryInventory {
        /**
         * device claim code
         */
        claimCode?: pulumi.Input<string>;
        /**
         * deviceprofile id if assigned, null if not assigned
         */
        deviceprofileId?: pulumi.Input<string>;
        /**
         * hostname reported by the device
         */
        hostname?: pulumi.Input<string>;
        /**
         * device id
         */
        id?: pulumi.Input<string>;
        /**
         * device MAC address
         */
        mac?: pulumi.Input<string>;
        /**
         * device model
         */
        model?: pulumi.Input<string>;
        orgId?: pulumi.Input<string>;
        /**
         * device serial
         */
        serial?: pulumi.Input<string>;
        /**
         * Site ID. Used to assign device to a Site
         */
        siteId?: pulumi.Input<string>;
        /**
         * enum: `ap`, `gateway`, `switch`
         */
        type?: pulumi.Input<string>;
        /**
         * Unclaim the device from the Mist Organization when removed from the provider inventory. Default is `false`
         */
        unclaimWhenDestroyed?: pulumi.Input<boolean>;
        /**
         * if `type`==`switch` and device part of a Virtual Chassis, MAC Address of the Virtual Chassis. if `type`==`gateway` and device part of a Clust, MAC Address of the Cluster
         */
        vcMac?: pulumi.Input<string>;
    }

    export interface NacruleMatching {
        /**
         * enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `psk`
         */
        authType?: pulumi.Input<string>;
        nactags?: pulumi.Input<pulumi.Input<string>[]>;
        portTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of site ids to match
         */
        siteIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of sitegroup ids to match
         */
        sitegroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of vendors to match
         */
        vendors?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NacruleNotMatching {
        /**
         * enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `psk`
         */
        authType?: pulumi.Input<string>;
        nactags?: pulumi.Input<pulumi.Input<string>[]>;
        portTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of site ids to match
         */
        siteIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of sitegroup ids to match
         */
        sitegroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of vendors to match
         */
        vendors?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkInternalAccess {
        enabled?: pulumi.Input<boolean>;
    }

    export interface NetworkInternetAccess {
        createSimpleServicePolicy?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworkInternetAccessDestinationNat>}>;
        enabled?: pulumi.Input<boolean>;
        /**
         * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
         */
        restricted?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworkInternetAccessStaticNat>}>;
    }

    export interface NetworkInternetAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface NetworkInternetAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface NetworkTenants {
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkVpnAccess {
        /**
         * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
         */
        advertisedSubnet?: pulumi.Input<string>;
        /**
         * whether to allow ping from vpn into this routed network
         */
        allowPing?: pulumi.Input<boolean>;
        /**
         * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
         */
        destinationNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworkVpnAccessDestinationNat>}>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
         */
        natPool?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        noReadvertiseToLanBgp?: pulumi.Input<boolean>;
        /**
         * toward LAN-side OSPF peers
         */
        noReadvertiseToLanOspf?: pulumi.Input<boolean>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * by default, the routes are only readvertised toward the same vrf on spoke
         * to allow it to be leaked to other vrfs
         */
        otherVrfs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether this network is routable
         */
        routed?: pulumi.Input<boolean>;
        /**
         * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
         */
        sourceNat?: pulumi.Input<inputs.org.NetworkVpnAccessSourceNat>;
        /**
         * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
         */
        staticNat?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworkVpnAccessStaticNat>}>;
        /**
         * toward overlay
         * how HUB should deal with routes it received from Spokes
         */
        summarizedSubnet?: pulumi.Input<string>;
        /**
         * toward LAN-side BGP peers
         */
        summarizedSubnetToLanBgp?: pulumi.Input<string>;
        /**
         * toward LAN-side OSPF peers
         */
        summarizedSubnetToLanOspf?: pulumi.Input<string>;
    }

    export interface NetworkVpnAccessDestinationNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface NetworkVpnAccessSourceNat {
        externalIp?: pulumi.Input<string>;
    }

    export interface NetworkVpnAccessStaticNat {
        internalIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * If not set, we configure the nat policies against all WAN ports for simplicity
         */
        wanName?: pulumi.Input<string>;
    }

    export interface NetworktemplateAclPolicy {
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        actions?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateAclPolicyAction>[]>;
        name?: pulumi.Input<string>;
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        srcTags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateAclPolicyAction {
        /**
         * enum: `allow`, `deny`
         */
        action?: pulumi.Input<string>;
        dstTag: pulumi.Input<string>;
    }

    export interface NetworktemplateAclTags {
        /**
         * required if
         * - `type`==`dynamicGbp` (gbp_tag received from RADIUS)
         * - `type`==`gbpResource`
         * - `type`==`staticGbp` (applying gbp tag against matching conditions)
         */
        gbpTag?: pulumi.Input<number>;
        /**
         * required if 
         * - `type`==`mac`
         * - `type`==`staticGbp` if from matching mac
         */
        macs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if:
         *   * `type`==`mac` (optional. default is `any`)
         *   * `type`==`subnet` (optional. default is `any`)
         *   * `type`==`network`
         *   * `type`==`resource` (optional. default is `any`)
         *   * `type`==`staticGbp` if from matching network (vlan)'
         */
        network?: pulumi.Input<string>;
        /**
         * required if:
         *   * `type`==`radiusGroup`
         *   * `type`==`staticGbp`
         * if from matching radius_group
         */
        radiusGroup?: pulumi.Input<string>;
        /**
         * if `type`==`resource` or `type`==`gbpResource`
         * empty means unrestricted, i.e. any
         */
        specs?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateAclTagsSpec>[]>;
        /**
         * if 
         * - `type`==`subnet` 
         * - `type`==`resource` (optional. default is `any`)
         * - `type`==`staticGbp` if from matching subnet
         */
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: 
         *   * `any`: matching anything not identified
         *   * `dynamicGbp`: from the gbpTag received from RADIUS
         *   * `gbpResource`: can only be used in `dstTags`
         *   * `mac`
         *   * `network`
         *   * `radiusGroup`
         *   * `resource`: can only be used in `dstTags`
         *   * `staticGbp`: applying gbp tag against matching conditions
         *   * `subnet`'
         */
        type: pulumi.Input<string>;
    }

    export interface NetworktemplateAclTagsSpec {
        /**
         * matched dst port, "0" means any
         */
        portRange?: pulumi.Input<string>;
        /**
         * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocolNumber` is between 1-254
         */
        protocol?: pulumi.Input<string>;
    }

    export interface NetworktemplateDhcpSnooping {
        allNetworks?: pulumi.Input<boolean>;
        /**
         * Enable for dynamic ARP inspection check
         */
        enableArpSpoofCheck?: pulumi.Input<boolean>;
        /**
         * Enable for check for forging source IP address
         */
        enableIpSourceGuard?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * if `allNetworks`==`false`, list of network with DHCP snooping enabled
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateExtraRoutes {
        /**
         * this takes precedence
         */
        discard?: pulumi.Input<boolean>;
        metric?: pulumi.Input<number>;
        nextQualified?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateExtraRoutesNextQualified>}>;
        noResolve?: pulumi.Input<boolean>;
        preference?: pulumi.Input<number>;
        /**
         * next-hop IP Address
         */
        via: pulumi.Input<string>;
    }

    export interface NetworktemplateExtraRoutes6 {
        /**
         * this takes precedence
         */
        discard?: pulumi.Input<boolean>;
        metric?: pulumi.Input<number>;
        nextQualified?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateExtraRoutes6NextQualified>}>;
        noResolve?: pulumi.Input<boolean>;
        preference?: pulumi.Input<number>;
        /**
         * next-hop IP Address
         */
        via: pulumi.Input<string>;
    }

    export interface NetworktemplateExtraRoutes6NextQualified {
        metric?: pulumi.Input<number>;
        preference?: pulumi.Input<number>;
    }

    export interface NetworktemplateExtraRoutesNextQualified {
        metric?: pulumi.Input<number>;
        preference?: pulumi.Input<number>;
    }

    export interface NetworktemplateMistNac {
        enabled?: pulumi.Input<boolean>;
        network?: pulumi.Input<string>;
    }

    export interface NetworktemplateNetworks {
        /**
         * only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
         */
        gateway?: pulumi.Input<string>;
        /**
         * only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
         */
        gateway6?: pulumi.Input<string>;
        /**
         * whether to stop clients to talk to each other, default is false (when enabled, a unique isolationVlanId is required)
         * NOTE: this features requires uplink device to also a be Juniper device and `interSwitchLink` to be set
         */
        isolation?: pulumi.Input<boolean>;
        isolationVlanId?: pulumi.Input<string>;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet?: pulumi.Input<string>;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet6?: pulumi.Input<string>;
        vlanId: pulumi.Input<string>;
    }

    export interface NetworktemplateOspfAreas {
        includeLoopback?: pulumi.Input<boolean>;
        networks: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateOspfAreasNetworks>}>;
        /**
         * OSPF type. enum: `default`, `nssa`, `stub`
         */
        type?: pulumi.Input<string>;
    }

    export interface NetworktemplateOspfAreasNetworks {
        /**
         * Required if `authType`==`md5`. Property key is the key number
         */
        authKeys?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Required if `authType`==`password`, the password, max length is 8
         */
        authPassword?: pulumi.Input<string>;
        /**
         * auth type. enum: `md5`, `none`, `password`
         */
        authType?: pulumi.Input<string>;
        bfdMinimumInterval?: pulumi.Input<number>;
        deadInterval?: pulumi.Input<number>;
        exportPolicy?: pulumi.Input<string>;
        helloInterval?: pulumi.Input<number>;
        importPolicy?: pulumi.Input<string>;
        /**
         * interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
         */
        interfaceType?: pulumi.Input<string>;
        metric?: pulumi.Input<number>;
        /**
         * by default, we'll re-advertise all learned OSPF routes toward overlay
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * whether to send OSPF-Hello
         */
        passive?: pulumi.Input<boolean>;
    }

    export interface NetworktemplatePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: pulumi.Input<string>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: pulumi.Input<string>;
    }

    export interface NetworktemplatePortUsages {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
         * All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         * When it is not defined, it means using the system's default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        allowMultipleSupplicants?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        description?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` whether the port is disabled
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        enableQos?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` interSwitchLink is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         */
        macAuthOnly?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
         */
        macAuthPreferred?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit?: pulumi.Input<number>;
        /**
         * `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         */
        mode?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: pulumi.Input<number>;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         */
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval?: pulumi.Input<number>;
        /**
         * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         */
        resetDefaultWhen?: pulumi.Input<string>;
        /**
         * Only if `mode`==`dynamic`
         */
        rules?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplatePortUsagesRule>[]>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` sets server fail fallback vlan
         */
        serverFailNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` when radius server reject / fails
         */
        serverRejectNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * Switch storm control
         * Only if `mode`!=`dynamic`
         */
        stormControl?: pulumi.Input<inputs.org.NetworktemplatePortUsagesStormControl>;
        /**
         * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge?: pulumi.Input<boolean>;
        stpNoRootPort?: pulumi.Input<boolean>;
        stpP2p?: pulumi.Input<boolean>;
        /**
         * optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
         */
        uiEvpntopoId?: pulumi.Input<string>;
        /**
         * if this is connected to a vstp network
         */
        useVstp?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: pulumi.Input<string>;
    }

    export interface NetworktemplatePortUsagesRule {
        equals?: pulumi.Input<string>;
        /**
         * use `equalsAny` to match any item in a list
         */
        equalsAnies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * "[0:3]":"abcdef" > "abc"
         * "split(.)[1]": "a.b.c" > "b"
         * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
         */
        expression?: pulumi.Input<string>;
        /**
         * enum: `linkPeermac`, `lldpChassisId`, `lldpHardwareRevision`, `lldpManufacturerName`, `lldpOui`, `lldpSerialNumber`, `lldpSystemName`, `radiusDynamicfilter`, `radiusUsermac`, `radiusUsername`
         */
        src: pulumi.Input<string>;
        /**
         * `portUsage` name
         */
        usage?: pulumi.Input<string>;
    }

    export interface NetworktemplatePortUsagesStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast?: pulumi.Input<boolean>;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage?: pulumi.Input<number>;
    }

    export interface NetworktemplateRadiusConfig {
        /**
         * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
         */
        acctInterimInterval?: pulumi.Input<number>;
        acctServers?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRadiusConfigAcctServer>[]>;
        authServers?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRadiusConfigAuthServer>[]>;
        /**
         * radius auth session retries
         */
        authServersRetries?: pulumi.Input<number>;
        /**
         * radius auth session timeout
         */
        authServersTimeout?: pulumi.Input<number>;
        /**
         * use `network`or `sourceIp`
         * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
         */
        network?: pulumi.Input<string>;
        /**
         * use `network`or `sourceIp`
         */
        sourceIp?: pulumi.Input<string>;
    }

    export interface NetworktemplateRadiusConfigAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Acct port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface NetworktemplateRadiusConfigAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Auth port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * whether to require Message-Authenticator in requests
         */
        requireMessageAuthenticator?: pulumi.Input<boolean>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslog {
        archive?: pulumi.Input<inputs.org.NetworktemplateRemoteSyslogArchive>;
        console?: pulumi.Input<inputs.org.NetworktemplateRemoteSyslogConsole>;
        enabled?: pulumi.Input<boolean>;
        files?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogFile>[]>;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        network?: pulumi.Input<string>;
        sendToAllServers?: pulumi.Input<boolean>;
        servers?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogServer>[]>;
        /**
         * enum: `millisecond`, `year`, `year millisecond`
         */
        timeFormat?: pulumi.Input<string>;
        users?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogUser>[]>;
    }

    export interface NetworktemplateRemoteSyslogArchive {
        files?: pulumi.Input<number>;
        size?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogConsole {
        contents?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogConsoleContent>[]>;
    }

    export interface NetworktemplateRemoteSyslogConsoleContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogFile {
        archive?: pulumi.Input<inputs.org.NetworktemplateRemoteSyslogFileArchive>;
        contents?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogFileContent>[]>;
        explicitPriority?: pulumi.Input<boolean>;
        file?: pulumi.Input<string>;
        match?: pulumi.Input<string>;
        structuredData?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateRemoteSyslogFileArchive {
        files?: pulumi.Input<number>;
        size?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogFileContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogServer {
        contents?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogServerContent>[]>;
        explicitPriority?: pulumi.Input<boolean>;
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        host?: pulumi.Input<string>;
        match?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        /**
         * enum: `tcp`, `udp`
         */
        protocol?: pulumi.Input<string>;
        routingInstance?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        sourceAddress?: pulumi.Input<string>;
        structuredData?: pulumi.Input<boolean>;
        tag?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogServerContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogUser {
        contents?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateRemoteSyslogUserContent>[]>;
        match?: pulumi.Input<string>;
        user?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogUserContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfig {
        clientLists?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigClientList>[]>;
        contact?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
         */
        engineId?: pulumi.Input<string>;
        location?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        trapGroups?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigTrapGroup>[]>;
        v2cConfigs?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV2cConfig>[]>;
        v3Config?: pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3Config>;
        views?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigView>[]>;
    }

    export interface NetworktemplateSnmpConfigClientList {
        clientListName?: pulumi.Input<string>;
        clients?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateSnmpConfigTrapGroup {
        categories?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
         */
        groupName?: pulumi.Input<string>;
        targets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `all`, `v1`, `v2`
         */
        version?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV2cConfig {
        authorization?: pulumi.Input<string>;
        /**
         * client_list_name here should refer to clientList above
         */
        clientListName?: pulumi.Input<string>;
        communityName?: pulumi.Input<string>;
        /**
         * view name here should be defined in views above
         */
        view?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3Config {
        notifies?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigNotify>[]>;
        notifyFilters?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigNotifyFilter>[]>;
        targetAddresses?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigTargetAddress>[]>;
        targetParameters?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigTargetParameter>[]>;
        usm?: pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigUsm>;
        vacm?: pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigVacm>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotify {
        name?: pulumi.Input<string>;
        tag?: pulumi.Input<string>;
        /**
         * enum: `inform`, `trap`
         */
        type?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilter {
        contents?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent>[]>;
        profileName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilterContent {
        include?: pulumi.Input<boolean>;
        oid?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetAddress {
        address?: pulumi.Input<string>;
        addressMask?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        /**
         * <refer to notify tag, can be multiple with blank
         */
        tagList?: pulumi.Input<string>;
        targetAddressName?: pulumi.Input<string>;
        /**
         * refer to notify target parameters name
         */
        targetParameters?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetParameter {
        /**
         * enum: `v1`, `v2c`, `v3`
         */
        messageProcessingModel?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * refer to profile-name in notify_filter
         */
        notifyFilter?: pulumi.Input<string>;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
        /**
         * refer to securityName in usm
         */
        securityName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsm {
        /**
         * enum: `localEngine`, `remoteEngine`
         */
        engineType?: pulumi.Input<string>;
        /**
         * required only if `engineType`==`remoteEngine`
         */
        engineid?: pulumi.Input<string>;
        users?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigUsmUser>[]>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsmUser {
        /**
         * Not required if `authenticationType`==`authenticationNone`
         * include alphabetic, numeric, and special characters, but it cannot include control characters.
         */
        authenticationPassword?: pulumi.Input<string>;
        /**
         * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authenticationMd5`, `authenticationNone`, `authenticationSha`, `authenticationSha224`, `authenticationSha256`, `authenticationSha384`, `authenticationSha512`
         */
        authenticationType?: pulumi.Input<string>;
        /**
         * Not required if `encryptionType`==`privacy-none`
         * include alphabetic, numeric, and special characters, but it cannot include control characters
         */
        encryptionPassword?: pulumi.Input<string>;
        /**
         * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
         */
        encryptionType?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacm {
        accesses?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigVacmAccess>[]>;
        securityToGroup?: pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccess {
        groupName?: pulumi.Input<string>;
        prefixLists?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList>[]>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList {
        /**
         * only required if `type`==`contextPrefix`
         */
        contextPrefix?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        notifyView?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        readView?: pulumi.Input<string>;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * enum: `any`, `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
        /**
         * enum: `contextPrefix`, `defaultContextPrefix`
         */
        type?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        writeView?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup {
        contents?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent>[]>;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent {
        /**
         * refer to groupName under access
         */
        group?: pulumi.Input<string>;
        securityName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigView {
        /**
         * if the root oid configured is included
         */
        include?: pulumi.Input<boolean>;
        oid?: pulumi.Input<string>;
        viewName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMatching {
        enable?: pulumi.Input<boolean>;
        /**
         * list of rules to define custom switch configuration based on different criterias. Each list must have at least one of `matchModel`, `matchName` or `matchRole` must be defined
         */
        rules?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSwitchMatchingRule>[]>;
    }

    export interface NetworktemplateSwitchMatchingRule {
        /**
         * additional CLI commands to append to the generated Junos config. **Note**: no check is done
         */
        additionalConfigCmds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * In-Band Management interface configuration
         */
        ipConfig?: pulumi.Input<inputs.org.NetworktemplateSwitchMatchingRuleIpConfig>;
        /**
         * string the switch model must start with to use this rule. It is possible to combine with the `matchName` and `matchRole` attributes
         */
        matchModel?: pulumi.Input<string>;
        /**
         * string the switch name must start with to use this rule. Use the `matchNameOffset` to indicate the first character of the switch name to compare to. It is possible to combine with the `matchModel` and `matchRole` attributes
         */
        matchName?: pulumi.Input<string>;
        /**
         * first character of the switch name to compare to the `matchName` value
         */
        matchNameOffset?: pulumi.Input<number>;
        /**
         * string the switch role must start with to use this rule. It is possible to combine with the `matchName` and `matchModel` attributes
         */
        matchRole?: pulumi.Input<string>;
        /**
         * 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `matchModel`,  `match_model[0-6]`
         *
         * @deprecated The `matchType` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `matchName`, `matchModel` and `matchRole`attribuites and may be removed in future versions.
Please update your configurations.
         */
        matchType?: pulumi.Input<string>;
        /**
         * @deprecated The `matchValue` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `matchName`, `matchModel` and `matchRole`attribuites and may be removed in future versions.
Please update your configurations.
         */
        matchValue?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Out-of-Band Management interface configuration
         */
        oobIpConfig?: pulumi.Input<inputs.org.NetworktemplateSwitchMatchingRuleOobIpConfig>;
        /**
         * Propery key is the interface name or interface range
         */
        portConfig?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateSwitchMatchingRulePortConfig>}>;
        /**
         * Property key is the port mirroring instance name
         * portMirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 port mirrorings is allowed
         */
        portMirroring?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateSwitchMatchingRulePortMirroring>}>;
    }

    export interface NetworktemplateSwitchMatchingRuleIpConfig {
        /**
         * VLAN Name for the management interface
         */
        network?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMatchingRuleOobIpConfig {
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateSwitchMatchingRulePortConfig {
        /**
         * To disable LACP support for the AE interface
         */
        aeDisableLacp?: pulumi.Input<boolean>;
        /**
         * Users could force to use the designated AE name
         */
        aeIdx?: pulumi.Input<number>;
        /**
         * to use fast timeout
         */
        aeLacpSlow?: pulumi.Input<boolean>;
        aggregated?: pulumi.Input<boolean>;
        /**
         * if want to generate port up/down alarm
         */
        critical?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        /**
         * if `speed` and `duplex` are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Enable dynamic usage for this port. Set to `dynamic` to enable.
         */
        dynamicUsage?: pulumi.Input<string>;
        esilag?: pulumi.Input<boolean>;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
         */
        mtu?: pulumi.Input<number>;
        /**
         * prevent helpdesk to override the port config
         */
        noLocalOverwrite?: pulumi.Input<boolean>;
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * port usage name. If EVPN is used, use `evpnUplink`or `evpnDownlink`
         */
        usage: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMatchingRulePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: pulumi.Input<string>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMgmt {
        /**
         * ap_affinity_threshold apAffinityThreshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
         */
        apAffinityThreshold?: pulumi.Input<number>;
        /**
         * Set Banners for switches. Allows markup formatting
         */
        cliBanner?: pulumi.Input<string>;
        /**
         * Sets timeout for switches
         */
        cliIdleTimeout?: pulumi.Input<number>;
        /**
         * the rollback timer for commit confirmed
         */
        configRevertTimer?: pulumi.Input<number>;
        /**
         * Enable to provide the FQDN with DHCP option 81
         */
        dhcpOptionFqdn?: pulumi.Input<boolean>;
        disableOobDownAlarm?: pulumi.Input<boolean>;
        /**
         * Property key is the user name. For Local user authentication
         */
        localAccounts?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateSwitchMgmtLocalAccounts>}>;
        mxedgeProxyHost?: pulumi.Input<string>;
        mxedgeProxyPort?: pulumi.Input<number>;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: pulumi.Input<inputs.org.NetworktemplateSwitchMgmtProtectRe>;
        rootPassword?: pulumi.Input<string>;
        tacacs?: pulumi.Input<inputs.org.NetworktemplateSwitchMgmtTacacs>;
        /**
         * to use mxedge as proxy
         */
        useMxedgeProxy?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateSwitchMgmtLocalAccounts {
        password?: pulumi.Input<string>;
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        role?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMgmtProtectRe {
        /**
         * optionally, services we'll allow. enum: `icmp`, `ssh`
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        customs?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSwitchMgmtProtectReCustom>[]>;
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateSwitchMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        portRange?: pulumi.Input<string>;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        protocol?: pulumi.Input<string>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateSwitchMgmtTacacs {
        acctServers?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSwitchMgmtTacacsAcctServer>[]>;
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        defaultRole?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * which network the TACACS server resides
         */
        network?: pulumi.Input<string>;
        tacplusServers?: pulumi.Input<pulumi.Input<inputs.org.NetworktemplateSwitchMgmtTacacsTacplusServer>[]>;
    }

    export interface NetworktemplateSwitchMgmtTacacsAcctServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        secret?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface NetworktemplateSwitchMgmtTacacsTacplusServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        secret?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface NetworktemplateVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateVrfInstances {
        /**
         * Property key is the destination CIDR (e.g. "10.0.0.0/8")
         */
        extraRoutes?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.NetworktemplateVrfInstancesExtraRoutes>}>;
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateVrfInstancesExtraRoutes {
        /**
         * Next-hop address
         */
        via: pulumi.Input<string>;
    }

    export interface RftemplateBand24 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface RftemplateBand5 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface RftemplateBand5On24Radio {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface RftemplateBand6 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower?: pulumi.Input<boolean>;
    }

    export interface RftemplateModelSpecific {
        antGain24?: pulumi.Input<number>;
        antGain5?: pulumi.Input<number>;
        antGain6?: pulumi.Input<number>;
        /**
         * Radio Band AP settings
         */
        band24?: pulumi.Input<inputs.org.RftemplateModelSpecificBand24>;
        /**
         * enum: `24`, `5`, `6`, `auto`
         */
        band24Usage?: pulumi.Input<string>;
        /**
         * Radio Band AP settings
         */
        band5?: pulumi.Input<inputs.org.RftemplateModelSpecificBand5>;
        /**
         * Radio Band AP settings
         */
        band5On24Radio?: pulumi.Input<inputs.org.RftemplateModelSpecificBand5On24Radio>;
        /**
         * Radio Band AP settings
         */
        band6?: pulumi.Input<inputs.org.RftemplateModelSpecificBand6>;
    }

    export interface RftemplateModelSpecificBand24 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 2.4GHz band. enum: `20`, `40`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface RftemplateModelSpecificBand5 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface RftemplateModelSpecificBand5On24Radio {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 5GHz band. enum: `20`, `40`, `80`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
    }

    export interface RftemplateModelSpecificBand6 {
        allowRrmDisable?: pulumi.Input<boolean>;
        antGain?: pulumi.Input<number>;
        /**
         * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
         */
        antennaMode?: pulumi.Input<string>;
        /**
         * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
         */
        bandwidth?: pulumi.Input<number>;
        /**
         * For RFTemplates. List of channels, null or empty array means auto
         */
        channels?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * whether to disable the radio
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
         */
        power?: pulumi.Input<number>;
        /**
         * when power=0, max tx power to use, HW-specific values will be used if not set
         */
        powerMax?: pulumi.Input<number>;
        /**
         * when power=0, min tx power to use, HW-specific values will be used if not set
         */
        powerMin?: pulumi.Input<number>;
        /**
         * enum: `auto`, `long`, `short`
         */
        preamble?: pulumi.Input<string>;
        /**
         * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
         */
        standardPower?: pulumi.Input<boolean>;
    }

    export interface ServiceSpec {
        /**
         * port number, port range, or variable
         */
        portRange?: pulumi.Input<string>;
        /**
         * `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`.
         * `protocolNumber` is between 1-254
         */
        protocol?: pulumi.Input<string>;
    }

    export interface ServicepolicyAppqoe {
        enabled?: pulumi.Input<boolean>;
    }

    export interface ServicepolicyEwf {
        alertOnly?: pulumi.Input<boolean>;
        blockMessage?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `critical`, `standard`, `strict`
         */
        profile?: pulumi.Input<string>;
    }

    export interface ServicepolicyIdp {
        alertOnly?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * org_level IDP Profile can be used, this takes precedence over `profile`
         */
        idpprofileId?: pulumi.Input<string>;
        /**
         * `strict` (default) / `standard` / or keys from from idp_profiles
         */
        profile?: pulumi.Input<string>;
    }

    export interface SettingApiPolicy {
        /**
         * by default, API hides password/secrets when the user doesn't have write access
         *   * `true`: API will hide passwords/secrets for all users
         *   * `false`: API will hide passwords/secrets for read-only users
         */
        noReveal?: pulumi.Input<boolean>;
    }

    export interface SettingCelona {
        apiKey: pulumi.Input<string>;
        apiPrefix: pulumi.Input<string>;
    }

    export interface SettingCloudshark {
        apitoken: pulumi.Input<string>;
        /**
         * if using CS Enteprise
         */
        url?: pulumi.Input<string>;
    }

    export interface SettingCradlepoint {
        cpApiId?: pulumi.Input<string>;
        cpApiKey?: pulumi.Input<string>;
        ecmApiId?: pulumi.Input<string>;
        ecmApiKey?: pulumi.Input<string>;
        enableLldp?: pulumi.Input<boolean>;
    }

    export interface SettingDeviceCert {
        cert: pulumi.Input<string>;
        key: pulumi.Input<string>;
    }

    export interface SettingInstaller {
        allowAllDevices?: pulumi.Input<boolean>;
        allowAllSites?: pulumi.Input<boolean>;
        extraSiteIds?: pulumi.Input<pulumi.Input<string>[]>;
        gracePeriod?: pulumi.Input<number>;
    }

    export interface SettingJcloud {
        /**
         * JCloud Org Token
         */
        orgApitoken: pulumi.Input<string>;
        /**
         * JCloud Org Token Name
         */
        orgApitokenName: pulumi.Input<string>;
        /**
         * JCloud Org ID
         */
        orgId: pulumi.Input<string>;
    }

    export interface SettingJcloudRa {
        /**
         * JCloud Routing Assurance Org Token
         */
        orgApitoken?: pulumi.Input<string>;
        /**
         * JCloud Routing Assurance Org Token Name
         */
        orgApitokenName?: pulumi.Input<string>;
        /**
         * JCloud Routing Assurance Org ID
         */
        orgId?: pulumi.Input<string>;
    }

    export interface SettingJuniper {
        accounts?: pulumi.Input<pulumi.Input<inputs.org.SettingJuniperAccount>[]>;
    }

    export interface SettingJuniperAccount {
        linkedBy?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface SettingMgmt {
        /**
         * list of Mist Tunnels
         */
        mxtunnelIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
         */
        useMxtunnel?: pulumi.Input<boolean>;
        /**
         * whether to use wxtunnel for mgmt connectivity
         */
        useWxtunnel?: pulumi.Input<boolean>;
    }

    export interface SettingMistNac {
        /**
         * list of PEM-encoded ca certs
         */
        cacerts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
         */
        defaultIdpId?: pulumi.Input<string>;
        /**
         * to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html
         */
        disableRsaeAlgorithms?: pulumi.Input<boolean>;
        /**
         * eap ssl security level
         * see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
         */
        eapSslSecurityLevel?: pulumi.Input<number>;
        /**
         * By default NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site.
         * For strict GDPR compliancy NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mistNac enabled
         */
        euOnly?: pulumi.Input<boolean>;
        /**
         * allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`
         */
        idpMachineCertLookupField?: pulumi.Input<string>;
        /**
         * allow customer to choose the EAP-TLS client certificate's field
         * to use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`
         */
        idpUserCertLookupField?: pulumi.Input<string>;
        idps?: pulumi.Input<pulumi.Input<inputs.org.SettingMistNacIdp>[]>;
        /**
         * radius server cert to be presented in EAP TLS
         */
        serverCert?: pulumi.Input<inputs.org.SettingMistNacServerCert>;
        /**
         * by default NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
         */
        useIpVersion?: pulumi.Input<string>;
        /**
         * By default NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(radsec) to reach mist-nac. 
         * Set `useSslPort`==`true` to override that port with TCP43 (ssl), 
         * This is a org level setting that is applicable to wlans, switch_templates, and mxedgeClusters that have mist-nac enabled
         */
        useSslPort?: pulumi.Input<boolean>;
    }

    export interface SettingMistNacIdp {
        /**
         * when the IDP of mxedgeProxy type, exclude the following realms from proxying in addition to other valid home realms in this org
         */
        excludeRealms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * ID of the `mistNacidp`
         */
        id: pulumi.Input<string>;
        /**
         * which realm should trigger this IDP. User Realm is extracted from:
         *   * Username-AVP (`mist.com` from john@mist.com)
         *   * Cert CN
         */
        userRealms: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingMistNacServerCert {
        cert?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
        /**
         * private key password (optional)
         */
        password?: pulumi.Input<string>;
    }

    export interface SettingMxedgeMgmt {
        fipsEnabled?: pulumi.Input<boolean>;
        mistPassword?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `disabled`, `static`
         */
        oobIpType?: pulumi.Input<string>;
        /**
         * enum: `autoconf`, `dhcp`, `disabled`, `static`
         */
        oobIpType6?: pulumi.Input<string>;
        rootPassword?: pulumi.Input<string>;
    }

    export interface SettingOpticPortConfig {
        /**
         * enable channelization
         */
        channelized?: pulumi.Input<boolean>;
        /**
         * interface speed (e.g. `25g`, `50g`), use the chassis speed by default
         */
        speed?: pulumi.Input<string>;
    }

    export interface SettingPasswordPolicy {
        /**
         * whether the policy is enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * password expiry in days
         */
        expiryInDays?: pulumi.Input<number>;
        /**
         * required password length
         */
        minLength?: pulumi.Input<number>;
        /**
         * whether to require special character
         */
        requiresSpecialChar?: pulumi.Input<boolean>;
        /**
         * whether to require two-factor auth
         */
        requiresTwoFactorAuth?: pulumi.Input<boolean>;
    }

    export interface SettingPcap {
        bucket?: pulumi.Input<string>;
        /**
         * max_len of non-management packets to capture
         */
        maxPktLen?: pulumi.Input<number>;
    }

    export interface SettingSecurity {
        /**
         * whether to disable local SSH (by default, local SSH is enabled with allowMist in Org is enabled
         */
        disableLocalSsh?: pulumi.Input<boolean>;
        /**
         * password required to zeroize devices (FIPS) on site level
         */
        fipsZeroizePassword?: pulumi.Input<string>;
        /**
         * whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
         */
        limitSshAccess?: pulumi.Input<boolean>;
    }

    export interface SettingSwitchMgmt {
        /**
         * If the field is set in both site/setting and org/setting, the value from site/setting will be used.
         */
        apAffinityThreshold?: pulumi.Input<number>;
    }

    export interface SettingSyntheticTest {
        disabled?: pulumi.Input<boolean>;
        vlans?: pulumi.Input<pulumi.Input<inputs.org.SettingSyntheticTestVlan>[]>;
        wanSpeedtest?: pulumi.Input<inputs.org.SettingSyntheticTestWanSpeedtest>;
    }

    export interface SettingSyntheticTestVlan {
        customTestUrls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for some vlans where we don't want this to run
         */
        disabled?: pulumi.Input<boolean>;
        vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingSyntheticTestWanSpeedtest {
        enabled?: pulumi.Input<boolean>;
        /**
         * any / HH:MM (24-hour format)
         */
        timeOfDay?: pulumi.Input<string>;
    }

    export interface SettingVpnOptions {
        asBase?: pulumi.Input<number>;
        /**
         * equiring /12 or bigger to support 16 private IPs for 65535 gateways
         */
        stSubnet?: pulumi.Input<string>;
    }

    export interface SettingWanPma {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingWiredPma {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingWirelessPma {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SsoRolePrivilege {
        /**
         * access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`
         */
        role: pulumi.Input<string>;
        /**
         * enum: `org`, `site`, `sitegroup`
         */
        scope: pulumi.Input<string>;
        /**
         * Required if `scope`==`site`
         */
        siteId?: pulumi.Input<string>;
        /**
         * Required if `scope`==`sitegroup`
         */
        sitegroupId?: pulumi.Input<string>;
    }

    export interface VpnPaths {
        /**
         * enum: `broadband`, `lte`
         */
        bfdProfile?: pulumi.Input<string>;
        /**
         * if different from the wan port
         */
        ip?: pulumi.Input<string>;
        pod?: pulumi.Input<number>;
    }

    export interface WlanAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Acct port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface WlanAirwatch {
        /**
         * API Key
         */
        apiKey: pulumi.Input<string>;
        /**
         * console URL
         */
        consoleUrl: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * password
         */
        password: pulumi.Input<string>;
        /**
         * username
         */
        username: pulumi.Input<string>;
    }

    export interface WlanAppLimit {
        /**
         * Map from app key to bandwidth in kbps. 
         * Property key is the app key, defined in Get Application List
         */
        apps?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
        enabled?: pulumi.Input<boolean>;
        /**
         * Map from wxtagId of Hostname Wxlan Tags to bandwidth in kbps
         * Property key is the wxtag id
         */
        wxtagIds?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
    }

    export interface WlanAppQos {
        apps?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.WlanAppQosApps>}>;
        enabled?: pulumi.Input<boolean>;
        others?: pulumi.Input<pulumi.Input<inputs.org.WlanAppQosOther>[]>;
    }

    export interface WlanAppQosApps {
        dscp?: pulumi.Input<number>;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        dstSubnet?: pulumi.Input<string>;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        srcSubnet?: pulumi.Input<string>;
    }

    export interface WlanAppQosOther {
        dscp?: pulumi.Input<number>;
        dstSubnet?: pulumi.Input<string>;
        portRanges?: pulumi.Input<string>;
        protocol?: pulumi.Input<string>;
        srcSubnet?: pulumi.Input<string>;
    }

    export interface WlanAuth {
        /**
         * SAE anti-clogging token threshold
         */
        anticlogThreshold?: pulumi.Input<number>;
        /**
         * whether to trigger EAP reauth when the session ends
         */
        eapReauth?: pulumi.Input<boolean>;
        /**
         * whether to enable MAC Auth, uses the same auth_servers
         */
        enableMacAuth?: pulumi.Input<boolean>;
        /**
         * when `type`==`wep`
         */
        keyIdx?: pulumi.Input<number>;
        /**
         * when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
         */
        keys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when `type`==`psk`, whether to only use multi_psk
         */
        multiPskOnly?: pulumi.Input<boolean>;
        /**
         * if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
         */
        owe?: pulumi.Input<string>;
        /**
         * when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
         */
        pairwises?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when `multiPskOnly`==`true`, whether private wlan is enabled
         */
        privateWlan?: pulumi.Input<boolean>;
        /**
         * when `type`==`psk`, 8-64 characters, or 64 hex characters
         */
        psk?: pulumi.Input<string>;
        /**
         * enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
         */
        type?: pulumi.Input<string>;
        /**
         * enable WEP as secondary auth
         */
        wepAsSecondaryAuth?: pulumi.Input<boolean>;
    }

    export interface WlanAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Auth port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * whether to require Message-Authenticator in requests
         */
        requireMessageAuthenticator?: pulumi.Input<boolean>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface WlanBonjour {
        /**
         * additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
         */
        additionalVlanIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to enable bonjour for this WLAN. Once enabled, limitBcast is assumed true, allowMdns is assumed false
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * what services are allowed. 
         * Property key is the service name
         */
        services: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.WlanBonjourServices>}>;
    }

    export interface WlanBonjourServices {
        /**
         * whether to prevent wireless clients to discover bonjour devices on the same WLAN
         */
        disableLocal?: pulumi.Input<boolean>;
        /**
         * optional, if the service is further restricted for certain RADIUS groups
         */
        radiusGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * how bonjour services should be discovered for the same WLAN. enum: `sameAp`, `sameMap`, `sameSite`
         */
        scope?: pulumi.Input<string>;
    }

    export interface WlanCiscoCwa {
        /**
         * list of hostnames without http(s):// (matched by substring)
         */
        allowedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of CIDRs
         */
        allowedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of blocked CIDRs
         */
        blockedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface WlanCoaServer {
        /**
         * whether to disable Event-Timestamp Check
         */
        disableEventTimestampCheck?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        ip: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        secret: pulumi.Input<string>;
    }

    export interface WlanDnsServerRewrite {
        enabled?: pulumi.Input<boolean>;
        /**
         * map between radiusGroup and the desired DNS server (IPv4 only)
         * Property key is the RADIUS group, property value is the desired DNS Server
         */
        radiusGroups?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WlanDynamicPsk {
        /**
         * default PSK to use if cloud WLC is not available, 8-63 characters
         */
        defaultPsk?: pulumi.Input<string>;
        defaultVlanId?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * when 11r is enabled, we'll try to use the cached PMK, this can be disabled
         * `false` means auto
         */
        forceLookup?: pulumi.Input<boolean>;
        /**
         * enum: `cloudPsks`, `radius`
         */
        source?: pulumi.Input<string>;
        vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WlanDynamicVlan {
        /**
         * Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
         */
        defaultVlanIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to enable dynamic vlan
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * vlan_ids to be locally bridged
         */
        localVlanIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
         */
        type?: pulumi.Input<string>;
        /**
         * map between vlanId (as string) to airespace interface names (comma-separated) or null for stndard mapping
         *   * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"
         *   * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
         */
        vlans?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WlanHotspot20 {
        domainNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to enable hotspot 2.0 config
         */
        enabled?: pulumi.Input<boolean>;
        naiRealms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of operators to support
         */
        operators?: pulumi.Input<pulumi.Input<string>[]>;
        rcois?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * venue name, default is site name
         */
        venueName?: pulumi.Input<string>;
    }

    export interface WlanInjectDhcpOption82 {
        /**
         * information to set in the `circuitId` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
         *   * {{AP_MAC}}
         *   * {{AP_MAC_DASHED}}
         *   * {{AP_MODEL}}
         *   * {{AP_NAME}}
         *   * {{SITE_NAME}}
         *   * {{SSID}}
         */
        circuitId?: pulumi.Input<string>;
        /**
         * whether to inject option 82 when forwarding DHCP packets
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WlanMistNac {
        /**
         * when enabled:
         *   * `authServers` is ignored
         *   * `acctServers` is ignored
         *   * `auth_servers_*` are ignored
         *   * `coaServers` is ignored
         *   * `radsec` is ignored
         *   * `coaEnabled` is assumed'
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WlanPortal {
        /**
         * whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable randomMac for seamless roaming)
         */
        allowWlanIdRoam?: pulumi.Input<boolean>;
        /**
         * amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        amazonClientId?: pulumi.Input<string>;
        /**
         * amazon OAuth2 client secret. If amazonClientId was provided, provide a correspoinding value. Else leave blank.
         */
        amazonClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        amazonEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether amazon is enabled as a login method
         */
        amazonEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
         */
        amazonExpire?: pulumi.Input<number>;
        /**
         * authentication scheme. enum: `external`, `none`, `sso`
         */
        auth?: pulumi.Input<string>;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client id
         */
        azureClientId?: pulumi.Input<string>;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client secret
         */
        azureClientSecret?: pulumi.Input<string>;
        /**
         * whether Azure Active Directory is enabled as a login method
         */
        azureEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
         */
        azureExpire?: pulumi.Input<number>;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory tenant id.
         */
        azureTenantId?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetPassword?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetSid?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetUserId?: pulumi.Input<string>;
        /**
         * whether to bypass the guest portal when cloud not reachable (and apply the default policies)
         */
        bypassWhenCloudDown?: pulumi.Input<boolean>;
        /**
         * when `smsProvider`==`clickatell`
         */
        clickatellApiKey?: pulumi.Input<string>;
        /**
         * whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable randomMac for seamless roaming)
         */
        crossSite?: pulumi.Input<boolean>;
        /**
         * whether email (access code verification) is enabled as a login method
         */
        emailEnabled?: pulumi.Input<boolean>;
        /**
         * whether guest portal is enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * how long to remain authorized, in minutes
         */
        expire?: pulumi.Input<number>;
        /**
         * external portal URL (e.g. https://host/url) where we can append our query parameters to
         */
        externalPortalUrl?: pulumi.Input<string>;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        facebookClientId?: pulumi.Input<string>;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app secret. If facebookClientId was provided, provide a correspoinding value. Else leave blank.
         */
        facebookClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        facebookEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether facebook is enabled as a login method
         */
        facebookEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
         */
        facebookExpire?: pulumi.Input<number>;
        /**
         * whether to forward the user to another URL after authorized
         */
        forward?: pulumi.Input<boolean>;
        /**
         * the URL to forward the user to
         */
        forwardUrl?: pulumi.Input<string>;
        /**
         * Google OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        googleClientId?: pulumi.Input<string>;
        /**
         * Google OAuth2 app secret. If googleClientId was provided, provide a correspoinding value. Else leave blank.
         */
        googleClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        googleEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether google is enabled as login method
         */
        googleEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
         */
        googleExpire?: pulumi.Input<number>;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupPassword?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupUserid?: pulumi.Input<string>;
        /**
         * microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        microsoftClientId?: pulumi.Input<string>;
        /**
         * microsoft 365 OAuth2 client secret. If microsoftClientId was provided, provide a correspoinding value. Else leave blank.
         */
        microsoftClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        microsoftEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether microsoft 365 is enabled as a login method
         */
        microsoftEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
         */
        microsoftExpire?: pulumi.Input<number>;
        /**
         * whether password is enabled
         */
        passphraseEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
         */
        passphraseExpire?: pulumi.Input<number>;
        /**
         * passphrase
         */
        password?: pulumi.Input<string>;
        /**
         * whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsorNotifyAll` and `predefinedSponsorsEnabled` are false, behaviour is acc to `sponsorEmailDomains`
         */
        predefinedSponsorsEnabled?: pulumi.Input<boolean>;
        /**
         * whether to hide sponsor’s email from list of sponsors
         */
        predefinedSponsorsHideEmail?: pulumi.Input<boolean>;
        privacy?: pulumi.Input<boolean>;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelPassword?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelServiceId?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelUsername?: pulumi.Input<string>;
        /**
         * whether sms is enabled as a login method
         */
        smsEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
         */
        smsExpire?: pulumi.Input<number>;
        smsMessageFormat?: pulumi.Input<string>;
        /**
         * enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
         */
        smsProvider?: pulumi.Input<string>;
        /**
         * whether to automatically approve guest and allow sponsor to revoke guest access, needs predefinedSponsorsEnabled enabled and sponsorNotifyAll disabled
         */
        sponsorAutoApprove?: pulumi.Input<boolean>;
        /**
         * list of domain allowed for sponsor email. Required if `sponsorEnabled` is `true` and `sponsors` is empty.
         */
        sponsorEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether sponsor is enabled
         */
        sponsorEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
         */
        sponsorExpire?: pulumi.Input<number>;
        /**
         * how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
         */
        sponsorLinkValidityDuration?: pulumi.Input<string>;
        /**
         * whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsorNotifyAll` and `predefinedSponsorsEnabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
         */
        sponsorNotifyAll?: pulumi.Input<boolean>;
        /**
         * if enabled, guest will get email about sponsor's action (approve/deny)
         */
        sponsorStatusNotify?: pulumi.Input<boolean>;
        /**
         * object of allowed sponsors email with name. Required if `sponsorEnabled`
         *             is `true` and `sponsorEmailDomains` is empty.
         *
         *             Property key is the sponsor email, Property value is the sponsor name
         */
        sponsors?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * if `wlanPortalAuth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
         */
        ssoDefaultRole?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`
         */
        ssoForcedRole?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, IDP Cert (used to verify the signed response)
         */
        ssoIdpCert?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
         */
        ssoIdpSignAlgo?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, IDP Single-Sign-On URL
         */
        ssoIdpSsoUrl?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, IDP issuer URL
         */
        ssoIssuer?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`. enum: `email`, `unspecified`
         */
        ssoNameidFormat?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`telstra`, Client ID provided by Telstra
         */
        telstraClientId?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`telstra`, Client secret provided by Telstra
         */
        telstraClientSecret?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`twilio`, Auth token account with twilio account
         */
        twilioAuthToken?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
         */
        twilioPhoneNumber?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`twilio`, Account SID provided by Twilio
         */
        twilioSid?: pulumi.Input<string>;
    }

    export interface WlanPortalTemplatePortalTemplate {
        accessCodeAlternateEmail?: pulumi.Input<string>;
        /**
         * defines alignment on portal. enum: `center`, `left`, `right`
         */
        alignment?: pulumi.Input<string>;
        /**
         * label for Amazon auth button
         */
        authButtonAmazon?: pulumi.Input<string>;
        /**
         * label for Azure auth button
         */
        authButtonAzure?: pulumi.Input<string>;
        /**
         * label for Email auth button
         */
        authButtonEmail?: pulumi.Input<string>;
        /**
         * label for Facebook auth button
         */
        authButtonFacebook?: pulumi.Input<string>;
        /**
         * label for Google auth button
         */
        authButtonGoogle?: pulumi.Input<string>;
        /**
         * label for Microsoft auth button
         */
        authButtonMicrosoft?: pulumi.Input<string>;
        /**
         * label for passphrase auth button
         */
        authButtonPassphrase?: pulumi.Input<string>;
        /**
         * label for SMS auth button
         */
        authButtonSms?: pulumi.Input<string>;
        /**
         * label for Sponsor auth button
         */
        authButtonSponsor?: pulumi.Input<string>;
        authLabel?: pulumi.Input<string>;
        /**
         * label of the link to go back to /logon
         */
        backLink?: pulumi.Input<string>;
        /**
         * Portal main color
         */
        color?: pulumi.Input<string>;
        colorDark?: pulumi.Input<string>;
        colorLight?: pulumi.Input<string>;
        /**
         * whether company field is required
         */
        company?: pulumi.Input<boolean>;
        /**
         * error message when company not provided
         */
        companyError?: pulumi.Input<string>;
        /**
         * label of company field
         */
        companyLabel?: pulumi.Input<string>;
        /**
         * whether email field is required
         */
        email?: pulumi.Input<boolean>;
        /**
         * error message when a user has valid social login but doesn't match specified email domains.
         */
        emailAccessDomainError?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission using email auth
         */
        emailCancel?: pulumi.Input<string>;
        emailCodeCancel?: pulumi.Input<string>;
        emailCodeError?: pulumi.Input<string>;
        emailCodeFieldLabel?: pulumi.Input<string>;
        emailCodeMessage?: pulumi.Input<string>;
        emailCodeSubmit?: pulumi.Input<string>;
        emailCodeTitle?: pulumi.Input<string>;
        /**
         * error message when email not provided
         */
        emailError?: pulumi.Input<string>;
        emailFieldLabel?: pulumi.Input<string>;
        /**
         * label of email field
         */
        emailLabel?: pulumi.Input<string>;
        emailMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button using email auth
         */
        emailSubmit?: pulumi.Input<string>;
        /**
         * Title for the Email registration
         */
        emailTitle?: pulumi.Input<string>;
        /**
         * whether to ask field1
         */
        field1?: pulumi.Input<boolean>;
        /**
         * error message when field1 not provided
         */
        field1error?: pulumi.Input<string>;
        /**
         * label of field1
         */
        field1label?: pulumi.Input<string>;
        /**
         * whether field1 is required field
         */
        field1required?: pulumi.Input<boolean>;
        /**
         * whether to ask field2
         */
        field2?: pulumi.Input<boolean>;
        /**
         * error message when field2 not provided
         */
        field2error?: pulumi.Input<string>;
        /**
         * label of field2
         */
        field2label?: pulumi.Input<string>;
        /**
         * whether field2 is required field
         */
        field2required?: pulumi.Input<boolean>;
        /**
         * whether to ask field3
         */
        field3?: pulumi.Input<boolean>;
        /**
         * error message when field3 not provided
         */
        field3error?: pulumi.Input<string>;
        /**
         * label of field3
         */
        field3label?: pulumi.Input<string>;
        /**
         * whether field3 is required field
         */
        field3required?: pulumi.Input<boolean>;
        /**
         * whether to ask field4
         */
        field4?: pulumi.Input<boolean>;
        /**
         * error message when field4 not provided
         */
        field4error?: pulumi.Input<string>;
        /**
         * label of field4
         */
        field4label?: pulumi.Input<string>;
        /**
         * whether field4 is required field
         */
        field4required?: pulumi.Input<boolean>;
        /**
         * Can be used to localize the portal based on the User Agent. Allowed property key values are:
         *   `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
         *   `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
         *   `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
         *   `zh-Hans`, `zh-Hant`
         */
        locales?: pulumi.Input<{[key: string]: pulumi.Input<inputs.org.WlanPortalTemplatePortalTemplateLocales>}>;
        /**
         * path to the background image file. File must be a `png` image less than 100kB and image dimension must be less 500px x 200px (width x height).
         */
        logo?: pulumi.Input<string>;
        message?: pulumi.Input<string>;
        multiAuth?: pulumi.Input<boolean>;
        /**
         * whether name field is required
         */
        name?: pulumi.Input<boolean>;
        /**
         * error message when name not provided
         */
        nameError?: pulumi.Input<string>;
        /**
         * label of name field
         */
        nameLabel?: pulumi.Input<string>;
        /**
         * Default value for the `Do not store` checkbox
         */
        optOutDefault?: pulumi.Input<boolean>;
        /**
         * whether to display Do Not Store My Personal Information
         */
        optout?: pulumi.Input<boolean>;
        /**
         * label for Do Not Store My Personal Information
         */
        optoutLabel?: pulumi.Input<string>;
        pageTitle?: pulumi.Input<string>;
        /**
         * Label for the Passphrase cancel button
         */
        passphraseCancel?: pulumi.Input<string>;
        /**
         * error message when invalid passphrase is provided
         */
        passphraseError?: pulumi.Input<string>;
        /**
         * Passphrase
         */
        passphraseLabel?: pulumi.Input<string>;
        passphraseMessage?: pulumi.Input<string>;
        /**
         * Label for the Passphrase submit button
         */
        passphraseSubmit?: pulumi.Input<string>;
        /**
         * Title for passphrase details page
         */
        passphraseTitle?: pulumi.Input<string>;
        /**
         * whether to show \"Powered by Mist\"
         */
        poweredBy?: pulumi.Input<boolean>;
        /**
         * wheter to require the Privacy Term acceptance
         */
        privacy?: pulumi.Input<boolean>;
        /**
         * prefix of the label of the link to go to Privacy Policy
         */
        privacyPolicyAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when Privacy Policy not accepted
         */
        privacyPolicyError?: pulumi.Input<string>;
        /**
         * label of the link to go to Privacy Policy
         */
        privacyPolicyLink?: pulumi.Input<string>;
        /**
         * text of the Privacy Policy
         */
        privacyPolicyText?: pulumi.Input<string>;
        /**
         * label to denote required field
         */
        requiredFieldLabel?: pulumi.Input<string>;
        responsiveLayout?: pulumi.Input<boolean>;
        /**
         * label of the button to /signin
         */
        signInLabel?: pulumi.Input<string>;
        smsCarrierDefault?: pulumi.Input<string>;
        smsCarrierError?: pulumi.Input<string>;
        /**
         * label for mobile carrier drop-down list
         */
        smsCarrierFieldLabel?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission
         */
        smsCodeCancel?: pulumi.Input<string>;
        /**
         * error message when confirmation code is invalid
         */
        smsCodeError?: pulumi.Input<string>;
        smsCodeFieldLabel?: pulumi.Input<string>;
        smsCodeMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button
         */
        smsCodeSubmit?: pulumi.Input<string>;
        smsCodeTitle?: pulumi.Input<string>;
        smsCountryFieldLabel?: pulumi.Input<string>;
        smsCountryFormat?: pulumi.Input<string>;
        /**
         * Label for checkbox to specify that the user has access code
         */
        smsHaveAccessCode?: pulumi.Input<string>;
        smsIsTwilio?: pulumi.Input<boolean>;
        /**
         * format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
         */
        smsMessageFormat?: pulumi.Input<string>;
        /**
         * label for canceling mobile details for SMS auth
         */
        smsNumberCancel?: pulumi.Input<string>;
        smsNumberError?: pulumi.Input<string>;
        /**
         * label for field to provide mobile number
         */
        smsNumberFieldLabel?: pulumi.Input<string>;
        smsNumberFormat?: pulumi.Input<string>;
        smsNumberMessage?: pulumi.Input<string>;
        /**
         * label for submit button for code generation
         */
        smsNumberSubmit?: pulumi.Input<string>;
        /**
         * Title for phone number details
         */
        smsNumberTitle?: pulumi.Input<string>;
        smsUsernameFormat?: pulumi.Input<string>;
        /**
         * how long confirmation code should be considered valid (in minutes)
         */
        smsValidityDuration?: pulumi.Input<number>;
        sponsorBackLink?: pulumi.Input<string>;
        sponsorCancel?: pulumi.Input<string>;
        /**
         * label for Sponsor Email
         */
        sponsorEmail?: pulumi.Input<string>;
        sponsorEmailError?: pulumi.Input<string>;
        /**
         * html template to replace/override default sponsor email template 
         * Sponsor Email Template supports following template variables:
         *   * `approveUrl`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
         *   * `denyUrl`: Renders URL to reject the request
         *   * `guestEmail`: Renders Email ID of the guest
         *   * `guestName`: Renders Name of the guest
         *   * `field1`: Renders value of the Custom Field 1
         *   * `field2`: Renders value of the Custom Field 2
         *   * `sponsorLinkValidityDuration`: Renders validity time of the request (i.e. Approve/Deny URL)
         *   * `authExpireMinutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
         */
        sponsorEmailTemplate?: pulumi.Input<string>;
        sponsorInfoApproved?: pulumi.Input<string>;
        sponsorInfoDenied?: pulumi.Input<string>;
        sponsorInfoPending?: pulumi.Input<string>;
        /**
         * label for Sponsor Name
         */
        sponsorName?: pulumi.Input<string>;
        sponsorNameError?: pulumi.Input<string>;
        sponsorNotePending?: pulumi.Input<string>;
        /**
         * submit button label request Wifi Access and notify sponsor about guest request
         */
        sponsorRequestAccess?: pulumi.Input<string>;
        /**
         * text to display if sponsor approves request
         */
        sponsorStatusApproved?: pulumi.Input<string>;
        /**
         * text to display when sponsor denies request
         */
        sponsorStatusDenied?: pulumi.Input<string>;
        /**
         * text to display if request is still pending
         */
        sponsorStatusPending?: pulumi.Input<string>;
        /**
         * submit button label to notify sponsor about guest request
         */
        sponsorSubmit?: pulumi.Input<string>;
        sponsorsError?: pulumi.Input<string>;
        sponsorsFieldLabel?: pulumi.Input<string>;
        tos?: pulumi.Input<boolean>;
        /**
         * prefix of the label of the link to go to tos
         */
        tosAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when tos not accepted
         */
        tosError?: pulumi.Input<string>;
        /**
         * label of the link to go to tos
         */
        tosLink?: pulumi.Input<string>;
        /**
         * text of the Terms of Service
         */
        tosText?: pulumi.Input<string>;
    }

    export interface WlanPortalTemplatePortalTemplateLocales {
        /**
         * label for Amazon auth button
         */
        authButtonAmazon?: pulumi.Input<string>;
        /**
         * label for Azure auth button
         */
        authButtonAzure?: pulumi.Input<string>;
        /**
         * label for Email auth button
         */
        authButtonEmail?: pulumi.Input<string>;
        /**
         * label for Facebook auth button
         */
        authButtonFacebook?: pulumi.Input<string>;
        /**
         * label for Google auth button
         */
        authButtonGoogle?: pulumi.Input<string>;
        /**
         * label for Microsoft auth button
         */
        authButtonMicrosoft?: pulumi.Input<string>;
        /**
         * label for passphrase auth button
         */
        authButtonPassphrase?: pulumi.Input<string>;
        /**
         * label for SMS auth button
         */
        authButtonSms?: pulumi.Input<string>;
        /**
         * label for Sponsor auth button
         */
        authButtonSponsor?: pulumi.Input<string>;
        authLabel?: pulumi.Input<string>;
        /**
         * label of the link to go back to /logon
         */
        backLink?: pulumi.Input<string>;
        /**
         * error message when company not provided
         */
        companyError?: pulumi.Input<string>;
        /**
         * label of company field
         */
        companyLabel?: pulumi.Input<string>;
        /**
         * error message when a user has valid social login but doesn't match specified email domains.
         */
        emailAccessDomainError?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission using email auth
         */
        emailCancel?: pulumi.Input<string>;
        emailCodeCancel?: pulumi.Input<string>;
        emailCodeError?: pulumi.Input<string>;
        emailCodeFieldLabel?: pulumi.Input<string>;
        emailCodeMessage?: pulumi.Input<string>;
        emailCodeSubmit?: pulumi.Input<string>;
        emailCodeTitle?: pulumi.Input<string>;
        /**
         * error message when email not provided
         */
        emailError?: pulumi.Input<string>;
        emailFieldLabel?: pulumi.Input<string>;
        /**
         * label of email field
         */
        emailLabel?: pulumi.Input<string>;
        emailMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button using email auth
         */
        emailSubmit?: pulumi.Input<string>;
        /**
         * Title for the Email registration
         */
        emailTitle?: pulumi.Input<string>;
        /**
         * error message when field1 not provided
         */
        field1error?: pulumi.Input<string>;
        /**
         * label of field1
         */
        field1label?: pulumi.Input<string>;
        /**
         * error message when field2 not provided
         */
        field2error?: pulumi.Input<string>;
        /**
         * label of field2
         */
        field2label?: pulumi.Input<string>;
        /**
         * error message when field3 not provided
         */
        field3error?: pulumi.Input<string>;
        /**
         * label of field3
         */
        field3label?: pulumi.Input<string>;
        /**
         * error message when field4 not provided
         */
        field4error?: pulumi.Input<string>;
        /**
         * label of field4
         */
        field4label?: pulumi.Input<string>;
        message?: pulumi.Input<string>;
        /**
         * error message when name not provided
         */
        nameError?: pulumi.Input<string>;
        /**
         * label of name field
         */
        nameLabel?: pulumi.Input<string>;
        /**
         * label for Do Not Store My Personal Information
         */
        optoutLabel?: pulumi.Input<string>;
        pageTitle?: pulumi.Input<string>;
        /**
         * Label for the Passphrase cancel button
         */
        passphraseCancel?: pulumi.Input<string>;
        /**
         * error message when invalid passphrase is provided
         */
        passphraseError?: pulumi.Input<string>;
        /**
         * Passphrase
         */
        passphraseLabel?: pulumi.Input<string>;
        passphraseMessage?: pulumi.Input<string>;
        /**
         * Label for the Passphrase submit button
         */
        passphraseSubmit?: pulumi.Input<string>;
        /**
         * Title for passphrase details page
         */
        passphraseTitle?: pulumi.Input<string>;
        /**
         * prefix of the label of the link to go to Privacy Policy
         */
        privacyPolicyAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when Privacy Policy not accepted
         */
        privacyPolicyError?: pulumi.Input<string>;
        /**
         * label of the link to go to Privacy Policy
         */
        privacyPolicyLink?: pulumi.Input<string>;
        /**
         * text of the Privacy Policy
         */
        privacyPolicyText?: pulumi.Input<string>;
        /**
         * label to denote required field
         */
        requiredFieldLabel?: pulumi.Input<string>;
        /**
         * label of the button to /signin
         */
        signInLabel?: pulumi.Input<string>;
        smsCarrierDefault?: pulumi.Input<string>;
        smsCarrierError?: pulumi.Input<string>;
        /**
         * label for mobile carrier drop-down list
         */
        smsCarrierFieldLabel?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission
         */
        smsCodeCancel?: pulumi.Input<string>;
        /**
         * error message when confirmation code is invalid
         */
        smsCodeError?: pulumi.Input<string>;
        smsCodeFieldLabel?: pulumi.Input<string>;
        smsCodeMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button
         */
        smsCodeSubmit?: pulumi.Input<string>;
        smsCodeTitle?: pulumi.Input<string>;
        smsCountryFieldLabel?: pulumi.Input<string>;
        smsCountryFormat?: pulumi.Input<string>;
        /**
         * Label for checkbox to specify that the user has access code
         */
        smsHaveAccessCode?: pulumi.Input<string>;
        /**
         * format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
         */
        smsMessageFormat?: pulumi.Input<string>;
        /**
         * label for canceling mobile details for SMS auth
         */
        smsNumberCancel?: pulumi.Input<string>;
        smsNumberError?: pulumi.Input<string>;
        /**
         * label for field to provide mobile number
         */
        smsNumberFieldLabel?: pulumi.Input<string>;
        smsNumberFormat?: pulumi.Input<string>;
        smsNumberMessage?: pulumi.Input<string>;
        /**
         * label for submit button for code generation
         */
        smsNumberSubmit?: pulumi.Input<string>;
        /**
         * Title for phone number details
         */
        smsNumberTitle?: pulumi.Input<string>;
        smsUsernameFormat?: pulumi.Input<string>;
        sponsorBackLink?: pulumi.Input<string>;
        sponsorCancel?: pulumi.Input<string>;
        /**
         * label for Sponsor Email
         */
        sponsorEmail?: pulumi.Input<string>;
        sponsorEmailError?: pulumi.Input<string>;
        sponsorInfoApproved?: pulumi.Input<string>;
        sponsorInfoDenied?: pulumi.Input<string>;
        sponsorInfoPending?: pulumi.Input<string>;
        /**
         * label for Sponsor Name
         */
        sponsorName?: pulumi.Input<string>;
        sponsorNameError?: pulumi.Input<string>;
        sponsorNotePending?: pulumi.Input<string>;
        /**
         * submit button label request Wifi Access and notify sponsor about guest request
         */
        sponsorRequestAccess?: pulumi.Input<string>;
        /**
         * text to display if sponsor approves request
         */
        sponsorStatusApproved?: pulumi.Input<string>;
        /**
         * text to display when sponsor denies request
         */
        sponsorStatusDenied?: pulumi.Input<string>;
        /**
         * text to display if request is still pending
         */
        sponsorStatusPending?: pulumi.Input<string>;
        /**
         * submit button label to notify sponsor about guest request
         */
        sponsorSubmit?: pulumi.Input<string>;
        sponsorsError?: pulumi.Input<string>;
        sponsorsFieldLabel?: pulumi.Input<string>;
        /**
         * prefix of the label of the link to go to tos
         */
        tosAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when tos not accepted
         */
        tosError?: pulumi.Input<string>;
        /**
         * label of the link to go to tos
         */
        tosLink?: pulumi.Input<string>;
        /**
         * text of the Terms of Service
         */
        tosText?: pulumi.Input<string>;
    }

    export interface WlanQos {
        /**
         * enum: `background`, `bestEffort`, `video`, `voice`
         */
        class?: pulumi.Input<string>;
        /**
         * whether to overwrite QoS
         */
        overwrite?: pulumi.Input<boolean>;
    }

    export interface WlanRadsec {
        coaEnabled?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        idleTimeout?: pulumi.Input<number>;
        /**
         * To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
         * Org mxedge(s) identified by mxcluster_ids
         */
        mxclusterIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
         * when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
         */
        proxyHosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
         */
        serverName?: pulumi.Input<string>;
        /**
         * List of Radsec Servers. Only if not Mist Edge.
         */
        servers?: pulumi.Input<pulumi.Input<inputs.org.WlanRadsecServer>[]>;
        /**
         * use mxedge(s) as radsecproxy
         */
        useMxedge?: pulumi.Input<boolean>;
        /**
         * To use Site mxedges when this WLAN does not use mxtunnel
         */
        useSiteMxedge?: pulumi.Input<boolean>;
    }

    export interface WlanRadsecServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface WlanRateset {
        /**
         * if `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
         */
        ht?: pulumi.Input<string>;
        /**
         * if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
         */
        legacies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Minimum RSSI for client to connect, 0 means not enforcing
         */
        minRssi?: pulumi.Input<number>;
        /**
         * Data Rates template to apply. enum: 
         *   * `no-legacy`: no 11b
         *   * `compatible`: all, like before, default setting that Broadcom/Atheros used
         *   * `legacy-only`: disable 802.11n and 802.11ac
         *   * `high-density`: no 11b, no low rates
         *   * `custom`: user defined
         */
        template?: pulumi.Input<string>;
        /**
         * if `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
         */
        vht?: pulumi.Input<string>;
    }

    export interface WlanSchedule {
        enabled?: pulumi.Input<boolean>;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
         *
         * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
         */
        hours?: pulumi.Input<inputs.org.WlanScheduleHours>;
    }

    export interface WlanScheduleHours {
        fri?: pulumi.Input<string>;
        mon?: pulumi.Input<string>;
        sat?: pulumi.Input<string>;
        sun?: pulumi.Input<string>;
        thu?: pulumi.Input<string>;
        tue?: pulumi.Input<string>;
        wed?: pulumi.Input<string>;
    }

    export interface WlantemplateApplies {
        orgId?: pulumi.Input<string>;
        /**
         * list of site ids
         */
        siteIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of sitegroup ids
         */
        sitegroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WlantemplateExceptions {
        /**
         * list of site ids
         */
        siteIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of sitegroup ids
         */
        sitegroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WxtagSpec {
        /**
         * matched destination port, "0" means any
         */
        portRange?: pulumi.Input<string>;
        /**
         * tcp / udp / icmp / gre / any / ":protocol_number", `protocolNumber` is between 1-254
         */
        protocol?: pulumi.Input<string>;
        /**
         * matched destination subnets and/or IP Addresses
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace site {
    export interface BaseLatlng {
        lat: pulumi.Input<number>;
        lng: pulumi.Input<number>;
    }

    export interface EvpnTopologyEvpnOptions {
        /**
         * optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
         */
        autoLoopbackSubnet?: pulumi.Input<string>;
        /**
         * optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides
         */
        autoLoopbackSubnet6?: pulumi.Input<string>;
        /**
         * optional, this generates routerId automatically, if specified, `routerIdPrefix` is ignored
         */
        autoRouterIdSubnet?: pulumi.Input<string>;
        /**
         * optional, this generates routerId automatically, if specified, `routerIdPrefix` is ignored
         */
        autoRouterIdSubnet6?: pulumi.Input<string>;
        /**
         * optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway
         * when `routedAt` != `core`, whether to do virtual-gateway at core as well
         */
        coreAsBorder?: pulumi.Input<boolean>;
        overlay?: pulumi.Input<inputs.site.EvpnTopologyEvpnOptionsOverlay>;
        /**
         * by default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4Mac
         * if enabled, 00-00-5e-00-XX-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)
         */
        perVlanVgaV4Mac?: pulumi.Input<boolean>;
        /**
         * optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`
         */
        routedAt?: pulumi.Input<string>;
        underlay?: pulumi.Input<inputs.site.EvpnTopologyEvpnOptionsUnderlay>;
        /**
         * optional, for EX9200 only to seggregate virtual-switches
         */
        vsInstances?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.EvpnTopologyEvpnOptionsVsInstances>}>;
    }

    export interface EvpnTopologyEvpnOptionsOverlay {
        /**
         * Overlay BGP Local AS Number
         */
        as?: pulumi.Input<number>;
    }

    export interface EvpnTopologyEvpnOptionsUnderlay {
        /**
         * Underlay BGP Base AS Number
         */
        asBase?: pulumi.Input<number>;
        routedIdPrefix?: pulumi.Input<string>;
        /**
         * underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6
         */
        subnet?: pulumi.Input<string>;
        /**
         * if v6 is desired for underlay
         */
        useIpv6?: pulumi.Input<boolean>;
    }

    export interface EvpnTopologyEvpnOptionsVsInstances {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EvpnTopologySwitches {
        deviceprofileId?: pulumi.Input<string>;
        evpnId?: pulumi.Input<number>;
        mac?: pulumi.Input<string>;
        model?: pulumi.Input<string>;
        /**
         * optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. 
         *   * for CLOS, to group dist / access switches into pods
         *   * for ERB/CRB, to group dist / esilag-access into pods
         */
        pod?: pulumi.Input<number>;
        /**
         * by default, core switches are assumed to be connecting all pods. 
         * if you want to limit the pods, you can specify pods.
         */
        pods?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`
         */
        role: pulumi.Input<string>;
        routerId?: pulumi.Input<string>;
        siteId?: pulumi.Input<string>;
    }

    export interface NetworktemplateAclPolicy {
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        actions?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateAclPolicyAction>[]>;
        name?: pulumi.Input<string>;
        /**
         * - for GBP-based policy, all srcTags and dstTags have to be gbp-based
         * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
         */
        srcTags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateAclPolicyAction {
        /**
         * enum: `allow`, `deny`
         */
        action?: pulumi.Input<string>;
        dstTag: pulumi.Input<string>;
    }

    export interface NetworktemplateAclTags {
        /**
         * required if
         * - `type`==`dynamicGbp` (gbp_tag received from RADIUS)
         * - `type`==`gbpResource`
         * - `type`==`staticGbp` (applying gbp tag against matching conditions)
         */
        gbpTag?: pulumi.Input<number>;
        /**
         * required if 
         * - `type`==`mac`
         * - `type`==`staticGbp` if from matching mac
         */
        macs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * if:
         *   * `type`==`mac` (optional. default is `any`)
         *   * `type`==`subnet` (optional. default is `any`)
         *   * `type`==`network`
         *   * `type`==`resource` (optional. default is `any`)
         *   * `type`==`staticGbp` if from matching network (vlan)'
         */
        network?: pulumi.Input<string>;
        /**
         * required if:
         *   * `type`==`radiusGroup`
         *   * `type`==`staticGbp`
         * if from matching radius_group
         */
        radiusGroup?: pulumi.Input<string>;
        /**
         * if `type`==`resource` or `type`==`gbpResource`
         * empty means unrestricted, i.e. any
         */
        specs?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateAclTagsSpec>[]>;
        /**
         * if 
         * - `type`==`subnet` 
         * - `type`==`resource` (optional. default is `any`)
         * - `type`==`staticGbp` if from matching subnet
         */
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: 
         *   * `any`: matching anything not identified
         *   * `dynamicGbp`: from the gbpTag received from RADIUS
         *   * `gbpResource`: can only be used in `dstTags`
         *   * `mac`
         *   * `network`
         *   * `radiusGroup`
         *   * `resource`: can only be used in `dstTags`
         *   * `staticGbp`: applying gbp tag against matching conditions
         *   * `subnet`'
         */
        type: pulumi.Input<string>;
    }

    export interface NetworktemplateAclTagsSpec {
        /**
         * matched dst port, "0" means any
         */
        portRange?: pulumi.Input<string>;
        /**
         * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocolNumber` is between 1-254
         */
        protocol?: pulumi.Input<string>;
    }

    export interface NetworktemplateDhcpSnooping {
        allNetworks?: pulumi.Input<boolean>;
        /**
         * Enable for dynamic ARP inspection check
         */
        enableArpSpoofCheck?: pulumi.Input<boolean>;
        /**
         * Enable for check for forging source IP address
         */
        enableIpSourceGuard?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * if `allNetworks`==`false`, list of network with DHCP snooping enabled
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateExtraRoutes {
        /**
         * this takes precedence
         */
        discard?: pulumi.Input<boolean>;
        metric?: pulumi.Input<number>;
        nextQualified?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateExtraRoutesNextQualified>}>;
        noResolve?: pulumi.Input<boolean>;
        preference?: pulumi.Input<number>;
        /**
         * next-hop IP Address
         */
        via: pulumi.Input<string>;
    }

    export interface NetworktemplateExtraRoutes6 {
        /**
         * this takes precedence
         */
        discard?: pulumi.Input<boolean>;
        metric?: pulumi.Input<number>;
        nextQualified?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateExtraRoutes6NextQualified>}>;
        noResolve?: pulumi.Input<boolean>;
        preference?: pulumi.Input<number>;
        /**
         * next-hop IP Address
         */
        via: pulumi.Input<string>;
    }

    export interface NetworktemplateExtraRoutes6NextQualified {
        metric?: pulumi.Input<number>;
        preference?: pulumi.Input<number>;
    }

    export interface NetworktemplateExtraRoutesNextQualified {
        metric?: pulumi.Input<number>;
        preference?: pulumi.Input<number>;
    }

    export interface NetworktemplateMistNac {
        enabled?: pulumi.Input<boolean>;
        network?: pulumi.Input<string>;
    }

    export interface NetworktemplateNetworks {
        /**
         * only required for EVPN-VXLAN networks, IPv4 Virtual Gateway
         */
        gateway?: pulumi.Input<string>;
        /**
         * only required for EVPN-VXLAN networks, IPv6 Virtual Gateway
         */
        gateway6?: pulumi.Input<string>;
        /**
         * whether to stop clients to talk to each other, default is false (when enabled, a unique isolationVlanId is required)
         * NOTE: this features requires uplink device to also a be Juniper device and `interSwitchLink` to be set
         */
        isolation?: pulumi.Input<boolean>;
        isolationVlanId?: pulumi.Input<string>;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet?: pulumi.Input<string>;
        /**
         * optional for pure switching, required when L3 / routing features are used
         */
        subnet6?: pulumi.Input<string>;
        vlanId: pulumi.Input<string>;
    }

    export interface NetworktemplateOspfAreas {
        includeLoopback?: pulumi.Input<boolean>;
        ospfNetworks: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateOspfAreasOspfNetworks>}>;
        /**
         * OSPF type. enum: `default`, `nssa`, `stub`
         */
        type?: pulumi.Input<string>;
    }

    export interface NetworktemplateOspfAreasOspfNetworks {
        /**
         * Required if `authType`==`md5`. Property key is the key number
         */
        authKeys?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Required if `authType`==`password`, the password, max length is 8
         */
        authPassword?: pulumi.Input<string>;
        /**
         * auth type. enum: `md5`, `none`, `password`
         */
        authType?: pulumi.Input<string>;
        bfdMinimumInterval?: pulumi.Input<number>;
        deadInterval?: pulumi.Input<number>;
        exportPolicy?: pulumi.Input<string>;
        helloInterval?: pulumi.Input<number>;
        importPolicy?: pulumi.Input<string>;
        /**
         * interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`
         */
        interfaceType?: pulumi.Input<string>;
        metric?: pulumi.Input<number>;
        /**
         * by default, we'll re-advertise all learned OSPF routes toward overlay
         */
        noReadvertiseToOverlay?: pulumi.Input<boolean>;
        /**
         * whether to send OSPF-Hello
         */
        passive?: pulumi.Input<boolean>;
    }

    export interface NetworktemplatePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: pulumi.Input<string>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: pulumi.Input<string>;
    }

    export interface NetworktemplatePortUsages {
        /**
         * Only if `mode`==`trunk` whether to trunk all network/vlans
         */
        allNetworks?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
         * All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state.
         * When it is not defined, it means using the system's default setting which depends on whether the port is a access or trunk port.
         */
        allowDhcpd?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        allowMultipleSupplicants?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDown?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         */
        bypassAuthWhenServerDownForUnkonwnClient?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        description?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` whether the port is disabled
         */
        disabled?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         */
        dynamicVlanNetworks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` whether to enable MAC Auth
         */
        enableMacAuth?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic`
         */
        enableQos?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         */
        guestNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` interSwitchLink is used together with "isolation" under networks
         * NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         */
        interSwitchLink?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         */
        macAuthOnly?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
         */
        macAuthPreferred?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         */
        macAuthProtocol?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         */
        macLimit?: pulumi.Input<number>;
        /**
         * `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         */
        mode?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         */
        mtu?: pulumi.Input<number>;
        /**
         * Only if `mode`==`trunk`, the list of network/vlans
         */
        networks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only if `mode`==`access` and `portAuth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         */
        persistMac?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         */
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         */
        portAuth?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         */
        portNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range
         */
        reauthInterval?: pulumi.Input<number>;
        /**
         * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         */
        resetDefaultWhen?: pulumi.Input<string>;
        /**
         * Only if `mode`==`dynamic`
         */
        rules?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplatePortUsagesRule>[]>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` sets server fail fallback vlan
         */
        serverFailNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` and `portAuth`==`dot1x` when radius server reject / fails
         */
        serverRejectNetwork?: pulumi.Input<string>;
        /**
         * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * Switch storm control
         * Only if `mode`!=`dynamic`
         */
        stormControl?: pulumi.Input<inputs.site.NetworktemplatePortUsagesStormControl>;
        /**
         * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         */
        stpEdge?: pulumi.Input<boolean>;
        stpNoRootPort?: pulumi.Input<boolean>;
        stpP2p?: pulumi.Input<boolean>;
        /**
         * optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
         */
        uiEvpntopoId?: pulumi.Input<string>;
        /**
         * if this is connected to a vstp network
         */
        useVstp?: pulumi.Input<boolean>;
        /**
         * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         */
        voipNetwork?: pulumi.Input<string>;
    }

    export interface NetworktemplatePortUsagesRule {
        equals?: pulumi.Input<string>;
        /**
         * use `equalsAny` to match any item in a list
         */
        equalsAnies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * "[0:3]":"abcdef" > "abc"
         * "split(.)[1]": "a.b.c" > "b"
         * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
         */
        expression?: pulumi.Input<string>;
        /**
         * enum: `linkPeermac`, `lldpChassisId`, `lldpHardwareRevision`, `lldpManufacturerName`, `lldpOui`, `lldpSerialNumber`, `lldpSystemName`, `radiusDynamicfilter`, `radiusUsermac`, `radiusUsername`
         */
        src: pulumi.Input<string>;
        /**
         * `portUsage` name
         */
        usage?: pulumi.Input<string>;
    }

    export interface NetworktemplatePortUsagesStormControl {
        /**
         * whether to disable storm control on broadcast traffic
         */
        noBroadcast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on multicast traffic
         */
        noMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on registered multicast traffic
         */
        noRegisteredMulticast?: pulumi.Input<boolean>;
        /**
         * whether to disable storm control on unknown unicast traffic
         */
        noUnknownUnicast?: pulumi.Input<boolean>;
        /**
         * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
         */
        percentage?: pulumi.Input<number>;
    }

    export interface NetworktemplateRadiusConfig {
        /**
         * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
         */
        acctInterimInterval?: pulumi.Input<number>;
        acctServers?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRadiusConfigAcctServer>[]>;
        authServers?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRadiusConfigAuthServer>[]>;
        /**
         * radius auth session retries
         */
        authServersRetries?: pulumi.Input<number>;
        /**
         * radius auth session timeout
         */
        authServersTimeout?: pulumi.Input<number>;
        /**
         * use `network`or `sourceIp`
         * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
         */
        network?: pulumi.Input<string>;
        /**
         * use `network`or `sourceIp`
         */
        sourceIp?: pulumi.Input<string>;
    }

    export interface NetworktemplateRadiusConfigAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Acct port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface NetworktemplateRadiusConfigAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Auth port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * whether to require Message-Authenticator in requests
         */
        requireMessageAuthenticator?: pulumi.Input<boolean>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslog {
        archive?: pulumi.Input<inputs.site.NetworktemplateRemoteSyslogArchive>;
        console?: pulumi.Input<inputs.site.NetworktemplateRemoteSyslogConsole>;
        enabled?: pulumi.Input<boolean>;
        files?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogFile>[]>;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        network?: pulumi.Input<string>;
        sendToAllServers?: pulumi.Input<boolean>;
        servers?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogServer>[]>;
        /**
         * enum: `millisecond`, `year`, `year millisecond`
         */
        timeFormat?: pulumi.Input<string>;
        users?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogUser>[]>;
    }

    export interface NetworktemplateRemoteSyslogArchive {
        files?: pulumi.Input<number>;
        size?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogConsole {
        contents?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogConsoleContent>[]>;
    }

    export interface NetworktemplateRemoteSyslogConsoleContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogFile {
        archive?: pulumi.Input<inputs.site.NetworktemplateRemoteSyslogFileArchive>;
        contents?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogFileContent>[]>;
        explicitPriority?: pulumi.Input<boolean>;
        file?: pulumi.Input<string>;
        match?: pulumi.Input<string>;
        structuredData?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateRemoteSyslogFileArchive {
        files?: pulumi.Input<number>;
        size?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogFileContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogServer {
        contents?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogServerContent>[]>;
        explicitPriority?: pulumi.Input<boolean>;
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        host?: pulumi.Input<string>;
        match?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        /**
         * enum: `tcp`, `udp`
         */
        protocol?: pulumi.Input<string>;
        routingInstance?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
        /**
         * if sourceAddress is configured, will use the vlan firstly otherwise use source_ip
         */
        sourceAddress?: pulumi.Input<string>;
        structuredData?: pulumi.Input<boolean>;
        tag?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogServerContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogUser {
        contents?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateRemoteSyslogUserContent>[]>;
        match?: pulumi.Input<string>;
        user?: pulumi.Input<string>;
    }

    export interface NetworktemplateRemoteSyslogUserContent {
        /**
         * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
         */
        facility?: pulumi.Input<string>;
        /**
         * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
         */
        severity?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfig {
        clientLists?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigClientList>[]>;
        contact?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
         */
        engineId?: pulumi.Input<string>;
        location?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        trapGroups?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigTrapGroup>[]>;
        v2cConfigs?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV2cConfig>[]>;
        v3Config?: pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3Config>;
        views?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigView>[]>;
    }

    export interface NetworktemplateSnmpConfigClientList {
        clientListName?: pulumi.Input<string>;
        clients?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateSnmpConfigTrapGroup {
        categories?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
         */
        groupName?: pulumi.Input<string>;
        targets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * enum: `all`, `v1`, `v2`
         */
        version?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV2cConfig {
        authorization?: pulumi.Input<string>;
        /**
         * client_list_name here should refer to clientList above
         */
        clientListName?: pulumi.Input<string>;
        communityName?: pulumi.Input<string>;
        /**
         * view name here should be defined in views above
         */
        view?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3Config {
        notifies?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigNotify>[]>;
        notifyFilters?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigNotifyFilter>[]>;
        targetAddresses?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigTargetAddress>[]>;
        targetParameters?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigTargetParameter>[]>;
        usm?: pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigUsm>;
        vacm?: pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigVacm>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotify {
        name?: pulumi.Input<string>;
        tag?: pulumi.Input<string>;
        /**
         * enum: `inform`, `trap`
         */
        type?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilter {
        contents?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigNotifyFilterContent>[]>;
        profileName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigNotifyFilterContent {
        include?: pulumi.Input<boolean>;
        oid?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetAddress {
        address?: pulumi.Input<string>;
        addressMask?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        /**
         * <refer to notify tag, can be multiple with blank
         */
        tagList?: pulumi.Input<string>;
        targetAddressName?: pulumi.Input<string>;
        /**
         * refer to notify target parameters name
         */
        targetParameters?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigTargetParameter {
        /**
         * enum: `v1`, `v2c`, `v3`
         */
        messageProcessingModel?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * refer to profile-name in notify_filter
         */
        notifyFilter?: pulumi.Input<string>;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
        /**
         * refer to securityName in usm
         */
        securityName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsm {
        /**
         * enum: `localEngine`, `remoteEngine`
         */
        engineType?: pulumi.Input<string>;
        /**
         * required only if `engineType`==`remoteEngine`
         */
        engineid?: pulumi.Input<string>;
        users?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigUsmUser>[]>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigUsmUser {
        /**
         * Not required if `authenticationType`==`authenticationNone`
         * include alphabetic, numeric, and special characters, but it cannot include control characters.
         */
        authenticationPassword?: pulumi.Input<string>;
        /**
         * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authenticationMd5`, `authenticationNone`, `authenticationSha`, `authenticationSha224`, `authenticationSha256`, `authenticationSha384`, `authenticationSha512`
         */
        authenticationType?: pulumi.Input<string>;
        /**
         * Not required if `encryptionType`==`privacy-none`
         * include alphabetic, numeric, and special characters, but it cannot include control characters
         */
        encryptionPassword?: pulumi.Input<string>;
        /**
         * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
         */
        encryptionType?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacm {
        accesses?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigVacmAccess>[]>;
        securityToGroup?: pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccess {
        groupName?: pulumi.Input<string>;
        prefixLists?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList>[]>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList {
        /**
         * only required if `type`==`contextPrefix`
         */
        contextPrefix?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        notifyView?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        readView?: pulumi.Input<string>;
        /**
         * enum: `authentication`, `none`, `privacy`
         */
        securityLevel?: pulumi.Input<string>;
        /**
         * enum: `any`, `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
        /**
         * enum: `contextPrefix`, `defaultContextPrefix`
         */
        type?: pulumi.Input<string>;
        /**
         * refer to view name
         */
        writeView?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup {
        contents?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent>[]>;
        /**
         * enum: `usm`, `v1`, `v2c`
         */
        securityModel?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent {
        /**
         * refer to groupName under access
         */
        group?: pulumi.Input<string>;
        securityName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSnmpConfigView {
        /**
         * if the root oid configured is included
         */
        include?: pulumi.Input<boolean>;
        oid?: pulumi.Input<string>;
        viewName?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMatching {
        enable?: pulumi.Input<boolean>;
        /**
         * list of rules to define custom switch configuration based on different criterias. Each list must have at least one of `matchModel`, `matchName` or `matchRole` must be defined
         */
        rules?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSwitchMatchingRule>[]>;
    }

    export interface NetworktemplateSwitchMatchingRule {
        /**
         * additional CLI commands to append to the generated Junos config. **Note**: no check is done
         */
        additionalConfigCmds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * In-Band Management interface configuration
         */
        ipConfig?: pulumi.Input<inputs.site.NetworktemplateSwitchMatchingRuleIpConfig>;
        /**
         * string the switch model must start with to use this rule. It is possible to combine with the `matchName` and `matchRole` attributes
         */
        matchModel?: pulumi.Input<string>;
        /**
         * string the switch name must start with to use this rule. Use the `matchNameOffset` to indicate the first character of the switch name to compare to. It is possible to combine with the `matchModel` and `matchRole` attributes
         */
        matchName?: pulumi.Input<string>;
        /**
         * first character of the switch name to compare to the `matchName` value
         */
        matchNameOffset?: pulumi.Input<number>;
        /**
         * string the switch role must start with to use this rule. It is possible to combine with the `matchName` and `matchModel` attributes
         */
        matchRole?: pulumi.Input<string>;
        /**
         * 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `matchModel`,  `match_model[0-6]`
         *
         * @deprecated The `matchType` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `matchName`, `matchModel` and `matchRole`attribuites and may be removed in future versions.
Please update your configurations.
         */
        matchType?: pulumi.Input<string>;
        /**
         * @deprecated The `matchValue` attribute has been deprecated in version v0.2.8 of the Juniper-Mist Provider. It has been replaced with the `matchName`, `matchModel` and `matchRole`attribuites and may be removed in future versions.
Please update your configurations.
         */
        matchValue?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Out-of-Band Management interface configuration
         */
        oobIpConfig?: pulumi.Input<inputs.site.NetworktemplateSwitchMatchingRuleOobIpConfig>;
        /**
         * Propery key is the interface name or interface range
         */
        portConfig?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateSwitchMatchingRulePortConfig>}>;
        /**
         * Property key is the port mirroring instance name
         * portMirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 port mirrorings is allowed
         */
        portMirroring?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateSwitchMatchingRulePortMirroring>}>;
    }

    export interface NetworktemplateSwitchMatchingRuleIpConfig {
        /**
         * VLAN Name for the management interface
         */
        network?: pulumi.Input<string>;
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMatchingRuleOobIpConfig {
        /**
         * enum: `dhcp`, `static`
         */
        type?: pulumi.Input<string>;
        /**
         * if supported on the platform. If enabled, DNS will be using this routing-instance, too
         */
        useMgmtVrf?: pulumi.Input<boolean>;
        /**
         * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
         */
        useMgmtVrfForHostOut?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateSwitchMatchingRulePortConfig {
        /**
         * To disable LACP support for the AE interface
         */
        aeDisableLacp?: pulumi.Input<boolean>;
        /**
         * Users could force to use the designated AE name
         */
        aeIdx?: pulumi.Input<number>;
        /**
         * to use fast timeout
         */
        aeLacpSlow?: pulumi.Input<boolean>;
        aggregated?: pulumi.Input<boolean>;
        /**
         * if want to generate port up/down alarm
         */
        critical?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        /**
         * if `speed` and `duplex` are specified, whether to disable autonegotiation
         */
        disableAutoneg?: pulumi.Input<boolean>;
        /**
         * enum: `auto`, `full`, `half`
         */
        duplex?: pulumi.Input<string>;
        /**
         * Enable dynamic usage for this port. Set to `dynamic` to enable.
         */
        dynamicUsage?: pulumi.Input<string>;
        esilag?: pulumi.Input<boolean>;
        /**
         * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
         */
        mtu?: pulumi.Input<number>;
        /**
         * prevent helpdesk to override the port config
         */
        noLocalOverwrite?: pulumi.Input<boolean>;
        poeDisabled?: pulumi.Input<boolean>;
        /**
         * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         */
        speed?: pulumi.Input<string>;
        /**
         * port usage name. If EVPN is used, use `evpnUplink`or `evpnDownlink`
         */
        usage: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMatchingRulePortMirroring {
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputNetworksIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsEgresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * at least one of the `inputPortIdsIngress`, `inputPortIdsEgress` or `inputNetworksIngress ` should be specified
         */
        inputPortIdsIngresses?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputNetwork?: pulumi.Input<string>;
        /**
         * exaclty one of the `outputPortId` or `outputNetwork` should be provided
         */
        outputPortId?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMgmt {
        /**
         * ap_affinity_threshold apAffinityThreshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
         */
        apAffinityThreshold?: pulumi.Input<number>;
        /**
         * Set Banners for switches. Allows markup formatting
         */
        cliBanner?: pulumi.Input<string>;
        /**
         * Sets timeout for switches
         */
        cliIdleTimeout?: pulumi.Input<number>;
        /**
         * the rollback timer for commit confirmed
         */
        configRevertTimer?: pulumi.Input<number>;
        /**
         * Enable to provide the FQDN with DHCP option 81
         */
        dhcpOptionFqdn?: pulumi.Input<boolean>;
        disableOobDownAlarm?: pulumi.Input<boolean>;
        /**
         * Property key is the user name. For Local user authentication
         */
        localAccounts?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateSwitchMgmtLocalAccounts>}>;
        mxedgeProxyHost?: pulumi.Input<string>;
        mxedgeProxyPort?: pulumi.Input<number>;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: pulumi.Input<inputs.site.NetworktemplateSwitchMgmtProtectRe>;
        rootPassword?: pulumi.Input<string>;
        tacacs?: pulumi.Input<inputs.site.NetworktemplateSwitchMgmtTacacs>;
        /**
         * to use mxedge as proxy
         */
        useMxedgeProxy?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateSwitchMgmtLocalAccounts {
        password?: pulumi.Input<string>;
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        role?: pulumi.Input<string>;
    }

    export interface NetworktemplateSwitchMgmtProtectRe {
        /**
         * optionally, services we'll allow. enum: `icmp`, `ssh`
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        customs?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSwitchMgmtProtectReCustom>[]>;
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateSwitchMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        portRange?: pulumi.Input<string>;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        protocol?: pulumi.Input<string>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateSwitchMgmtTacacs {
        acctServers?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSwitchMgmtTacacsAcctServer>[]>;
        /**
         * enum: `admin`, `helpdesk`, `none`, `read`
         */
        defaultRole?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * which network the TACACS server resides
         */
        network?: pulumi.Input<string>;
        tacplusServers?: pulumi.Input<pulumi.Input<inputs.site.NetworktemplateSwitchMgmtTacacsTacplusServer>[]>;
    }

    export interface NetworktemplateSwitchMgmtTacacsAcctServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        secret?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface NetworktemplateSwitchMgmtTacacsTacplusServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        secret?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface NetworktemplateVrfConfig {
        /**
         * whether to enable VRF (when supported on the device)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface NetworktemplateVrfInstances {
        /**
         * Property key is the destination CIDR (e.g. "10.0.0.0/8")
         */
        extraRoutes?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.NetworktemplateVrfInstancesExtraRoutes>}>;
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworktemplateVrfInstancesExtraRoutes {
        /**
         * Next-hop address
         */
        via: pulumi.Input<string>;
    }

    export interface SettingAnalytic {
        /**
         * enable Advanced Analytic feature (using SUB-ANA license)
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingAutoUpgrade {
        /**
         * custom versions for different models. Property key is the model name (e.g. "AP41")
         */
        customVersions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
         */
        dayOfWeek?: pulumi.Input<string>;
        /**
         * whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
         */
        timeOfDay?: pulumi.Input<string>;
        /**
         * desired version. enum: `beta`, `custom`, `stable`
         */
        version?: pulumi.Input<string>;
    }

    export interface SettingBleConfig {
        /**
         * whether Mist beacons is enabled
         */
        beaconEnabled?: pulumi.Input<boolean>;
        /**
         * required if `beaconRateMode`==`custom`, 1-10, in number-beacons-per-second
         */
        beaconRate?: pulumi.Input<number>;
        /**
         * enum: `custom`, `default`
         */
        beaconRateMode?: pulumi.Input<string>;
        /**
         * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
         */
        beamDisableds?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send custom packet
         */
        customBlePacketEnabled?: pulumi.Input<boolean>;
        /**
         * The custom frame to be sent out in this beacon. The frame must be a hexstring
         */
        customBlePacketFrame?: pulumi.Input<string>;
        /**
         * Frequency (msec) of data emitted by custom ble beacon
         */
        customBlePacketFreqMsec?: pulumi.Input<number>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUidAdvPower?: pulumi.Input<number>;
        eddystoneUidBeams?: pulumi.Input<string>;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-UID beacon is enabled
         */
        eddystoneUidEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emmit by Eddystone-UID beacon
         */
        eddystoneUidFreqMsec?: pulumi.Input<number>;
        /**
         * Eddystone-UID instance for the device
         */
        eddystoneUidInstance?: pulumi.Input<string>;
        /**
         * Eddystone-UID namespace
         */
        eddystoneUidNamespace?: pulumi.Input<string>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        eddystoneUrlAdvPower?: pulumi.Input<number>;
        eddystoneUrlBeams?: pulumi.Input<string>;
        /**
         * only if `beaconEnabled`==`false`, Whether Eddystone-URL beacon is enabled
         */
        eddystoneUrlEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emit by Eddystone-UID beacon
         */
        eddystoneUrlFreqMsec?: pulumi.Input<number>;
        /**
         * URL pointed by Eddystone-URL beacon
         */
        eddystoneUrlUrl?: pulumi.Input<string>;
        /**
         * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
         */
        ibeaconAdvPower?: pulumi.Input<number>;
        ibeaconBeams?: pulumi.Input<string>;
        /**
         * can be enabled if `beaconEnabled`==`true`, whether to send iBeacon
         */
        ibeaconEnabled?: pulumi.Input<boolean>;
        /**
         * Frequency (msec) of data emmit for iBeacon
         */
        ibeaconFreqMsec?: pulumi.Input<number>;
        /**
         * Major number for iBeacon
         */
        ibeaconMajor?: pulumi.Input<number>;
        /**
         * Minor number for iBeacon
         */
        ibeaconMinor?: pulumi.Input<number>;
        /**
         * optional, if not specified, the same UUID as the beacon will be used
         */
        ibeaconUuid?: pulumi.Input<string>;
        /**
         * required if `powerMode`==`custom`; else use `powerMode` as default
         */
        power?: pulumi.Input<number>;
        /**
         * enum: `custom`, `default`
         */
        powerMode?: pulumi.Input<string>;
    }

    export interface SettingConfigPushPolicy {
        /**
         * stop any new config from being pushed to the device
         */
        noPush?: pulumi.Input<boolean>;
        /**
         * if enabled, new config will only be pushed to device within the specified time window
         */
        pushWindow?: pulumi.Input<inputs.site.SettingConfigPushPolicyPushWindow>;
    }

    export interface SettingConfigPushPolicyPushWindow {
        enabled?: pulumi.Input<boolean>;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
         *
         * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
         */
        hours?: pulumi.Input<inputs.site.SettingConfigPushPolicyPushWindowHours>;
    }

    export interface SettingConfigPushPolicyPushWindowHours {
        fri?: pulumi.Input<string>;
        mon?: pulumi.Input<string>;
        sat?: pulumi.Input<string>;
        sun?: pulumi.Input<string>;
        thu?: pulumi.Input<string>;
        tue?: pulumi.Input<string>;
        wed?: pulumi.Input<string>;
    }

    export interface SettingCriticalUrlMonitoring {
        enabled?: pulumi.Input<boolean>;
        monitors?: pulumi.Input<pulumi.Input<inputs.site.SettingCriticalUrlMonitoringMonitor>[]>;
    }

    export interface SettingCriticalUrlMonitoringMonitor {
        url?: pulumi.Input<string>;
        vlanId?: pulumi.Input<string>;
    }

    export interface SettingEngagement {
        dwellTagNames?: pulumi.Input<inputs.site.SettingEngagementDwellTagNames>;
        /**
         * add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
         */
        dwellTags?: pulumi.Input<inputs.site.SettingEngagementDwellTags>;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
         *
         * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
         */
        hours?: pulumi.Input<inputs.site.SettingEngagementHours>;
        /**
         * max time, default is 43200(12h), max is 68400 (18h)
         */
        maxDwell?: pulumi.Input<number>;
        /**
         * min time
         */
        minDwell?: pulumi.Input<number>;
    }

    export interface SettingEngagementDwellTagNames {
        bounce?: pulumi.Input<string>;
        engaged?: pulumi.Input<string>;
        passerby?: pulumi.Input<string>;
        stationed?: pulumi.Input<string>;
    }

    export interface SettingEngagementDwellTags {
        bounce?: pulumi.Input<string>;
        engaged?: pulumi.Input<string>;
        passerby?: pulumi.Input<string>;
        stationed?: pulumi.Input<string>;
    }

    export interface SettingEngagementHours {
        fri?: pulumi.Input<string>;
        mon?: pulumi.Input<string>;
        sat?: pulumi.Input<string>;
        sun?: pulumi.Input<string>;
        thu?: pulumi.Input<string>;
        tue?: pulumi.Input<string>;
        wed?: pulumi.Input<string>;
    }

    export interface SettingGatewayMgmt {
        /**
         * for SSR only, as direct root access is not allowed
         */
        adminSshkeys?: pulumi.Input<pulumi.Input<string>[]>;
        appProbing?: pulumi.Input<inputs.site.SettingGatewayMgmtAppProbing>;
        /**
         * consumes uplink bandwidth, requires WA license
         */
        appUsage?: pulumi.Input<boolean>;
        autoSignatureUpdate?: pulumi.Input<inputs.site.SettingGatewayMgmtAutoSignatureUpdate>;
        /**
         * he rollback timer for commit confirmed
         */
        configRevertTimer?: pulumi.Input<number>;
        /**
         * for both SSR and SRX disable console port
         */
        disableConsole?: pulumi.Input<boolean>;
        /**
         * for both SSR and SRX disable management interface
         */
        disableOob?: pulumi.Input<boolean>;
        probeHosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * restrict inbound-traffic to host
         * when enabled, all traffic that is not essential to our operation will be dropped 
         * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
         */
        protectRe?: pulumi.Input<inputs.site.SettingGatewayMgmtProtectRe>;
        /**
         * for SRX only
         */
        rootPassword?: pulumi.Input<string>;
        securityLogSourceAddress?: pulumi.Input<string>;
        securityLogSourceInterface?: pulumi.Input<string>;
    }

    export interface SettingGatewayMgmtAppProbing {
        /**
         * app-keys from /api/v1/const/applications
         */
        apps?: pulumi.Input<pulumi.Input<string>[]>;
        customApps?: pulumi.Input<pulumi.Input<inputs.site.SettingGatewayMgmtAppProbingCustomApp>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingGatewayMgmtAppProbingCustomApp {
        address?: pulumi.Input<string>;
        appType?: pulumi.Input<string>;
        /**
         * Only 1 entry is allowed:
         *     * if `protocol`==`http`: URL (e.g. `http://test.com` or `https://test.com`)
         *     * if `protocol`==`icmp`: IP Address (e.g. `1.2.3.4`)
         */
        hostnames: pulumi.Input<pulumi.Input<string>[]>;
        key?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        network?: pulumi.Input<string>;
        /**
         * if `protocol`==`icmp`
         */
        packetSize?: pulumi.Input<number>;
        /**
         * enum: `http`, `icmp`
         */
        protocol: pulumi.Input<string>;
        url?: pulumi.Input<string>;
        vrf?: pulumi.Input<string>;
    }

    export interface SettingGatewayMgmtAutoSignatureUpdate {
        /**
         * enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
         */
        dayOfWeek?: pulumi.Input<string>;
        enable?: pulumi.Input<boolean>;
        /**
         * optional, Mist will decide the timing
         */
        timeOfDay?: pulumi.Input<string>;
    }

    export interface SettingGatewayMgmtProtectRe {
        /**
         * optionally, services we'll allow. enum: `icmp`, `ssh`
         */
        allowedServices?: pulumi.Input<pulumi.Input<string>[]>;
        customs?: pulumi.Input<pulumi.Input<inputs.site.SettingGatewayMgmtProtectReCustom>[]>;
        /**
         * when enabled, all traffic that is not essential to our operation will be dropped
         * e.g. ntp / dns / traffic to mist will be allowed by default
         *      if dhcpd is enabled, we'll make sure it works
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * host/subnets we'll allow traffic to/from
         */
        trustedHosts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingGatewayMgmtProtectReCustom {
        /**
         * matched dst port, "0" means any. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        portRange?: pulumi.Input<string>;
        /**
         * enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `portRange`==`any`, configure `trustedHosts` instead
         */
        protocol?: pulumi.Input<string>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingLed {
        brightness?: pulumi.Input<number>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingOccupancy {
        /**
         * indicate whether named BLE assets should be included in the zone occupancy calculation
         */
        assetsEnabled?: pulumi.Input<boolean>;
        /**
         * indicate whether connected WiFi clients should be included in the zone occupancy calculation
         */
        clientsEnabled?: pulumi.Input<boolean>;
        /**
         * minimum duration
         */
        minDuration?: pulumi.Input<number>;
        /**
         * indicate whether SDK clients should be included in the zone occupancy calculation
         */
        sdkclientsEnabled?: pulumi.Input<boolean>;
        /**
         * indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
         */
        unconnectedClientsEnabled?: pulumi.Input<boolean>;
    }

    export interface SettingProxy {
        url?: pulumi.Input<string>;
    }

    export interface SettingRogue {
        /**
         * whether or not rogue detection is enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * whether or not honeypot detection is enabled
         */
        honeypotEnabled?: pulumi.Input<boolean>;
        /**
         * minimum duration for a bssid to be considered rogue
         */
        minDuration?: pulumi.Input<number>;
        /**
         * minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
         */
        minRssi?: pulumi.Input<number>;
        /**
         * list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
         */
        whitelistedBssids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of SSIDs to whitelist
         */
        whitelistedSsids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingRtsa {
        appWaking?: pulumi.Input<boolean>;
        disableDeadReckoning?: pulumi.Input<boolean>;
        disablePressureSensor?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        /**
         * asset tracking related
         */
        trackAsset?: pulumi.Input<boolean>;
    }

    export interface SettingSimpleAlert {
        arpFailure?: pulumi.Input<inputs.site.SettingSimpleAlertArpFailure>;
        dhcpFailure?: pulumi.Input<inputs.site.SettingSimpleAlertDhcpFailure>;
        dnsFailure?: pulumi.Input<inputs.site.SettingSimpleAlertDnsFailure>;
    }

    export interface SettingSimpleAlertArpFailure {
        clientCount?: pulumi.Input<number>;
        /**
         * failing within minutes
         */
        duration?: pulumi.Input<number>;
        incidentCount?: pulumi.Input<number>;
    }

    export interface SettingSimpleAlertDhcpFailure {
        clientCount?: pulumi.Input<number>;
        /**
         * failing within minutes
         */
        duration?: pulumi.Input<number>;
        incidentCount?: pulumi.Input<number>;
    }

    export interface SettingSimpleAlertDnsFailure {
        clientCount?: pulumi.Input<number>;
        /**
         * failing within minutes
         */
        duration?: pulumi.Input<number>;
        incidentCount?: pulumi.Input<number>;
    }

    export interface SettingSkyatp {
        enabled?: pulumi.Input<boolean>;
        /**
         * whether to send IP-MAC mapping to SkyATP
         */
        sendIpMacMapping?: pulumi.Input<boolean>;
    }

    export interface SettingSrxApp {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingSsr {
        conductorHosts?: pulumi.Input<pulumi.Input<string>[]>;
        disableStats?: pulumi.Input<boolean>;
    }

    export interface SettingSyntheticTest {
        disabled?: pulumi.Input<boolean>;
        vlans?: pulumi.Input<pulumi.Input<inputs.site.SettingSyntheticTestVlan>[]>;
        wanSpeedtest?: pulumi.Input<inputs.site.SettingSyntheticTestWanSpeedtest>;
    }

    export interface SettingSyntheticTestVlan {
        customTestUrls?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * for some vlans where we don't want this to run
         */
        disabled?: pulumi.Input<boolean>;
        vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingSyntheticTestWanSpeedtest {
        enabled?: pulumi.Input<boolean>;
        /**
         * any / HH:MM (24-hour format)
         */
        timeOfDay?: pulumi.Input<string>;
    }

    export interface SettingUplinkPortConfig {
        /**
         * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
         */
        dot1x?: pulumi.Input<boolean>;
        /**
         * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
         */
        keepWlansUpIfDown?: pulumi.Input<boolean>;
    }

    export interface SettingVna {
        /**
         * enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingVsInstance {
        networks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SettingWanVna {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingWids {
        repeatedAuthFailures?: pulumi.Input<inputs.site.SettingWidsRepeatedAuthFailures>;
    }

    export interface SettingWidsRepeatedAuthFailures {
        /**
         * window where a trigger will be detected and action to be taken (in seconds)
         */
        duration?: pulumi.Input<number>;
        /**
         * count of events to trigger
         */
        threshold?: pulumi.Input<number>;
    }

    export interface SettingWifi {
        ciscoEnabled?: pulumi.Input<boolean>;
        /**
         * whether to disable 11k
         */
        disable11k?: pulumi.Input<boolean>;
        disableRadiosWhenPowerConstrained?: pulumi.Input<boolean>;
        /**
         * when proxyArp is enabled, check for arp spoofing.
         */
        enableArpSpoofCheck?: pulumi.Input<boolean>;
        enableSharedRadioScanning?: pulumi.Input<boolean>;
        /**
         * enable WIFI feature (using SUB-MAN license)
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * whether to locate connected clients
         */
        locateConnected?: pulumi.Input<boolean>;
        /**
         * whether to locate unconnected clients
         */
        locateUnconnected?: pulumi.Input<boolean>;
        /**
         * whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
         */
        meshAllowDfs?: pulumi.Input<boolean>;
        /**
         * used to enable/disable CRM
         */
        meshEnableCrm?: pulumi.Input<boolean>;
        /**
         * whether to enable Mesh feature for the site
         */
        meshEnabled?: pulumi.Input<boolean>;
        /**
         * optional passphrase of mesh networking, default is generated randomly
         */
        meshPsk?: pulumi.Input<string>;
        /**
         * optional ssid of mesh networking, default is based on site_id
         */
        meshSsid?: pulumi.Input<string>;
        /**
         * enum: `default`, `disabled`, `enabled`
         */
        proxyArp?: pulumi.Input<string>;
    }

    export interface SettingWiredVna {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingZoneOccupancyAlert {
        /**
         * list of email addresses to send email notifications when the alert threshold is reached
         */
        emailNotifiers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * indicate whether zone occupancy alert is enabled for the site
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
         */
        threshold?: pulumi.Input<number>;
    }

    export interface WlanAcctServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Acct port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface WlanAirwatch {
        /**
         * API Key
         */
        apiKey: pulumi.Input<string>;
        /**
         * console URL
         */
        consoleUrl: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * password
         */
        password: pulumi.Input<string>;
        /**
         * username
         */
        username: pulumi.Input<string>;
    }

    export interface WlanAppLimit {
        /**
         * Map from app key to bandwidth in kbps. 
         * Property key is the app key, defined in Get Application List
         */
        apps?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
        enabled?: pulumi.Input<boolean>;
        /**
         * Map from wxtagId of Hostname Wxlan Tags to bandwidth in kbps
         * Property key is the wxtag id
         */
        wxtagIds?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
    }

    export interface WlanAppQos {
        apps?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.WlanAppQosApps>}>;
        enabled?: pulumi.Input<boolean>;
        others?: pulumi.Input<pulumi.Input<inputs.site.WlanAppQosOther>[]>;
    }

    export interface WlanAppQosApps {
        dscp?: pulumi.Input<number>;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        dstSubnet?: pulumi.Input<string>;
        /**
         * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
         */
        srcSubnet?: pulumi.Input<string>;
    }

    export interface WlanAppQosOther {
        dscp?: pulumi.Input<number>;
        dstSubnet?: pulumi.Input<string>;
        portRanges?: pulumi.Input<string>;
        protocol?: pulumi.Input<string>;
        srcSubnet?: pulumi.Input<string>;
    }

    export interface WlanAuth {
        /**
         * SAE anti-clogging token threshold
         */
        anticlogThreshold?: pulumi.Input<number>;
        /**
         * whether to trigger EAP reauth when the session ends
         */
        eapReauth?: pulumi.Input<boolean>;
        /**
         * whether to enable MAC Auth, uses the same auth_servers
         */
        enableMacAuth?: pulumi.Input<boolean>;
        /**
         * when `type`==`wep`
         */
        keyIdx?: pulumi.Input<number>;
        /**
         * when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
         */
        keys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when `type`==`psk`, whether to only use multi_psk
         */
        multiPskOnly?: pulumi.Input<boolean>;
        /**
         * if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
         */
        owe?: pulumi.Input<string>;
        /**
         * when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
         */
        pairwises?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * when `multiPskOnly`==`true`, whether private wlan is enabled
         */
        privateWlan?: pulumi.Input<boolean>;
        /**
         * when `type`==`psk`, 8-64 characters, or 64 hex characters
         */
        psk?: pulumi.Input<string>;
        /**
         * enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
         */
        type?: pulumi.Input<string>;
        /**
         * enable WEP as secondary auth
         */
        wepAsSecondaryAuth?: pulumi.Input<boolean>;
    }

    export interface WlanAuthServer {
        /**
         * ip / hostname of RADIUS server
         */
        host: pulumi.Input<string>;
        keywrapEnabled?: pulumi.Input<boolean>;
        /**
         * enum: `ascii`, `hex`
         */
        keywrapFormat?: pulumi.Input<string>;
        keywrapKek?: pulumi.Input<string>;
        keywrapMack?: pulumi.Input<string>;
        /**
         * Auth port of RADIUS server
         */
        port?: pulumi.Input<number>;
        /**
         * whether to require Message-Authenticator in requests
         */
        requireMessageAuthenticator?: pulumi.Input<boolean>;
        /**
         * secret of RADIUS server
         */
        secret: pulumi.Input<string>;
    }

    export interface WlanBonjour {
        /**
         * additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
         */
        additionalVlanIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to enable bonjour for this WLAN. Once enabled, limitBcast is assumed true, allowMdns is assumed false
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * what services are allowed. 
         * Property key is the service name
         */
        services: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.WlanBonjourServices>}>;
    }

    export interface WlanBonjourServices {
        /**
         * whether to prevent wireless clients to discover bonjour devices on the same WLAN
         */
        disableLocal?: pulumi.Input<boolean>;
        /**
         * optional, if the service is further restricted for certain RADIUS groups
         */
        radiusGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * how bonjour services should be discovered for the same WLAN. enum: `sameAp`, `sameMap`, `sameSite`
         */
        scope?: pulumi.Input<string>;
    }

    export interface WlanCiscoCwa {
        /**
         * list of hostnames without http(s):// (matched by substring)
         */
        allowedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of CIDRs
         */
        allowedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of blocked CIDRs
         */
        blockedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface WlanCoaServer {
        /**
         * whether to disable Event-Timestamp Check
         */
        disableEventTimestampCheck?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        ip: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        secret: pulumi.Input<string>;
    }

    export interface WlanDnsServerRewrite {
        enabled?: pulumi.Input<boolean>;
        /**
         * map between radiusGroup and the desired DNS server (IPv4 only)
         * Property key is the RADIUS group, property value is the desired DNS Server
         */
        radiusGroups?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WlanDynamicPsk {
        /**
         * default PSK to use if cloud WLC is not available, 8-63 characters
         */
        defaultPsk?: pulumi.Input<string>;
        defaultVlanId?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * when 11r is enabled, we'll try to use the cached PMK, this can be disabled
         * `false` means auto
         */
        forceLookup?: pulumi.Input<boolean>;
        /**
         * enum: `cloudPsks`, `radius`
         */
        source?: pulumi.Input<string>;
        vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WlanDynamicVlan {
        /**
         * Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
         */
        defaultVlanIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to enable dynamic vlan
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * vlan_ids to be locally bridged
         */
        localVlanIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
         */
        type?: pulumi.Input<string>;
        /**
         * map between vlanId (as string) to airespace interface names (comma-separated) or null for stndard mapping
         *   * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"
         *   * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
         */
        vlans?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface WlanHotspot20 {
        domainNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether to enable hotspot 2.0 config
         */
        enabled?: pulumi.Input<boolean>;
        naiRealms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * list of operators to support
         */
        operators?: pulumi.Input<pulumi.Input<string>[]>;
        rcois?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * venue name, default is site name
         */
        venueName?: pulumi.Input<string>;
    }

    export interface WlanInjectDhcpOption82 {
        /**
         * information to set in the `circuitId` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):
         *   * {{AP_MAC}}
         *   * {{AP_MAC_DASHED}}
         *   * {{AP_MODEL}}
         *   * {{AP_NAME}}
         *   * {{SITE_NAME}}
         *   * {{SSID}}
         */
        circuitId?: pulumi.Input<string>;
        /**
         * whether to inject option 82 when forwarding DHCP packets
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WlanMistNac {
        /**
         * when enabled:
         *   * `authServers` is ignored
         *   * `acctServers` is ignored
         *   * `auth_servers_*` are ignored
         *   * `coaServers` is ignored
         *   * `radsec` is ignored
         *   * `coaEnabled` is assumed'
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WlanPortal {
        /**
         * whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable randomMac for seamless roaming)
         */
        allowWlanIdRoam?: pulumi.Input<boolean>;
        /**
         * amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        amazonClientId?: pulumi.Input<string>;
        /**
         * amazon OAuth2 client secret. If amazonClientId was provided, provide a correspoinding value. Else leave blank.
         */
        amazonClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        amazonEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether amazon is enabled as a login method
         */
        amazonEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
         */
        amazonExpire?: pulumi.Input<number>;
        /**
         * authentication scheme. enum: `external`, `none`, `sso`
         */
        auth?: pulumi.Input<string>;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client id
         */
        azureClientId?: pulumi.Input<string>;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory app client secret
         */
        azureClientSecret?: pulumi.Input<string>;
        /**
         * whether Azure Active Directory is enabled as a login method
         */
        azureEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
         */
        azureExpire?: pulumi.Input<number>;
        /**
         * Required if `azureEnabled`==`true`.
         * Azure active directory tenant id.
         */
        azureTenantId?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetPassword?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetSid?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`broadnet`
         */
        broadnetUserId?: pulumi.Input<string>;
        /**
         * whether to bypass the guest portal when cloud not reachable (and apply the default policies)
         */
        bypassWhenCloudDown?: pulumi.Input<boolean>;
        /**
         * when `smsProvider`==`clickatell`
         */
        clickatellApiKey?: pulumi.Input<string>;
        /**
         * whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable randomMac for seamless roaming)
         */
        crossSite?: pulumi.Input<boolean>;
        /**
         * whether email (access code verification) is enabled as a login method
         */
        emailEnabled?: pulumi.Input<boolean>;
        /**
         * whether guest portal is enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * how long to remain authorized, in minutes
         */
        expire?: pulumi.Input<number>;
        /**
         * external portal URL (e.g. https://host/url) where we can append our query parameters to
         */
        externalPortalUrl?: pulumi.Input<string>;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        facebookClientId?: pulumi.Input<string>;
        /**
         * Required if `facebookEnabled`==`true`.
         * Facebook OAuth2 app secret. If facebookClientId was provided, provide a correspoinding value. Else leave blank.
         */
        facebookClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        facebookEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether facebook is enabled as a login method
         */
        facebookEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
         */
        facebookExpire?: pulumi.Input<number>;
        /**
         * whether to forward the user to another URL after authorized
         */
        forward?: pulumi.Input<boolean>;
        /**
         * the URL to forward the user to
         */
        forwardUrl?: pulumi.Input<string>;
        /**
         * Google OAuth2 app id. This is optional. If not provided, it will use a default one.
         */
        googleClientId?: pulumi.Input<string>;
        /**
         * Google OAuth2 app secret. If googleClientId was provided, provide a correspoinding value. Else leave blank.
         */
        googleClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        googleEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether google is enabled as login method
         */
        googleEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
         */
        googleExpire?: pulumi.Input<number>;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupPassword?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`gupshup`
         */
        gupshupUserid?: pulumi.Input<string>;
        /**
         * microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
         */
        microsoftClientId?: pulumi.Input<string>;
        /**
         * microsoft 365 OAuth2 client secret. If microsoftClientId was provided, provide a correspoinding value. Else leave blank.
         */
        microsoftClientSecret?: pulumi.Input<string>;
        /**
         * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
         */
        microsoftEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether microsoft 365 is enabled as a login method
         */
        microsoftEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
         */
        microsoftExpire?: pulumi.Input<number>;
        /**
         * whether password is enabled
         */
        passphraseEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
         */
        passphraseExpire?: pulumi.Input<number>;
        /**
         * passphrase
         */
        password?: pulumi.Input<string>;
        /**
         * whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsorNotifyAll` and `predefinedSponsorsEnabled` are false, behaviour is acc to `sponsorEmailDomains`
         */
        predefinedSponsorsEnabled?: pulumi.Input<boolean>;
        /**
         * whether to hide sponsor’s email from list of sponsors
         */
        predefinedSponsorsHideEmail?: pulumi.Input<boolean>;
        privacy?: pulumi.Input<boolean>;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelPassword?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelServiceId?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`puzzel`
         */
        puzzelUsername?: pulumi.Input<string>;
        /**
         * whether sms is enabled as a login method
         */
        smsEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
         */
        smsExpire?: pulumi.Input<number>;
        smsMessageFormat?: pulumi.Input<string>;
        /**
         * enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
         */
        smsProvider?: pulumi.Input<string>;
        /**
         * whether to automatically approve guest and allow sponsor to revoke guest access, needs predefinedSponsorsEnabled enabled and sponsorNotifyAll disabled
         */
        sponsorAutoApprove?: pulumi.Input<boolean>;
        /**
         * list of domain allowed for sponsor email. Required if `sponsorEnabled` is `true` and `sponsors` is empty.
         */
        sponsorEmailDomains?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * whether sponsor is enabled
         */
        sponsorEnabled?: pulumi.Input<boolean>;
        /**
         * interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
         */
        sponsorExpire?: pulumi.Input<number>;
        /**
         * how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
         */
        sponsorLinkValidityDuration?: pulumi.Input<string>;
        /**
         * whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsorNotifyAll` and `predefinedSponsorsEnabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
         */
        sponsorNotifyAll?: pulumi.Input<boolean>;
        /**
         * if enabled, guest will get email about sponsor's action (approve/deny)
         */
        sponsorStatusNotify?: pulumi.Input<boolean>;
        /**
         * object of allowed sponsors email with name. Required if `sponsorEnabled`
         *             is `true` and `sponsorEmailDomains` is empty.
         *
         *             Property key is the sponsor email, Property value is the sponsor name
         */
        sponsors?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * if `wlanPortalAuth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
         */
        ssoDefaultRole?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`
         */
        ssoForcedRole?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, IDP Cert (used to verify the signed response)
         */
        ssoIdpCert?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`
         */
        ssoIdpSignAlgo?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, IDP Single-Sign-On URL
         */
        ssoIdpSsoUrl?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`, IDP issuer URL
         */
        ssoIssuer?: pulumi.Input<string>;
        /**
         * if `wlanPortalAuth`==`sso`. enum: `email`, `unspecified`
         */
        ssoNameidFormat?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`telstra`, Client ID provided by Telstra
         */
        telstraClientId?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`telstra`, Client secret provided by Telstra
         */
        telstraClientSecret?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`twilio`, Auth token account with twilio account
         */
        twilioAuthToken?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
         */
        twilioPhoneNumber?: pulumi.Input<string>;
        /**
         * when `smsProvider`==`twilio`, Account SID provided by Twilio
         */
        twilioSid?: pulumi.Input<string>;
    }

    export interface WlanPortalTemplatePortalTemplate {
        accessCodeAlternateEmail?: pulumi.Input<string>;
        /**
         * defines alignment on portal. enum: `center`, `left`, `right`
         */
        alignment?: pulumi.Input<string>;
        /**
         * label for Amazon auth button
         */
        authButtonAmazon?: pulumi.Input<string>;
        /**
         * label for Azure auth button
         */
        authButtonAzure?: pulumi.Input<string>;
        /**
         * label for Email auth button
         */
        authButtonEmail?: pulumi.Input<string>;
        /**
         * label for Facebook auth button
         */
        authButtonFacebook?: pulumi.Input<string>;
        /**
         * label for Google auth button
         */
        authButtonGoogle?: pulumi.Input<string>;
        /**
         * label for Microsoft auth button
         */
        authButtonMicrosoft?: pulumi.Input<string>;
        /**
         * label for passphrase auth button
         */
        authButtonPassphrase?: pulumi.Input<string>;
        /**
         * label for SMS auth button
         */
        authButtonSms?: pulumi.Input<string>;
        /**
         * label for Sponsor auth button
         */
        authButtonSponsor?: pulumi.Input<string>;
        authLabel?: pulumi.Input<string>;
        /**
         * label of the link to go back to /logon
         */
        backLink?: pulumi.Input<string>;
        /**
         * Portal main color
         */
        color?: pulumi.Input<string>;
        colorDark?: pulumi.Input<string>;
        colorLight?: pulumi.Input<string>;
        /**
         * whether company field is required
         */
        company?: pulumi.Input<boolean>;
        /**
         * error message when company not provided
         */
        companyError?: pulumi.Input<string>;
        /**
         * label of company field
         */
        companyLabel?: pulumi.Input<string>;
        /**
         * whether email field is required
         */
        email?: pulumi.Input<boolean>;
        /**
         * error message when a user has valid social login but doesn't match specified email domains.
         */
        emailAccessDomainError?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission using email auth
         */
        emailCancel?: pulumi.Input<string>;
        emailCodeCancel?: pulumi.Input<string>;
        emailCodeError?: pulumi.Input<string>;
        emailCodeFieldLabel?: pulumi.Input<string>;
        emailCodeMessage?: pulumi.Input<string>;
        emailCodeSubmit?: pulumi.Input<string>;
        emailCodeTitle?: pulumi.Input<string>;
        /**
         * error message when email not provided
         */
        emailError?: pulumi.Input<string>;
        emailFieldLabel?: pulumi.Input<string>;
        /**
         * label of email field
         */
        emailLabel?: pulumi.Input<string>;
        emailMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button using email auth
         */
        emailSubmit?: pulumi.Input<string>;
        /**
         * Title for the Email registration
         */
        emailTitle?: pulumi.Input<string>;
        /**
         * whether to ask field1
         */
        field1?: pulumi.Input<boolean>;
        /**
         * error message when field1 not provided
         */
        field1error?: pulumi.Input<string>;
        /**
         * label of field1
         */
        field1label?: pulumi.Input<string>;
        /**
         * whether field1 is required field
         */
        field1required?: pulumi.Input<boolean>;
        /**
         * whether to ask field2
         */
        field2?: pulumi.Input<boolean>;
        /**
         * error message when field2 not provided
         */
        field2error?: pulumi.Input<string>;
        /**
         * label of field2
         */
        field2label?: pulumi.Input<string>;
        /**
         * whether field2 is required field
         */
        field2required?: pulumi.Input<boolean>;
        /**
         * whether to ask field3
         */
        field3?: pulumi.Input<boolean>;
        /**
         * error message when field3 not provided
         */
        field3error?: pulumi.Input<string>;
        /**
         * label of field3
         */
        field3label?: pulumi.Input<string>;
        /**
         * whether field3 is required field
         */
        field3required?: pulumi.Input<boolean>;
        /**
         * whether to ask field4
         */
        field4?: pulumi.Input<boolean>;
        /**
         * error message when field4 not provided
         */
        field4error?: pulumi.Input<string>;
        /**
         * label of field4
         */
        field4label?: pulumi.Input<string>;
        /**
         * whether field4 is required field
         */
        field4required?: pulumi.Input<boolean>;
        /**
         * Can be used to localize the portal based on the User Agent. Allowed property key values are:
         *   `ar`, `ca-ES`, `cs-CZ`, `da-DK`, `de-DE`, `el-GR`, `en-GB`, `en-US`, `es-ES`, `fi-FI`, `fr-FR`, 
         *   `he-IL`, `hi-IN`, `hr-HR`, `hu-HU`, `id-ID`, `it-IT`, `ja-J^`, `ko-KT`, `ms-MY`, `nb-NO`, `nl-NL`, 
         *   `pl-PL`, `pt-BR`, `pt-PT`, `ro-RO`, `ru-RU`, `sk-SK`, `sv-SE`, `th-TH`, `tr-TR`, `uk-UA`, `vi-VN`, 
         *   `zh-Hans`, `zh-Hant`
         */
        locales?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.WlanPortalTemplatePortalTemplateLocales>}>;
        /**
         * path to the background image file. File must be a `png` image`
         */
        logo?: pulumi.Input<string>;
        message?: pulumi.Input<string>;
        multiAuth?: pulumi.Input<boolean>;
        /**
         * whether name field is required
         */
        name?: pulumi.Input<boolean>;
        /**
         * error message when name not provided
         */
        nameError?: pulumi.Input<string>;
        /**
         * label of name field
         */
        nameLabel?: pulumi.Input<string>;
        /**
         * Default value for the `Do not store` checkbox
         */
        optOutDefault?: pulumi.Input<boolean>;
        /**
         * whether to display Do Not Store My Personal Information
         */
        optout?: pulumi.Input<boolean>;
        /**
         * label for Do Not Store My Personal Information
         */
        optoutLabel?: pulumi.Input<string>;
        pageTitle?: pulumi.Input<string>;
        /**
         * Label for the Passphrase cancel button
         */
        passphraseCancel?: pulumi.Input<string>;
        /**
         * error message when invalid passphrase is provided
         */
        passphraseError?: pulumi.Input<string>;
        /**
         * Passphrase
         */
        passphraseLabel?: pulumi.Input<string>;
        passphraseMessage?: pulumi.Input<string>;
        /**
         * Label for the Passphrase submit button
         */
        passphraseSubmit?: pulumi.Input<string>;
        /**
         * Title for passphrase details page
         */
        passphraseTitle?: pulumi.Input<string>;
        /**
         * whether to show \"Powered by Mist\"
         */
        poweredBy?: pulumi.Input<boolean>;
        /**
         * wheter to require the Privacy Term acceptance
         */
        privacy?: pulumi.Input<boolean>;
        /**
         * prefix of the label of the link to go to Privacy Policy
         */
        privacyPolicyAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when Privacy Policy not accepted
         */
        privacyPolicyError?: pulumi.Input<string>;
        /**
         * label of the link to go to Privacy Policy
         */
        privacyPolicyLink?: pulumi.Input<string>;
        /**
         * text of the Privacy Policy
         */
        privacyPolicyText?: pulumi.Input<string>;
        /**
         * label to denote required field
         */
        requiredFieldLabel?: pulumi.Input<string>;
        responsiveLayout?: pulumi.Input<boolean>;
        /**
         * label of the button to /signin
         */
        signInLabel?: pulumi.Input<string>;
        smsCarrierDefault?: pulumi.Input<string>;
        smsCarrierError?: pulumi.Input<string>;
        /**
         * label for mobile carrier drop-down list
         */
        smsCarrierFieldLabel?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission
         */
        smsCodeCancel?: pulumi.Input<string>;
        /**
         * error message when confirmation code is invalid
         */
        smsCodeError?: pulumi.Input<string>;
        smsCodeFieldLabel?: pulumi.Input<string>;
        smsCodeMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button
         */
        smsCodeSubmit?: pulumi.Input<string>;
        smsCodeTitle?: pulumi.Input<string>;
        smsCountryFieldLabel?: pulumi.Input<string>;
        smsCountryFormat?: pulumi.Input<string>;
        /**
         * Label for checkbox to specify that the user has access code
         */
        smsHaveAccessCode?: pulumi.Input<string>;
        smsIsTwilio?: pulumi.Input<boolean>;
        /**
         * format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
         */
        smsMessageFormat?: pulumi.Input<string>;
        /**
         * label for canceling mobile details for SMS auth
         */
        smsNumberCancel?: pulumi.Input<string>;
        smsNumberError?: pulumi.Input<string>;
        /**
         * label for field to provide mobile number
         */
        smsNumberFieldLabel?: pulumi.Input<string>;
        smsNumberFormat?: pulumi.Input<string>;
        smsNumberMessage?: pulumi.Input<string>;
        /**
         * label for submit button for code generation
         */
        smsNumberSubmit?: pulumi.Input<string>;
        /**
         * Title for phone number details
         */
        smsNumberTitle?: pulumi.Input<string>;
        smsUsernameFormat?: pulumi.Input<string>;
        /**
         * how long confirmation code should be considered valid (in minutes)
         */
        smsValidityDuration?: pulumi.Input<number>;
        sponsorBackLink?: pulumi.Input<string>;
        sponsorCancel?: pulumi.Input<string>;
        /**
         * label for Sponsor Email
         */
        sponsorEmail?: pulumi.Input<string>;
        sponsorEmailError?: pulumi.Input<string>;
        /**
         * html template to replace/override default sponsor email template 
         * Sponsor Email Template supports following template variables:
         *   * `approveUrl`: Renders URL to approve the request; optionally &minutes=N query param can be appended to change the Authorization period of the guest, where N is a valid integer denoting number of minutes a guest remains authorized
         *   * `denyUrl`: Renders URL to reject the request
         *   * `guestEmail`: Renders Email ID of the guest
         *   * `guestName`: Renders Name of the guest
         *   * `field1`: Renders value of the Custom Field 1
         *   * `field2`: Renders value of the Custom Field 2
         *   * `sponsorLinkValidityDuration`: Renders validity time of the request (i.e. Approve/Deny URL)
         *   * `authExpireMinutes`: Renders Wlan-level configured Guest Authorization Expiration time period (in minutes), If not configured then default (1 day in minutes)
         */
        sponsorEmailTemplate?: pulumi.Input<string>;
        sponsorInfoApproved?: pulumi.Input<string>;
        sponsorInfoDenied?: pulumi.Input<string>;
        sponsorInfoPending?: pulumi.Input<string>;
        /**
         * label for Sponsor Name
         */
        sponsorName?: pulumi.Input<string>;
        sponsorNameError?: pulumi.Input<string>;
        sponsorNotePending?: pulumi.Input<string>;
        /**
         * submit button label request Wifi Access and notify sponsor about guest request
         */
        sponsorRequestAccess?: pulumi.Input<string>;
        /**
         * text to display if sponsor approves request
         */
        sponsorStatusApproved?: pulumi.Input<string>;
        /**
         * text to display when sponsor denies request
         */
        sponsorStatusDenied?: pulumi.Input<string>;
        /**
         * text to display if request is still pending
         */
        sponsorStatusPending?: pulumi.Input<string>;
        /**
         * submit button label to notify sponsor about guest request
         */
        sponsorSubmit?: pulumi.Input<string>;
        sponsorsError?: pulumi.Input<string>;
        sponsorsFieldLabel?: pulumi.Input<string>;
        tos?: pulumi.Input<boolean>;
        /**
         * prefix of the label of the link to go to tos
         */
        tosAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when tos not accepted
         */
        tosError?: pulumi.Input<string>;
        /**
         * label of the link to go to tos
         */
        tosLink?: pulumi.Input<string>;
        /**
         * text of the Terms of Service
         */
        tosText?: pulumi.Input<string>;
    }

    export interface WlanPortalTemplatePortalTemplateLocales {
        /**
         * label for Amazon auth button
         */
        authButtonAmazon?: pulumi.Input<string>;
        /**
         * label for Azure auth button
         */
        authButtonAzure?: pulumi.Input<string>;
        /**
         * label for Email auth button
         */
        authButtonEmail?: pulumi.Input<string>;
        /**
         * label for Facebook auth button
         */
        authButtonFacebook?: pulumi.Input<string>;
        /**
         * label for Google auth button
         */
        authButtonGoogle?: pulumi.Input<string>;
        /**
         * label for Microsoft auth button
         */
        authButtonMicrosoft?: pulumi.Input<string>;
        /**
         * label for passphrase auth button
         */
        authButtonPassphrase?: pulumi.Input<string>;
        /**
         * label for SMS auth button
         */
        authButtonSms?: pulumi.Input<string>;
        /**
         * label for Sponsor auth button
         */
        authButtonSponsor?: pulumi.Input<string>;
        authLabel?: pulumi.Input<string>;
        /**
         * label of the link to go back to /logon
         */
        backLink?: pulumi.Input<string>;
        /**
         * error message when company not provided
         */
        companyError?: pulumi.Input<string>;
        /**
         * label of company field
         */
        companyLabel?: pulumi.Input<string>;
        /**
         * error message when a user has valid social login but doesn't match specified email domains.
         */
        emailAccessDomainError?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission using email auth
         */
        emailCancel?: pulumi.Input<string>;
        emailCodeCancel?: pulumi.Input<string>;
        emailCodeError?: pulumi.Input<string>;
        emailCodeFieldLabel?: pulumi.Input<string>;
        emailCodeMessage?: pulumi.Input<string>;
        emailCodeSubmit?: pulumi.Input<string>;
        emailCodeTitle?: pulumi.Input<string>;
        /**
         * error message when email not provided
         */
        emailError?: pulumi.Input<string>;
        emailFieldLabel?: pulumi.Input<string>;
        /**
         * label of email field
         */
        emailLabel?: pulumi.Input<string>;
        emailMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button using email auth
         */
        emailSubmit?: pulumi.Input<string>;
        /**
         * Title for the Email registration
         */
        emailTitle?: pulumi.Input<string>;
        /**
         * error message when field1 not provided
         */
        field1error?: pulumi.Input<string>;
        /**
         * label of field1
         */
        field1label?: pulumi.Input<string>;
        /**
         * error message when field2 not provided
         */
        field2error?: pulumi.Input<string>;
        /**
         * label of field2
         */
        field2label?: pulumi.Input<string>;
        /**
         * error message when field3 not provided
         */
        field3error?: pulumi.Input<string>;
        /**
         * label of field3
         */
        field3label?: pulumi.Input<string>;
        /**
         * error message when field4 not provided
         */
        field4error?: pulumi.Input<string>;
        /**
         * label of field4
         */
        field4label?: pulumi.Input<string>;
        message?: pulumi.Input<string>;
        /**
         * error message when name not provided
         */
        nameError?: pulumi.Input<string>;
        /**
         * label of name field
         */
        nameLabel?: pulumi.Input<string>;
        /**
         * label for Do Not Store My Personal Information
         */
        optoutLabel?: pulumi.Input<string>;
        pageTitle?: pulumi.Input<string>;
        /**
         * Label for the Passphrase cancel button
         */
        passphraseCancel?: pulumi.Input<string>;
        /**
         * error message when invalid passphrase is provided
         */
        passphraseError?: pulumi.Input<string>;
        /**
         * Passphrase
         */
        passphraseLabel?: pulumi.Input<string>;
        passphraseMessage?: pulumi.Input<string>;
        /**
         * Label for the Passphrase submit button
         */
        passphraseSubmit?: pulumi.Input<string>;
        /**
         * Title for passphrase details page
         */
        passphraseTitle?: pulumi.Input<string>;
        /**
         * prefix of the label of the link to go to Privacy Policy
         */
        privacyPolicyAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when Privacy Policy not accepted
         */
        privacyPolicyError?: pulumi.Input<string>;
        /**
         * label of the link to go to Privacy Policy
         */
        privacyPolicyLink?: pulumi.Input<string>;
        /**
         * text of the Privacy Policy
         */
        privacyPolicyText?: pulumi.Input<string>;
        /**
         * label to denote required field
         */
        requiredFieldLabel?: pulumi.Input<string>;
        /**
         * label of the button to /signin
         */
        signInLabel?: pulumi.Input<string>;
        smsCarrierDefault?: pulumi.Input<string>;
        smsCarrierError?: pulumi.Input<string>;
        /**
         * label for mobile carrier drop-down list
         */
        smsCarrierFieldLabel?: pulumi.Input<string>;
        /**
         * Label for cancel confirmation code submission
         */
        smsCodeCancel?: pulumi.Input<string>;
        /**
         * error message when confirmation code is invalid
         */
        smsCodeError?: pulumi.Input<string>;
        smsCodeFieldLabel?: pulumi.Input<string>;
        smsCodeMessage?: pulumi.Input<string>;
        /**
         * Label for confirmation code submit button
         */
        smsCodeSubmit?: pulumi.Input<string>;
        smsCodeTitle?: pulumi.Input<string>;
        smsCountryFieldLabel?: pulumi.Input<string>;
        smsCountryFormat?: pulumi.Input<string>;
        /**
         * Label for checkbox to specify that the user has access code
         */
        smsHaveAccessCode?: pulumi.Input<string>;
        /**
         * format of access code sms message. {{code}} and {{duration}} are place holders and should be retained as is.
         */
        smsMessageFormat?: pulumi.Input<string>;
        /**
         * label for canceling mobile details for SMS auth
         */
        smsNumberCancel?: pulumi.Input<string>;
        smsNumberError?: pulumi.Input<string>;
        /**
         * label for field to provide mobile number
         */
        smsNumberFieldLabel?: pulumi.Input<string>;
        smsNumberFormat?: pulumi.Input<string>;
        smsNumberMessage?: pulumi.Input<string>;
        /**
         * label for submit button for code generation
         */
        smsNumberSubmit?: pulumi.Input<string>;
        /**
         * Title for phone number details
         */
        smsNumberTitle?: pulumi.Input<string>;
        smsUsernameFormat?: pulumi.Input<string>;
        sponsorBackLink?: pulumi.Input<string>;
        sponsorCancel?: pulumi.Input<string>;
        /**
         * label for Sponsor Email
         */
        sponsorEmail?: pulumi.Input<string>;
        sponsorEmailError?: pulumi.Input<string>;
        sponsorInfoApproved?: pulumi.Input<string>;
        sponsorInfoDenied?: pulumi.Input<string>;
        sponsorInfoPending?: pulumi.Input<string>;
        /**
         * label for Sponsor Name
         */
        sponsorName?: pulumi.Input<string>;
        sponsorNameError?: pulumi.Input<string>;
        sponsorNotePending?: pulumi.Input<string>;
        /**
         * submit button label request Wifi Access and notify sponsor about guest request
         */
        sponsorRequestAccess?: pulumi.Input<string>;
        /**
         * text to display if sponsor approves request
         */
        sponsorStatusApproved?: pulumi.Input<string>;
        /**
         * text to display when sponsor denies request
         */
        sponsorStatusDenied?: pulumi.Input<string>;
        /**
         * text to display if request is still pending
         */
        sponsorStatusPending?: pulumi.Input<string>;
        /**
         * submit button label to notify sponsor about guest request
         */
        sponsorSubmit?: pulumi.Input<string>;
        sponsorsError?: pulumi.Input<string>;
        sponsorsFieldLabel?: pulumi.Input<string>;
        /**
         * prefix of the label of the link to go to tos
         */
        tosAcceptLabel?: pulumi.Input<string>;
        /**
         * error message when tos not accepted
         */
        tosError?: pulumi.Input<string>;
        /**
         * label of the link to go to tos
         */
        tosLink?: pulumi.Input<string>;
        /**
         * text of the Terms of Service
         */
        tosText?: pulumi.Input<string>;
    }

    export interface WlanQos {
        /**
         * enum: `background`, `bestEffort`, `video`, `voice`
         */
        class?: pulumi.Input<string>;
        /**
         * whether to overwrite QoS
         */
        overwrite?: pulumi.Input<boolean>;
    }

    export interface WlanRadsec {
        coaEnabled?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        idleTimeout?: pulumi.Input<number>;
        /**
         * To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
         * Org mxedge(s) identified by mxcluster_ids
         */
        mxclusterIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
         * when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
         */
        proxyHosts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
         */
        serverName?: pulumi.Input<string>;
        /**
         * List of Radsec Servers. Only if not Mist Edge.
         */
        servers?: pulumi.Input<pulumi.Input<inputs.site.WlanRadsecServer>[]>;
        /**
         * use mxedge(s) as radsecproxy
         */
        useMxedge?: pulumi.Input<boolean>;
        /**
         * To use Site mxedges when this WLAN does not use mxtunnel
         */
        useSiteMxedge?: pulumi.Input<boolean>;
    }

    export interface WlanRadsecServer {
        host?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface WlanRateset {
        /**
         * if `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)
         */
        ht?: pulumi.Input<string>;
        /**
         * if `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values. enum: `1`, `11`, `11b`, `12`, `12b`, `18`, `18b`, `1b`, `2`, `24`, `24b`, `2b`, `36`, `36b`, `48`, `48b`, `5.5`, `5.5b`, `54`, `54b`, `6`, `6b`, `9`, `9b`
         */
        legacies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Minimum RSSI for client to connect, 0 means not enforcing
         */
        minRssi?: pulumi.Input<number>;
        /**
         * Data Rates template to apply. enum: 
         *   * `no-legacy`: no 11b
         *   * `compatible`: all, like before, default setting that Broadcom/Atheros used
         *   * `legacy-only`: disable 802.11n and 802.11ac
         *   * `high-density`: no 11b, no low rates
         *   * `custom`: user defined
         */
        template?: pulumi.Input<string>;
        /**
         * if `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.
         */
        vht?: pulumi.Input<string>;
    }

    export interface WlanSchedule {
        enabled?: pulumi.Input<boolean>;
        /**
         * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
         *
         * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
         */
        hours?: pulumi.Input<inputs.site.WlanScheduleHours>;
    }

    export interface WlanScheduleHours {
        fri?: pulumi.Input<string>;
        mon?: pulumi.Input<string>;
        sat?: pulumi.Input<string>;
        sun?: pulumi.Input<string>;
        thu?: pulumi.Input<string>;
        tue?: pulumi.Input<string>;
        wed?: pulumi.Input<string>;
    }

    export interface WxtagSpec {
        /**
         * matched destination port, "0" means any
         */
        portRange?: pulumi.Input<string>;
        /**
         * tcp / udp / icmp / gre / any / ":protocol_number", `protocolNumber` is between 1-254
         */
        protocol?: pulumi.Input<string>;
        /**
         * matched destination subnets and/or IP Addresses
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }
}
