// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * This resource manages the Org Wlans.The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as junipermist from "@pulumi/juniper-mist";
 *
 * const wlanOne = new junipermist.org.Wlan("wlan_one", {
 *     ssid: "wlan_one",
 *     orgId: terraformTest.id,
 *     templateId: test101.id,
 *     bands: [
 *         "5",
 *         "6",
 *     ],
 *     vlanId: "143",
 *     wlanLimitUp: 10000,
 *     wlanLimitDown: 20000,
 *     clientLimitUp: 512,
 *     clientLimitDown: 1000,
 *     auth: {
 *         type: "psk",
 *         psk: "secretpsk",
 *     },
 *     "interface": "all",
 * });
 * ```
 *
 * ## Import
 *
 * Using `pulumi import`, import `mist_org_wlan` with:
 *
 * Org WLAN can be imported by specifying the org_id and the wlan_id
 *
 * ```sh
 * $ pulumi import junipermist:org/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
 * ```
 */
export class Wlan extends pulumi.CustomResource {
    /**
     * Get an existing Wlan resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: WlanState, opts?: pulumi.CustomResourceOptions): Wlan {
        return new Wlan(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'junipermist:org/wlan:Wlan';

    /**
     * Returns true if the given object is an instance of Wlan.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Wlan {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Wlan.__pulumiType;
    }

    /**
     * enable coa-immediate-update and address-change-immediate-update on the access profile.
     */
    public readonly acctImmediateUpdate!: pulumi.Output<boolean>;
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     */
    public readonly acctInterimInterval!: pulumi.Output<number>;
    /**
     * list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     */
    public readonly acctServers!: pulumi.Output<outputs.org.WlanAcctServer[]>;
    /**
     * airwatch wlan settings
     */
    public readonly airwatch!: pulumi.Output<outputs.org.WlanAirwatch | undefined>;
    /**
     * only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     */
    public readonly allowIpv6Ndp!: pulumi.Output<boolean>;
    /**
     * only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     */
    public readonly allowMdns!: pulumi.Output<boolean>;
    /**
     * only applicable when `limitBcast`==`tru`e, which allows SSDP
     */
    public readonly allowSsdp!: pulumi.Output<boolean>;
    /**
     * list of device ids
     */
    public readonly apIds!: pulumi.Output<string[]>;
    /**
     * bandwidth limiting for apps (applies to up/down)
     */
    public readonly appLimit!: pulumi.Output<outputs.org.WlanAppLimit | undefined>;
    /**
     * app qos wlan settings
     */
    public readonly appQos!: pulumi.Output<outputs.org.WlanAppQos | undefined>;
    /**
     * enum: `aps`, `site`, `wxtags`
     */
    public readonly applyTo!: pulumi.Output<string | undefined>;
    /**
     * whether to enable smart arp filter
     */
    public readonly arpFilter!: pulumi.Output<boolean>;
    /**
     * authentication wlan settings
     */
    public readonly auth!: pulumi.Output<outputs.org.WlanAuth | undefined>;
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     */
    public readonly authServerSelection!: pulumi.Output<string>;
    /**
     * list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     */
    public readonly authServers!: pulumi.Output<outputs.org.WlanAuthServer[]>;
    /**
     * optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     */
    public readonly authServersNasId!: pulumi.Output<string | undefined>;
    /**
     * optional, NAS-IP-ADDRESS to use
     */
    public readonly authServersNasIp!: pulumi.Output<string | undefined>;
    /**
     * radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to
     * default value to 3.
     */
    public readonly authServersRetries!: pulumi.Output<number>;
    /**
     * radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting authServersTimeout and is set to default value of 10.
     */
    public readonly authServersTimeout!: pulumi.Output<number>;
    /**
     * whether to enable band_steering, this works only when band==both
     */
    public readonly bandSteer!: pulumi.Output<boolean>;
    /**
     * force dualBand capable client to connect to 5G
     */
    public readonly bandSteerForceBand5!: pulumi.Output<boolean>;
    /**
     * list of radios that the wlan should apply to
     */
    public readonly bands!: pulumi.Output<string[] | undefined>;
    /**
     * whether to block the clients in the blacklist (up to first 256 macs)
     */
    public readonly blockBlacklistClients!: pulumi.Output<boolean>;
    /**
     * bonjour gateway wlan settings
     */
    public readonly bonjour!: pulumi.Output<outputs.org.WlanBonjour | undefined>;
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     */
    public readonly ciscoCwa!: pulumi.Output<outputs.org.WlanCiscoCwa | undefined>;
    /**
     * kbps
     */
    public readonly clientLimitDown!: pulumi.Output<number | undefined>;
    /**
     * if downlink limiting per-client is enabled
     */
    public readonly clientLimitDownEnabled!: pulumi.Output<boolean>;
    /**
     * kbps
     */
    public readonly clientLimitUp!: pulumi.Output<number | undefined>;
    /**
     * if uplink limiting per-client is enabled
     */
    public readonly clientLimitUpEnabled!: pulumi.Output<boolean>;
    /**
     * list of COA (change of authorization) servers, optional
     */
    public readonly coaServers!: pulumi.Output<outputs.org.WlanCoaServer[]>;
    /**
     * some old WLAN drivers may not be compatible
     */
    public readonly disable11ax!: pulumi.Output<boolean>;
    /**
     * to disable ht or vht rates
     */
    public readonly disableHtVhtRates!: pulumi.Output<boolean>;
    /**
     * whether to disable U-APSD
     */
    public readonly disableUapsd!: pulumi.Output<boolean>;
    /**
     * disable sending v2 roam notification messages
     */
    public readonly disableV1RoamNotify!: pulumi.Output<boolean>;
    /**
     * disable sending v2 roam notification messages
     */
    public readonly disableV2RoamNotify!: pulumi.Output<boolean>;
    /**
     * whether to disable WMM
     */
    public readonly disableWmm!: pulumi.Output<boolean>;
    /**
     * for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     */
    public readonly dnsServerRewrite!: pulumi.Output<outputs.org.WlanDnsServerRewrite | undefined>;
    public readonly dtim!: pulumi.Output<number>;
    /**
     * for dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
     * used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
     * wpa3 support on the roadmap)
     */
    public readonly dynamicPsk!: pulumi.Output<outputs.org.WlanDynamicPsk | undefined>;
    /**
     * for 802.1x
     */
    public readonly dynamicVlan!: pulumi.Output<outputs.org.WlanDynamicVlan | undefined>;
    /**
     * enable AP-AP keycaching via multicast
     */
    public readonly enableLocalKeycaching!: pulumi.Output<boolean>;
    /**
     * by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wirelessBridging can be enabled
     */
    public readonly enableWirelessBridging!: pulumi.Output<boolean>;
    /**
     * if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
     * packets to be forwarded to wireless
     */
    public readonly enableWirelessBridgingDhcpTracking!: pulumi.Output<boolean>;
    /**
     * if this wlan is enabled
     */
    public readonly enabled!: pulumi.Output<boolean>;
    /**
     * if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     */
    public readonly fastDot1xTimers!: pulumi.Output<boolean>;
    /**
     * whether to hide SSID in beacon
     */
    public readonly hideSsid!: pulumi.Output<boolean>;
    /**
     * include hostname inside IE in AP beacons / probe responses
     */
    public readonly hostnameIe!: pulumi.Output<boolean>;
    /**
     * hostspot 2.0 wlan settings
     */
    public readonly hotspot20!: pulumi.Output<outputs.org.WlanHotspot20 | undefined>;
    public readonly injectDhcpOption82!: pulumi.Output<outputs.org.WlanInjectDhcpOption82 | undefined>;
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     */
    public readonly interface!: pulumi.Output<string>;
    /**
     * whether to stop clients to talk to each other
     */
    public readonly isolation!: pulumi.Output<boolean>;
    /**
     * if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     */
    public readonly l2Isolation!: pulumi.Output<boolean>;
    /**
     * legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     */
    public readonly legacyOverds!: pulumi.Output<boolean>;
    /**
     * whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     */
    public readonly limitBcast!: pulumi.Output<boolean>;
    /**
     * limit probe response base on some heuristic rules
     */
    public readonly limitProbeResponse!: pulumi.Output<boolean>;
    /**
     * max idle time in seconds
     */
    public readonly maxIdletime!: pulumi.Output<number>;
    public readonly mistNac!: pulumi.Output<outputs.org.WlanMistNac | undefined>;
    public /*out*/ readonly mspId!: pulumi.Output<string>;
    /**
     * when `interface`=`mxtunnel`, id of the Mist Tunnel
     */
    public readonly mxtunnelIds!: pulumi.Output<string[]>;
    /**
     * when `interface`=`siteMedge`, name of the mxtunnel that in mxtunnels under Site Setting
     */
    public readonly mxtunnelNames!: pulumi.Output<string[]>;
    /**
     * whether to only allow client to use DNS that we’ve learned from DHCP response
     */
    public readonly noStaticDns!: pulumi.Output<boolean>;
    /**
     * whether to only allow client that we’ve learned from DHCP exchange to talk
     */
    public readonly noStaticIp!: pulumi.Output<boolean>;
    public readonly orgId!: pulumi.Output<string>;
    /**
     * portal wlan settings
     */
    public readonly portal!: pulumi.Output<outputs.org.WlanPortal | undefined>;
    /**
     * list of hostnames without http(s):// (matched by substring)
     */
    public readonly portalAllowedHostnames!: pulumi.Output<string[]>;
    /**
     * list of CIDRs
     */
    public readonly portalAllowedSubnets!: pulumi.Output<string[]>;
    /**
     * api secret (auto-generated) that can be used to sign guest authorization requests
     */
    public /*out*/ readonly portalApiSecret!: pulumi.Output<string>;
    /**
     * list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     */
    public readonly portalDeniedHostnames!: pulumi.Output<string[]>;
    /**
     * Url of portal background image
     */
    public /*out*/ readonly portalImage!: pulumi.Output<string>;
    public /*out*/ readonly portalSsoUrl!: pulumi.Output<string>;
    /**
     * N.B portalTemplate will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
     * To update portal_template, use Wlan Portal Template.
     */
    public /*out*/ readonly portalTemplateUrl!: pulumi.Output<string>;
    public readonly qos!: pulumi.Output<outputs.org.WlanQos | undefined>;
    /**
     * Radsec settings
     */
    public readonly radsec!: pulumi.Output<outputs.org.WlanRadsec | undefined>;
    /**
     * enum: `11r`, `OKC`, `none`
     */
    public readonly roamMode!: pulumi.Output<string>;
    /**
     * WLAN operating schedule, default is disabled
     */
    public readonly schedule!: pulumi.Output<outputs.org.WlanSchedule | undefined>;
    /**
     * whether to exclude this WLAN from SLE metrics
     */
    public readonly sleExcluded!: pulumi.Output<boolean>;
    /**
     * the name of the SSID
     */
    public readonly ssid!: pulumi.Output<string>;
    public readonly templateId!: pulumi.Output<string>;
    /**
     * Url of portal background image thumbnail
     */
    public /*out*/ readonly thumbnail!: pulumi.Output<string>;
    /**
     * if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     */
    public readonly useEapolV1!: pulumi.Output<boolean>;
    /**
     * if vlan tagging is enabled
     */
    public readonly vlanEnabled!: pulumi.Output<boolean>;
    public readonly vlanId!: pulumi.Output<string | undefined>;
    /**
     * vlan_ids to use when there’s no match from RA
     */
    public readonly vlanIds!: pulumi.Output<string[]>;
    /**
     * vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     */
    public readonly vlanPooling!: pulumi.Output<boolean>;
    /**
     * kbps
     */
    public readonly wlanLimitDown!: pulumi.Output<number>;
    /**
     * if downlink limiting for whole wlan is enabled
     */
    public readonly wlanLimitDownEnabled!: pulumi.Output<boolean>;
    /**
     * kbps
     */
    public readonly wlanLimitUp!: pulumi.Output<number>;
    /**
     * if uplink limiting for whole wlan is enabled
     */
    public readonly wlanLimitUpEnabled!: pulumi.Output<boolean>;
    /**
     * list of wxtag_ids
     */
    public readonly wxtagIds!: pulumi.Output<string[]>;
    /**
     * when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     */
    public readonly wxtunnelId!: pulumi.Output<string>;
    /**
     * when `interface`=`wxtunnel`, remote tunnel identifier
     */
    public readonly wxtunnelRemoteId!: pulumi.Output<string>;

    /**
     * Create a Wlan resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: WlanArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: WlanArgs | WlanState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as WlanState | undefined;
            resourceInputs["acctImmediateUpdate"] = state ? state.acctImmediateUpdate : undefined;
            resourceInputs["acctInterimInterval"] = state ? state.acctInterimInterval : undefined;
            resourceInputs["acctServers"] = state ? state.acctServers : undefined;
            resourceInputs["airwatch"] = state ? state.airwatch : undefined;
            resourceInputs["allowIpv6Ndp"] = state ? state.allowIpv6Ndp : undefined;
            resourceInputs["allowMdns"] = state ? state.allowMdns : undefined;
            resourceInputs["allowSsdp"] = state ? state.allowSsdp : undefined;
            resourceInputs["apIds"] = state ? state.apIds : undefined;
            resourceInputs["appLimit"] = state ? state.appLimit : undefined;
            resourceInputs["appQos"] = state ? state.appQos : undefined;
            resourceInputs["applyTo"] = state ? state.applyTo : undefined;
            resourceInputs["arpFilter"] = state ? state.arpFilter : undefined;
            resourceInputs["auth"] = state ? state.auth : undefined;
            resourceInputs["authServerSelection"] = state ? state.authServerSelection : undefined;
            resourceInputs["authServers"] = state ? state.authServers : undefined;
            resourceInputs["authServersNasId"] = state ? state.authServersNasId : undefined;
            resourceInputs["authServersNasIp"] = state ? state.authServersNasIp : undefined;
            resourceInputs["authServersRetries"] = state ? state.authServersRetries : undefined;
            resourceInputs["authServersTimeout"] = state ? state.authServersTimeout : undefined;
            resourceInputs["bandSteer"] = state ? state.bandSteer : undefined;
            resourceInputs["bandSteerForceBand5"] = state ? state.bandSteerForceBand5 : undefined;
            resourceInputs["bands"] = state ? state.bands : undefined;
            resourceInputs["blockBlacklistClients"] = state ? state.blockBlacklistClients : undefined;
            resourceInputs["bonjour"] = state ? state.bonjour : undefined;
            resourceInputs["ciscoCwa"] = state ? state.ciscoCwa : undefined;
            resourceInputs["clientLimitDown"] = state ? state.clientLimitDown : undefined;
            resourceInputs["clientLimitDownEnabled"] = state ? state.clientLimitDownEnabled : undefined;
            resourceInputs["clientLimitUp"] = state ? state.clientLimitUp : undefined;
            resourceInputs["clientLimitUpEnabled"] = state ? state.clientLimitUpEnabled : undefined;
            resourceInputs["coaServers"] = state ? state.coaServers : undefined;
            resourceInputs["disable11ax"] = state ? state.disable11ax : undefined;
            resourceInputs["disableHtVhtRates"] = state ? state.disableHtVhtRates : undefined;
            resourceInputs["disableUapsd"] = state ? state.disableUapsd : undefined;
            resourceInputs["disableV1RoamNotify"] = state ? state.disableV1RoamNotify : undefined;
            resourceInputs["disableV2RoamNotify"] = state ? state.disableV2RoamNotify : undefined;
            resourceInputs["disableWmm"] = state ? state.disableWmm : undefined;
            resourceInputs["dnsServerRewrite"] = state ? state.dnsServerRewrite : undefined;
            resourceInputs["dtim"] = state ? state.dtim : undefined;
            resourceInputs["dynamicPsk"] = state ? state.dynamicPsk : undefined;
            resourceInputs["dynamicVlan"] = state ? state.dynamicVlan : undefined;
            resourceInputs["enableLocalKeycaching"] = state ? state.enableLocalKeycaching : undefined;
            resourceInputs["enableWirelessBridging"] = state ? state.enableWirelessBridging : undefined;
            resourceInputs["enableWirelessBridgingDhcpTracking"] = state ? state.enableWirelessBridgingDhcpTracking : undefined;
            resourceInputs["enabled"] = state ? state.enabled : undefined;
            resourceInputs["fastDot1xTimers"] = state ? state.fastDot1xTimers : undefined;
            resourceInputs["hideSsid"] = state ? state.hideSsid : undefined;
            resourceInputs["hostnameIe"] = state ? state.hostnameIe : undefined;
            resourceInputs["hotspot20"] = state ? state.hotspot20 : undefined;
            resourceInputs["injectDhcpOption82"] = state ? state.injectDhcpOption82 : undefined;
            resourceInputs["interface"] = state ? state.interface : undefined;
            resourceInputs["isolation"] = state ? state.isolation : undefined;
            resourceInputs["l2Isolation"] = state ? state.l2Isolation : undefined;
            resourceInputs["legacyOverds"] = state ? state.legacyOverds : undefined;
            resourceInputs["limitBcast"] = state ? state.limitBcast : undefined;
            resourceInputs["limitProbeResponse"] = state ? state.limitProbeResponse : undefined;
            resourceInputs["maxIdletime"] = state ? state.maxIdletime : undefined;
            resourceInputs["mistNac"] = state ? state.mistNac : undefined;
            resourceInputs["mspId"] = state ? state.mspId : undefined;
            resourceInputs["mxtunnelIds"] = state ? state.mxtunnelIds : undefined;
            resourceInputs["mxtunnelNames"] = state ? state.mxtunnelNames : undefined;
            resourceInputs["noStaticDns"] = state ? state.noStaticDns : undefined;
            resourceInputs["noStaticIp"] = state ? state.noStaticIp : undefined;
            resourceInputs["orgId"] = state ? state.orgId : undefined;
            resourceInputs["portal"] = state ? state.portal : undefined;
            resourceInputs["portalAllowedHostnames"] = state ? state.portalAllowedHostnames : undefined;
            resourceInputs["portalAllowedSubnets"] = state ? state.portalAllowedSubnets : undefined;
            resourceInputs["portalApiSecret"] = state ? state.portalApiSecret : undefined;
            resourceInputs["portalDeniedHostnames"] = state ? state.portalDeniedHostnames : undefined;
            resourceInputs["portalImage"] = state ? state.portalImage : undefined;
            resourceInputs["portalSsoUrl"] = state ? state.portalSsoUrl : undefined;
            resourceInputs["portalTemplateUrl"] = state ? state.portalTemplateUrl : undefined;
            resourceInputs["qos"] = state ? state.qos : undefined;
            resourceInputs["radsec"] = state ? state.radsec : undefined;
            resourceInputs["roamMode"] = state ? state.roamMode : undefined;
            resourceInputs["schedule"] = state ? state.schedule : undefined;
            resourceInputs["sleExcluded"] = state ? state.sleExcluded : undefined;
            resourceInputs["ssid"] = state ? state.ssid : undefined;
            resourceInputs["templateId"] = state ? state.templateId : undefined;
            resourceInputs["thumbnail"] = state ? state.thumbnail : undefined;
            resourceInputs["useEapolV1"] = state ? state.useEapolV1 : undefined;
            resourceInputs["vlanEnabled"] = state ? state.vlanEnabled : undefined;
            resourceInputs["vlanId"] = state ? state.vlanId : undefined;
            resourceInputs["vlanIds"] = state ? state.vlanIds : undefined;
            resourceInputs["vlanPooling"] = state ? state.vlanPooling : undefined;
            resourceInputs["wlanLimitDown"] = state ? state.wlanLimitDown : undefined;
            resourceInputs["wlanLimitDownEnabled"] = state ? state.wlanLimitDownEnabled : undefined;
            resourceInputs["wlanLimitUp"] = state ? state.wlanLimitUp : undefined;
            resourceInputs["wlanLimitUpEnabled"] = state ? state.wlanLimitUpEnabled : undefined;
            resourceInputs["wxtagIds"] = state ? state.wxtagIds : undefined;
            resourceInputs["wxtunnelId"] = state ? state.wxtunnelId : undefined;
            resourceInputs["wxtunnelRemoteId"] = state ? state.wxtunnelRemoteId : undefined;
        } else {
            const args = argsOrState as WlanArgs | undefined;
            if ((!args || args.orgId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'orgId'");
            }
            if ((!args || args.ssid === undefined) && !opts.urn) {
                throw new Error("Missing required property 'ssid'");
            }
            if ((!args || args.templateId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'templateId'");
            }
            resourceInputs["acctImmediateUpdate"] = args ? args.acctImmediateUpdate : undefined;
            resourceInputs["acctInterimInterval"] = args ? args.acctInterimInterval : undefined;
            resourceInputs["acctServers"] = args ? args.acctServers : undefined;
            resourceInputs["airwatch"] = args ? args.airwatch : undefined;
            resourceInputs["allowIpv6Ndp"] = args ? args.allowIpv6Ndp : undefined;
            resourceInputs["allowMdns"] = args ? args.allowMdns : undefined;
            resourceInputs["allowSsdp"] = args ? args.allowSsdp : undefined;
            resourceInputs["apIds"] = args ? args.apIds : undefined;
            resourceInputs["appLimit"] = args ? args.appLimit : undefined;
            resourceInputs["appQos"] = args ? args.appQos : undefined;
            resourceInputs["applyTo"] = args ? args.applyTo : undefined;
            resourceInputs["arpFilter"] = args ? args.arpFilter : undefined;
            resourceInputs["auth"] = args ? args.auth : undefined;
            resourceInputs["authServerSelection"] = args ? args.authServerSelection : undefined;
            resourceInputs["authServers"] = args ? args.authServers : undefined;
            resourceInputs["authServersNasId"] = args ? args.authServersNasId : undefined;
            resourceInputs["authServersNasIp"] = args ? args.authServersNasIp : undefined;
            resourceInputs["authServersRetries"] = args ? args.authServersRetries : undefined;
            resourceInputs["authServersTimeout"] = args ? args.authServersTimeout : undefined;
            resourceInputs["bandSteer"] = args ? args.bandSteer : undefined;
            resourceInputs["bandSteerForceBand5"] = args ? args.bandSteerForceBand5 : undefined;
            resourceInputs["bands"] = args ? args.bands : undefined;
            resourceInputs["blockBlacklistClients"] = args ? args.blockBlacklistClients : undefined;
            resourceInputs["bonjour"] = args ? args.bonjour : undefined;
            resourceInputs["ciscoCwa"] = args ? args.ciscoCwa : undefined;
            resourceInputs["clientLimitDown"] = args ? args.clientLimitDown : undefined;
            resourceInputs["clientLimitDownEnabled"] = args ? args.clientLimitDownEnabled : undefined;
            resourceInputs["clientLimitUp"] = args ? args.clientLimitUp : undefined;
            resourceInputs["clientLimitUpEnabled"] = args ? args.clientLimitUpEnabled : undefined;
            resourceInputs["coaServers"] = args ? args.coaServers : undefined;
            resourceInputs["disable11ax"] = args ? args.disable11ax : undefined;
            resourceInputs["disableHtVhtRates"] = args ? args.disableHtVhtRates : undefined;
            resourceInputs["disableUapsd"] = args ? args.disableUapsd : undefined;
            resourceInputs["disableV1RoamNotify"] = args ? args.disableV1RoamNotify : undefined;
            resourceInputs["disableV2RoamNotify"] = args ? args.disableV2RoamNotify : undefined;
            resourceInputs["disableWmm"] = args ? args.disableWmm : undefined;
            resourceInputs["dnsServerRewrite"] = args ? args.dnsServerRewrite : undefined;
            resourceInputs["dtim"] = args ? args.dtim : undefined;
            resourceInputs["dynamicPsk"] = args ? args.dynamicPsk : undefined;
            resourceInputs["dynamicVlan"] = args ? args.dynamicVlan : undefined;
            resourceInputs["enableLocalKeycaching"] = args ? args.enableLocalKeycaching : undefined;
            resourceInputs["enableWirelessBridging"] = args ? args.enableWirelessBridging : undefined;
            resourceInputs["enableWirelessBridgingDhcpTracking"] = args ? args.enableWirelessBridgingDhcpTracking : undefined;
            resourceInputs["enabled"] = args ? args.enabled : undefined;
            resourceInputs["fastDot1xTimers"] = args ? args.fastDot1xTimers : undefined;
            resourceInputs["hideSsid"] = args ? args.hideSsid : undefined;
            resourceInputs["hostnameIe"] = args ? args.hostnameIe : undefined;
            resourceInputs["hotspot20"] = args ? args.hotspot20 : undefined;
            resourceInputs["injectDhcpOption82"] = args ? args.injectDhcpOption82 : undefined;
            resourceInputs["interface"] = args ? args.interface : undefined;
            resourceInputs["isolation"] = args ? args.isolation : undefined;
            resourceInputs["l2Isolation"] = args ? args.l2Isolation : undefined;
            resourceInputs["legacyOverds"] = args ? args.legacyOverds : undefined;
            resourceInputs["limitBcast"] = args ? args.limitBcast : undefined;
            resourceInputs["limitProbeResponse"] = args ? args.limitProbeResponse : undefined;
            resourceInputs["maxIdletime"] = args ? args.maxIdletime : undefined;
            resourceInputs["mistNac"] = args ? args.mistNac : undefined;
            resourceInputs["mxtunnelIds"] = args ? args.mxtunnelIds : undefined;
            resourceInputs["mxtunnelNames"] = args ? args.mxtunnelNames : undefined;
            resourceInputs["noStaticDns"] = args ? args.noStaticDns : undefined;
            resourceInputs["noStaticIp"] = args ? args.noStaticIp : undefined;
            resourceInputs["orgId"] = args ? args.orgId : undefined;
            resourceInputs["portal"] = args ? args.portal : undefined;
            resourceInputs["portalAllowedHostnames"] = args ? args.portalAllowedHostnames : undefined;
            resourceInputs["portalAllowedSubnets"] = args ? args.portalAllowedSubnets : undefined;
            resourceInputs["portalDeniedHostnames"] = args ? args.portalDeniedHostnames : undefined;
            resourceInputs["qos"] = args ? args.qos : undefined;
            resourceInputs["radsec"] = args ? args.radsec : undefined;
            resourceInputs["roamMode"] = args ? args.roamMode : undefined;
            resourceInputs["schedule"] = args ? args.schedule : undefined;
            resourceInputs["sleExcluded"] = args ? args.sleExcluded : undefined;
            resourceInputs["ssid"] = args ? args.ssid : undefined;
            resourceInputs["templateId"] = args ? args.templateId : undefined;
            resourceInputs["useEapolV1"] = args ? args.useEapolV1 : undefined;
            resourceInputs["vlanEnabled"] = args ? args.vlanEnabled : undefined;
            resourceInputs["vlanId"] = args ? args.vlanId : undefined;
            resourceInputs["vlanIds"] = args ? args.vlanIds : undefined;
            resourceInputs["vlanPooling"] = args ? args.vlanPooling : undefined;
            resourceInputs["wlanLimitDown"] = args ? args.wlanLimitDown : undefined;
            resourceInputs["wlanLimitDownEnabled"] = args ? args.wlanLimitDownEnabled : undefined;
            resourceInputs["wlanLimitUp"] = args ? args.wlanLimitUp : undefined;
            resourceInputs["wlanLimitUpEnabled"] = args ? args.wlanLimitUpEnabled : undefined;
            resourceInputs["wxtagIds"] = args ? args.wxtagIds : undefined;
            resourceInputs["wxtunnelId"] = args ? args.wxtunnelId : undefined;
            resourceInputs["wxtunnelRemoteId"] = args ? args.wxtunnelRemoteId : undefined;
            resourceInputs["mspId"] = undefined /*out*/;
            resourceInputs["portalApiSecret"] = undefined /*out*/;
            resourceInputs["portalImage"] = undefined /*out*/;
            resourceInputs["portalSsoUrl"] = undefined /*out*/;
            resourceInputs["portalTemplateUrl"] = undefined /*out*/;
            resourceInputs["thumbnail"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Wlan.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Wlan resources.
 */
export interface WlanState {
    /**
     * enable coa-immediate-update and address-change-immediate-update on the access profile.
     */
    acctImmediateUpdate?: pulumi.Input<boolean>;
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     */
    acctInterimInterval?: pulumi.Input<number>;
    /**
     * list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     */
    acctServers?: pulumi.Input<pulumi.Input<inputs.org.WlanAcctServer>[]>;
    /**
     * airwatch wlan settings
     */
    airwatch?: pulumi.Input<inputs.org.WlanAirwatch>;
    /**
     * only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     */
    allowIpv6Ndp?: pulumi.Input<boolean>;
    /**
     * only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     */
    allowMdns?: pulumi.Input<boolean>;
    /**
     * only applicable when `limitBcast`==`tru`e, which allows SSDP
     */
    allowSsdp?: pulumi.Input<boolean>;
    /**
     * list of device ids
     */
    apIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * bandwidth limiting for apps (applies to up/down)
     */
    appLimit?: pulumi.Input<inputs.org.WlanAppLimit>;
    /**
     * app qos wlan settings
     */
    appQos?: pulumi.Input<inputs.org.WlanAppQos>;
    /**
     * enum: `aps`, `site`, `wxtags`
     */
    applyTo?: pulumi.Input<string>;
    /**
     * whether to enable smart arp filter
     */
    arpFilter?: pulumi.Input<boolean>;
    /**
     * authentication wlan settings
     */
    auth?: pulumi.Input<inputs.org.WlanAuth>;
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     */
    authServerSelection?: pulumi.Input<string>;
    /**
     * list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     */
    authServers?: pulumi.Input<pulumi.Input<inputs.org.WlanAuthServer>[]>;
    /**
     * optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     */
    authServersNasId?: pulumi.Input<string>;
    /**
     * optional, NAS-IP-ADDRESS to use
     */
    authServersNasIp?: pulumi.Input<string>;
    /**
     * radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to
     * default value to 3.
     */
    authServersRetries?: pulumi.Input<number>;
    /**
     * radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting authServersTimeout and is set to default value of 10.
     */
    authServersTimeout?: pulumi.Input<number>;
    /**
     * whether to enable band_steering, this works only when band==both
     */
    bandSteer?: pulumi.Input<boolean>;
    /**
     * force dualBand capable client to connect to 5G
     */
    bandSteerForceBand5?: pulumi.Input<boolean>;
    /**
     * list of radios that the wlan should apply to
     */
    bands?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * whether to block the clients in the blacklist (up to first 256 macs)
     */
    blockBlacklistClients?: pulumi.Input<boolean>;
    /**
     * bonjour gateway wlan settings
     */
    bonjour?: pulumi.Input<inputs.org.WlanBonjour>;
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     */
    ciscoCwa?: pulumi.Input<inputs.org.WlanCiscoCwa>;
    /**
     * kbps
     */
    clientLimitDown?: pulumi.Input<number>;
    /**
     * if downlink limiting per-client is enabled
     */
    clientLimitDownEnabled?: pulumi.Input<boolean>;
    /**
     * kbps
     */
    clientLimitUp?: pulumi.Input<number>;
    /**
     * if uplink limiting per-client is enabled
     */
    clientLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * list of COA (change of authorization) servers, optional
     */
    coaServers?: pulumi.Input<pulumi.Input<inputs.org.WlanCoaServer>[]>;
    /**
     * some old WLAN drivers may not be compatible
     */
    disable11ax?: pulumi.Input<boolean>;
    /**
     * to disable ht or vht rates
     */
    disableHtVhtRates?: pulumi.Input<boolean>;
    /**
     * whether to disable U-APSD
     */
    disableUapsd?: pulumi.Input<boolean>;
    /**
     * disable sending v2 roam notification messages
     */
    disableV1RoamNotify?: pulumi.Input<boolean>;
    /**
     * disable sending v2 roam notification messages
     */
    disableV2RoamNotify?: pulumi.Input<boolean>;
    /**
     * whether to disable WMM
     */
    disableWmm?: pulumi.Input<boolean>;
    /**
     * for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     */
    dnsServerRewrite?: pulumi.Input<inputs.org.WlanDnsServerRewrite>;
    dtim?: pulumi.Input<number>;
    /**
     * for dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
     * used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
     * wpa3 support on the roadmap)
     */
    dynamicPsk?: pulumi.Input<inputs.org.WlanDynamicPsk>;
    /**
     * for 802.1x
     */
    dynamicVlan?: pulumi.Input<inputs.org.WlanDynamicVlan>;
    /**
     * enable AP-AP keycaching via multicast
     */
    enableLocalKeycaching?: pulumi.Input<boolean>;
    /**
     * by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wirelessBridging can be enabled
     */
    enableWirelessBridging?: pulumi.Input<boolean>;
    /**
     * if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
     * packets to be forwarded to wireless
     */
    enableWirelessBridgingDhcpTracking?: pulumi.Input<boolean>;
    /**
     * if this wlan is enabled
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     */
    fastDot1xTimers?: pulumi.Input<boolean>;
    /**
     * whether to hide SSID in beacon
     */
    hideSsid?: pulumi.Input<boolean>;
    /**
     * include hostname inside IE in AP beacons / probe responses
     */
    hostnameIe?: pulumi.Input<boolean>;
    /**
     * hostspot 2.0 wlan settings
     */
    hotspot20?: pulumi.Input<inputs.org.WlanHotspot20>;
    injectDhcpOption82?: pulumi.Input<inputs.org.WlanInjectDhcpOption82>;
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     */
    interface?: pulumi.Input<string>;
    /**
     * whether to stop clients to talk to each other
     */
    isolation?: pulumi.Input<boolean>;
    /**
     * if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     */
    l2Isolation?: pulumi.Input<boolean>;
    /**
     * legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     */
    legacyOverds?: pulumi.Input<boolean>;
    /**
     * whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     */
    limitBcast?: pulumi.Input<boolean>;
    /**
     * limit probe response base on some heuristic rules
     */
    limitProbeResponse?: pulumi.Input<boolean>;
    /**
     * max idle time in seconds
     */
    maxIdletime?: pulumi.Input<number>;
    mistNac?: pulumi.Input<inputs.org.WlanMistNac>;
    mspId?: pulumi.Input<string>;
    /**
     * when `interface`=`mxtunnel`, id of the Mist Tunnel
     */
    mxtunnelIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * when `interface`=`siteMedge`, name of the mxtunnel that in mxtunnels under Site Setting
     */
    mxtunnelNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * whether to only allow client to use DNS that we’ve learned from DHCP response
     */
    noStaticDns?: pulumi.Input<boolean>;
    /**
     * whether to only allow client that we’ve learned from DHCP exchange to talk
     */
    noStaticIp?: pulumi.Input<boolean>;
    orgId?: pulumi.Input<string>;
    /**
     * portal wlan settings
     */
    portal?: pulumi.Input<inputs.org.WlanPortal>;
    /**
     * list of hostnames without http(s):// (matched by substring)
     */
    portalAllowedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of CIDRs
     */
    portalAllowedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * api secret (auto-generated) that can be used to sign guest authorization requests
     */
    portalApiSecret?: pulumi.Input<string>;
    /**
     * list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     */
    portalDeniedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Url of portal background image
     */
    portalImage?: pulumi.Input<string>;
    portalSsoUrl?: pulumi.Input<string>;
    /**
     * N.B portalTemplate will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
     * To update portal_template, use Wlan Portal Template.
     */
    portalTemplateUrl?: pulumi.Input<string>;
    qos?: pulumi.Input<inputs.org.WlanQos>;
    /**
     * Radsec settings
     */
    radsec?: pulumi.Input<inputs.org.WlanRadsec>;
    /**
     * enum: `11r`, `OKC`, `none`
     */
    roamMode?: pulumi.Input<string>;
    /**
     * WLAN operating schedule, default is disabled
     */
    schedule?: pulumi.Input<inputs.org.WlanSchedule>;
    /**
     * whether to exclude this WLAN from SLE metrics
     */
    sleExcluded?: pulumi.Input<boolean>;
    /**
     * the name of the SSID
     */
    ssid?: pulumi.Input<string>;
    templateId?: pulumi.Input<string>;
    /**
     * Url of portal background image thumbnail
     */
    thumbnail?: pulumi.Input<string>;
    /**
     * if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     */
    useEapolV1?: pulumi.Input<boolean>;
    /**
     * if vlan tagging is enabled
     */
    vlanEnabled?: pulumi.Input<boolean>;
    vlanId?: pulumi.Input<string>;
    /**
     * vlan_ids to use when there’s no match from RA
     */
    vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     */
    vlanPooling?: pulumi.Input<boolean>;
    /**
     * kbps
     */
    wlanLimitDown?: pulumi.Input<number>;
    /**
     * if downlink limiting for whole wlan is enabled
     */
    wlanLimitDownEnabled?: pulumi.Input<boolean>;
    /**
     * kbps
     */
    wlanLimitUp?: pulumi.Input<number>;
    /**
     * if uplink limiting for whole wlan is enabled
     */
    wlanLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * list of wxtag_ids
     */
    wxtagIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     */
    wxtunnelId?: pulumi.Input<string>;
    /**
     * when `interface`=`wxtunnel`, remote tunnel identifier
     */
    wxtunnelRemoteId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Wlan resource.
 */
export interface WlanArgs {
    /**
     * enable coa-immediate-update and address-change-immediate-update on the access profile.
     */
    acctImmediateUpdate?: pulumi.Input<boolean>;
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     */
    acctInterimInterval?: pulumi.Input<number>;
    /**
     * list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     */
    acctServers?: pulumi.Input<pulumi.Input<inputs.org.WlanAcctServer>[]>;
    /**
     * airwatch wlan settings
     */
    airwatch?: pulumi.Input<inputs.org.WlanAirwatch>;
    /**
     * only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     */
    allowIpv6Ndp?: pulumi.Input<boolean>;
    /**
     * only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     */
    allowMdns?: pulumi.Input<boolean>;
    /**
     * only applicable when `limitBcast`==`tru`e, which allows SSDP
     */
    allowSsdp?: pulumi.Input<boolean>;
    /**
     * list of device ids
     */
    apIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * bandwidth limiting for apps (applies to up/down)
     */
    appLimit?: pulumi.Input<inputs.org.WlanAppLimit>;
    /**
     * app qos wlan settings
     */
    appQos?: pulumi.Input<inputs.org.WlanAppQos>;
    /**
     * enum: `aps`, `site`, `wxtags`
     */
    applyTo?: pulumi.Input<string>;
    /**
     * whether to enable smart arp filter
     */
    arpFilter?: pulumi.Input<boolean>;
    /**
     * authentication wlan settings
     */
    auth?: pulumi.Input<inputs.org.WlanAuth>;
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     */
    authServerSelection?: pulumi.Input<string>;
    /**
     * list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     */
    authServers?: pulumi.Input<pulumi.Input<inputs.org.WlanAuthServer>[]>;
    /**
     * optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     */
    authServersNasId?: pulumi.Input<string>;
    /**
     * optional, NAS-IP-ADDRESS to use
     */
    authServersNasIp?: pulumi.Input<string>;
    /**
     * radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to
     * default value to 3.
     */
    authServersRetries?: pulumi.Input<number>;
    /**
     * radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting authServersTimeout and is set to default value of 10.
     */
    authServersTimeout?: pulumi.Input<number>;
    /**
     * whether to enable band_steering, this works only when band==both
     */
    bandSteer?: pulumi.Input<boolean>;
    /**
     * force dualBand capable client to connect to 5G
     */
    bandSteerForceBand5?: pulumi.Input<boolean>;
    /**
     * list of radios that the wlan should apply to
     */
    bands?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * whether to block the clients in the blacklist (up to first 256 macs)
     */
    blockBlacklistClients?: pulumi.Input<boolean>;
    /**
     * bonjour gateway wlan settings
     */
    bonjour?: pulumi.Input<inputs.org.WlanBonjour>;
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     */
    ciscoCwa?: pulumi.Input<inputs.org.WlanCiscoCwa>;
    /**
     * kbps
     */
    clientLimitDown?: pulumi.Input<number>;
    /**
     * if downlink limiting per-client is enabled
     */
    clientLimitDownEnabled?: pulumi.Input<boolean>;
    /**
     * kbps
     */
    clientLimitUp?: pulumi.Input<number>;
    /**
     * if uplink limiting per-client is enabled
     */
    clientLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * list of COA (change of authorization) servers, optional
     */
    coaServers?: pulumi.Input<pulumi.Input<inputs.org.WlanCoaServer>[]>;
    /**
     * some old WLAN drivers may not be compatible
     */
    disable11ax?: pulumi.Input<boolean>;
    /**
     * to disable ht or vht rates
     */
    disableHtVhtRates?: pulumi.Input<boolean>;
    /**
     * whether to disable U-APSD
     */
    disableUapsd?: pulumi.Input<boolean>;
    /**
     * disable sending v2 roam notification messages
     */
    disableV1RoamNotify?: pulumi.Input<boolean>;
    /**
     * disable sending v2 roam notification messages
     */
    disableV2RoamNotify?: pulumi.Input<boolean>;
    /**
     * whether to disable WMM
     */
    disableWmm?: pulumi.Input<boolean>;
    /**
     * for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     */
    dnsServerRewrite?: pulumi.Input<inputs.org.WlanDnsServerRewrite>;
    dtim?: pulumi.Input<number>;
    /**
     * for dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
     * used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
     * wpa3 support on the roadmap)
     */
    dynamicPsk?: pulumi.Input<inputs.org.WlanDynamicPsk>;
    /**
     * for 802.1x
     */
    dynamicVlan?: pulumi.Input<inputs.org.WlanDynamicVlan>;
    /**
     * enable AP-AP keycaching via multicast
     */
    enableLocalKeycaching?: pulumi.Input<boolean>;
    /**
     * by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wirelessBridging can be enabled
     */
    enableWirelessBridging?: pulumi.Input<boolean>;
    /**
     * if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
     * packets to be forwarded to wireless
     */
    enableWirelessBridgingDhcpTracking?: pulumi.Input<boolean>;
    /**
     * if this wlan is enabled
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     */
    fastDot1xTimers?: pulumi.Input<boolean>;
    /**
     * whether to hide SSID in beacon
     */
    hideSsid?: pulumi.Input<boolean>;
    /**
     * include hostname inside IE in AP beacons / probe responses
     */
    hostnameIe?: pulumi.Input<boolean>;
    /**
     * hostspot 2.0 wlan settings
     */
    hotspot20?: pulumi.Input<inputs.org.WlanHotspot20>;
    injectDhcpOption82?: pulumi.Input<inputs.org.WlanInjectDhcpOption82>;
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     */
    interface?: pulumi.Input<string>;
    /**
     * whether to stop clients to talk to each other
     */
    isolation?: pulumi.Input<boolean>;
    /**
     * if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     */
    l2Isolation?: pulumi.Input<boolean>;
    /**
     * legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     */
    legacyOverds?: pulumi.Input<boolean>;
    /**
     * whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     */
    limitBcast?: pulumi.Input<boolean>;
    /**
     * limit probe response base on some heuristic rules
     */
    limitProbeResponse?: pulumi.Input<boolean>;
    /**
     * max idle time in seconds
     */
    maxIdletime?: pulumi.Input<number>;
    mistNac?: pulumi.Input<inputs.org.WlanMistNac>;
    /**
     * when `interface`=`mxtunnel`, id of the Mist Tunnel
     */
    mxtunnelIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * when `interface`=`siteMedge`, name of the mxtunnel that in mxtunnels under Site Setting
     */
    mxtunnelNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * whether to only allow client to use DNS that we’ve learned from DHCP response
     */
    noStaticDns?: pulumi.Input<boolean>;
    /**
     * whether to only allow client that we’ve learned from DHCP exchange to talk
     */
    noStaticIp?: pulumi.Input<boolean>;
    orgId: pulumi.Input<string>;
    /**
     * portal wlan settings
     */
    portal?: pulumi.Input<inputs.org.WlanPortal>;
    /**
     * list of hostnames without http(s):// (matched by substring)
     */
    portalAllowedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of CIDRs
     */
    portalAllowedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     */
    portalDeniedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    qos?: pulumi.Input<inputs.org.WlanQos>;
    /**
     * Radsec settings
     */
    radsec?: pulumi.Input<inputs.org.WlanRadsec>;
    /**
     * enum: `11r`, `OKC`, `none`
     */
    roamMode?: pulumi.Input<string>;
    /**
     * WLAN operating schedule, default is disabled
     */
    schedule?: pulumi.Input<inputs.org.WlanSchedule>;
    /**
     * whether to exclude this WLAN from SLE metrics
     */
    sleExcluded?: pulumi.Input<boolean>;
    /**
     * the name of the SSID
     */
    ssid: pulumi.Input<string>;
    templateId: pulumi.Input<string>;
    /**
     * if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     */
    useEapolV1?: pulumi.Input<boolean>;
    /**
     * if vlan tagging is enabled
     */
    vlanEnabled?: pulumi.Input<boolean>;
    vlanId?: pulumi.Input<string>;
    /**
     * vlan_ids to use when there’s no match from RA
     */
    vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     */
    vlanPooling?: pulumi.Input<boolean>;
    /**
     * kbps
     */
    wlanLimitDown?: pulumi.Input<number>;
    /**
     * if downlink limiting for whole wlan is enabled
     */
    wlanLimitDownEnabled?: pulumi.Input<boolean>;
    /**
     * kbps
     */
    wlanLimitUp?: pulumi.Input<number>;
    /**
     * if uplink limiting for whole wlan is enabled
     */
    wlanLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * list of wxtag_ids
     */
    wxtagIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     */
    wxtunnelId?: pulumi.Input<string>;
    /**
     * when `interface`=`wxtunnel`, remote tunnel identifier
     */
    wxtunnelRemoteId?: pulumi.Input<string>;
}
