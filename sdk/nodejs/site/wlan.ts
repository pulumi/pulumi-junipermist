// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * This resource manages the Site Wlans.
 * The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as junipermist from "@pulumi/juniper-mist";
 *
 * const wlanOne = new junipermist.site.Wlan("wlan_one", {
 *     ssid: "wlan_one",
 *     siteId: terraformTest.id,
 *     bands: [
 *         "5",
 *         "6",
 *     ],
 *     vlanEnabled: true,
 *     vlanId: "143",
 *     wlanLimitUp: "10000",
 *     wlanLimitDown: "20000",
 *     clientLimitUp: "512",
 *     clientLimitDown: "1000",
 *     auth: {
 *         type: "psk",
 *         psk: "secretpsk",
 *     },
 *     "interface": "all",
 * });
 * ```
 *
 * ## Import
 *
 * Using `pulumi import`, import `mist_site_wlan` with:
 *
 * Site WLAN can be imported by specifying the site_id and the wlan_id
 *
 * ```sh
 * $ pulumi import junipermist:site/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
 * ```
 */
export class Wlan extends pulumi.CustomResource {
    /**
     * Get an existing Wlan resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: WlanState, opts?: pulumi.CustomResourceOptions): Wlan {
        return new Wlan(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'junipermist:site/wlan:Wlan';

    /**
     * Returns true if the given object is an instance of Wlan.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Wlan {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Wlan.__pulumiType;
    }

    /**
     * Enable coa-immediate-update and address-change-immediate-update on the access profile.
     */
    declare public readonly acctImmediateUpdate: pulumi.Output<boolean>;
    /**
     * How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     */
    declare public readonly acctInterimInterval: pulumi.Output<number>;
    /**
     * List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     */
    declare public readonly acctServers: pulumi.Output<outputs.site.WlanAcctServer[]>;
    /**
     * Airwatch wlan settings
     */
    declare public readonly airwatch: pulumi.Output<outputs.site.WlanAirwatch>;
    /**
     * Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     */
    declare public readonly allowIpv6Ndp: pulumi.Output<boolean>;
    /**
     * Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     */
    declare public readonly allowMdns: pulumi.Output<boolean>;
    /**
     * Only applicable when `limitBcast`==`true`, which allows SSDP
     */
    declare public readonly allowSsdp: pulumi.Output<boolean>;
    /**
     * List of device ids
     */
    declare public readonly apIds: pulumi.Output<string[]>;
    /**
     * Bandwidth limiting for apps (applies to up/down)
     */
    declare public readonly appLimit: pulumi.Output<outputs.site.WlanAppLimit | undefined>;
    /**
     * APp qos wlan settings
     */
    declare public readonly appQos: pulumi.Output<outputs.site.WlanAppQos>;
    /**
     * enum: `aps`, `site`, `wxtags`
     */
    declare public readonly applyTo: pulumi.Output<string>;
    /**
     * Whether to enable smart arp filter
     */
    declare public readonly arpFilter: pulumi.Output<boolean>;
    /**
     * Authentication wlan settings
     */
    declare public readonly auth: pulumi.Output<outputs.site.WlanAuth | undefined>;
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     */
    declare public readonly authServerSelection: pulumi.Output<string>;
    /**
     * List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     */
    declare public readonly authServers: pulumi.Output<outputs.site.WlanAuthServer[]>;
    /**
     * Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     */
    declare public readonly authServersNasId: pulumi.Output<string>;
    /**
     * Optional, NAS-IP-ADDRESS to use
     */
    declare public readonly authServersNasIp: pulumi.Output<string>;
    /**
     * Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default value to 3.
     */
    declare public readonly authServersRetries: pulumi.Output<number | undefined>;
    /**
     * Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting authServersTimeout and is set to default value of 10.
     */
    declare public readonly authServersTimeout: pulumi.Output<number | undefined>;
    /**
     * Whether to enable band_steering, this works only when band==both
     */
    declare public readonly bandSteer: pulumi.Output<boolean>;
    /**
     * Force dualBand capable client to connect to 5G
     */
    declare public readonly bandSteerForceBand5: pulumi.Output<boolean | undefined>;
    /**
     * list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     */
    declare public readonly bands: pulumi.Output<string[] | undefined>;
    /**
     * Whether to block the clients in the blacklist (up to first 256 macs)
     */
    declare public readonly blockBlacklistClients: pulumi.Output<boolean | undefined>;
    /**
     * Bonjour gateway wlan settings
     */
    declare public readonly bonjour: pulumi.Output<outputs.site.WlanBonjour | undefined>;
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     */
    declare public readonly ciscoCwa: pulumi.Output<outputs.site.WlanCiscoCwa>;
    declare public readonly clientLimitDown: pulumi.Output<string>;
    /**
     * If downlink limiting per-client is enabled
     */
    declare public readonly clientLimitDownEnabled: pulumi.Output<boolean | undefined>;
    declare public readonly clientLimitUp: pulumi.Output<string>;
    /**
     * If uplink limiting per-client is enabled
     */
    declare public readonly clientLimitUpEnabled: pulumi.Output<boolean | undefined>;
    /**
     * List of COA (change of authorization) servers, optional
     */
    declare public readonly coaServers: pulumi.Output<outputs.site.WlanCoaServer[] | undefined>;
    /**
     * Some old WLAN drivers may not be compatible
     */
    declare public readonly disable11ax: pulumi.Output<boolean>;
    /**
     * To disable Wi-Fi 7 EHT IEs
     */
    declare public readonly disable11be: pulumi.Output<boolean | undefined>;
    /**
     * To disable ht or vht rates
     */
    declare public readonly disableHtVhtRates: pulumi.Output<boolean | undefined>;
    /**
     * Whether to disable U-APSD
     */
    declare public readonly disableUapsd: pulumi.Output<boolean>;
    /**
     * Disable sending v2 roam notification messages
     */
    declare public readonly disableV1RoamNotify: pulumi.Output<boolean | undefined>;
    /**
     * Disable sending v2 roam notification messages
     */
    declare public readonly disableV2RoamNotify: pulumi.Output<boolean | undefined>;
    /**
     * When any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     */
    declare public readonly disableWhenGatewayUnreachable: pulumi.Output<boolean | undefined>;
    declare public readonly disableWhenMxtunnelDown: pulumi.Output<boolean | undefined>;
    /**
     * Whether to disable WMM
     */
    declare public readonly disableWmm: pulumi.Output<boolean>;
    /**
     * For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     */
    declare public readonly dnsServerRewrite: pulumi.Output<outputs.site.WlanDnsServerRewrite | undefined>;
    declare public readonly dtim: pulumi.Output<number>;
    /**
     * For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `authServers` is required
     *   * PSK will come from cloud WLC if source is cloudPsks
     *   * defaultPsk will be used if cloud WLC is not available
     *   * `multiPskOnly` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     */
    declare public readonly dynamicPsk: pulumi.Output<outputs.site.WlanDynamicPsk | undefined>;
    /**
     * For 802.1x
     */
    declare public readonly dynamicVlan: pulumi.Output<outputs.site.WlanDynamicVlan | undefined>;
    /**
     * Enable AP-AP keycaching via multicast
     */
    declare public readonly enableLocalKeycaching: pulumi.Output<boolean | undefined>;
    /**
     * By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
     */
    declare public readonly enableWirelessBridging: pulumi.Output<boolean | undefined>;
    /**
     * If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response packets to be forwarded to wireless
     */
    declare public readonly enableWirelessBridgingDhcpTracking: pulumi.Output<boolean | undefined>;
    /**
     * If this wlan is enabled
     */
    declare public readonly enabled: pulumi.Output<boolean>;
    /**
     * If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     */
    declare public readonly fastDot1xTimers: pulumi.Output<boolean | undefined>;
    /**
     * Whether to hide SSID in beacon
     */
    declare public readonly hideSsid: pulumi.Output<boolean>;
    /**
     * Include hostname inside IE in AP beacons / probe responses
     */
    declare public readonly hostnameIe: pulumi.Output<boolean>;
    /**
     * Hostspot 2.0 wlan settings
     */
    declare public readonly hotspot20: pulumi.Output<outputs.site.WlanHotspot20 | undefined>;
    declare public readonly injectDhcpOption82: pulumi.Output<outputs.site.WlanInjectDhcpOption82 | undefined>;
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     */
    declare public readonly interface: pulumi.Output<string>;
    /**
     * Whether to stop clients to talk to each other
     */
    declare public readonly isolation: pulumi.Output<boolean | undefined>;
    /**
     * If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     */
    declare public readonly l2Isolation: pulumi.Output<boolean | undefined>;
    /**
     * Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     */
    declare public readonly legacyOverds: pulumi.Output<boolean | undefined>;
    /**
     * Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     */
    declare public readonly limitBcast: pulumi.Output<boolean>;
    /**
     * Limit probe response base on some heuristic rules
     */
    declare public readonly limitProbeResponse: pulumi.Output<boolean>;
    /**
     * Max idle time in seconds
     */
    declare public readonly maxIdletime: pulumi.Output<number>;
    /**
     * Maximum number of client connected to the SSID. `0` means unlimited
     */
    declare public readonly maxNumClients: pulumi.Output<number | undefined>;
    declare public readonly mistNac: pulumi.Output<outputs.site.WlanMistNac>;
    declare public /*out*/ readonly mspId: pulumi.Output<string>;
    /**
     * When `interface`=`mxtunnel`, id of the Mist Tunnel
     */
    declare public readonly mxtunnelIds: pulumi.Output<string[]>;
    /**
     * When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     */
    declare public readonly mxtunnelNames: pulumi.Output<string[]>;
    /**
     * Whether to only allow client to use DNS that we’ve learned from DHCP response
     */
    declare public readonly noStaticDns: pulumi.Output<boolean>;
    /**
     * Whether to only allow client that we’ve learned from DHCP exchange to talk
     */
    declare public readonly noStaticIp: pulumi.Output<boolean>;
    declare public /*out*/ readonly orgId: pulumi.Output<string>;
    /**
     * Portal wlan settings
     */
    declare public readonly portal: pulumi.Output<outputs.site.WlanPortal>;
    /**
     * List of hostnames without http(s):// (matched by substring)
     */
    declare public readonly portalAllowedHostnames: pulumi.Output<string[]>;
    /**
     * List of CIDRs
     */
    declare public readonly portalAllowedSubnets: pulumi.Output<string[]>;
    /**
     * API secret (auto-generated) that can be used to sign guest authorization requests, only generated when auth is set to `external`
     */
    declare public /*out*/ readonly portalApiSecret: pulumi.Output<string>;
    /**
     * List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     */
    declare public readonly portalDeniedHostnames: pulumi.Output<string[]>;
    /**
     * Url of portal background image
     */
    declare public /*out*/ readonly portalImage: pulumi.Output<string>;
    /**
     * URL used in the SSO process, auto-generated when auth is set to `sso`
     */
    declare public /*out*/ readonly portalSsoUrl: pulumi.Output<string>;
    declare public readonly qos: pulumi.Output<outputs.site.WlanQos>;
    /**
     * RadSec settings
     */
    declare public readonly radsec: pulumi.Output<outputs.site.WlanRadsec>;
    /**
     * Property key is the RF band. enum: `24`, `5`, `6`
     */
    declare public readonly rateset: pulumi.Output<{[key: string]: outputs.site.WlanRateset}>;
    /**
     * When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
     */
    declare public readonly reconnectClientsWhenRoamingMxcluster: pulumi.Output<boolean | undefined>;
    /**
     * enum: `11r`, `OKC`, `NONE`
     */
    declare public readonly roamMode: pulumi.Output<string | undefined>;
    /**
     * WLAN operating schedule, default is disabled
     */
    declare public readonly schedule: pulumi.Output<outputs.site.WlanSchedule>;
    declare public readonly siteId: pulumi.Output<string>;
    /**
     * Whether to exclude this WLAN from SLE metrics
     */
    declare public readonly sleExcluded: pulumi.Output<boolean | undefined>;
    /**
     * Name of the SSID
     */
    declare public readonly ssid: pulumi.Output<string>;
    /**
     * If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     */
    declare public readonly useEapolV1: pulumi.Output<boolean>;
    /**
     * If vlan tagging is enabled
     */
    declare public readonly vlanEnabled: pulumi.Output<boolean>;
    declare public readonly vlanId: pulumi.Output<string | undefined>;
    /**
     * if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     */
    declare public readonly vlanIds: pulumi.Output<string[]>;
    /**
     * Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     */
    declare public readonly vlanPooling: pulumi.Output<boolean>;
    declare public readonly wlanLimitDown: pulumi.Output<string>;
    /**
     * If downlink limiting for whole wlan is enabled
     */
    declare public readonly wlanLimitDownEnabled: pulumi.Output<boolean | undefined>;
    declare public readonly wlanLimitUp: pulumi.Output<string>;
    /**
     * If uplink limiting for whole wlan is enabled
     */
    declare public readonly wlanLimitUpEnabled: pulumi.Output<boolean | undefined>;
    /**
     * List of wxtag_ids
     */
    declare public readonly wxtagIds: pulumi.Output<string[]>;
    /**
     * When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     */
    declare public readonly wxtunnelId: pulumi.Output<string>;
    /**
     * When `interface`=`wxtunnel`, remote tunnel identifier
     */
    declare public readonly wxtunnelRemoteId: pulumi.Output<string>;

    /**
     * Create a Wlan resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: WlanArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: WlanArgs | WlanState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as WlanState | undefined;
            resourceInputs["acctImmediateUpdate"] = state?.acctImmediateUpdate;
            resourceInputs["acctInterimInterval"] = state?.acctInterimInterval;
            resourceInputs["acctServers"] = state?.acctServers;
            resourceInputs["airwatch"] = state?.airwatch;
            resourceInputs["allowIpv6Ndp"] = state?.allowIpv6Ndp;
            resourceInputs["allowMdns"] = state?.allowMdns;
            resourceInputs["allowSsdp"] = state?.allowSsdp;
            resourceInputs["apIds"] = state?.apIds;
            resourceInputs["appLimit"] = state?.appLimit;
            resourceInputs["appQos"] = state?.appQos;
            resourceInputs["applyTo"] = state?.applyTo;
            resourceInputs["arpFilter"] = state?.arpFilter;
            resourceInputs["auth"] = state?.auth;
            resourceInputs["authServerSelection"] = state?.authServerSelection;
            resourceInputs["authServers"] = state?.authServers;
            resourceInputs["authServersNasId"] = state?.authServersNasId;
            resourceInputs["authServersNasIp"] = state?.authServersNasIp;
            resourceInputs["authServersRetries"] = state?.authServersRetries;
            resourceInputs["authServersTimeout"] = state?.authServersTimeout;
            resourceInputs["bandSteer"] = state?.bandSteer;
            resourceInputs["bandSteerForceBand5"] = state?.bandSteerForceBand5;
            resourceInputs["bands"] = state?.bands;
            resourceInputs["blockBlacklistClients"] = state?.blockBlacklistClients;
            resourceInputs["bonjour"] = state?.bonjour;
            resourceInputs["ciscoCwa"] = state?.ciscoCwa;
            resourceInputs["clientLimitDown"] = state?.clientLimitDown;
            resourceInputs["clientLimitDownEnabled"] = state?.clientLimitDownEnabled;
            resourceInputs["clientLimitUp"] = state?.clientLimitUp;
            resourceInputs["clientLimitUpEnabled"] = state?.clientLimitUpEnabled;
            resourceInputs["coaServers"] = state?.coaServers;
            resourceInputs["disable11ax"] = state?.disable11ax;
            resourceInputs["disable11be"] = state?.disable11be;
            resourceInputs["disableHtVhtRates"] = state?.disableHtVhtRates;
            resourceInputs["disableUapsd"] = state?.disableUapsd;
            resourceInputs["disableV1RoamNotify"] = state?.disableV1RoamNotify;
            resourceInputs["disableV2RoamNotify"] = state?.disableV2RoamNotify;
            resourceInputs["disableWhenGatewayUnreachable"] = state?.disableWhenGatewayUnreachable;
            resourceInputs["disableWhenMxtunnelDown"] = state?.disableWhenMxtunnelDown;
            resourceInputs["disableWmm"] = state?.disableWmm;
            resourceInputs["dnsServerRewrite"] = state?.dnsServerRewrite;
            resourceInputs["dtim"] = state?.dtim;
            resourceInputs["dynamicPsk"] = state?.dynamicPsk;
            resourceInputs["dynamicVlan"] = state?.dynamicVlan;
            resourceInputs["enableLocalKeycaching"] = state?.enableLocalKeycaching;
            resourceInputs["enableWirelessBridging"] = state?.enableWirelessBridging;
            resourceInputs["enableWirelessBridgingDhcpTracking"] = state?.enableWirelessBridgingDhcpTracking;
            resourceInputs["enabled"] = state?.enabled;
            resourceInputs["fastDot1xTimers"] = state?.fastDot1xTimers;
            resourceInputs["hideSsid"] = state?.hideSsid;
            resourceInputs["hostnameIe"] = state?.hostnameIe;
            resourceInputs["hotspot20"] = state?.hotspot20;
            resourceInputs["injectDhcpOption82"] = state?.injectDhcpOption82;
            resourceInputs["interface"] = state?.interface;
            resourceInputs["isolation"] = state?.isolation;
            resourceInputs["l2Isolation"] = state?.l2Isolation;
            resourceInputs["legacyOverds"] = state?.legacyOverds;
            resourceInputs["limitBcast"] = state?.limitBcast;
            resourceInputs["limitProbeResponse"] = state?.limitProbeResponse;
            resourceInputs["maxIdletime"] = state?.maxIdletime;
            resourceInputs["maxNumClients"] = state?.maxNumClients;
            resourceInputs["mistNac"] = state?.mistNac;
            resourceInputs["mspId"] = state?.mspId;
            resourceInputs["mxtunnelIds"] = state?.mxtunnelIds;
            resourceInputs["mxtunnelNames"] = state?.mxtunnelNames;
            resourceInputs["noStaticDns"] = state?.noStaticDns;
            resourceInputs["noStaticIp"] = state?.noStaticIp;
            resourceInputs["orgId"] = state?.orgId;
            resourceInputs["portal"] = state?.portal;
            resourceInputs["portalAllowedHostnames"] = state?.portalAllowedHostnames;
            resourceInputs["portalAllowedSubnets"] = state?.portalAllowedSubnets;
            resourceInputs["portalApiSecret"] = state?.portalApiSecret;
            resourceInputs["portalDeniedHostnames"] = state?.portalDeniedHostnames;
            resourceInputs["portalImage"] = state?.portalImage;
            resourceInputs["portalSsoUrl"] = state?.portalSsoUrl;
            resourceInputs["qos"] = state?.qos;
            resourceInputs["radsec"] = state?.radsec;
            resourceInputs["rateset"] = state?.rateset;
            resourceInputs["reconnectClientsWhenRoamingMxcluster"] = state?.reconnectClientsWhenRoamingMxcluster;
            resourceInputs["roamMode"] = state?.roamMode;
            resourceInputs["schedule"] = state?.schedule;
            resourceInputs["siteId"] = state?.siteId;
            resourceInputs["sleExcluded"] = state?.sleExcluded;
            resourceInputs["ssid"] = state?.ssid;
            resourceInputs["useEapolV1"] = state?.useEapolV1;
            resourceInputs["vlanEnabled"] = state?.vlanEnabled;
            resourceInputs["vlanId"] = state?.vlanId;
            resourceInputs["vlanIds"] = state?.vlanIds;
            resourceInputs["vlanPooling"] = state?.vlanPooling;
            resourceInputs["wlanLimitDown"] = state?.wlanLimitDown;
            resourceInputs["wlanLimitDownEnabled"] = state?.wlanLimitDownEnabled;
            resourceInputs["wlanLimitUp"] = state?.wlanLimitUp;
            resourceInputs["wlanLimitUpEnabled"] = state?.wlanLimitUpEnabled;
            resourceInputs["wxtagIds"] = state?.wxtagIds;
            resourceInputs["wxtunnelId"] = state?.wxtunnelId;
            resourceInputs["wxtunnelRemoteId"] = state?.wxtunnelRemoteId;
        } else {
            const args = argsOrState as WlanArgs | undefined;
            if (args?.siteId === undefined && !opts.urn) {
                throw new Error("Missing required property 'siteId'");
            }
            if (args?.ssid === undefined && !opts.urn) {
                throw new Error("Missing required property 'ssid'");
            }
            resourceInputs["acctImmediateUpdate"] = args?.acctImmediateUpdate;
            resourceInputs["acctInterimInterval"] = args?.acctInterimInterval;
            resourceInputs["acctServers"] = args?.acctServers;
            resourceInputs["airwatch"] = args?.airwatch;
            resourceInputs["allowIpv6Ndp"] = args?.allowIpv6Ndp;
            resourceInputs["allowMdns"] = args?.allowMdns;
            resourceInputs["allowSsdp"] = args?.allowSsdp;
            resourceInputs["apIds"] = args?.apIds;
            resourceInputs["appLimit"] = args?.appLimit;
            resourceInputs["appQos"] = args?.appQos;
            resourceInputs["applyTo"] = args?.applyTo;
            resourceInputs["arpFilter"] = args?.arpFilter;
            resourceInputs["auth"] = args?.auth;
            resourceInputs["authServerSelection"] = args?.authServerSelection;
            resourceInputs["authServers"] = args?.authServers;
            resourceInputs["authServersNasId"] = args?.authServersNasId;
            resourceInputs["authServersNasIp"] = args?.authServersNasIp;
            resourceInputs["authServersRetries"] = args?.authServersRetries;
            resourceInputs["authServersTimeout"] = args?.authServersTimeout;
            resourceInputs["bandSteer"] = args?.bandSteer;
            resourceInputs["bandSteerForceBand5"] = args?.bandSteerForceBand5;
            resourceInputs["bands"] = args?.bands;
            resourceInputs["blockBlacklistClients"] = args?.blockBlacklistClients;
            resourceInputs["bonjour"] = args?.bonjour;
            resourceInputs["ciscoCwa"] = args?.ciscoCwa;
            resourceInputs["clientLimitDown"] = args?.clientLimitDown;
            resourceInputs["clientLimitDownEnabled"] = args?.clientLimitDownEnabled;
            resourceInputs["clientLimitUp"] = args?.clientLimitUp;
            resourceInputs["clientLimitUpEnabled"] = args?.clientLimitUpEnabled;
            resourceInputs["coaServers"] = args?.coaServers;
            resourceInputs["disable11ax"] = args?.disable11ax;
            resourceInputs["disable11be"] = args?.disable11be;
            resourceInputs["disableHtVhtRates"] = args?.disableHtVhtRates;
            resourceInputs["disableUapsd"] = args?.disableUapsd;
            resourceInputs["disableV1RoamNotify"] = args?.disableV1RoamNotify;
            resourceInputs["disableV2RoamNotify"] = args?.disableV2RoamNotify;
            resourceInputs["disableWhenGatewayUnreachable"] = args?.disableWhenGatewayUnreachable;
            resourceInputs["disableWhenMxtunnelDown"] = args?.disableWhenMxtunnelDown;
            resourceInputs["disableWmm"] = args?.disableWmm;
            resourceInputs["dnsServerRewrite"] = args?.dnsServerRewrite;
            resourceInputs["dtim"] = args?.dtim;
            resourceInputs["dynamicPsk"] = args?.dynamicPsk;
            resourceInputs["dynamicVlan"] = args?.dynamicVlan;
            resourceInputs["enableLocalKeycaching"] = args?.enableLocalKeycaching;
            resourceInputs["enableWirelessBridging"] = args?.enableWirelessBridging;
            resourceInputs["enableWirelessBridgingDhcpTracking"] = args?.enableWirelessBridgingDhcpTracking;
            resourceInputs["enabled"] = args?.enabled;
            resourceInputs["fastDot1xTimers"] = args?.fastDot1xTimers;
            resourceInputs["hideSsid"] = args?.hideSsid;
            resourceInputs["hostnameIe"] = args?.hostnameIe;
            resourceInputs["hotspot20"] = args?.hotspot20;
            resourceInputs["injectDhcpOption82"] = args?.injectDhcpOption82;
            resourceInputs["interface"] = args?.interface;
            resourceInputs["isolation"] = args?.isolation;
            resourceInputs["l2Isolation"] = args?.l2Isolation;
            resourceInputs["legacyOverds"] = args?.legacyOverds;
            resourceInputs["limitBcast"] = args?.limitBcast;
            resourceInputs["limitProbeResponse"] = args?.limitProbeResponse;
            resourceInputs["maxIdletime"] = args?.maxIdletime;
            resourceInputs["maxNumClients"] = args?.maxNumClients;
            resourceInputs["mistNac"] = args?.mistNac;
            resourceInputs["mxtunnelIds"] = args?.mxtunnelIds;
            resourceInputs["mxtunnelNames"] = args?.mxtunnelNames;
            resourceInputs["noStaticDns"] = args?.noStaticDns;
            resourceInputs["noStaticIp"] = args?.noStaticIp;
            resourceInputs["portal"] = args?.portal;
            resourceInputs["portalAllowedHostnames"] = args?.portalAllowedHostnames;
            resourceInputs["portalAllowedSubnets"] = args?.portalAllowedSubnets;
            resourceInputs["portalDeniedHostnames"] = args?.portalDeniedHostnames;
            resourceInputs["qos"] = args?.qos;
            resourceInputs["radsec"] = args?.radsec;
            resourceInputs["rateset"] = args?.rateset;
            resourceInputs["reconnectClientsWhenRoamingMxcluster"] = args?.reconnectClientsWhenRoamingMxcluster;
            resourceInputs["roamMode"] = args?.roamMode;
            resourceInputs["schedule"] = args?.schedule;
            resourceInputs["siteId"] = args?.siteId;
            resourceInputs["sleExcluded"] = args?.sleExcluded;
            resourceInputs["ssid"] = args?.ssid;
            resourceInputs["useEapolV1"] = args?.useEapolV1;
            resourceInputs["vlanEnabled"] = args?.vlanEnabled;
            resourceInputs["vlanId"] = args?.vlanId;
            resourceInputs["vlanIds"] = args?.vlanIds;
            resourceInputs["vlanPooling"] = args?.vlanPooling;
            resourceInputs["wlanLimitDown"] = args?.wlanLimitDown;
            resourceInputs["wlanLimitDownEnabled"] = args?.wlanLimitDownEnabled;
            resourceInputs["wlanLimitUp"] = args?.wlanLimitUp;
            resourceInputs["wlanLimitUpEnabled"] = args?.wlanLimitUpEnabled;
            resourceInputs["wxtagIds"] = args?.wxtagIds;
            resourceInputs["wxtunnelId"] = args?.wxtunnelId;
            resourceInputs["wxtunnelRemoteId"] = args?.wxtunnelRemoteId;
            resourceInputs["mspId"] = undefined /*out*/;
            resourceInputs["orgId"] = undefined /*out*/;
            resourceInputs["portalApiSecret"] = undefined /*out*/;
            resourceInputs["portalImage"] = undefined /*out*/;
            resourceInputs["portalSsoUrl"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Wlan.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Wlan resources.
 */
export interface WlanState {
    /**
     * Enable coa-immediate-update and address-change-immediate-update on the access profile.
     */
    acctImmediateUpdate?: pulumi.Input<boolean>;
    /**
     * How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     */
    acctInterimInterval?: pulumi.Input<number>;
    /**
     * List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     */
    acctServers?: pulumi.Input<pulumi.Input<inputs.site.WlanAcctServer>[]>;
    /**
     * Airwatch wlan settings
     */
    airwatch?: pulumi.Input<inputs.site.WlanAirwatch>;
    /**
     * Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     */
    allowIpv6Ndp?: pulumi.Input<boolean>;
    /**
     * Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     */
    allowMdns?: pulumi.Input<boolean>;
    /**
     * Only applicable when `limitBcast`==`true`, which allows SSDP
     */
    allowSsdp?: pulumi.Input<boolean>;
    /**
     * List of device ids
     */
    apIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Bandwidth limiting for apps (applies to up/down)
     */
    appLimit?: pulumi.Input<inputs.site.WlanAppLimit>;
    /**
     * APp qos wlan settings
     */
    appQos?: pulumi.Input<inputs.site.WlanAppQos>;
    /**
     * enum: `aps`, `site`, `wxtags`
     */
    applyTo?: pulumi.Input<string>;
    /**
     * Whether to enable smart arp filter
     */
    arpFilter?: pulumi.Input<boolean>;
    /**
     * Authentication wlan settings
     */
    auth?: pulumi.Input<inputs.site.WlanAuth>;
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     */
    authServerSelection?: pulumi.Input<string>;
    /**
     * List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     */
    authServers?: pulumi.Input<pulumi.Input<inputs.site.WlanAuthServer>[]>;
    /**
     * Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     */
    authServersNasId?: pulumi.Input<string>;
    /**
     * Optional, NAS-IP-ADDRESS to use
     */
    authServersNasIp?: pulumi.Input<string>;
    /**
     * Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default value to 3.
     */
    authServersRetries?: pulumi.Input<number>;
    /**
     * Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting authServersTimeout and is set to default value of 10.
     */
    authServersTimeout?: pulumi.Input<number>;
    /**
     * Whether to enable band_steering, this works only when band==both
     */
    bandSteer?: pulumi.Input<boolean>;
    /**
     * Force dualBand capable client to connect to 5G
     */
    bandSteerForceBand5?: pulumi.Input<boolean>;
    /**
     * list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     */
    bands?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to block the clients in the blacklist (up to first 256 macs)
     */
    blockBlacklistClients?: pulumi.Input<boolean>;
    /**
     * Bonjour gateway wlan settings
     */
    bonjour?: pulumi.Input<inputs.site.WlanBonjour>;
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     */
    ciscoCwa?: pulumi.Input<inputs.site.WlanCiscoCwa>;
    clientLimitDown?: pulumi.Input<string>;
    /**
     * If downlink limiting per-client is enabled
     */
    clientLimitDownEnabled?: pulumi.Input<boolean>;
    clientLimitUp?: pulumi.Input<string>;
    /**
     * If uplink limiting per-client is enabled
     */
    clientLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * List of COA (change of authorization) servers, optional
     */
    coaServers?: pulumi.Input<pulumi.Input<inputs.site.WlanCoaServer>[]>;
    /**
     * Some old WLAN drivers may not be compatible
     */
    disable11ax?: pulumi.Input<boolean>;
    /**
     * To disable Wi-Fi 7 EHT IEs
     */
    disable11be?: pulumi.Input<boolean>;
    /**
     * To disable ht or vht rates
     */
    disableHtVhtRates?: pulumi.Input<boolean>;
    /**
     * Whether to disable U-APSD
     */
    disableUapsd?: pulumi.Input<boolean>;
    /**
     * Disable sending v2 roam notification messages
     */
    disableV1RoamNotify?: pulumi.Input<boolean>;
    /**
     * Disable sending v2 roam notification messages
     */
    disableV2RoamNotify?: pulumi.Input<boolean>;
    /**
     * When any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     */
    disableWhenGatewayUnreachable?: pulumi.Input<boolean>;
    disableWhenMxtunnelDown?: pulumi.Input<boolean>;
    /**
     * Whether to disable WMM
     */
    disableWmm?: pulumi.Input<boolean>;
    /**
     * For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     */
    dnsServerRewrite?: pulumi.Input<inputs.site.WlanDnsServerRewrite>;
    dtim?: pulumi.Input<number>;
    /**
     * For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `authServers` is required
     *   * PSK will come from cloud WLC if source is cloudPsks
     *   * defaultPsk will be used if cloud WLC is not available
     *   * `multiPskOnly` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     */
    dynamicPsk?: pulumi.Input<inputs.site.WlanDynamicPsk>;
    /**
     * For 802.1x
     */
    dynamicVlan?: pulumi.Input<inputs.site.WlanDynamicVlan>;
    /**
     * Enable AP-AP keycaching via multicast
     */
    enableLocalKeycaching?: pulumi.Input<boolean>;
    /**
     * By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
     */
    enableWirelessBridging?: pulumi.Input<boolean>;
    /**
     * If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response packets to be forwarded to wireless
     */
    enableWirelessBridgingDhcpTracking?: pulumi.Input<boolean>;
    /**
     * If this wlan is enabled
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     */
    fastDot1xTimers?: pulumi.Input<boolean>;
    /**
     * Whether to hide SSID in beacon
     */
    hideSsid?: pulumi.Input<boolean>;
    /**
     * Include hostname inside IE in AP beacons / probe responses
     */
    hostnameIe?: pulumi.Input<boolean>;
    /**
     * Hostspot 2.0 wlan settings
     */
    hotspot20?: pulumi.Input<inputs.site.WlanHotspot20>;
    injectDhcpOption82?: pulumi.Input<inputs.site.WlanInjectDhcpOption82>;
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     */
    interface?: pulumi.Input<string>;
    /**
     * Whether to stop clients to talk to each other
     */
    isolation?: pulumi.Input<boolean>;
    /**
     * If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     */
    l2Isolation?: pulumi.Input<boolean>;
    /**
     * Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     */
    legacyOverds?: pulumi.Input<boolean>;
    /**
     * Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     */
    limitBcast?: pulumi.Input<boolean>;
    /**
     * Limit probe response base on some heuristic rules
     */
    limitProbeResponse?: pulumi.Input<boolean>;
    /**
     * Max idle time in seconds
     */
    maxIdletime?: pulumi.Input<number>;
    /**
     * Maximum number of client connected to the SSID. `0` means unlimited
     */
    maxNumClients?: pulumi.Input<number>;
    mistNac?: pulumi.Input<inputs.site.WlanMistNac>;
    mspId?: pulumi.Input<string>;
    /**
     * When `interface`=`mxtunnel`, id of the Mist Tunnel
     */
    mxtunnelIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     */
    mxtunnelNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to only allow client to use DNS that we’ve learned from DHCP response
     */
    noStaticDns?: pulumi.Input<boolean>;
    /**
     * Whether to only allow client that we’ve learned from DHCP exchange to talk
     */
    noStaticIp?: pulumi.Input<boolean>;
    orgId?: pulumi.Input<string>;
    /**
     * Portal wlan settings
     */
    portal?: pulumi.Input<inputs.site.WlanPortal>;
    /**
     * List of hostnames without http(s):// (matched by substring)
     */
    portalAllowedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of CIDRs
     */
    portalAllowedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * API secret (auto-generated) that can be used to sign guest authorization requests, only generated when auth is set to `external`
     */
    portalApiSecret?: pulumi.Input<string>;
    /**
     * List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     */
    portalDeniedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Url of portal background image
     */
    portalImage?: pulumi.Input<string>;
    /**
     * URL used in the SSO process, auto-generated when auth is set to `sso`
     */
    portalSsoUrl?: pulumi.Input<string>;
    qos?: pulumi.Input<inputs.site.WlanQos>;
    /**
     * RadSec settings
     */
    radsec?: pulumi.Input<inputs.site.WlanRadsec>;
    /**
     * Property key is the RF band. enum: `24`, `5`, `6`
     */
    rateset?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.WlanRateset>}>;
    /**
     * When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
     */
    reconnectClientsWhenRoamingMxcluster?: pulumi.Input<boolean>;
    /**
     * enum: `11r`, `OKC`, `NONE`
     */
    roamMode?: pulumi.Input<string>;
    /**
     * WLAN operating schedule, default is disabled
     */
    schedule?: pulumi.Input<inputs.site.WlanSchedule>;
    siteId?: pulumi.Input<string>;
    /**
     * Whether to exclude this WLAN from SLE metrics
     */
    sleExcluded?: pulumi.Input<boolean>;
    /**
     * Name of the SSID
     */
    ssid?: pulumi.Input<string>;
    /**
     * If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     */
    useEapolV1?: pulumi.Input<boolean>;
    /**
     * If vlan tagging is enabled
     */
    vlanEnabled?: pulumi.Input<boolean>;
    vlanId?: pulumi.Input<string>;
    /**
     * if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     */
    vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     */
    vlanPooling?: pulumi.Input<boolean>;
    wlanLimitDown?: pulumi.Input<string>;
    /**
     * If downlink limiting for whole wlan is enabled
     */
    wlanLimitDownEnabled?: pulumi.Input<boolean>;
    wlanLimitUp?: pulumi.Input<string>;
    /**
     * If uplink limiting for whole wlan is enabled
     */
    wlanLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * List of wxtag_ids
     */
    wxtagIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     */
    wxtunnelId?: pulumi.Input<string>;
    /**
     * When `interface`=`wxtunnel`, remote tunnel identifier
     */
    wxtunnelRemoteId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Wlan resource.
 */
export interface WlanArgs {
    /**
     * Enable coa-immediate-update and address-change-immediate-update on the access profile.
     */
    acctImmediateUpdate?: pulumi.Input<boolean>;
    /**
     * How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     */
    acctInterimInterval?: pulumi.Input<number>;
    /**
     * List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     */
    acctServers?: pulumi.Input<pulumi.Input<inputs.site.WlanAcctServer>[]>;
    /**
     * Airwatch wlan settings
     */
    airwatch?: pulumi.Input<inputs.site.WlanAirwatch>;
    /**
     * Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     */
    allowIpv6Ndp?: pulumi.Input<boolean>;
    /**
     * Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     */
    allowMdns?: pulumi.Input<boolean>;
    /**
     * Only applicable when `limitBcast`==`true`, which allows SSDP
     */
    allowSsdp?: pulumi.Input<boolean>;
    /**
     * List of device ids
     */
    apIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Bandwidth limiting for apps (applies to up/down)
     */
    appLimit?: pulumi.Input<inputs.site.WlanAppLimit>;
    /**
     * APp qos wlan settings
     */
    appQos?: pulumi.Input<inputs.site.WlanAppQos>;
    /**
     * enum: `aps`, `site`, `wxtags`
     */
    applyTo?: pulumi.Input<string>;
    /**
     * Whether to enable smart arp filter
     */
    arpFilter?: pulumi.Input<boolean>;
    /**
     * Authentication wlan settings
     */
    auth?: pulumi.Input<inputs.site.WlanAuth>;
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     */
    authServerSelection?: pulumi.Input<string>;
    /**
     * List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     */
    authServers?: pulumi.Input<pulumi.Input<inputs.site.WlanAuthServer>[]>;
    /**
     * Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     */
    authServersNasId?: pulumi.Input<string>;
    /**
     * Optional, NAS-IP-ADDRESS to use
     */
    authServersNasIp?: pulumi.Input<string>;
    /**
     * Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default value to 3.
     */
    authServersRetries?: pulumi.Input<number>;
    /**
     * Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting authServersTimeout and is set to default value of 10.
     */
    authServersTimeout?: pulumi.Input<number>;
    /**
     * Whether to enable band_steering, this works only when band==both
     */
    bandSteer?: pulumi.Input<boolean>;
    /**
     * Force dualBand capable client to connect to 5G
     */
    bandSteerForceBand5?: pulumi.Input<boolean>;
    /**
     * list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     */
    bands?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to block the clients in the blacklist (up to first 256 macs)
     */
    blockBlacklistClients?: pulumi.Input<boolean>;
    /**
     * Bonjour gateway wlan settings
     */
    bonjour?: pulumi.Input<inputs.site.WlanBonjour>;
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     */
    ciscoCwa?: pulumi.Input<inputs.site.WlanCiscoCwa>;
    clientLimitDown?: pulumi.Input<string>;
    /**
     * If downlink limiting per-client is enabled
     */
    clientLimitDownEnabled?: pulumi.Input<boolean>;
    clientLimitUp?: pulumi.Input<string>;
    /**
     * If uplink limiting per-client is enabled
     */
    clientLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * List of COA (change of authorization) servers, optional
     */
    coaServers?: pulumi.Input<pulumi.Input<inputs.site.WlanCoaServer>[]>;
    /**
     * Some old WLAN drivers may not be compatible
     */
    disable11ax?: pulumi.Input<boolean>;
    /**
     * To disable Wi-Fi 7 EHT IEs
     */
    disable11be?: pulumi.Input<boolean>;
    /**
     * To disable ht or vht rates
     */
    disableHtVhtRates?: pulumi.Input<boolean>;
    /**
     * Whether to disable U-APSD
     */
    disableUapsd?: pulumi.Input<boolean>;
    /**
     * Disable sending v2 roam notification messages
     */
    disableV1RoamNotify?: pulumi.Input<boolean>;
    /**
     * Disable sending v2 roam notification messages
     */
    disableV2RoamNotify?: pulumi.Input<boolean>;
    /**
     * When any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     */
    disableWhenGatewayUnreachable?: pulumi.Input<boolean>;
    disableWhenMxtunnelDown?: pulumi.Input<boolean>;
    /**
     * Whether to disable WMM
     */
    disableWmm?: pulumi.Input<boolean>;
    /**
     * For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     */
    dnsServerRewrite?: pulumi.Input<inputs.site.WlanDnsServerRewrite>;
    dtim?: pulumi.Input<number>;
    /**
     * For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `authServers` is required
     *   * PSK will come from cloud WLC if source is cloudPsks
     *   * defaultPsk will be used if cloud WLC is not available
     *   * `multiPskOnly` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     */
    dynamicPsk?: pulumi.Input<inputs.site.WlanDynamicPsk>;
    /**
     * For 802.1x
     */
    dynamicVlan?: pulumi.Input<inputs.site.WlanDynamicVlan>;
    /**
     * Enable AP-AP keycaching via multicast
     */
    enableLocalKeycaching?: pulumi.Input<boolean>;
    /**
     * By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
     */
    enableWirelessBridging?: pulumi.Input<boolean>;
    /**
     * If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response packets to be forwarded to wireless
     */
    enableWirelessBridgingDhcpTracking?: pulumi.Input<boolean>;
    /**
     * If this wlan is enabled
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     */
    fastDot1xTimers?: pulumi.Input<boolean>;
    /**
     * Whether to hide SSID in beacon
     */
    hideSsid?: pulumi.Input<boolean>;
    /**
     * Include hostname inside IE in AP beacons / probe responses
     */
    hostnameIe?: pulumi.Input<boolean>;
    /**
     * Hostspot 2.0 wlan settings
     */
    hotspot20?: pulumi.Input<inputs.site.WlanHotspot20>;
    injectDhcpOption82?: pulumi.Input<inputs.site.WlanInjectDhcpOption82>;
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     */
    interface?: pulumi.Input<string>;
    /**
     * Whether to stop clients to talk to each other
     */
    isolation?: pulumi.Input<boolean>;
    /**
     * If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     */
    l2Isolation?: pulumi.Input<boolean>;
    /**
     * Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     */
    legacyOverds?: pulumi.Input<boolean>;
    /**
     * Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     */
    limitBcast?: pulumi.Input<boolean>;
    /**
     * Limit probe response base on some heuristic rules
     */
    limitProbeResponse?: pulumi.Input<boolean>;
    /**
     * Max idle time in seconds
     */
    maxIdletime?: pulumi.Input<number>;
    /**
     * Maximum number of client connected to the SSID. `0` means unlimited
     */
    maxNumClients?: pulumi.Input<number>;
    mistNac?: pulumi.Input<inputs.site.WlanMistNac>;
    /**
     * When `interface`=`mxtunnel`, id of the Mist Tunnel
     */
    mxtunnelIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     */
    mxtunnelNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to only allow client to use DNS that we’ve learned from DHCP response
     */
    noStaticDns?: pulumi.Input<boolean>;
    /**
     * Whether to only allow client that we’ve learned from DHCP exchange to talk
     */
    noStaticIp?: pulumi.Input<boolean>;
    /**
     * Portal wlan settings
     */
    portal?: pulumi.Input<inputs.site.WlanPortal>;
    /**
     * List of hostnames without http(s):// (matched by substring)
     */
    portalAllowedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of CIDRs
     */
    portalAllowedSubnets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     */
    portalDeniedHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    qos?: pulumi.Input<inputs.site.WlanQos>;
    /**
     * RadSec settings
     */
    radsec?: pulumi.Input<inputs.site.WlanRadsec>;
    /**
     * Property key is the RF band. enum: `24`, `5`, `6`
     */
    rateset?: pulumi.Input<{[key: string]: pulumi.Input<inputs.site.WlanRateset>}>;
    /**
     * When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
     */
    reconnectClientsWhenRoamingMxcluster?: pulumi.Input<boolean>;
    /**
     * enum: `11r`, `OKC`, `NONE`
     */
    roamMode?: pulumi.Input<string>;
    /**
     * WLAN operating schedule, default is disabled
     */
    schedule?: pulumi.Input<inputs.site.WlanSchedule>;
    siteId: pulumi.Input<string>;
    /**
     * Whether to exclude this WLAN from SLE metrics
     */
    sleExcluded?: pulumi.Input<boolean>;
    /**
     * Name of the SSID
     */
    ssid: pulumi.Input<string>;
    /**
     * If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     */
    useEapolV1?: pulumi.Input<boolean>;
    /**
     * If vlan tagging is enabled
     */
    vlanEnabled?: pulumi.Input<boolean>;
    vlanId?: pulumi.Input<string>;
    /**
     * if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     */
    vlanIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     */
    vlanPooling?: pulumi.Input<boolean>;
    wlanLimitDown?: pulumi.Input<string>;
    /**
     * If downlink limiting for whole wlan is enabled
     */
    wlanLimitDownEnabled?: pulumi.Input<boolean>;
    wlanLimitUp?: pulumi.Input<string>;
    /**
     * If uplink limiting for whole wlan is enabled
     */
    wlanLimitUpEnabled?: pulumi.Input<boolean>;
    /**
     * List of wxtag_ids
     */
    wxtagIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     */
    wxtunnelId?: pulumi.Input<string>;
    /**
     * When `interface`=`wxtunnel`, remote tunnel identifier
     */
    wxtunnelRemoteId?: pulumi.Input<string>;
}
