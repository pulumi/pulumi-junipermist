// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package site

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-junipermist/sdk/go/junipermist/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource manages the Site Wlans.
// The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-junipermist/sdk/go/junipermist/site"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := site.NewWlan(ctx, "wlan_one", &site.WlanArgs{
//				Ssid:   pulumi.String("wlan_one"),
//				SiteId: pulumi.Any(terraformTest.Id),
//				Bands: pulumi.StringArray{
//					pulumi.String("5"),
//					pulumi.String("6"),
//				},
//				VlanEnabled:     pulumi.Bool(true),
//				VlanId:          pulumi.String("143"),
//				WlanLimitUp:     pulumi.Int(10000),
//				WlanLimitDown:   pulumi.Int(20000),
//				ClientLimitUp:   pulumi.Int(512),
//				ClientLimitDown: pulumi.Int(1000),
//				Auth: &site.WlanAuthArgs{
//					Type: pulumi.String("psk"),
//					Psk:  pulumi.String("secretpsk"),
//				},
//				Interface: pulumi.String("all"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Using `pulumi import`, import `mist_site_wlan` with:
//
// Site WLAN can be imported by specifying the site_id and the wlan_id
//
// ```sh
// $ pulumi import junipermist:site/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
// ```
type Wlan struct {
	pulumi.CustomResourceState

	// Enable coa-immediate-update and address-change-immediate-update on the access profile.
	AcctImmediateUpdate pulumi.BoolOutput `pulumi:"acctImmediateUpdate"`
	// How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
	// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
	// when enabled
	AcctInterimInterval pulumi.IntOutput `pulumi:"acctInterimInterval"`
	// List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
	AcctServers WlanAcctServerArrayOutput `pulumi:"acctServers"`
	// Airwatch wlan settings
	Airwatch WlanAirwatchOutput `pulumi:"airwatch"`
	// Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
	AllowIpv6Ndp pulumi.BoolOutput `pulumi:"allowIpv6Ndp"`
	// Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
	AllowMdns pulumi.BoolOutput `pulumi:"allowMdns"`
	// Only applicable when `limitBcast`==`true`, which allows SSDP
	AllowSsdp pulumi.BoolOutput `pulumi:"allowSsdp"`
	// List of device ids
	ApIds pulumi.StringArrayOutput `pulumi:"apIds"`
	// Bandwidth limiting for apps (applies to up/down)
	AppLimit WlanAppLimitOutput `pulumi:"appLimit"`
	// APp qos wlan settings
	AppQos WlanAppQosOutput `pulumi:"appQos"`
	// enum: `aps`, `site`, `wxtags`
	ApplyTo pulumi.StringOutput `pulumi:"applyTo"`
	// Whether to enable smart arp filter
	ArpFilter pulumi.BoolOutput `pulumi:"arpFilter"`
	// Authentication wlan settings
	Auth WlanAuthPtrOutput `pulumi:"auth"`
	// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
	AuthServerSelection pulumi.StringOutput `pulumi:"authServerSelection"`
	// List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
	// is treated as primary
	AuthServers WlanAuthServerArrayOutput `pulumi:"authServers"`
	// Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
	AuthServersNasId pulumi.StringOutput `pulumi:"authServersNasId"`
	// Optional, NAS-IP-ADDRESS to use
	AuthServersNasIp pulumi.StringOutput `pulumi:"authServersNasIp"`
	// Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’ are set
	// to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default
	// value to 3.
	AuthServersRetries pulumi.IntOutput `pulumi:"authServersRetries"`
	// Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’ and
	// ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
	// setting authServersTimeout and is set to default value of 10.
	AuthServersTimeout pulumi.IntOutput `pulumi:"authServersTimeout"`
	// Whether to enable band_steering, this works only when band==both
	BandSteer pulumi.BoolOutput `pulumi:"bandSteer"`
	// Force dualBand capable client to connect to 5G
	BandSteerForceBand5 pulumi.BoolOutput `pulumi:"bandSteerForceBand5"`
	// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
	Bands pulumi.StringArrayOutput `pulumi:"bands"`
	// Whether to block the clients in the blacklist (up to first 256 macs)
	BlockBlacklistClients pulumi.BoolOutput `pulumi:"blockBlacklistClients"`
	// Bonjour gateway wlan settings
	Bonjour WlanBonjourOutput `pulumi:"bonjour"`
	// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
	// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
	CiscoCwa WlanCiscoCwaOutput `pulumi:"ciscoCwa"`
	// In kbps
	ClientLimitDown pulumi.IntOutput `pulumi:"clientLimitDown"`
	// If downlink limiting per-client is enabled
	ClientLimitDownEnabled pulumi.BoolOutput `pulumi:"clientLimitDownEnabled"`
	// In kbps
	ClientLimitUp pulumi.IntOutput `pulumi:"clientLimitUp"`
	// If uplink limiting per-client is enabled
	ClientLimitUpEnabled pulumi.BoolOutput `pulumi:"clientLimitUpEnabled"`
	// List of COA (change of authorization) servers, optional
	CoaServers WlanCoaServerArrayOutput `pulumi:"coaServers"`
	// Some old WLAN drivers may not be compatible
	Disable11ax pulumi.BoolOutput `pulumi:"disable11ax"`
	// To disable Wi-Fi 7 EHT IEs
	Disable11be pulumi.BoolOutput `pulumi:"disable11be"`
	// To disable ht or vht rates
	DisableHtVhtRates pulumi.BoolOutput `pulumi:"disableHtVhtRates"`
	// Whether to disable U-APSD
	DisableUapsd pulumi.BoolOutput `pulumi:"disableUapsd"`
	// Disable sending v2 roam notification messages
	DisableV1RoamNotify pulumi.BoolOutput `pulumi:"disableV1RoamNotify"`
	// Disable sending v2 roam notification messages
	DisableV2RoamNotify pulumi.BoolOutput `pulumi:"disableV2RoamNotify"`
	// When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
	// reach default gateway
	DisableWhenGatewayUnreachable pulumi.BoolPtrOutput `pulumi:"disableWhenGatewayUnreachable"`
	DisableWhenMxtunnelDown       pulumi.BoolPtrOutput `pulumi:"disableWhenMxtunnelDown"`
	// Whether to disable WMM
	DisableWmm pulumi.BoolOutput `pulumi:"disableWmm"`
	// For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
	DnsServerRewrite WlanDnsServerRewriteOutput `pulumi:"dnsServerRewrite"`
	Dtim             pulumi.IntOutput           `pulumi:"dtim"`
	// For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
	// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
	// AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
	// Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
	// used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
	// wpa3 support on the roadmap)
	DynamicPsk WlanDynamicPskPtrOutput `pulumi:"dynamicPsk"`
	// For 802.1x
	DynamicVlan WlanDynamicVlanPtrOutput `pulumi:"dynamicVlan"`
	// Enable AP-AP keycaching via multicast
	EnableLocalKeycaching pulumi.BoolOutput `pulumi:"enableLocalKeycaching"`
	// By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
	// client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
	EnableWirelessBridging pulumi.BoolOutput `pulumi:"enableWirelessBridging"`
	// If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
	// packets to be forwarded to wireless
	EnableWirelessBridgingDhcpTracking pulumi.BoolOutput `pulumi:"enableWirelessBridgingDhcpTracking"`
	// If this wlan is enabled
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
	// ‘auth_server_retries’ .
	FastDot1xTimers pulumi.BoolOutput `pulumi:"fastDot1xTimers"`
	// Whether to hide SSID in beacon
	HideSsid pulumi.BoolOutput `pulumi:"hideSsid"`
	// Include hostname inside IE in AP beacons / probe responses
	HostnameIe pulumi.BoolOutput `pulumi:"hostnameIe"`
	// Hostspot 2.0 wlan settings
	Hotspot20          WlanHotspot20Output             `pulumi:"hotspot20"`
	InjectDhcpOption82 WlanInjectDhcpOption82PtrOutput `pulumi:"injectDhcpOption82"`
	// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
	Interface pulumi.StringOutput `pulumi:"interface"`
	// Whether to stop clients to talk to each other
	Isolation pulumi.BoolOutput `pulumi:"isolation"`
	// If isolation is enabled, whether to deny clients to talk to L2 on the LAN
	L2Isolation pulumi.BoolOutput `pulumi:"l2Isolation"`
	// Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
	// Enabling this will cause problem for iOS devices.
	LegacyOverds pulumi.BoolOutput `pulumi:"legacyOverds"`
	// Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
	LimitBcast pulumi.BoolOutput `pulumi:"limitBcast"`
	// Limit probe response base on some heuristic rules
	LimitProbeResponse pulumi.BoolOutput `pulumi:"limitProbeResponse"`
	// Max idle time in seconds
	MaxIdletime pulumi.IntOutput `pulumi:"maxIdletime"`
	// Maximum number of client connected to the SSID. `0` means unlimited
	MaxNumClients pulumi.IntOutput    `pulumi:"maxNumClients"`
	MistNac       WlanMistNacOutput   `pulumi:"mistNac"`
	MspId         pulumi.StringOutput `pulumi:"mspId"`
	// When `interface`=`mxtunnel`, id of the Mist Tunnel
	MxtunnelIds pulumi.StringArrayOutput `pulumi:"mxtunnelIds"`
	// When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
	MxtunnelNames pulumi.StringArrayOutput `pulumi:"mxtunnelNames"`
	// Whether to only allow client to use DNS that we’ve learned from DHCP response
	NoStaticDns pulumi.BoolOutput `pulumi:"noStaticDns"`
	// Whether to only allow client that we’ve learned from DHCP exchange to talk
	NoStaticIp pulumi.BoolOutput   `pulumi:"noStaticIp"`
	OrgId      pulumi.StringOutput `pulumi:"orgId"`
	// Portal wlan settings
	Portal WlanPortalOutput `pulumi:"portal"`
	// List of hostnames without http(s):// (matched by substring)
	PortalAllowedHostnames pulumi.StringArrayOutput `pulumi:"portalAllowedHostnames"`
	// List of CIDRs
	PortalAllowedSubnets pulumi.StringArrayOutput `pulumi:"portalAllowedSubnets"`
	// APi secret (auto-generated) that can be used to sign guest authorization requests
	PortalApiSecret pulumi.StringOutput `pulumi:"portalApiSecret"`
	// List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
	PortalDeniedHostnames pulumi.StringArrayOutput `pulumi:"portalDeniedHostnames"`
	// Url of portal background image
	PortalImage  pulumi.StringOutput `pulumi:"portalImage"`
	PortalSsoUrl pulumi.StringOutput `pulumi:"portalSsoUrl"`
	Qos          WlanQosOutput       `pulumi:"qos"`
	// RadSec settings
	Radsec WlanRadsecOutput `pulumi:"radsec"`
	// Property key is the RF band. enum: `24`, `5`, `6`
	Rateset WlanRatesetMapOutput `pulumi:"rateset"`
	// When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
	ReconnectClientsWhenRoamingMxcluster pulumi.BoolPtrOutput `pulumi:"reconnectClientsWhenRoamingMxcluster"`
	// enum: `11r`, `OKC`, `NONE`
	RoamMode pulumi.StringOutput `pulumi:"roamMode"`
	// WLAN operating schedule, default is disabled
	Schedule WlanScheduleOutput  `pulumi:"schedule"`
	SiteId   pulumi.StringOutput `pulumi:"siteId"`
	// Whether to exclude this WLAN from SLE metrics
	SleExcluded pulumi.BoolOutput `pulumi:"sleExcluded"`
	// Name of the SSID
	Ssid pulumi.StringOutput `pulumi:"ssid"`
	// If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
	UseEapolV1 pulumi.BoolOutput `pulumi:"useEapolV1"`
	// If vlan tagging is enabled
	VlanEnabled pulumi.BoolOutput      `pulumi:"vlanEnabled"`
	VlanId      pulumi.StringPtrOutput `pulumi:"vlanId"`
	// if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
	VlanIds pulumi.StringArrayOutput `pulumi:"vlanIds"`
	// Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
	// deterministic algorithm
	VlanPooling pulumi.BoolOutput `pulumi:"vlanPooling"`
	// In kbps
	WlanLimitDown pulumi.IntOutput `pulumi:"wlanLimitDown"`
	// If downlink limiting for whole wlan is enabled
	WlanLimitDownEnabled pulumi.BoolOutput `pulumi:"wlanLimitDownEnabled"`
	// In kbps
	WlanLimitUp pulumi.IntOutput `pulumi:"wlanLimitUp"`
	// If uplink limiting for whole wlan is enabled
	WlanLimitUpEnabled pulumi.BoolOutput `pulumi:"wlanLimitUpEnabled"`
	// List of wxtag_ids
	WxtagIds pulumi.StringArrayOutput `pulumi:"wxtagIds"`
	// When `interface`=`wxtunnel`, id of the WXLAN Tunnel
	WxtunnelId pulumi.StringOutput `pulumi:"wxtunnelId"`
	// When `interface`=`wxtunnel`, remote tunnel identifier
	WxtunnelRemoteId pulumi.StringOutput `pulumi:"wxtunnelRemoteId"`
}

// NewWlan registers a new resource with the given unique name, arguments, and options.
func NewWlan(ctx *pulumi.Context,
	name string, args *WlanArgs, opts ...pulumi.ResourceOption) (*Wlan, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SiteId == nil {
		return nil, errors.New("invalid value for required argument 'SiteId'")
	}
	if args.Ssid == nil {
		return nil, errors.New("invalid value for required argument 'Ssid'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Wlan
	err := ctx.RegisterResource("junipermist:site/wlan:Wlan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetWlan gets an existing Wlan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetWlan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *WlanState, opts ...pulumi.ResourceOption) (*Wlan, error) {
	var resource Wlan
	err := ctx.ReadResource("junipermist:site/wlan:Wlan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Wlan resources.
type wlanState struct {
	// Enable coa-immediate-update and address-change-immediate-update on the access profile.
	AcctImmediateUpdate *bool `pulumi:"acctImmediateUpdate"`
	// How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
	// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
	// when enabled
	AcctInterimInterval *int `pulumi:"acctInterimInterval"`
	// List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
	AcctServers []WlanAcctServer `pulumi:"acctServers"`
	// Airwatch wlan settings
	Airwatch *WlanAirwatch `pulumi:"airwatch"`
	// Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
	AllowIpv6Ndp *bool `pulumi:"allowIpv6Ndp"`
	// Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
	AllowMdns *bool `pulumi:"allowMdns"`
	// Only applicable when `limitBcast`==`true`, which allows SSDP
	AllowSsdp *bool `pulumi:"allowSsdp"`
	// List of device ids
	ApIds []string `pulumi:"apIds"`
	// Bandwidth limiting for apps (applies to up/down)
	AppLimit *WlanAppLimit `pulumi:"appLimit"`
	// APp qos wlan settings
	AppQos *WlanAppQos `pulumi:"appQos"`
	// enum: `aps`, `site`, `wxtags`
	ApplyTo *string `pulumi:"applyTo"`
	// Whether to enable smart arp filter
	ArpFilter *bool `pulumi:"arpFilter"`
	// Authentication wlan settings
	Auth *WlanAuth `pulumi:"auth"`
	// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
	AuthServerSelection *string `pulumi:"authServerSelection"`
	// List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
	// is treated as primary
	AuthServers []WlanAuthServer `pulumi:"authServers"`
	// Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
	AuthServersNasId *string `pulumi:"authServersNasId"`
	// Optional, NAS-IP-ADDRESS to use
	AuthServersNasIp *string `pulumi:"authServersNasIp"`
	// Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’ are set
	// to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default
	// value to 3.
	AuthServersRetries *int `pulumi:"authServersRetries"`
	// Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’ and
	// ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
	// setting authServersTimeout and is set to default value of 10.
	AuthServersTimeout *int `pulumi:"authServersTimeout"`
	// Whether to enable band_steering, this works only when band==both
	BandSteer *bool `pulumi:"bandSteer"`
	// Force dualBand capable client to connect to 5G
	BandSteerForceBand5 *bool `pulumi:"bandSteerForceBand5"`
	// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
	Bands []string `pulumi:"bands"`
	// Whether to block the clients in the blacklist (up to first 256 macs)
	BlockBlacklistClients *bool `pulumi:"blockBlacklistClients"`
	// Bonjour gateway wlan settings
	Bonjour *WlanBonjour `pulumi:"bonjour"`
	// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
	// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
	CiscoCwa *WlanCiscoCwa `pulumi:"ciscoCwa"`
	// In kbps
	ClientLimitDown *int `pulumi:"clientLimitDown"`
	// If downlink limiting per-client is enabled
	ClientLimitDownEnabled *bool `pulumi:"clientLimitDownEnabled"`
	// In kbps
	ClientLimitUp *int `pulumi:"clientLimitUp"`
	// If uplink limiting per-client is enabled
	ClientLimitUpEnabled *bool `pulumi:"clientLimitUpEnabled"`
	// List of COA (change of authorization) servers, optional
	CoaServers []WlanCoaServer `pulumi:"coaServers"`
	// Some old WLAN drivers may not be compatible
	Disable11ax *bool `pulumi:"disable11ax"`
	// To disable Wi-Fi 7 EHT IEs
	Disable11be *bool `pulumi:"disable11be"`
	// To disable ht or vht rates
	DisableHtVhtRates *bool `pulumi:"disableHtVhtRates"`
	// Whether to disable U-APSD
	DisableUapsd *bool `pulumi:"disableUapsd"`
	// Disable sending v2 roam notification messages
	DisableV1RoamNotify *bool `pulumi:"disableV1RoamNotify"`
	// Disable sending v2 roam notification messages
	DisableV2RoamNotify *bool `pulumi:"disableV2RoamNotify"`
	// When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
	// reach default gateway
	DisableWhenGatewayUnreachable *bool `pulumi:"disableWhenGatewayUnreachable"`
	DisableWhenMxtunnelDown       *bool `pulumi:"disableWhenMxtunnelDown"`
	// Whether to disable WMM
	DisableWmm *bool `pulumi:"disableWmm"`
	// For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
	DnsServerRewrite *WlanDnsServerRewrite `pulumi:"dnsServerRewrite"`
	Dtim             *int                  `pulumi:"dtim"`
	// For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
	// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
	// AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
	// Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
	// used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
	// wpa3 support on the roadmap)
	DynamicPsk *WlanDynamicPsk `pulumi:"dynamicPsk"`
	// For 802.1x
	DynamicVlan *WlanDynamicVlan `pulumi:"dynamicVlan"`
	// Enable AP-AP keycaching via multicast
	EnableLocalKeycaching *bool `pulumi:"enableLocalKeycaching"`
	// By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
	// client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
	EnableWirelessBridging *bool `pulumi:"enableWirelessBridging"`
	// If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
	// packets to be forwarded to wireless
	EnableWirelessBridgingDhcpTracking *bool `pulumi:"enableWirelessBridgingDhcpTracking"`
	// If this wlan is enabled
	Enabled *bool `pulumi:"enabled"`
	// If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
	// ‘auth_server_retries’ .
	FastDot1xTimers *bool `pulumi:"fastDot1xTimers"`
	// Whether to hide SSID in beacon
	HideSsid *bool `pulumi:"hideSsid"`
	// Include hostname inside IE in AP beacons / probe responses
	HostnameIe *bool `pulumi:"hostnameIe"`
	// Hostspot 2.0 wlan settings
	Hotspot20          *WlanHotspot20          `pulumi:"hotspot20"`
	InjectDhcpOption82 *WlanInjectDhcpOption82 `pulumi:"injectDhcpOption82"`
	// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
	Interface *string `pulumi:"interface"`
	// Whether to stop clients to talk to each other
	Isolation *bool `pulumi:"isolation"`
	// If isolation is enabled, whether to deny clients to talk to L2 on the LAN
	L2Isolation *bool `pulumi:"l2Isolation"`
	// Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
	// Enabling this will cause problem for iOS devices.
	LegacyOverds *bool `pulumi:"legacyOverds"`
	// Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
	LimitBcast *bool `pulumi:"limitBcast"`
	// Limit probe response base on some heuristic rules
	LimitProbeResponse *bool `pulumi:"limitProbeResponse"`
	// Max idle time in seconds
	MaxIdletime *int `pulumi:"maxIdletime"`
	// Maximum number of client connected to the SSID. `0` means unlimited
	MaxNumClients *int         `pulumi:"maxNumClients"`
	MistNac       *WlanMistNac `pulumi:"mistNac"`
	MspId         *string      `pulumi:"mspId"`
	// When `interface`=`mxtunnel`, id of the Mist Tunnel
	MxtunnelIds []string `pulumi:"mxtunnelIds"`
	// When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
	MxtunnelNames []string `pulumi:"mxtunnelNames"`
	// Whether to only allow client to use DNS that we’ve learned from DHCP response
	NoStaticDns *bool `pulumi:"noStaticDns"`
	// Whether to only allow client that we’ve learned from DHCP exchange to talk
	NoStaticIp *bool   `pulumi:"noStaticIp"`
	OrgId      *string `pulumi:"orgId"`
	// Portal wlan settings
	Portal *WlanPortal `pulumi:"portal"`
	// List of hostnames without http(s):// (matched by substring)
	PortalAllowedHostnames []string `pulumi:"portalAllowedHostnames"`
	// List of CIDRs
	PortalAllowedSubnets []string `pulumi:"portalAllowedSubnets"`
	// APi secret (auto-generated) that can be used to sign guest authorization requests
	PortalApiSecret *string `pulumi:"portalApiSecret"`
	// List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
	PortalDeniedHostnames []string `pulumi:"portalDeniedHostnames"`
	// Url of portal background image
	PortalImage  *string  `pulumi:"portalImage"`
	PortalSsoUrl *string  `pulumi:"portalSsoUrl"`
	Qos          *WlanQos `pulumi:"qos"`
	// RadSec settings
	Radsec *WlanRadsec `pulumi:"radsec"`
	// Property key is the RF band. enum: `24`, `5`, `6`
	Rateset map[string]WlanRateset `pulumi:"rateset"`
	// When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
	ReconnectClientsWhenRoamingMxcluster *bool `pulumi:"reconnectClientsWhenRoamingMxcluster"`
	// enum: `11r`, `OKC`, `NONE`
	RoamMode *string `pulumi:"roamMode"`
	// WLAN operating schedule, default is disabled
	Schedule *WlanSchedule `pulumi:"schedule"`
	SiteId   *string       `pulumi:"siteId"`
	// Whether to exclude this WLAN from SLE metrics
	SleExcluded *bool `pulumi:"sleExcluded"`
	// Name of the SSID
	Ssid *string `pulumi:"ssid"`
	// If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
	UseEapolV1 *bool `pulumi:"useEapolV1"`
	// If vlan tagging is enabled
	VlanEnabled *bool   `pulumi:"vlanEnabled"`
	VlanId      *string `pulumi:"vlanId"`
	// if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
	VlanIds []string `pulumi:"vlanIds"`
	// Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
	// deterministic algorithm
	VlanPooling *bool `pulumi:"vlanPooling"`
	// In kbps
	WlanLimitDown *int `pulumi:"wlanLimitDown"`
	// If downlink limiting for whole wlan is enabled
	WlanLimitDownEnabled *bool `pulumi:"wlanLimitDownEnabled"`
	// In kbps
	WlanLimitUp *int `pulumi:"wlanLimitUp"`
	// If uplink limiting for whole wlan is enabled
	WlanLimitUpEnabled *bool `pulumi:"wlanLimitUpEnabled"`
	// List of wxtag_ids
	WxtagIds []string `pulumi:"wxtagIds"`
	// When `interface`=`wxtunnel`, id of the WXLAN Tunnel
	WxtunnelId *string `pulumi:"wxtunnelId"`
	// When `interface`=`wxtunnel`, remote tunnel identifier
	WxtunnelRemoteId *string `pulumi:"wxtunnelRemoteId"`
}

type WlanState struct {
	// Enable coa-immediate-update and address-change-immediate-update on the access profile.
	AcctImmediateUpdate pulumi.BoolPtrInput
	// How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
	// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
	// when enabled
	AcctInterimInterval pulumi.IntPtrInput
	// List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
	AcctServers WlanAcctServerArrayInput
	// Airwatch wlan settings
	Airwatch WlanAirwatchPtrInput
	// Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
	AllowIpv6Ndp pulumi.BoolPtrInput
	// Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
	AllowMdns pulumi.BoolPtrInput
	// Only applicable when `limitBcast`==`true`, which allows SSDP
	AllowSsdp pulumi.BoolPtrInput
	// List of device ids
	ApIds pulumi.StringArrayInput
	// Bandwidth limiting for apps (applies to up/down)
	AppLimit WlanAppLimitPtrInput
	// APp qos wlan settings
	AppQos WlanAppQosPtrInput
	// enum: `aps`, `site`, `wxtags`
	ApplyTo pulumi.StringPtrInput
	// Whether to enable smart arp filter
	ArpFilter pulumi.BoolPtrInput
	// Authentication wlan settings
	Auth WlanAuthPtrInput
	// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
	AuthServerSelection pulumi.StringPtrInput
	// List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
	// is treated as primary
	AuthServers WlanAuthServerArrayInput
	// Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
	AuthServersNasId pulumi.StringPtrInput
	// Optional, NAS-IP-ADDRESS to use
	AuthServersNasIp pulumi.StringPtrInput
	// Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’ are set
	// to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default
	// value to 3.
	AuthServersRetries pulumi.IntPtrInput
	// Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’ and
	// ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
	// setting authServersTimeout and is set to default value of 10.
	AuthServersTimeout pulumi.IntPtrInput
	// Whether to enable band_steering, this works only when band==both
	BandSteer pulumi.BoolPtrInput
	// Force dualBand capable client to connect to 5G
	BandSteerForceBand5 pulumi.BoolPtrInput
	// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
	Bands pulumi.StringArrayInput
	// Whether to block the clients in the blacklist (up to first 256 macs)
	BlockBlacklistClients pulumi.BoolPtrInput
	// Bonjour gateway wlan settings
	Bonjour WlanBonjourPtrInput
	// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
	// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
	CiscoCwa WlanCiscoCwaPtrInput
	// In kbps
	ClientLimitDown pulumi.IntPtrInput
	// If downlink limiting per-client is enabled
	ClientLimitDownEnabled pulumi.BoolPtrInput
	// In kbps
	ClientLimitUp pulumi.IntPtrInput
	// If uplink limiting per-client is enabled
	ClientLimitUpEnabled pulumi.BoolPtrInput
	// List of COA (change of authorization) servers, optional
	CoaServers WlanCoaServerArrayInput
	// Some old WLAN drivers may not be compatible
	Disable11ax pulumi.BoolPtrInput
	// To disable Wi-Fi 7 EHT IEs
	Disable11be pulumi.BoolPtrInput
	// To disable ht or vht rates
	DisableHtVhtRates pulumi.BoolPtrInput
	// Whether to disable U-APSD
	DisableUapsd pulumi.BoolPtrInput
	// Disable sending v2 roam notification messages
	DisableV1RoamNotify pulumi.BoolPtrInput
	// Disable sending v2 roam notification messages
	DisableV2RoamNotify pulumi.BoolPtrInput
	// When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
	// reach default gateway
	DisableWhenGatewayUnreachable pulumi.BoolPtrInput
	DisableWhenMxtunnelDown       pulumi.BoolPtrInput
	// Whether to disable WMM
	DisableWmm pulumi.BoolPtrInput
	// For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
	DnsServerRewrite WlanDnsServerRewritePtrInput
	Dtim             pulumi.IntPtrInput
	// For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
	// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
	// AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
	// Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
	// used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
	// wpa3 support on the roadmap)
	DynamicPsk WlanDynamicPskPtrInput
	// For 802.1x
	DynamicVlan WlanDynamicVlanPtrInput
	// Enable AP-AP keycaching via multicast
	EnableLocalKeycaching pulumi.BoolPtrInput
	// By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
	// client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
	EnableWirelessBridging pulumi.BoolPtrInput
	// If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
	// packets to be forwarded to wireless
	EnableWirelessBridgingDhcpTracking pulumi.BoolPtrInput
	// If this wlan is enabled
	Enabled pulumi.BoolPtrInput
	// If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
	// ‘auth_server_retries’ .
	FastDot1xTimers pulumi.BoolPtrInput
	// Whether to hide SSID in beacon
	HideSsid pulumi.BoolPtrInput
	// Include hostname inside IE in AP beacons / probe responses
	HostnameIe pulumi.BoolPtrInput
	// Hostspot 2.0 wlan settings
	Hotspot20          WlanHotspot20PtrInput
	InjectDhcpOption82 WlanInjectDhcpOption82PtrInput
	// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
	Interface pulumi.StringPtrInput
	// Whether to stop clients to talk to each other
	Isolation pulumi.BoolPtrInput
	// If isolation is enabled, whether to deny clients to talk to L2 on the LAN
	L2Isolation pulumi.BoolPtrInput
	// Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
	// Enabling this will cause problem for iOS devices.
	LegacyOverds pulumi.BoolPtrInput
	// Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
	LimitBcast pulumi.BoolPtrInput
	// Limit probe response base on some heuristic rules
	LimitProbeResponse pulumi.BoolPtrInput
	// Max idle time in seconds
	MaxIdletime pulumi.IntPtrInput
	// Maximum number of client connected to the SSID. `0` means unlimited
	MaxNumClients pulumi.IntPtrInput
	MistNac       WlanMistNacPtrInput
	MspId         pulumi.StringPtrInput
	// When `interface`=`mxtunnel`, id of the Mist Tunnel
	MxtunnelIds pulumi.StringArrayInput
	// When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
	MxtunnelNames pulumi.StringArrayInput
	// Whether to only allow client to use DNS that we’ve learned from DHCP response
	NoStaticDns pulumi.BoolPtrInput
	// Whether to only allow client that we’ve learned from DHCP exchange to talk
	NoStaticIp pulumi.BoolPtrInput
	OrgId      pulumi.StringPtrInput
	// Portal wlan settings
	Portal WlanPortalPtrInput
	// List of hostnames without http(s):// (matched by substring)
	PortalAllowedHostnames pulumi.StringArrayInput
	// List of CIDRs
	PortalAllowedSubnets pulumi.StringArrayInput
	// APi secret (auto-generated) that can be used to sign guest authorization requests
	PortalApiSecret pulumi.StringPtrInput
	// List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
	PortalDeniedHostnames pulumi.StringArrayInput
	// Url of portal background image
	PortalImage  pulumi.StringPtrInput
	PortalSsoUrl pulumi.StringPtrInput
	Qos          WlanQosPtrInput
	// RadSec settings
	Radsec WlanRadsecPtrInput
	// Property key is the RF band. enum: `24`, `5`, `6`
	Rateset WlanRatesetMapInput
	// When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
	ReconnectClientsWhenRoamingMxcluster pulumi.BoolPtrInput
	// enum: `11r`, `OKC`, `NONE`
	RoamMode pulumi.StringPtrInput
	// WLAN operating schedule, default is disabled
	Schedule WlanSchedulePtrInput
	SiteId   pulumi.StringPtrInput
	// Whether to exclude this WLAN from SLE metrics
	SleExcluded pulumi.BoolPtrInput
	// Name of the SSID
	Ssid pulumi.StringPtrInput
	// If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
	UseEapolV1 pulumi.BoolPtrInput
	// If vlan tagging is enabled
	VlanEnabled pulumi.BoolPtrInput
	VlanId      pulumi.StringPtrInput
	// if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
	VlanIds pulumi.StringArrayInput
	// Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
	// deterministic algorithm
	VlanPooling pulumi.BoolPtrInput
	// In kbps
	WlanLimitDown pulumi.IntPtrInput
	// If downlink limiting for whole wlan is enabled
	WlanLimitDownEnabled pulumi.BoolPtrInput
	// In kbps
	WlanLimitUp pulumi.IntPtrInput
	// If uplink limiting for whole wlan is enabled
	WlanLimitUpEnabled pulumi.BoolPtrInput
	// List of wxtag_ids
	WxtagIds pulumi.StringArrayInput
	// When `interface`=`wxtunnel`, id of the WXLAN Tunnel
	WxtunnelId pulumi.StringPtrInput
	// When `interface`=`wxtunnel`, remote tunnel identifier
	WxtunnelRemoteId pulumi.StringPtrInput
}

func (WlanState) ElementType() reflect.Type {
	return reflect.TypeOf((*wlanState)(nil)).Elem()
}

type wlanArgs struct {
	// Enable coa-immediate-update and address-change-immediate-update on the access profile.
	AcctImmediateUpdate *bool `pulumi:"acctImmediateUpdate"`
	// How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
	// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
	// when enabled
	AcctInterimInterval *int `pulumi:"acctInterimInterval"`
	// List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
	AcctServers []WlanAcctServer `pulumi:"acctServers"`
	// Airwatch wlan settings
	Airwatch *WlanAirwatch `pulumi:"airwatch"`
	// Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
	AllowIpv6Ndp *bool `pulumi:"allowIpv6Ndp"`
	// Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
	AllowMdns *bool `pulumi:"allowMdns"`
	// Only applicable when `limitBcast`==`true`, which allows SSDP
	AllowSsdp *bool `pulumi:"allowSsdp"`
	// List of device ids
	ApIds []string `pulumi:"apIds"`
	// Bandwidth limiting for apps (applies to up/down)
	AppLimit *WlanAppLimit `pulumi:"appLimit"`
	// APp qos wlan settings
	AppQos *WlanAppQos `pulumi:"appQos"`
	// enum: `aps`, `site`, `wxtags`
	ApplyTo *string `pulumi:"applyTo"`
	// Whether to enable smart arp filter
	ArpFilter *bool `pulumi:"arpFilter"`
	// Authentication wlan settings
	Auth *WlanAuth `pulumi:"auth"`
	// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
	AuthServerSelection *string `pulumi:"authServerSelection"`
	// List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
	// is treated as primary
	AuthServers []WlanAuthServer `pulumi:"authServers"`
	// Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
	AuthServersNasId *string `pulumi:"authServersNasId"`
	// Optional, NAS-IP-ADDRESS to use
	AuthServersNasIp *string `pulumi:"authServersNasIp"`
	// Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’ are set
	// to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default
	// value to 3.
	AuthServersRetries *int `pulumi:"authServersRetries"`
	// Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’ and
	// ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
	// setting authServersTimeout and is set to default value of 10.
	AuthServersTimeout *int `pulumi:"authServersTimeout"`
	// Whether to enable band_steering, this works only when band==both
	BandSteer *bool `pulumi:"bandSteer"`
	// Force dualBand capable client to connect to 5G
	BandSteerForceBand5 *bool `pulumi:"bandSteerForceBand5"`
	// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
	Bands []string `pulumi:"bands"`
	// Whether to block the clients in the blacklist (up to first 256 macs)
	BlockBlacklistClients *bool `pulumi:"blockBlacklistClients"`
	// Bonjour gateway wlan settings
	Bonjour *WlanBonjour `pulumi:"bonjour"`
	// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
	// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
	CiscoCwa *WlanCiscoCwa `pulumi:"ciscoCwa"`
	// In kbps
	ClientLimitDown *int `pulumi:"clientLimitDown"`
	// If downlink limiting per-client is enabled
	ClientLimitDownEnabled *bool `pulumi:"clientLimitDownEnabled"`
	// In kbps
	ClientLimitUp *int `pulumi:"clientLimitUp"`
	// If uplink limiting per-client is enabled
	ClientLimitUpEnabled *bool `pulumi:"clientLimitUpEnabled"`
	// List of COA (change of authorization) servers, optional
	CoaServers []WlanCoaServer `pulumi:"coaServers"`
	// Some old WLAN drivers may not be compatible
	Disable11ax *bool `pulumi:"disable11ax"`
	// To disable Wi-Fi 7 EHT IEs
	Disable11be *bool `pulumi:"disable11be"`
	// To disable ht or vht rates
	DisableHtVhtRates *bool `pulumi:"disableHtVhtRates"`
	// Whether to disable U-APSD
	DisableUapsd *bool `pulumi:"disableUapsd"`
	// Disable sending v2 roam notification messages
	DisableV1RoamNotify *bool `pulumi:"disableV1RoamNotify"`
	// Disable sending v2 roam notification messages
	DisableV2RoamNotify *bool `pulumi:"disableV2RoamNotify"`
	// When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
	// reach default gateway
	DisableWhenGatewayUnreachable *bool `pulumi:"disableWhenGatewayUnreachable"`
	DisableWhenMxtunnelDown       *bool `pulumi:"disableWhenMxtunnelDown"`
	// Whether to disable WMM
	DisableWmm *bool `pulumi:"disableWmm"`
	// For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
	DnsServerRewrite *WlanDnsServerRewrite `pulumi:"dnsServerRewrite"`
	Dtim             *int                  `pulumi:"dtim"`
	// For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
	// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
	// AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
	// Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
	// used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
	// wpa3 support on the roadmap)
	DynamicPsk *WlanDynamicPsk `pulumi:"dynamicPsk"`
	// For 802.1x
	DynamicVlan *WlanDynamicVlan `pulumi:"dynamicVlan"`
	// Enable AP-AP keycaching via multicast
	EnableLocalKeycaching *bool `pulumi:"enableLocalKeycaching"`
	// By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
	// client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
	EnableWirelessBridging *bool `pulumi:"enableWirelessBridging"`
	// If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
	// packets to be forwarded to wireless
	EnableWirelessBridgingDhcpTracking *bool `pulumi:"enableWirelessBridgingDhcpTracking"`
	// If this wlan is enabled
	Enabled *bool `pulumi:"enabled"`
	// If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
	// ‘auth_server_retries’ .
	FastDot1xTimers *bool `pulumi:"fastDot1xTimers"`
	// Whether to hide SSID in beacon
	HideSsid *bool `pulumi:"hideSsid"`
	// Include hostname inside IE in AP beacons / probe responses
	HostnameIe *bool `pulumi:"hostnameIe"`
	// Hostspot 2.0 wlan settings
	Hotspot20          *WlanHotspot20          `pulumi:"hotspot20"`
	InjectDhcpOption82 *WlanInjectDhcpOption82 `pulumi:"injectDhcpOption82"`
	// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
	Interface *string `pulumi:"interface"`
	// Whether to stop clients to talk to each other
	Isolation *bool `pulumi:"isolation"`
	// If isolation is enabled, whether to deny clients to talk to L2 on the LAN
	L2Isolation *bool `pulumi:"l2Isolation"`
	// Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
	// Enabling this will cause problem for iOS devices.
	LegacyOverds *bool `pulumi:"legacyOverds"`
	// Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
	LimitBcast *bool `pulumi:"limitBcast"`
	// Limit probe response base on some heuristic rules
	LimitProbeResponse *bool `pulumi:"limitProbeResponse"`
	// Max idle time in seconds
	MaxIdletime *int `pulumi:"maxIdletime"`
	// Maximum number of client connected to the SSID. `0` means unlimited
	MaxNumClients *int         `pulumi:"maxNumClients"`
	MistNac       *WlanMistNac `pulumi:"mistNac"`
	// When `interface`=`mxtunnel`, id of the Mist Tunnel
	MxtunnelIds []string `pulumi:"mxtunnelIds"`
	// When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
	MxtunnelNames []string `pulumi:"mxtunnelNames"`
	// Whether to only allow client to use DNS that we’ve learned from DHCP response
	NoStaticDns *bool `pulumi:"noStaticDns"`
	// Whether to only allow client that we’ve learned from DHCP exchange to talk
	NoStaticIp *bool `pulumi:"noStaticIp"`
	// Portal wlan settings
	Portal *WlanPortal `pulumi:"portal"`
	// List of hostnames without http(s):// (matched by substring)
	PortalAllowedHostnames []string `pulumi:"portalAllowedHostnames"`
	// List of CIDRs
	PortalAllowedSubnets []string `pulumi:"portalAllowedSubnets"`
	// List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
	PortalDeniedHostnames []string `pulumi:"portalDeniedHostnames"`
	Qos                   *WlanQos `pulumi:"qos"`
	// RadSec settings
	Radsec *WlanRadsec `pulumi:"radsec"`
	// Property key is the RF band. enum: `24`, `5`, `6`
	Rateset map[string]WlanRateset `pulumi:"rateset"`
	// When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
	ReconnectClientsWhenRoamingMxcluster *bool `pulumi:"reconnectClientsWhenRoamingMxcluster"`
	// enum: `11r`, `OKC`, `NONE`
	RoamMode *string `pulumi:"roamMode"`
	// WLAN operating schedule, default is disabled
	Schedule *WlanSchedule `pulumi:"schedule"`
	SiteId   string        `pulumi:"siteId"`
	// Whether to exclude this WLAN from SLE metrics
	SleExcluded *bool `pulumi:"sleExcluded"`
	// Name of the SSID
	Ssid string `pulumi:"ssid"`
	// If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
	UseEapolV1 *bool `pulumi:"useEapolV1"`
	// If vlan tagging is enabled
	VlanEnabled *bool   `pulumi:"vlanEnabled"`
	VlanId      *string `pulumi:"vlanId"`
	// if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
	VlanIds []string `pulumi:"vlanIds"`
	// Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
	// deterministic algorithm
	VlanPooling *bool `pulumi:"vlanPooling"`
	// In kbps
	WlanLimitDown *int `pulumi:"wlanLimitDown"`
	// If downlink limiting for whole wlan is enabled
	WlanLimitDownEnabled *bool `pulumi:"wlanLimitDownEnabled"`
	// In kbps
	WlanLimitUp *int `pulumi:"wlanLimitUp"`
	// If uplink limiting for whole wlan is enabled
	WlanLimitUpEnabled *bool `pulumi:"wlanLimitUpEnabled"`
	// List of wxtag_ids
	WxtagIds []string `pulumi:"wxtagIds"`
	// When `interface`=`wxtunnel`, id of the WXLAN Tunnel
	WxtunnelId *string `pulumi:"wxtunnelId"`
	// When `interface`=`wxtunnel`, remote tunnel identifier
	WxtunnelRemoteId *string `pulumi:"wxtunnelRemoteId"`
}

// The set of arguments for constructing a Wlan resource.
type WlanArgs struct {
	// Enable coa-immediate-update and address-change-immediate-update on the access profile.
	AcctImmediateUpdate pulumi.BoolPtrInput
	// How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
	// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
	// when enabled
	AcctInterimInterval pulumi.IntPtrInput
	// List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
	AcctServers WlanAcctServerArrayInput
	// Airwatch wlan settings
	Airwatch WlanAirwatchPtrInput
	// Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
	AllowIpv6Ndp pulumi.BoolPtrInput
	// Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
	AllowMdns pulumi.BoolPtrInput
	// Only applicable when `limitBcast`==`true`, which allows SSDP
	AllowSsdp pulumi.BoolPtrInput
	// List of device ids
	ApIds pulumi.StringArrayInput
	// Bandwidth limiting for apps (applies to up/down)
	AppLimit WlanAppLimitPtrInput
	// APp qos wlan settings
	AppQos WlanAppQosPtrInput
	// enum: `aps`, `site`, `wxtags`
	ApplyTo pulumi.StringPtrInput
	// Whether to enable smart arp filter
	ArpFilter pulumi.BoolPtrInput
	// Authentication wlan settings
	Auth WlanAuthPtrInput
	// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
	AuthServerSelection pulumi.StringPtrInput
	// List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
	// is treated as primary
	AuthServers WlanAuthServerArrayInput
	// Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
	AuthServersNasId pulumi.StringPtrInput
	// Optional, NAS-IP-ADDRESS to use
	AuthServersNasIp pulumi.StringPtrInput
	// Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’ are set
	// to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default
	// value to 3.
	AuthServersRetries pulumi.IntPtrInput
	// Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’ and
	// ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
	// setting authServersTimeout and is set to default value of 10.
	AuthServersTimeout pulumi.IntPtrInput
	// Whether to enable band_steering, this works only when band==both
	BandSteer pulumi.BoolPtrInput
	// Force dualBand capable client to connect to 5G
	BandSteerForceBand5 pulumi.BoolPtrInput
	// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
	Bands pulumi.StringArrayInput
	// Whether to block the clients in the blacklist (up to first 256 macs)
	BlockBlacklistClients pulumi.BoolPtrInput
	// Bonjour gateway wlan settings
	Bonjour WlanBonjourPtrInput
	// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
	// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
	CiscoCwa WlanCiscoCwaPtrInput
	// In kbps
	ClientLimitDown pulumi.IntPtrInput
	// If downlink limiting per-client is enabled
	ClientLimitDownEnabled pulumi.BoolPtrInput
	// In kbps
	ClientLimitUp pulumi.IntPtrInput
	// If uplink limiting per-client is enabled
	ClientLimitUpEnabled pulumi.BoolPtrInput
	// List of COA (change of authorization) servers, optional
	CoaServers WlanCoaServerArrayInput
	// Some old WLAN drivers may not be compatible
	Disable11ax pulumi.BoolPtrInput
	// To disable Wi-Fi 7 EHT IEs
	Disable11be pulumi.BoolPtrInput
	// To disable ht or vht rates
	DisableHtVhtRates pulumi.BoolPtrInput
	// Whether to disable U-APSD
	DisableUapsd pulumi.BoolPtrInput
	// Disable sending v2 roam notification messages
	DisableV1RoamNotify pulumi.BoolPtrInput
	// Disable sending v2 roam notification messages
	DisableV2RoamNotify pulumi.BoolPtrInput
	// When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
	// reach default gateway
	DisableWhenGatewayUnreachable pulumi.BoolPtrInput
	DisableWhenMxtunnelDown       pulumi.BoolPtrInput
	// Whether to disable WMM
	DisableWmm pulumi.BoolPtrInput
	// For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
	DnsServerRewrite WlanDnsServerRewritePtrInput
	Dtim             pulumi.IntPtrInput
	// For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
	// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
	// AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
	// Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
	// used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
	// wpa3 support on the roadmap)
	DynamicPsk WlanDynamicPskPtrInput
	// For 802.1x
	DynamicVlan WlanDynamicVlanPtrInput
	// Enable AP-AP keycaching via multicast
	EnableLocalKeycaching pulumi.BoolPtrInput
	// By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
	// client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
	EnableWirelessBridging pulumi.BoolPtrInput
	// If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
	// packets to be forwarded to wireless
	EnableWirelessBridgingDhcpTracking pulumi.BoolPtrInput
	// If this wlan is enabled
	Enabled pulumi.BoolPtrInput
	// If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
	// ‘auth_server_retries’ .
	FastDot1xTimers pulumi.BoolPtrInput
	// Whether to hide SSID in beacon
	HideSsid pulumi.BoolPtrInput
	// Include hostname inside IE in AP beacons / probe responses
	HostnameIe pulumi.BoolPtrInput
	// Hostspot 2.0 wlan settings
	Hotspot20          WlanHotspot20PtrInput
	InjectDhcpOption82 WlanInjectDhcpOption82PtrInput
	// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
	Interface pulumi.StringPtrInput
	// Whether to stop clients to talk to each other
	Isolation pulumi.BoolPtrInput
	// If isolation is enabled, whether to deny clients to talk to L2 on the LAN
	L2Isolation pulumi.BoolPtrInput
	// Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
	// Enabling this will cause problem for iOS devices.
	LegacyOverds pulumi.BoolPtrInput
	// Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
	LimitBcast pulumi.BoolPtrInput
	// Limit probe response base on some heuristic rules
	LimitProbeResponse pulumi.BoolPtrInput
	// Max idle time in seconds
	MaxIdletime pulumi.IntPtrInput
	// Maximum number of client connected to the SSID. `0` means unlimited
	MaxNumClients pulumi.IntPtrInput
	MistNac       WlanMistNacPtrInput
	// When `interface`=`mxtunnel`, id of the Mist Tunnel
	MxtunnelIds pulumi.StringArrayInput
	// When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
	MxtunnelNames pulumi.StringArrayInput
	// Whether to only allow client to use DNS that we’ve learned from DHCP response
	NoStaticDns pulumi.BoolPtrInput
	// Whether to only allow client that we’ve learned from DHCP exchange to talk
	NoStaticIp pulumi.BoolPtrInput
	// Portal wlan settings
	Portal WlanPortalPtrInput
	// List of hostnames without http(s):// (matched by substring)
	PortalAllowedHostnames pulumi.StringArrayInput
	// List of CIDRs
	PortalAllowedSubnets pulumi.StringArrayInput
	// List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
	PortalDeniedHostnames pulumi.StringArrayInput
	Qos                   WlanQosPtrInput
	// RadSec settings
	Radsec WlanRadsecPtrInput
	// Property key is the RF band. enum: `24`, `5`, `6`
	Rateset WlanRatesetMapInput
	// When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
	ReconnectClientsWhenRoamingMxcluster pulumi.BoolPtrInput
	// enum: `11r`, `OKC`, `NONE`
	RoamMode pulumi.StringPtrInput
	// WLAN operating schedule, default is disabled
	Schedule WlanSchedulePtrInput
	SiteId   pulumi.StringInput
	// Whether to exclude this WLAN from SLE metrics
	SleExcluded pulumi.BoolPtrInput
	// Name of the SSID
	Ssid pulumi.StringInput
	// If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
	UseEapolV1 pulumi.BoolPtrInput
	// If vlan tagging is enabled
	VlanEnabled pulumi.BoolPtrInput
	VlanId      pulumi.StringPtrInput
	// if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
	VlanIds pulumi.StringArrayInput
	// Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
	// deterministic algorithm
	VlanPooling pulumi.BoolPtrInput
	// In kbps
	WlanLimitDown pulumi.IntPtrInput
	// If downlink limiting for whole wlan is enabled
	WlanLimitDownEnabled pulumi.BoolPtrInput
	// In kbps
	WlanLimitUp pulumi.IntPtrInput
	// If uplink limiting for whole wlan is enabled
	WlanLimitUpEnabled pulumi.BoolPtrInput
	// List of wxtag_ids
	WxtagIds pulumi.StringArrayInput
	// When `interface`=`wxtunnel`, id of the WXLAN Tunnel
	WxtunnelId pulumi.StringPtrInput
	// When `interface`=`wxtunnel`, remote tunnel identifier
	WxtunnelRemoteId pulumi.StringPtrInput
}

func (WlanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*wlanArgs)(nil)).Elem()
}

type WlanInput interface {
	pulumi.Input

	ToWlanOutput() WlanOutput
	ToWlanOutputWithContext(ctx context.Context) WlanOutput
}

func (*Wlan) ElementType() reflect.Type {
	return reflect.TypeOf((**Wlan)(nil)).Elem()
}

func (i *Wlan) ToWlanOutput() WlanOutput {
	return i.ToWlanOutputWithContext(context.Background())
}

func (i *Wlan) ToWlanOutputWithContext(ctx context.Context) WlanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WlanOutput)
}

// WlanArrayInput is an input type that accepts WlanArray and WlanArrayOutput values.
// You can construct a concrete instance of `WlanArrayInput` via:
//
//	WlanArray{ WlanArgs{...} }
type WlanArrayInput interface {
	pulumi.Input

	ToWlanArrayOutput() WlanArrayOutput
	ToWlanArrayOutputWithContext(context.Context) WlanArrayOutput
}

type WlanArray []WlanInput

func (WlanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Wlan)(nil)).Elem()
}

func (i WlanArray) ToWlanArrayOutput() WlanArrayOutput {
	return i.ToWlanArrayOutputWithContext(context.Background())
}

func (i WlanArray) ToWlanArrayOutputWithContext(ctx context.Context) WlanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WlanArrayOutput)
}

// WlanMapInput is an input type that accepts WlanMap and WlanMapOutput values.
// You can construct a concrete instance of `WlanMapInput` via:
//
//	WlanMap{ "key": WlanArgs{...} }
type WlanMapInput interface {
	pulumi.Input

	ToWlanMapOutput() WlanMapOutput
	ToWlanMapOutputWithContext(context.Context) WlanMapOutput
}

type WlanMap map[string]WlanInput

func (WlanMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Wlan)(nil)).Elem()
}

func (i WlanMap) ToWlanMapOutput() WlanMapOutput {
	return i.ToWlanMapOutputWithContext(context.Background())
}

func (i WlanMap) ToWlanMapOutputWithContext(ctx context.Context) WlanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WlanMapOutput)
}

type WlanOutput struct{ *pulumi.OutputState }

func (WlanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Wlan)(nil)).Elem()
}

func (o WlanOutput) ToWlanOutput() WlanOutput {
	return o
}

func (o WlanOutput) ToWlanOutputWithContext(ctx context.Context) WlanOutput {
	return o
}

// Enable coa-immediate-update and address-change-immediate-update on the access profile.
func (o WlanOutput) AcctImmediateUpdate() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.AcctImmediateUpdate }).(pulumi.BoolOutput)
}

// How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
// when enabled
func (o WlanOutput) AcctInterimInterval() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.AcctInterimInterval }).(pulumi.IntOutput)
}

// List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
func (o WlanOutput) AcctServers() WlanAcctServerArrayOutput {
	return o.ApplyT(func(v *Wlan) WlanAcctServerArrayOutput { return v.AcctServers }).(WlanAcctServerArrayOutput)
}

// Airwatch wlan settings
func (o WlanOutput) Airwatch() WlanAirwatchOutput {
	return o.ApplyT(func(v *Wlan) WlanAirwatchOutput { return v.Airwatch }).(WlanAirwatchOutput)
}

// Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
func (o WlanOutput) AllowIpv6Ndp() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.AllowIpv6Ndp }).(pulumi.BoolOutput)
}

// Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
func (o WlanOutput) AllowMdns() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.AllowMdns }).(pulumi.BoolOutput)
}

// Only applicable when `limitBcast`==`true`, which allows SSDP
func (o WlanOutput) AllowSsdp() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.AllowSsdp }).(pulumi.BoolOutput)
}

// List of device ids
func (o WlanOutput) ApIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.ApIds }).(pulumi.StringArrayOutput)
}

// Bandwidth limiting for apps (applies to up/down)
func (o WlanOutput) AppLimit() WlanAppLimitOutput {
	return o.ApplyT(func(v *Wlan) WlanAppLimitOutput { return v.AppLimit }).(WlanAppLimitOutput)
}

// APp qos wlan settings
func (o WlanOutput) AppQos() WlanAppQosOutput {
	return o.ApplyT(func(v *Wlan) WlanAppQosOutput { return v.AppQos }).(WlanAppQosOutput)
}

// enum: `aps`, `site`, `wxtags`
func (o WlanOutput) ApplyTo() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.ApplyTo }).(pulumi.StringOutput)
}

// Whether to enable smart arp filter
func (o WlanOutput) ArpFilter() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.ArpFilter }).(pulumi.BoolOutput)
}

// Authentication wlan settings
func (o WlanOutput) Auth() WlanAuthPtrOutput {
	return o.ApplyT(func(v *Wlan) WlanAuthPtrOutput { return v.Auth }).(WlanAuthPtrOutput)
}

// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
func (o WlanOutput) AuthServerSelection() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.AuthServerSelection }).(pulumi.StringOutput)
}

// List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
// is treated as primary
func (o WlanOutput) AuthServers() WlanAuthServerArrayOutput {
	return o.ApplyT(func(v *Wlan) WlanAuthServerArrayOutput { return v.AuthServers }).(WlanAuthServerArrayOutput)
}

// Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
func (o WlanOutput) AuthServersNasId() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.AuthServersNasId }).(pulumi.StringOutput)
}

// Optional, NAS-IP-ADDRESS to use
func (o WlanOutput) AuthServersNasIp() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.AuthServersNasIp }).(pulumi.StringOutput)
}

// Radius auth session retries. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘retries’ are set
// to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default
// value to 3.
func (o WlanOutput) AuthServersRetries() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.AuthServersRetries }).(pulumi.IntOutput)
}

// Radius auth session timeout. Following fast timers are set if "fastDot1xTimers" knob is enabled. ‘quite-period’ and
// ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
// setting authServersTimeout and is set to default value of 10.
func (o WlanOutput) AuthServersTimeout() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.AuthServersTimeout }).(pulumi.IntOutput)
}

// Whether to enable band_steering, this works only when band==both
func (o WlanOutput) BandSteer() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.BandSteer }).(pulumi.BoolOutput)
}

// Force dualBand capable client to connect to 5G
func (o WlanOutput) BandSteerForceBand5() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.BandSteerForceBand5 }).(pulumi.BoolOutput)
}

// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
func (o WlanOutput) Bands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.Bands }).(pulumi.StringArrayOutput)
}

// Whether to block the clients in the blacklist (up to first 256 macs)
func (o WlanOutput) BlockBlacklistClients() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.BlockBlacklistClients }).(pulumi.BoolOutput)
}

// Bonjour gateway wlan settings
func (o WlanOutput) Bonjour() WlanBonjourOutput {
	return o.ApplyT(func(v *Wlan) WlanBonjourOutput { return v.Bonjour }).(WlanBonjourOutput)
}

// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
func (o WlanOutput) CiscoCwa() WlanCiscoCwaOutput {
	return o.ApplyT(func(v *Wlan) WlanCiscoCwaOutput { return v.CiscoCwa }).(WlanCiscoCwaOutput)
}

// In kbps
func (o WlanOutput) ClientLimitDown() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.ClientLimitDown }).(pulumi.IntOutput)
}

// If downlink limiting per-client is enabled
func (o WlanOutput) ClientLimitDownEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.ClientLimitDownEnabled }).(pulumi.BoolOutput)
}

// In kbps
func (o WlanOutput) ClientLimitUp() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.ClientLimitUp }).(pulumi.IntOutput)
}

// If uplink limiting per-client is enabled
func (o WlanOutput) ClientLimitUpEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.ClientLimitUpEnabled }).(pulumi.BoolOutput)
}

// List of COA (change of authorization) servers, optional
func (o WlanOutput) CoaServers() WlanCoaServerArrayOutput {
	return o.ApplyT(func(v *Wlan) WlanCoaServerArrayOutput { return v.CoaServers }).(WlanCoaServerArrayOutput)
}

// Some old WLAN drivers may not be compatible
func (o WlanOutput) Disable11ax() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.Disable11ax }).(pulumi.BoolOutput)
}

// To disable Wi-Fi 7 EHT IEs
func (o WlanOutput) Disable11be() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.Disable11be }).(pulumi.BoolOutput)
}

// To disable ht or vht rates
func (o WlanOutput) DisableHtVhtRates() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.DisableHtVhtRates }).(pulumi.BoolOutput)
}

// Whether to disable U-APSD
func (o WlanOutput) DisableUapsd() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.DisableUapsd }).(pulumi.BoolOutput)
}

// Disable sending v2 roam notification messages
func (o WlanOutput) DisableV1RoamNotify() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.DisableV1RoamNotify }).(pulumi.BoolOutput)
}

// Disable sending v2 roam notification messages
func (o WlanOutput) DisableV2RoamNotify() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.DisableV2RoamNotify }).(pulumi.BoolOutput)
}

// When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
// reach default gateway
func (o WlanOutput) DisableWhenGatewayUnreachable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolPtrOutput { return v.DisableWhenGatewayUnreachable }).(pulumi.BoolPtrOutput)
}

func (o WlanOutput) DisableWhenMxtunnelDown() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolPtrOutput { return v.DisableWhenMxtunnelDown }).(pulumi.BoolPtrOutput)
}

// Whether to disable WMM
func (o WlanOutput) DisableWmm() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.DisableWmm }).(pulumi.BoolOutput)
}

// For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
func (o WlanOutput) DnsServerRewrite() WlanDnsServerRewriteOutput {
	return o.ApplyT(func(v *Wlan) WlanDnsServerRewriteOutput { return v.DnsServerRewrite }).(WlanDnsServerRewriteOutput)
}

func (o WlanOutput) Dtim() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.Dtim }).(pulumi.IntOutput)
}

// For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on
// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
// AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed) * AP sends BSSID:SSID as
// Caller-Station-ID * `authServers` is required * PSK will come from cloud WLC if source is cloudPsks * defaultPsk will be
// used if cloud WLC is not available * `multiPskOnly` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for now,
// wpa3 support on the roadmap)
func (o WlanOutput) DynamicPsk() WlanDynamicPskPtrOutput {
	return o.ApplyT(func(v *Wlan) WlanDynamicPskPtrOutput { return v.DynamicPsk }).(WlanDynamicPskPtrOutput)
}

// For 802.1x
func (o WlanOutput) DynamicVlan() WlanDynamicVlanPtrOutput {
	return o.ApplyT(func(v *Wlan) WlanDynamicVlanPtrOutput { return v.DynamicVlan }).(WlanDynamicVlanPtrOutput)
}

// Enable AP-AP keycaching via multicast
func (o WlanOutput) EnableLocalKeycaching() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.EnableLocalKeycaching }).(pulumi.BoolOutput)
}

// By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
// client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
func (o WlanOutput) EnableWirelessBridging() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.EnableWirelessBridging }).(pulumi.BoolOutput)
}

// If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response
// packets to be forwarded to wireless
func (o WlanOutput) EnableWirelessBridgingDhcpTracking() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.EnableWirelessBridgingDhcpTracking }).(pulumi.BoolOutput)
}

// If this wlan is enabled
func (o WlanOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
// ‘auth_server_retries’ .
func (o WlanOutput) FastDot1xTimers() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.FastDot1xTimers }).(pulumi.BoolOutput)
}

// Whether to hide SSID in beacon
func (o WlanOutput) HideSsid() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.HideSsid }).(pulumi.BoolOutput)
}

// Include hostname inside IE in AP beacons / probe responses
func (o WlanOutput) HostnameIe() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.HostnameIe }).(pulumi.BoolOutput)
}

// Hostspot 2.0 wlan settings
func (o WlanOutput) Hotspot20() WlanHotspot20Output {
	return o.ApplyT(func(v *Wlan) WlanHotspot20Output { return v.Hotspot20 }).(WlanHotspot20Output)
}

func (o WlanOutput) InjectDhcpOption82() WlanInjectDhcpOption82PtrOutput {
	return o.ApplyT(func(v *Wlan) WlanInjectDhcpOption82PtrOutput { return v.InjectDhcpOption82 }).(WlanInjectDhcpOption82PtrOutput)
}

// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
func (o WlanOutput) Interface() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.Interface }).(pulumi.StringOutput)
}

// Whether to stop clients to talk to each other
func (o WlanOutput) Isolation() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.Isolation }).(pulumi.BoolOutput)
}

// If isolation is enabled, whether to deny clients to talk to L2 on the LAN
func (o WlanOutput) L2Isolation() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.L2Isolation }).(pulumi.BoolOutput)
}

// Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
// Enabling this will cause problem for iOS devices.
func (o WlanOutput) LegacyOverds() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.LegacyOverds }).(pulumi.BoolOutput)
}

// Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
func (o WlanOutput) LimitBcast() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.LimitBcast }).(pulumi.BoolOutput)
}

// Limit probe response base on some heuristic rules
func (o WlanOutput) LimitProbeResponse() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.LimitProbeResponse }).(pulumi.BoolOutput)
}

// Max idle time in seconds
func (o WlanOutput) MaxIdletime() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.MaxIdletime }).(pulumi.IntOutput)
}

// Maximum number of client connected to the SSID. `0` means unlimited
func (o WlanOutput) MaxNumClients() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.MaxNumClients }).(pulumi.IntOutput)
}

func (o WlanOutput) MistNac() WlanMistNacOutput {
	return o.ApplyT(func(v *Wlan) WlanMistNacOutput { return v.MistNac }).(WlanMistNacOutput)
}

func (o WlanOutput) MspId() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.MspId }).(pulumi.StringOutput)
}

// When `interface`=`mxtunnel`, id of the Mist Tunnel
func (o WlanOutput) MxtunnelIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.MxtunnelIds }).(pulumi.StringArrayOutput)
}

// When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
func (o WlanOutput) MxtunnelNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.MxtunnelNames }).(pulumi.StringArrayOutput)
}

// Whether to only allow client to use DNS that we’ve learned from DHCP response
func (o WlanOutput) NoStaticDns() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.NoStaticDns }).(pulumi.BoolOutput)
}

// Whether to only allow client that we’ve learned from DHCP exchange to talk
func (o WlanOutput) NoStaticIp() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.NoStaticIp }).(pulumi.BoolOutput)
}

func (o WlanOutput) OrgId() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.OrgId }).(pulumi.StringOutput)
}

// Portal wlan settings
func (o WlanOutput) Portal() WlanPortalOutput {
	return o.ApplyT(func(v *Wlan) WlanPortalOutput { return v.Portal }).(WlanPortalOutput)
}

// List of hostnames without http(s):// (matched by substring)
func (o WlanOutput) PortalAllowedHostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.PortalAllowedHostnames }).(pulumi.StringArrayOutput)
}

// List of CIDRs
func (o WlanOutput) PortalAllowedSubnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.PortalAllowedSubnets }).(pulumi.StringArrayOutput)
}

// APi secret (auto-generated) that can be used to sign guest authorization requests
func (o WlanOutput) PortalApiSecret() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.PortalApiSecret }).(pulumi.StringOutput)
}

// List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
func (o WlanOutput) PortalDeniedHostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.PortalDeniedHostnames }).(pulumi.StringArrayOutput)
}

// Url of portal background image
func (o WlanOutput) PortalImage() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.PortalImage }).(pulumi.StringOutput)
}

func (o WlanOutput) PortalSsoUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.PortalSsoUrl }).(pulumi.StringOutput)
}

func (o WlanOutput) Qos() WlanQosOutput {
	return o.ApplyT(func(v *Wlan) WlanQosOutput { return v.Qos }).(WlanQosOutput)
}

// RadSec settings
func (o WlanOutput) Radsec() WlanRadsecOutput {
	return o.ApplyT(func(v *Wlan) WlanRadsecOutput { return v.Radsec }).(WlanRadsecOutput)
}

// Property key is the RF band. enum: `24`, `5`, `6`
func (o WlanOutput) Rateset() WlanRatesetMapOutput {
	return o.ApplyT(func(v *Wlan) WlanRatesetMapOutput { return v.Rateset }).(WlanRatesetMapOutput)
}

// When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
func (o WlanOutput) ReconnectClientsWhenRoamingMxcluster() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolPtrOutput { return v.ReconnectClientsWhenRoamingMxcluster }).(pulumi.BoolPtrOutput)
}

// enum: `11r`, `OKC`, `NONE`
func (o WlanOutput) RoamMode() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.RoamMode }).(pulumi.StringOutput)
}

// WLAN operating schedule, default is disabled
func (o WlanOutput) Schedule() WlanScheduleOutput {
	return o.ApplyT(func(v *Wlan) WlanScheduleOutput { return v.Schedule }).(WlanScheduleOutput)
}

func (o WlanOutput) SiteId() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.SiteId }).(pulumi.StringOutput)
}

// Whether to exclude this WLAN from SLE metrics
func (o WlanOutput) SleExcluded() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.SleExcluded }).(pulumi.BoolOutput)
}

// Name of the SSID
func (o WlanOutput) Ssid() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.Ssid }).(pulumi.StringOutput)
}

// If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
func (o WlanOutput) UseEapolV1() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.UseEapolV1 }).(pulumi.BoolOutput)
}

// If vlan tagging is enabled
func (o WlanOutput) VlanEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.VlanEnabled }).(pulumi.BoolOutput)
}

func (o WlanOutput) VlanId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringPtrOutput { return v.VlanId }).(pulumi.StringPtrOutput)
}

// if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
func (o WlanOutput) VlanIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.VlanIds }).(pulumi.StringArrayOutput)
}

// Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
// deterministic algorithm
func (o WlanOutput) VlanPooling() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.VlanPooling }).(pulumi.BoolOutput)
}

// In kbps
func (o WlanOutput) WlanLimitDown() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.WlanLimitDown }).(pulumi.IntOutput)
}

// If downlink limiting for whole wlan is enabled
func (o WlanOutput) WlanLimitDownEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.WlanLimitDownEnabled }).(pulumi.BoolOutput)
}

// In kbps
func (o WlanOutput) WlanLimitUp() pulumi.IntOutput {
	return o.ApplyT(func(v *Wlan) pulumi.IntOutput { return v.WlanLimitUp }).(pulumi.IntOutput)
}

// If uplink limiting for whole wlan is enabled
func (o WlanOutput) WlanLimitUpEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Wlan) pulumi.BoolOutput { return v.WlanLimitUpEnabled }).(pulumi.BoolOutput)
}

// List of wxtag_ids
func (o WlanOutput) WxtagIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringArrayOutput { return v.WxtagIds }).(pulumi.StringArrayOutput)
}

// When `interface`=`wxtunnel`, id of the WXLAN Tunnel
func (o WlanOutput) WxtunnelId() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.WxtunnelId }).(pulumi.StringOutput)
}

// When `interface`=`wxtunnel`, remote tunnel identifier
func (o WlanOutput) WxtunnelRemoteId() pulumi.StringOutput {
	return o.ApplyT(func(v *Wlan) pulumi.StringOutput { return v.WxtunnelRemoteId }).(pulumi.StringOutput)
}

type WlanArrayOutput struct{ *pulumi.OutputState }

func (WlanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Wlan)(nil)).Elem()
}

func (o WlanArrayOutput) ToWlanArrayOutput() WlanArrayOutput {
	return o
}

func (o WlanArrayOutput) ToWlanArrayOutputWithContext(ctx context.Context) WlanArrayOutput {
	return o
}

func (o WlanArrayOutput) Index(i pulumi.IntInput) WlanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Wlan {
		return vs[0].([]*Wlan)[vs[1].(int)]
	}).(WlanOutput)
}

type WlanMapOutput struct{ *pulumi.OutputState }

func (WlanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Wlan)(nil)).Elem()
}

func (o WlanMapOutput) ToWlanMapOutput() WlanMapOutput {
	return o
}

func (o WlanMapOutput) ToWlanMapOutputWithContext(ctx context.Context) WlanMapOutput {
	return o
}

func (o WlanMapOutput) MapIndex(k pulumi.StringInput) WlanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Wlan {
		return vs[0].(map[string]*Wlan)[vs[1].(string)]
	}).(WlanOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*WlanInput)(nil)).Elem(), &Wlan{})
	pulumi.RegisterInputType(reflect.TypeOf((*WlanArrayInput)(nil)).Elem(), WlanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WlanMapInput)(nil)).Elem(), WlanMap{})
	pulumi.RegisterOutputType(WlanOutput{})
	pulumi.RegisterOutputType(WlanArrayOutput{})
	pulumi.RegisterOutputType(WlanMapOutput{})
}
