// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package org

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-junipermist/sdk/go/junipermist/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource manages Org SSO Configuration.
//
// Org SSO, or Single Sign-On, is a method of authentication that allows users to securely log in to multiple applications and websites with a single set of login credentials.\
// It involves integrating the Org portal with an Identity Provider (IdP) using the Security Assertion Markup Language (SAML) framework.\
// This enables users to authenticate themselves through their corporate IdP, eliminating the need to remember separate passwords or enter credentials each time they access the Org portal.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-junipermist/sdk/go/junipermist/org"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := org.NewSso(ctx, "sso_admin_one", &org.SsoArgs{
//				OrgId:           pulumi.Any(terraformTest.Id),
//				Name:            pulumi.String("sso_admin_one"),
//				CustomLogoutUrl: pulumi.String("https://idp.com/logout"),
//				IdpCert:         pulumi.String("-----BEGIN CERTIFICATE-----MIIF0jC .../fSCGx7-----END CERTIFICATE-----"),
//				IdpSignAlgo:     pulumi.String("sha512"),
//				IdpSsoUrl:       pulumi.String("https://idp.com/login"),
//				Issuer:          pulumi.String("my_idp_issuer"),
//				NameidFormat:    pulumi.String("email"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Using `pulumi import`, import `mist_org_sso` with:
//
// Org PSK can be imported by specifying the org_id and the sso_id
//
// ```sh
// $ pulumi import junipermist:org/sso:Sso sso_admin_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
// ```
type Sso struct {
	pulumi.CustomResourceState

	// a URL we will redirect the user after user logout from Mist (for some IdP which supports a custom logout URL that is different from SP-initiated SLO process)
	CustomLogoutUrl pulumi.StringPtrOutput `pulumi:"customLogoutUrl"`
	// default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
	DefaultRole pulumi.StringPtrOutput `pulumi:"defaultRole"`
	// Random string generated during the SSO creation and used to generate the SAML URLs:
	//   * ACS URL = `/api/v1/saml/{domain}/login` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/login`)
	//   * Single Logout URL = `/api/v1/saml/{domain}/logout` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/logout`)
	Domain pulumi.StringOutput `pulumi:"domain"`
	// IDP Cert (used to verify the signed response)
	IdpCert pulumi.StringOutput `pulumi:"idpCert"`
	// Signing algorithm for SAML Assertion. enum `sha1`, `sha256`, `sha384`, `sha512`
	IdpSignAlgo pulumi.StringOutput `pulumi:"idpSignAlgo"`
	// IDP Single-Sign-On URL
	IdpSsoUrl pulumi.StringOutput `pulumi:"idpSsoUrl"`
	// ignore any unmatched roles provided in assertion. By default, an assertion is treated as invalid for any unmatched role
	IgnoreUnmatchedRoles pulumi.BoolPtrOutput `pulumi:"ignoreUnmatchedRoles"`
	// IDP issuer URL
	Issuer pulumi.StringOutput `pulumi:"issuer"`
	// Name
	Name pulumi.StringOutput `pulumi:"name"`
	// enum: `email`, `unspecified`
	NameidFormat pulumi.StringOutput `pulumi:"nameidFormat"`
	OrgId        pulumi.StringOutput `pulumi:"orgId"`
	// custom role attribute parsing scheme. Supported Role Parsing Schemes <table><tr><th>Name</th><th>Scheme</th></tr><tr><td>`cn`</td><td><ul><li>The expected role attribute format in SAML Assertion is “CN=cn,OU=ou1,OU=ou2,…”</li><li>CN (the key) is case insensitive and exactly 1 CN is expected (or the entire entry will be ignored)</li></ul>E.g. if role attribute is “CN=cn,OU=ou1,OU=ou2” then parsed role value is “cn”</td></tr></table>
	RoleAttrExtraction pulumi.StringPtrOutput `pulumi:"roleAttrExtraction"`
	// name of the attribute in SAML Assertion to extract role from. Default: `Role`
	RoleAttrFrom pulumi.StringOutput `pulumi:"roleAttrFrom"`
}

// NewSso registers a new resource with the given unique name, arguments, and options.
func NewSso(ctx *pulumi.Context,
	name string, args *SsoArgs, opts ...pulumi.ResourceOption) (*Sso, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IdpCert == nil {
		return nil, errors.New("invalid value for required argument 'IdpCert'")
	}
	if args.IdpSignAlgo == nil {
		return nil, errors.New("invalid value for required argument 'IdpSignAlgo'")
	}
	if args.IdpSsoUrl == nil {
		return nil, errors.New("invalid value for required argument 'IdpSsoUrl'")
	}
	if args.Issuer == nil {
		return nil, errors.New("invalid value for required argument 'Issuer'")
	}
	if args.OrgId == nil {
		return nil, errors.New("invalid value for required argument 'OrgId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Sso
	err := ctx.RegisterResource("junipermist:org/sso:Sso", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSso gets an existing Sso resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSso(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SsoState, opts ...pulumi.ResourceOption) (*Sso, error) {
	var resource Sso
	err := ctx.ReadResource("junipermist:org/sso:Sso", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Sso resources.
type ssoState struct {
	// a URL we will redirect the user after user logout from Mist (for some IdP which supports a custom logout URL that is different from SP-initiated SLO process)
	CustomLogoutUrl *string `pulumi:"customLogoutUrl"`
	// default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
	DefaultRole *string `pulumi:"defaultRole"`
	// Random string generated during the SSO creation and used to generate the SAML URLs:
	//   * ACS URL = `/api/v1/saml/{domain}/login` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/login`)
	//   * Single Logout URL = `/api/v1/saml/{domain}/logout` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/logout`)
	Domain *string `pulumi:"domain"`
	// IDP Cert (used to verify the signed response)
	IdpCert *string `pulumi:"idpCert"`
	// Signing algorithm for SAML Assertion. enum `sha1`, `sha256`, `sha384`, `sha512`
	IdpSignAlgo *string `pulumi:"idpSignAlgo"`
	// IDP Single-Sign-On URL
	IdpSsoUrl *string `pulumi:"idpSsoUrl"`
	// ignore any unmatched roles provided in assertion. By default, an assertion is treated as invalid for any unmatched role
	IgnoreUnmatchedRoles *bool `pulumi:"ignoreUnmatchedRoles"`
	// IDP issuer URL
	Issuer *string `pulumi:"issuer"`
	// Name
	Name *string `pulumi:"name"`
	// enum: `email`, `unspecified`
	NameidFormat *string `pulumi:"nameidFormat"`
	OrgId        *string `pulumi:"orgId"`
	// custom role attribute parsing scheme. Supported Role Parsing Schemes <table><tr><th>Name</th><th>Scheme</th></tr><tr><td>`cn`</td><td><ul><li>The expected role attribute format in SAML Assertion is “CN=cn,OU=ou1,OU=ou2,…”</li><li>CN (the key) is case insensitive and exactly 1 CN is expected (or the entire entry will be ignored)</li></ul>E.g. if role attribute is “CN=cn,OU=ou1,OU=ou2” then parsed role value is “cn”</td></tr></table>
	RoleAttrExtraction *string `pulumi:"roleAttrExtraction"`
	// name of the attribute in SAML Assertion to extract role from. Default: `Role`
	RoleAttrFrom *string `pulumi:"roleAttrFrom"`
}

type SsoState struct {
	// a URL we will redirect the user after user logout from Mist (for some IdP which supports a custom logout URL that is different from SP-initiated SLO process)
	CustomLogoutUrl pulumi.StringPtrInput
	// default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
	DefaultRole pulumi.StringPtrInput
	// Random string generated during the SSO creation and used to generate the SAML URLs:
	//   * ACS URL = `/api/v1/saml/{domain}/login` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/login`)
	//   * Single Logout URL = `/api/v1/saml/{domain}/logout` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/logout`)
	Domain pulumi.StringPtrInput
	// IDP Cert (used to verify the signed response)
	IdpCert pulumi.StringPtrInput
	// Signing algorithm for SAML Assertion. enum `sha1`, `sha256`, `sha384`, `sha512`
	IdpSignAlgo pulumi.StringPtrInput
	// IDP Single-Sign-On URL
	IdpSsoUrl pulumi.StringPtrInput
	// ignore any unmatched roles provided in assertion. By default, an assertion is treated as invalid for any unmatched role
	IgnoreUnmatchedRoles pulumi.BoolPtrInput
	// IDP issuer URL
	Issuer pulumi.StringPtrInput
	// Name
	Name pulumi.StringPtrInput
	// enum: `email`, `unspecified`
	NameidFormat pulumi.StringPtrInput
	OrgId        pulumi.StringPtrInput
	// custom role attribute parsing scheme. Supported Role Parsing Schemes <table><tr><th>Name</th><th>Scheme</th></tr><tr><td>`cn`</td><td><ul><li>The expected role attribute format in SAML Assertion is “CN=cn,OU=ou1,OU=ou2,…”</li><li>CN (the key) is case insensitive and exactly 1 CN is expected (or the entire entry will be ignored)</li></ul>E.g. if role attribute is “CN=cn,OU=ou1,OU=ou2” then parsed role value is “cn”</td></tr></table>
	RoleAttrExtraction pulumi.StringPtrInput
	// name of the attribute in SAML Assertion to extract role from. Default: `Role`
	RoleAttrFrom pulumi.StringPtrInput
}

func (SsoState) ElementType() reflect.Type {
	return reflect.TypeOf((*ssoState)(nil)).Elem()
}

type ssoArgs struct {
	// a URL we will redirect the user after user logout from Mist (for some IdP which supports a custom logout URL that is different from SP-initiated SLO process)
	CustomLogoutUrl *string `pulumi:"customLogoutUrl"`
	// default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
	DefaultRole *string `pulumi:"defaultRole"`
	// IDP Cert (used to verify the signed response)
	IdpCert string `pulumi:"idpCert"`
	// Signing algorithm for SAML Assertion. enum `sha1`, `sha256`, `sha384`, `sha512`
	IdpSignAlgo string `pulumi:"idpSignAlgo"`
	// IDP Single-Sign-On URL
	IdpSsoUrl string `pulumi:"idpSsoUrl"`
	// ignore any unmatched roles provided in assertion. By default, an assertion is treated as invalid for any unmatched role
	IgnoreUnmatchedRoles *bool `pulumi:"ignoreUnmatchedRoles"`
	// IDP issuer URL
	Issuer string `pulumi:"issuer"`
	// Name
	Name *string `pulumi:"name"`
	// enum: `email`, `unspecified`
	NameidFormat *string `pulumi:"nameidFormat"`
	OrgId        string  `pulumi:"orgId"`
	// custom role attribute parsing scheme. Supported Role Parsing Schemes <table><tr><th>Name</th><th>Scheme</th></tr><tr><td>`cn`</td><td><ul><li>The expected role attribute format in SAML Assertion is “CN=cn,OU=ou1,OU=ou2,…”</li><li>CN (the key) is case insensitive and exactly 1 CN is expected (or the entire entry will be ignored)</li></ul>E.g. if role attribute is “CN=cn,OU=ou1,OU=ou2” then parsed role value is “cn”</td></tr></table>
	RoleAttrExtraction *string `pulumi:"roleAttrExtraction"`
	// name of the attribute in SAML Assertion to extract role from. Default: `Role`
	RoleAttrFrom *string `pulumi:"roleAttrFrom"`
}

// The set of arguments for constructing a Sso resource.
type SsoArgs struct {
	// a URL we will redirect the user after user logout from Mist (for some IdP which supports a custom logout URL that is different from SP-initiated SLO process)
	CustomLogoutUrl pulumi.StringPtrInput
	// default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
	DefaultRole pulumi.StringPtrInput
	// IDP Cert (used to verify the signed response)
	IdpCert pulumi.StringInput
	// Signing algorithm for SAML Assertion. enum `sha1`, `sha256`, `sha384`, `sha512`
	IdpSignAlgo pulumi.StringInput
	// IDP Single-Sign-On URL
	IdpSsoUrl pulumi.StringInput
	// ignore any unmatched roles provided in assertion. By default, an assertion is treated as invalid for any unmatched role
	IgnoreUnmatchedRoles pulumi.BoolPtrInput
	// IDP issuer URL
	Issuer pulumi.StringInput
	// Name
	Name pulumi.StringPtrInput
	// enum: `email`, `unspecified`
	NameidFormat pulumi.StringPtrInput
	OrgId        pulumi.StringInput
	// custom role attribute parsing scheme. Supported Role Parsing Schemes <table><tr><th>Name</th><th>Scheme</th></tr><tr><td>`cn`</td><td><ul><li>The expected role attribute format in SAML Assertion is “CN=cn,OU=ou1,OU=ou2,…”</li><li>CN (the key) is case insensitive and exactly 1 CN is expected (or the entire entry will be ignored)</li></ul>E.g. if role attribute is “CN=cn,OU=ou1,OU=ou2” then parsed role value is “cn”</td></tr></table>
	RoleAttrExtraction pulumi.StringPtrInput
	// name of the attribute in SAML Assertion to extract role from. Default: `Role`
	RoleAttrFrom pulumi.StringPtrInput
}

func (SsoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ssoArgs)(nil)).Elem()
}

type SsoInput interface {
	pulumi.Input

	ToSsoOutput() SsoOutput
	ToSsoOutputWithContext(ctx context.Context) SsoOutput
}

func (*Sso) ElementType() reflect.Type {
	return reflect.TypeOf((**Sso)(nil)).Elem()
}

func (i *Sso) ToSsoOutput() SsoOutput {
	return i.ToSsoOutputWithContext(context.Background())
}

func (i *Sso) ToSsoOutputWithContext(ctx context.Context) SsoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SsoOutput)
}

// SsoArrayInput is an input type that accepts SsoArray and SsoArrayOutput values.
// You can construct a concrete instance of `SsoArrayInput` via:
//
//	SsoArray{ SsoArgs{...} }
type SsoArrayInput interface {
	pulumi.Input

	ToSsoArrayOutput() SsoArrayOutput
	ToSsoArrayOutputWithContext(context.Context) SsoArrayOutput
}

type SsoArray []SsoInput

func (SsoArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sso)(nil)).Elem()
}

func (i SsoArray) ToSsoArrayOutput() SsoArrayOutput {
	return i.ToSsoArrayOutputWithContext(context.Background())
}

func (i SsoArray) ToSsoArrayOutputWithContext(ctx context.Context) SsoArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SsoArrayOutput)
}

// SsoMapInput is an input type that accepts SsoMap and SsoMapOutput values.
// You can construct a concrete instance of `SsoMapInput` via:
//
//	SsoMap{ "key": SsoArgs{...} }
type SsoMapInput interface {
	pulumi.Input

	ToSsoMapOutput() SsoMapOutput
	ToSsoMapOutputWithContext(context.Context) SsoMapOutput
}

type SsoMap map[string]SsoInput

func (SsoMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sso)(nil)).Elem()
}

func (i SsoMap) ToSsoMapOutput() SsoMapOutput {
	return i.ToSsoMapOutputWithContext(context.Background())
}

func (i SsoMap) ToSsoMapOutputWithContext(ctx context.Context) SsoMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SsoMapOutput)
}

type SsoOutput struct{ *pulumi.OutputState }

func (SsoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sso)(nil)).Elem()
}

func (o SsoOutput) ToSsoOutput() SsoOutput {
	return o
}

func (o SsoOutput) ToSsoOutputWithContext(ctx context.Context) SsoOutput {
	return o
}

// a URL we will redirect the user after user logout from Mist (for some IdP which supports a custom logout URL that is different from SP-initiated SLO process)
func (o SsoOutput) CustomLogoutUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringPtrOutput { return v.CustomLogoutUrl }).(pulumi.StringPtrOutput)
}

// default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
func (o SsoOutput) DefaultRole() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringPtrOutput { return v.DefaultRole }).(pulumi.StringPtrOutput)
}

// Random string generated during the SSO creation and used to generate the SAML URLs:
//   - ACS URL = `/api/v1/saml/{domain}/login` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/login`)
//   - Single Logout URL = `/api/v1/saml/{domain}/logout` (e.g. `https://api.mist.com/api/v1/saml/s4t5vwv8/logout`)
func (o SsoOutput) Domain() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.Domain }).(pulumi.StringOutput)
}

// IDP Cert (used to verify the signed response)
func (o SsoOutput) IdpCert() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.IdpCert }).(pulumi.StringOutput)
}

// Signing algorithm for SAML Assertion. enum `sha1`, `sha256`, `sha384`, `sha512`
func (o SsoOutput) IdpSignAlgo() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.IdpSignAlgo }).(pulumi.StringOutput)
}

// IDP Single-Sign-On URL
func (o SsoOutput) IdpSsoUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.IdpSsoUrl }).(pulumi.StringOutput)
}

// ignore any unmatched roles provided in assertion. By default, an assertion is treated as invalid for any unmatched role
func (o SsoOutput) IgnoreUnmatchedRoles() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Sso) pulumi.BoolPtrOutput { return v.IgnoreUnmatchedRoles }).(pulumi.BoolPtrOutput)
}

// IDP issuer URL
func (o SsoOutput) Issuer() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.Issuer }).(pulumi.StringOutput)
}

// Name
func (o SsoOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// enum: `email`, `unspecified`
func (o SsoOutput) NameidFormat() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.NameidFormat }).(pulumi.StringOutput)
}

func (o SsoOutput) OrgId() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.OrgId }).(pulumi.StringOutput)
}

// custom role attribute parsing scheme. Supported Role Parsing Schemes <table><tr><th>Name</th><th>Scheme</th></tr><tr><td>`cn`</td><td><ul><li>The expected role attribute format in SAML Assertion is “CN=cn,OU=ou1,OU=ou2,…”</li><li>CN (the key) is case insensitive and exactly 1 CN is expected (or the entire entry will be ignored)</li></ul>E.g. if role attribute is “CN=cn,OU=ou1,OU=ou2” then parsed role value is “cn”</td></tr></table>
func (o SsoOutput) RoleAttrExtraction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringPtrOutput { return v.RoleAttrExtraction }).(pulumi.StringPtrOutput)
}

// name of the attribute in SAML Assertion to extract role from. Default: `Role`
func (o SsoOutput) RoleAttrFrom() pulumi.StringOutput {
	return o.ApplyT(func(v *Sso) pulumi.StringOutput { return v.RoleAttrFrom }).(pulumi.StringOutput)
}

type SsoArrayOutput struct{ *pulumi.OutputState }

func (SsoArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sso)(nil)).Elem()
}

func (o SsoArrayOutput) ToSsoArrayOutput() SsoArrayOutput {
	return o
}

func (o SsoArrayOutput) ToSsoArrayOutputWithContext(ctx context.Context) SsoArrayOutput {
	return o
}

func (o SsoArrayOutput) Index(i pulumi.IntInput) SsoOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Sso {
		return vs[0].([]*Sso)[vs[1].(int)]
	}).(SsoOutput)
}

type SsoMapOutput struct{ *pulumi.OutputState }

func (SsoMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sso)(nil)).Elem()
}

func (o SsoMapOutput) ToSsoMapOutput() SsoMapOutput {
	return o
}

func (o SsoMapOutput) ToSsoMapOutputWithContext(ctx context.Context) SsoMapOutput {
	return o
}

func (o SsoMapOutput) MapIndex(k pulumi.StringInput) SsoOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Sso {
		return vs[0].(map[string]*Sso)[vs[1].(string)]
	}).(SsoOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SsoInput)(nil)).Elem(), &Sso{})
	pulumi.RegisterInputType(reflect.TypeOf((*SsoArrayInput)(nil)).Elem(), SsoArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SsoMapInput)(nil)).Elem(), SsoMap{})
	pulumi.RegisterOutputType(SsoOutput{})
	pulumi.RegisterOutputType(SsoArrayOutput{})
	pulumi.RegisterOutputType(SsoMapOutput{})
}
