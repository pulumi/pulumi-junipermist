// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package junipermist

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-junipermist/sdk/go/junipermist/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource can be used to upgrade the firmware of a single device (Wi-Fi Access Points, Switches and SRX/SSR Gateways).
//
// The resource will send the upgrade command to Mist, which will take care of deploying the new firmware version to the device, and reboot it if required.
//
// The time required to upgrade a device depends on the type of device and its hardware. By default, the resource will track the upgrade process and only return the result once the device is upgraded and rebooted (unless `reboot`==`false` or `rebootAt` is set).\
// If required it is possible to run the upgrade in async mode (attribute `sync`=`false`). In this case, the resource will only trigger the upgrade and return the Mist response, but will not track the upgrade progress.
//
// The list of available firmware versions can be retrieved with the `device.getVersions` data source.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-junipermist/sdk/go/junipermist"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := junipermist.NewUpgradeDevice(ctx, "ap_upgrade", &junipermist.UpgradeDeviceArgs{
//				SiteId:        pulumi.Any(terraformTest.Id),
//				DeviceId:      pulumi.Any(apOne.Id),
//				TargetVersion: pulumi.String("0.14.29543"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = junipermist.NewUpgradeDevice(ctx, "switch_upgrade", &junipermist.UpgradeDeviceArgs{
//				SiteId:             pulumi.Any(terraformTest.Id),
//				DeviceId:           pulumi.Any(switchOne.Id),
//				TargetVersion:      pulumi.String("24.2R1-S1.10"),
//				Reboot:             pulumi.Bool(true),
//				SyncUpgradeTimeout: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type UpgradeDevice struct {
	pulumi.CustomResourceState

	DeviceId pulumi.StringOutput `pulumi:"deviceId"`
	// current device firmware version
	DeviceVersion pulumi.StringOutput         `pulumi:"deviceVersion"`
	Fwupdate      UpgradeDeviceFwupdateOutput `pulumi:"fwupdate"`
	// For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
	Reboot pulumi.BoolOutput `pulumi:"reboot"`
	// For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
	RebootAt pulumi.IntPtrOutput `pulumi:"rebootAt"`
	SiteId   pulumi.StringOutput `pulumi:"siteId"`
	// For Junos devices only. Perform recovery snapshot after device is rebooted
	Snapshot pulumi.BoolOutput `pulumi:"snapshot"`
	// Firmware download start time in epoch
	StartTime pulumi.IntPtrOutput `pulumi:"startTime"`
	// enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
	Status pulumi.StringOutput `pulumi:"status"`
	// if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
	SyncUpgrade pulumi.BoolOutput `pulumi:"syncUpgrade"`
	// if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
	SyncUpgradeRefreshInterval pulumi.IntOutput `pulumi:"syncUpgradeRefreshInterval"`
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
	SyncUpgradeStartTimeout pulumi.IntOutput `pulumi:"syncUpgradeStartTimeout"`
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
	SyncUpgradeTimeout pulumi.IntOutput `pulumi:"syncUpgradeTimeout"`
	// firmware version to deploy to the device. Use the `device.getVersions` datasource to get the list of available firmware versions
	TargetVersion pulumi.StringOutput `pulumi:"targetVersion"`
	// Epoch (seconds)
	Timestamp pulumi.Float64Output `pulumi:"timestamp"`
}

// NewUpgradeDevice registers a new resource with the given unique name, arguments, and options.
func NewUpgradeDevice(ctx *pulumi.Context,
	name string, args *UpgradeDeviceArgs, opts ...pulumi.ResourceOption) (*UpgradeDevice, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DeviceId == nil {
		return nil, errors.New("invalid value for required argument 'DeviceId'")
	}
	if args.SiteId == nil {
		return nil, errors.New("invalid value for required argument 'SiteId'")
	}
	if args.TargetVersion == nil {
		return nil, errors.New("invalid value for required argument 'TargetVersion'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UpgradeDevice
	err := ctx.RegisterResource("junipermist:index/upgradeDevice:UpgradeDevice", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUpgradeDevice gets an existing UpgradeDevice resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUpgradeDevice(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UpgradeDeviceState, opts ...pulumi.ResourceOption) (*UpgradeDevice, error) {
	var resource UpgradeDevice
	err := ctx.ReadResource("junipermist:index/upgradeDevice:UpgradeDevice", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UpgradeDevice resources.
type upgradeDeviceState struct {
	DeviceId *string `pulumi:"deviceId"`
	// current device firmware version
	DeviceVersion *string                `pulumi:"deviceVersion"`
	Fwupdate      *UpgradeDeviceFwupdate `pulumi:"fwupdate"`
	// For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
	Reboot *bool `pulumi:"reboot"`
	// For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
	RebootAt *int    `pulumi:"rebootAt"`
	SiteId   *string `pulumi:"siteId"`
	// For Junos devices only. Perform recovery snapshot after device is rebooted
	Snapshot *bool `pulumi:"snapshot"`
	// Firmware download start time in epoch
	StartTime *int `pulumi:"startTime"`
	// enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
	Status *string `pulumi:"status"`
	// if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
	SyncUpgrade *bool `pulumi:"syncUpgrade"`
	// if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
	SyncUpgradeRefreshInterval *int `pulumi:"syncUpgradeRefreshInterval"`
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
	SyncUpgradeStartTimeout *int `pulumi:"syncUpgradeStartTimeout"`
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
	SyncUpgradeTimeout *int `pulumi:"syncUpgradeTimeout"`
	// firmware version to deploy to the device. Use the `device.getVersions` datasource to get the list of available firmware versions
	TargetVersion *string `pulumi:"targetVersion"`
	// Epoch (seconds)
	Timestamp *float64 `pulumi:"timestamp"`
}

type UpgradeDeviceState struct {
	DeviceId pulumi.StringPtrInput
	// current device firmware version
	DeviceVersion pulumi.StringPtrInput
	Fwupdate      UpgradeDeviceFwupdatePtrInput
	// For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
	Reboot pulumi.BoolPtrInput
	// For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
	RebootAt pulumi.IntPtrInput
	SiteId   pulumi.StringPtrInput
	// For Junos devices only. Perform recovery snapshot after device is rebooted
	Snapshot pulumi.BoolPtrInput
	// Firmware download start time in epoch
	StartTime pulumi.IntPtrInput
	// enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
	Status pulumi.StringPtrInput
	// if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
	SyncUpgrade pulumi.BoolPtrInput
	// if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
	SyncUpgradeRefreshInterval pulumi.IntPtrInput
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
	SyncUpgradeStartTimeout pulumi.IntPtrInput
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
	SyncUpgradeTimeout pulumi.IntPtrInput
	// firmware version to deploy to the device. Use the `device.getVersions` datasource to get the list of available firmware versions
	TargetVersion pulumi.StringPtrInput
	// Epoch (seconds)
	Timestamp pulumi.Float64PtrInput
}

func (UpgradeDeviceState) ElementType() reflect.Type {
	return reflect.TypeOf((*upgradeDeviceState)(nil)).Elem()
}

type upgradeDeviceArgs struct {
	DeviceId string `pulumi:"deviceId"`
	// For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
	Reboot *bool `pulumi:"reboot"`
	// For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
	RebootAt *int   `pulumi:"rebootAt"`
	SiteId   string `pulumi:"siteId"`
	// For Junos devices only. Perform recovery snapshot after device is rebooted
	Snapshot *bool `pulumi:"snapshot"`
	// Firmware download start time in epoch
	StartTime *int `pulumi:"startTime"`
	// if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
	SyncUpgrade *bool `pulumi:"syncUpgrade"`
	// if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
	SyncUpgradeRefreshInterval *int `pulumi:"syncUpgradeRefreshInterval"`
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
	SyncUpgradeStartTimeout *int `pulumi:"syncUpgradeStartTimeout"`
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
	SyncUpgradeTimeout *int `pulumi:"syncUpgradeTimeout"`
	// firmware version to deploy to the device. Use the `device.getVersions` datasource to get the list of available firmware versions
	TargetVersion string `pulumi:"targetVersion"`
}

// The set of arguments for constructing a UpgradeDevice resource.
type UpgradeDeviceArgs struct {
	DeviceId pulumi.StringInput
	// For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
	Reboot pulumi.BoolPtrInput
	// For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
	RebootAt pulumi.IntPtrInput
	SiteId   pulumi.StringInput
	// For Junos devices only. Perform recovery snapshot after device is rebooted
	Snapshot pulumi.BoolPtrInput
	// Firmware download start time in epoch
	StartTime pulumi.IntPtrInput
	// if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
	SyncUpgrade pulumi.BoolPtrInput
	// if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
	SyncUpgradeRefreshInterval pulumi.IntPtrInput
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
	SyncUpgradeStartTimeout pulumi.IntPtrInput
	// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
	SyncUpgradeTimeout pulumi.IntPtrInput
	// firmware version to deploy to the device. Use the `device.getVersions` datasource to get the list of available firmware versions
	TargetVersion pulumi.StringInput
}

func (UpgradeDeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*upgradeDeviceArgs)(nil)).Elem()
}

type UpgradeDeviceInput interface {
	pulumi.Input

	ToUpgradeDeviceOutput() UpgradeDeviceOutput
	ToUpgradeDeviceOutputWithContext(ctx context.Context) UpgradeDeviceOutput
}

func (*UpgradeDevice) ElementType() reflect.Type {
	return reflect.TypeOf((**UpgradeDevice)(nil)).Elem()
}

func (i *UpgradeDevice) ToUpgradeDeviceOutput() UpgradeDeviceOutput {
	return i.ToUpgradeDeviceOutputWithContext(context.Background())
}

func (i *UpgradeDevice) ToUpgradeDeviceOutputWithContext(ctx context.Context) UpgradeDeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UpgradeDeviceOutput)
}

// UpgradeDeviceArrayInput is an input type that accepts UpgradeDeviceArray and UpgradeDeviceArrayOutput values.
// You can construct a concrete instance of `UpgradeDeviceArrayInput` via:
//
//	UpgradeDeviceArray{ UpgradeDeviceArgs{...} }
type UpgradeDeviceArrayInput interface {
	pulumi.Input

	ToUpgradeDeviceArrayOutput() UpgradeDeviceArrayOutput
	ToUpgradeDeviceArrayOutputWithContext(context.Context) UpgradeDeviceArrayOutput
}

type UpgradeDeviceArray []UpgradeDeviceInput

func (UpgradeDeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UpgradeDevice)(nil)).Elem()
}

func (i UpgradeDeviceArray) ToUpgradeDeviceArrayOutput() UpgradeDeviceArrayOutput {
	return i.ToUpgradeDeviceArrayOutputWithContext(context.Background())
}

func (i UpgradeDeviceArray) ToUpgradeDeviceArrayOutputWithContext(ctx context.Context) UpgradeDeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UpgradeDeviceArrayOutput)
}

// UpgradeDeviceMapInput is an input type that accepts UpgradeDeviceMap and UpgradeDeviceMapOutput values.
// You can construct a concrete instance of `UpgradeDeviceMapInput` via:
//
//	UpgradeDeviceMap{ "key": UpgradeDeviceArgs{...} }
type UpgradeDeviceMapInput interface {
	pulumi.Input

	ToUpgradeDeviceMapOutput() UpgradeDeviceMapOutput
	ToUpgradeDeviceMapOutputWithContext(context.Context) UpgradeDeviceMapOutput
}

type UpgradeDeviceMap map[string]UpgradeDeviceInput

func (UpgradeDeviceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UpgradeDevice)(nil)).Elem()
}

func (i UpgradeDeviceMap) ToUpgradeDeviceMapOutput() UpgradeDeviceMapOutput {
	return i.ToUpgradeDeviceMapOutputWithContext(context.Background())
}

func (i UpgradeDeviceMap) ToUpgradeDeviceMapOutputWithContext(ctx context.Context) UpgradeDeviceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UpgradeDeviceMapOutput)
}

type UpgradeDeviceOutput struct{ *pulumi.OutputState }

func (UpgradeDeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UpgradeDevice)(nil)).Elem()
}

func (o UpgradeDeviceOutput) ToUpgradeDeviceOutput() UpgradeDeviceOutput {
	return o
}

func (o UpgradeDeviceOutput) ToUpgradeDeviceOutputWithContext(ctx context.Context) UpgradeDeviceOutput {
	return o
}

func (o UpgradeDeviceOutput) DeviceId() pulumi.StringOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.StringOutput { return v.DeviceId }).(pulumi.StringOutput)
}

// current device firmware version
func (o UpgradeDeviceOutput) DeviceVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.StringOutput { return v.DeviceVersion }).(pulumi.StringOutput)
}

func (o UpgradeDeviceOutput) Fwupdate() UpgradeDeviceFwupdateOutput {
	return o.ApplyT(func(v *UpgradeDevice) UpgradeDeviceFwupdateOutput { return v.Fwupdate }).(UpgradeDeviceFwupdateOutput)
}

// For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
func (o UpgradeDeviceOutput) Reboot() pulumi.BoolOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.BoolOutput { return v.Reboot }).(pulumi.BoolOutput)
}

// For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
func (o UpgradeDeviceOutput) RebootAt() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.IntPtrOutput { return v.RebootAt }).(pulumi.IntPtrOutput)
}

func (o UpgradeDeviceOutput) SiteId() pulumi.StringOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.StringOutput { return v.SiteId }).(pulumi.StringOutput)
}

// For Junos devices only. Perform recovery snapshot after device is rebooted
func (o UpgradeDeviceOutput) Snapshot() pulumi.BoolOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.BoolOutput { return v.Snapshot }).(pulumi.BoolOutput)
}

// Firmware download start time in epoch
func (o UpgradeDeviceOutput) StartTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.IntPtrOutput { return v.StartTime }).(pulumi.IntPtrOutput)
}

// enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
func (o UpgradeDeviceOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
func (o UpgradeDeviceOutput) SyncUpgrade() pulumi.BoolOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.BoolOutput { return v.SyncUpgrade }).(pulumi.BoolOutput)
}

// if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
func (o UpgradeDeviceOutput) SyncUpgradeRefreshInterval() pulumi.IntOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.IntOutput { return v.SyncUpgradeRefreshInterval }).(pulumi.IntOutput)
}

// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
func (o UpgradeDeviceOutput) SyncUpgradeStartTimeout() pulumi.IntOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.IntOutput { return v.SyncUpgradeStartTimeout }).(pulumi.IntOutput)
}

// if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
func (o UpgradeDeviceOutput) SyncUpgradeTimeout() pulumi.IntOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.IntOutput { return v.SyncUpgradeTimeout }).(pulumi.IntOutput)
}

// firmware version to deploy to the device. Use the `device.getVersions` datasource to get the list of available firmware versions
func (o UpgradeDeviceOutput) TargetVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.StringOutput { return v.TargetVersion }).(pulumi.StringOutput)
}

// Epoch (seconds)
func (o UpgradeDeviceOutput) Timestamp() pulumi.Float64Output {
	return o.ApplyT(func(v *UpgradeDevice) pulumi.Float64Output { return v.Timestamp }).(pulumi.Float64Output)
}

type UpgradeDeviceArrayOutput struct{ *pulumi.OutputState }

func (UpgradeDeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UpgradeDevice)(nil)).Elem()
}

func (o UpgradeDeviceArrayOutput) ToUpgradeDeviceArrayOutput() UpgradeDeviceArrayOutput {
	return o
}

func (o UpgradeDeviceArrayOutput) ToUpgradeDeviceArrayOutputWithContext(ctx context.Context) UpgradeDeviceArrayOutput {
	return o
}

func (o UpgradeDeviceArrayOutput) Index(i pulumi.IntInput) UpgradeDeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UpgradeDevice {
		return vs[0].([]*UpgradeDevice)[vs[1].(int)]
	}).(UpgradeDeviceOutput)
}

type UpgradeDeviceMapOutput struct{ *pulumi.OutputState }

func (UpgradeDeviceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UpgradeDevice)(nil)).Elem()
}

func (o UpgradeDeviceMapOutput) ToUpgradeDeviceMapOutput() UpgradeDeviceMapOutput {
	return o
}

func (o UpgradeDeviceMapOutput) ToUpgradeDeviceMapOutputWithContext(ctx context.Context) UpgradeDeviceMapOutput {
	return o
}

func (o UpgradeDeviceMapOutput) MapIndex(k pulumi.StringInput) UpgradeDeviceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UpgradeDevice {
		return vs[0].(map[string]*UpgradeDevice)[vs[1].(string)]
	}).(UpgradeDeviceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UpgradeDeviceInput)(nil)).Elem(), &UpgradeDevice{})
	pulumi.RegisterInputType(reflect.TypeOf((*UpgradeDeviceArrayInput)(nil)).Elem(), UpgradeDeviceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UpgradeDeviceMapInput)(nil)).Elem(), UpgradeDeviceMap{})
	pulumi.RegisterOutputType(UpgradeDeviceOutput{})
	pulumi.RegisterOutputType(UpgradeDeviceArrayOutput{})
	pulumi.RegisterOutputType(UpgradeDeviceMapOutput{})
}
