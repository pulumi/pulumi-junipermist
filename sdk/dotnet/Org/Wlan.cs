// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.JuniperMist.Org
{
    /// <summary>
    /// This resource manages the Org Wlans.
    /// The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using JuniperMist = Pulumi.JuniperMist;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var wlanOne = new JuniperMist.Org.Wlan("wlan_one", new()
    ///     {
    ///         Ssid = "wlan_one",
    ///         OrgId = terraformTest.Id,
    ///         TemplateId = test101.Id,
    ///         Bands = new[]
    ///         {
    ///             "5",
    ///             "6",
    ///         },
    ///         VlanEnabled = true,
    ///         VlanId = "143",
    ///         WlanLimitUp = 10000,
    ///         WlanLimitDown = 20000,
    ///         ClientLimitUp = 512,
    ///         ClientLimitDown = 1000,
    ///         Auth = new JuniperMist.Org.Inputs.WlanAuthArgs
    ///         {
    ///             Type = "psk",
    ///             Psk = "secretpsk",
    ///         },
    ///         Interface = "all",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Using `pulumi import`, import `mist_org_wlan` with:
    /// 
    /// Org WLAN can be imported by specifying the org_id and the wlan_id
    /// 
    /// ```sh
    /// $ pulumi import junipermist:org/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
    /// ```
    /// </summary>
    [JuniperMistResourceType("junipermist:org/wlan:Wlan")]
    public partial class Wlan : global::Pulumi.CustomResource
    {
        /// <summary>
        /// enable coa-immediate-update and address-change-immediate-update on the access profile.
        /// </summary>
        [Output("acctImmediateUpdate")]
        public Output<bool> AcctImmediateUpdate { get; private set; } = null!;

        /// <summary>
        /// how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        /// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        /// when enabled
        /// </summary>
        [Output("acctInterimInterval")]
        public Output<int> AcctInterimInterval { get; private set; } = null!;

        /// <summary>
        /// list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        /// </summary>
        [Output("acctServers")]
        public Output<ImmutableArray<Outputs.WlanAcctServer>> AcctServers { get; private set; } = null!;

        /// <summary>
        /// airwatch wlan settings
        /// </summary>
        [Output("airwatch")]
        public Output<Outputs.WlanAirwatch> Airwatch { get; private set; } = null!;

        /// <summary>
        /// only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        /// </summary>
        [Output("allowIpv6Ndp")]
        public Output<bool> AllowIpv6Ndp { get; private set; } = null!;

        /// <summary>
        /// only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        /// </summary>
        [Output("allowMdns")]
        public Output<bool> AllowMdns { get; private set; } = null!;

        /// <summary>
        /// only applicable when `limit_bcast`==`true`, which allows SSDP
        /// </summary>
        [Output("allowSsdp")]
        public Output<bool> AllowSsdp { get; private set; } = null!;

        /// <summary>
        /// list of device ids
        /// </summary>
        [Output("apIds")]
        public Output<ImmutableArray<string>> ApIds { get; private set; } = null!;

        /// <summary>
        /// bandwidth limiting for apps (applies to up/down)
        /// </summary>
        [Output("appLimit")]
        public Output<Outputs.WlanAppLimit> AppLimit { get; private set; } = null!;

        /// <summary>
        /// app qos wlan settings
        /// </summary>
        [Output("appQos")]
        public Output<Outputs.WlanAppQos> AppQos { get; private set; } = null!;

        /// <summary>
        /// enum: `aps`, `site`, `wxtags`
        /// </summary>
        [Output("applyTo")]
        public Output<string> ApplyTo { get; private set; } = null!;

        /// <summary>
        /// whether to enable smart arp filter
        /// </summary>
        [Output("arpFilter")]
        public Output<bool> ArpFilter { get; private set; } = null!;

        /// <summary>
        /// authentication wlan settings
        /// </summary>
        [Output("auth")]
        public Output<Outputs.WlanAuth?> Auth { get; private set; } = null!;

        /// <summary>
        /// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        /// </summary>
        [Output("authServerSelection")]
        public Output<string> AuthServerSelection { get; private set; } = null!;

        /// <summary>
        /// list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        /// is treated as primary
        /// </summary>
        [Output("authServers")]
        public Output<ImmutableArray<Outputs.WlanAuthServer>> AuthServers { get; private set; } = null!;

        /// <summary>
        /// optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        /// </summary>
        [Output("authServersNasId")]
        public Output<string> AuthServersNasId { get; private set; } = null!;

        /// <summary>
        /// optional, NAS-IP-ADDRESS to use
        /// </summary>
        [Output("authServersNasIp")]
        public Output<string> AuthServersNasIp { get; private set; } = null!;

        /// <summary>
        /// radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
        /// set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
        /// default value to 3.
        /// </summary>
        [Output("authServersRetries")]
        public Output<int> AuthServersRetries { get; private set; } = null!;

        /// <summary>
        /// radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
        /// ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
        /// is also set when setting auth_servers_timeout and is set to default value of 10.
        /// </summary>
        [Output("authServersTimeout")]
        public Output<int> AuthServersTimeout { get; private set; } = null!;

        /// <summary>
        /// whether to enable band_steering, this works only when band==both
        /// </summary>
        [Output("bandSteer")]
        public Output<bool> BandSteer { get; private set; } = null!;

        /// <summary>
        /// force dual_band capable client to connect to 5G
        /// </summary>
        [Output("bandSteerForceBand5")]
        public Output<bool> BandSteerForceBand5 { get; private set; } = null!;

        /// <summary>
        /// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        /// </summary>
        [Output("bands")]
        public Output<ImmutableArray<string>> Bands { get; private set; } = null!;

        /// <summary>
        /// whether to block the clients in the blacklist (up to first 256 macs)
        /// </summary>
        [Output("blockBlacklistClients")]
        public Output<bool> BlockBlacklistClients { get; private set; } = null!;

        /// <summary>
        /// bonjour gateway wlan settings
        /// </summary>
        [Output("bonjour")]
        public Output<Outputs.WlanBonjour> Bonjour { get; private set; } = null!;

        /// <summary>
        /// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        /// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        /// </summary>
        [Output("ciscoCwa")]
        public Output<Outputs.WlanCiscoCwa> CiscoCwa { get; private set; } = null!;

        /// <summary>
        /// kbps
        /// </summary>
        [Output("clientLimitDown")]
        public Output<int> ClientLimitDown { get; private set; } = null!;

        /// <summary>
        /// if downlink limiting per-client is enabled
        /// </summary>
        [Output("clientLimitDownEnabled")]
        public Output<bool> ClientLimitDownEnabled { get; private set; } = null!;

        /// <summary>
        /// kbps
        /// </summary>
        [Output("clientLimitUp")]
        public Output<int> ClientLimitUp { get; private set; } = null!;

        /// <summary>
        /// if uplink limiting per-client is enabled
        /// </summary>
        [Output("clientLimitUpEnabled")]
        public Output<bool> ClientLimitUpEnabled { get; private set; } = null!;

        /// <summary>
        /// list of COA (change of authorization) servers, optional
        /// </summary>
        [Output("coaServers")]
        public Output<ImmutableArray<Outputs.WlanCoaServer>> CoaServers { get; private set; } = null!;

        /// <summary>
        /// some old WLAN drivers may not be compatible
        /// </summary>
        [Output("disable11ax")]
        public Output<bool> Disable11ax { get; private set; } = null!;

        /// <summary>
        /// to disable ht or vht rates
        /// </summary>
        [Output("disableHtVhtRates")]
        public Output<bool> DisableHtVhtRates { get; private set; } = null!;

        /// <summary>
        /// whether to disable U-APSD
        /// </summary>
        [Output("disableUapsd")]
        public Output<bool> DisableUapsd { get; private set; } = null!;

        /// <summary>
        /// disable sending v2 roam notification messages
        /// </summary>
        [Output("disableV1RoamNotify")]
        public Output<bool> DisableV1RoamNotify { get; private set; } = null!;

        /// <summary>
        /// disable sending v2 roam notification messages
        /// </summary>
        [Output("disableV2RoamNotify")]
        public Output<bool> DisableV2RoamNotify { get; private set; } = null!;

        /// <summary>
        /// when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
        /// reach default gateway
        /// </summary>
        [Output("disableWhenGatewayUnreachable")]
        public Output<bool?> DisableWhenGatewayUnreachable { get; private set; } = null!;

        [Output("disableWhenMxtunnelDown")]
        public Output<bool?> DisableWhenMxtunnelDown { get; private set; } = null!;

        /// <summary>
        /// whether to disable WMM
        /// </summary>
        [Output("disableWmm")]
        public Output<bool> DisableWmm { get; private set; } = null!;

        /// <summary>
        /// for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        /// </summary>
        [Output("dnsServerRewrite")]
        public Output<Outputs.WlanDnsServerRewrite> DnsServerRewrite { get; private set; } = null!;

        [Output("dtim")]
        public Output<int> Dtim { get; private set; } = null!;

        /// <summary>
        /// for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        /// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        /// AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        /// Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        /// be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        /// now, wpa3 support on the roadmap)
        /// </summary>
        [Output("dynamicPsk")]
        public Output<Outputs.WlanDynamicPsk?> DynamicPsk { get; private set; } = null!;

        /// <summary>
        /// for 802.1x
        /// </summary>
        [Output("dynamicVlan")]
        public Output<Outputs.WlanDynamicVlan?> DynamicVlan { get; private set; } = null!;

        /// <summary>
        /// enable AP-AP keycaching via multicast
        /// </summary>
        [Output("enableLocalKeycaching")]
        public Output<bool> EnableLocalKeycaching { get; private set; } = null!;

        /// <summary>
        /// by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        /// client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        /// </summary>
        [Output("enableWirelessBridging")]
        public Output<bool> EnableWirelessBridging { get; private set; } = null!;

        /// <summary>
        /// if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        /// packets to be forwarded to wireless
        /// </summary>
        [Output("enableWirelessBridgingDhcpTracking")]
        public Output<bool> EnableWirelessBridgingDhcpTracking { get; private set; } = null!;

        /// <summary>
        /// if this wlan is enabled
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        /// ‘auth_server_retries’ .
        /// </summary>
        [Output("fastDot1xTimers")]
        public Output<bool> FastDot1xTimers { get; private set; } = null!;

        /// <summary>
        /// whether to hide SSID in beacon
        /// </summary>
        [Output("hideSsid")]
        public Output<bool> HideSsid { get; private set; } = null!;

        /// <summary>
        /// include hostname inside IE in AP beacons / probe responses
        /// </summary>
        [Output("hostnameIe")]
        public Output<bool> HostnameIe { get; private set; } = null!;

        /// <summary>
        /// hostspot 2.0 wlan settings
        /// </summary>
        [Output("hotspot20")]
        public Output<Outputs.WlanHotspot20> Hotspot20 { get; private set; } = null!;

        [Output("injectDhcpOption82")]
        public Output<Outputs.WlanInjectDhcpOption82?> InjectDhcpOption82 { get; private set; } = null!;

        /// <summary>
        /// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        /// </summary>
        [Output("interface")]
        public Output<string> Interface { get; private set; } = null!;

        /// <summary>
        /// whether to stop clients to talk to each other
        /// </summary>
        [Output("isolation")]
        public Output<bool> Isolation { get; private set; } = null!;

        /// <summary>
        /// if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        /// </summary>
        [Output("l2Isolation")]
        public Output<bool> L2Isolation { get; private set; } = null!;

        /// <summary>
        /// legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        /// Enabling this will cause problem for iOS devices.
        /// </summary>
        [Output("legacyOverds")]
        public Output<bool> LegacyOverds { get; private set; } = null!;

        /// <summary>
        /// whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        /// </summary>
        [Output("limitBcast")]
        public Output<bool> LimitBcast { get; private set; } = null!;

        /// <summary>
        /// limit probe response base on some heuristic rules
        /// </summary>
        [Output("limitProbeResponse")]
        public Output<bool> LimitProbeResponse { get; private set; } = null!;

        /// <summary>
        /// max idle time in seconds
        /// </summary>
        [Output("maxIdletime")]
        public Output<int> MaxIdletime { get; private set; } = null!;

        /// <summary>
        /// maximum number of client connected to the SSID. `0` means unlimited
        /// </summary>
        [Output("maxNumClients")]
        public Output<int> MaxNumClients { get; private set; } = null!;

        [Output("mistNac")]
        public Output<Outputs.WlanMistNac> MistNac { get; private set; } = null!;

        [Output("mspId")]
        public Output<string> MspId { get; private set; } = null!;

        /// <summary>
        /// when `interface`=`mxtunnel`, id of the Mist Tunnel
        /// </summary>
        [Output("mxtunnelIds")]
        public Output<ImmutableArray<string>> MxtunnelIds { get; private set; } = null!;

        /// <summary>
        /// when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        /// </summary>
        [Output("mxtunnelNames")]
        public Output<ImmutableArray<string>> MxtunnelNames { get; private set; } = null!;

        /// <summary>
        /// whether to only allow client to use DNS that we’ve learned from DHCP response
        /// </summary>
        [Output("noStaticDns")]
        public Output<bool> NoStaticDns { get; private set; } = null!;

        /// <summary>
        /// whether to only allow client that we’ve learned from DHCP exchange to talk
        /// </summary>
        [Output("noStaticIp")]
        public Output<bool> NoStaticIp { get; private set; } = null!;

        [Output("orgId")]
        public Output<string> OrgId { get; private set; } = null!;

        /// <summary>
        /// portal wlan settings
        /// </summary>
        [Output("portal")]
        public Output<Outputs.WlanPortal> Portal { get; private set; } = null!;

        /// <summary>
        /// list of hostnames without http(s):// (matched by substring)
        /// </summary>
        [Output("portalAllowedHostnames")]
        public Output<ImmutableArray<string>> PortalAllowedHostnames { get; private set; } = null!;

        /// <summary>
        /// list of CIDRs
        /// </summary>
        [Output("portalAllowedSubnets")]
        public Output<ImmutableArray<string>> PortalAllowedSubnets { get; private set; } = null!;

        /// <summary>
        /// api secret (auto-generated) that can be used to sign guest authorization requests
        /// </summary>
        [Output("portalApiSecret")]
        public Output<string> PortalApiSecret { get; private set; } = null!;

        /// <summary>
        /// list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        /// </summary>
        [Output("portalDeniedHostnames")]
        public Output<ImmutableArray<string>> PortalDeniedHostnames { get; private set; } = null!;

        /// <summary>
        /// Url of portal background image
        /// </summary>
        [Output("portalImage")]
        public Output<string> PortalImage { get; private set; } = null!;

        [Output("portalSsoUrl")]
        public Output<string> PortalSsoUrl { get; private set; } = null!;

        [Output("qos")]
        public Output<Outputs.WlanQos> Qos { get; private set; } = null!;

        /// <summary>
        /// Radsec settings
        /// </summary>
        [Output("radsec")]
        public Output<Outputs.WlanRadsec> Radsec { get; private set; } = null!;

        /// <summary>
        /// Property key is the RF band. enum: `24`, `5`, `6`
        /// </summary>
        [Output("rateset")]
        public Output<ImmutableDictionary<string, Outputs.WlanRateset>> Rateset { get; private set; } = null!;

        /// <summary>
        /// when different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        /// </summary>
        [Output("reconnectClientsWhenRoamingMxcluster")]
        public Output<bool?> ReconnectClientsWhenRoamingMxcluster { get; private set; } = null!;

        /// <summary>
        /// enum: `11r`, `OKC`, `NONE`
        /// </summary>
        [Output("roamMode")]
        public Output<string> RoamMode { get; private set; } = null!;

        /// <summary>
        /// WLAN operating schedule, default is disabled
        /// </summary>
        [Output("schedule")]
        public Output<Outputs.WlanSchedule> Schedule { get; private set; } = null!;

        /// <summary>
        /// whether to exclude this WLAN from SLE metrics
        /// </summary>
        [Output("sleExcluded")]
        public Output<bool> SleExcluded { get; private set; } = null!;

        /// <summary>
        /// the name of the SSID
        /// </summary>
        [Output("ssid")]
        public Output<string> Ssid { get; private set; } = null!;

        [Output("templateId")]
        public Output<string> TemplateId { get; private set; } = null!;

        /// <summary>
        /// if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        /// </summary>
        [Output("useEapolV1")]
        public Output<bool> UseEapolV1 { get; private set; } = null!;

        /// <summary>
        /// if vlan tagging is enabled
        /// </summary>
        [Output("vlanEnabled")]
        public Output<bool> VlanEnabled { get; private set; } = null!;

        [Output("vlanId")]
        public Output<string?> VlanId { get; private set; } = null!;

        /// <summary>
        /// if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
        /// </summary>
        [Output("vlanIds")]
        public Output<ImmutableArray<string>> VlanIds { get; private set; } = null!;

        /// <summary>
        /// Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
        /// deterministic algorithm
        /// </summary>
        [Output("vlanPooling")]
        public Output<bool> VlanPooling { get; private set; } = null!;

        /// <summary>
        /// kbps
        /// </summary>
        [Output("wlanLimitDown")]
        public Output<int> WlanLimitDown { get; private set; } = null!;

        /// <summary>
        /// if downlink limiting for whole wlan is enabled
        /// </summary>
        [Output("wlanLimitDownEnabled")]
        public Output<bool> WlanLimitDownEnabled { get; private set; } = null!;

        /// <summary>
        /// kbps
        /// </summary>
        [Output("wlanLimitUp")]
        public Output<int> WlanLimitUp { get; private set; } = null!;

        /// <summary>
        /// if uplink limiting for whole wlan is enabled
        /// </summary>
        [Output("wlanLimitUpEnabled")]
        public Output<bool> WlanLimitUpEnabled { get; private set; } = null!;

        /// <summary>
        /// list of wxtag_ids
        /// </summary>
        [Output("wxtagIds")]
        public Output<ImmutableArray<string>> WxtagIds { get; private set; } = null!;

        /// <summary>
        /// when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        /// </summary>
        [Output("wxtunnelId")]
        public Output<string> WxtunnelId { get; private set; } = null!;

        /// <summary>
        /// when `interface`=`wxtunnel`, remote tunnel identifier
        /// </summary>
        [Output("wxtunnelRemoteId")]
        public Output<string> WxtunnelRemoteId { get; private set; } = null!;


        /// <summary>
        /// Create a Wlan resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Wlan(string name, WlanArgs args, CustomResourceOptions? options = null)
            : base("junipermist:org/wlan:Wlan", name, args ?? new WlanArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Wlan(string name, Input<string> id, WlanState? state = null, CustomResourceOptions? options = null)
            : base("junipermist:org/wlan:Wlan", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumi/pulumi-junipermist",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Wlan resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Wlan Get(string name, Input<string> id, WlanState? state = null, CustomResourceOptions? options = null)
        {
            return new Wlan(name, id, state, options);
        }
    }

    public sealed class WlanArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// enable coa-immediate-update and address-change-immediate-update on the access profile.
        /// </summary>
        [Input("acctImmediateUpdate")]
        public Input<bool>? AcctImmediateUpdate { get; set; }

        /// <summary>
        /// how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        /// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        /// when enabled
        /// </summary>
        [Input("acctInterimInterval")]
        public Input<int>? AcctInterimInterval { get; set; }

        [Input("acctServers")]
        private InputList<Inputs.WlanAcctServerArgs>? _acctServers;

        /// <summary>
        /// list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        /// </summary>
        public InputList<Inputs.WlanAcctServerArgs> AcctServers
        {
            get => _acctServers ?? (_acctServers = new InputList<Inputs.WlanAcctServerArgs>());
            set => _acctServers = value;
        }

        /// <summary>
        /// airwatch wlan settings
        /// </summary>
        [Input("airwatch")]
        public Input<Inputs.WlanAirwatchArgs>? Airwatch { get; set; }

        /// <summary>
        /// only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        /// </summary>
        [Input("allowIpv6Ndp")]
        public Input<bool>? AllowIpv6Ndp { get; set; }

        /// <summary>
        /// only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        /// </summary>
        [Input("allowMdns")]
        public Input<bool>? AllowMdns { get; set; }

        /// <summary>
        /// only applicable when `limit_bcast`==`true`, which allows SSDP
        /// </summary>
        [Input("allowSsdp")]
        public Input<bool>? AllowSsdp { get; set; }

        [Input("apIds")]
        private InputList<string>? _apIds;

        /// <summary>
        /// list of device ids
        /// </summary>
        public InputList<string> ApIds
        {
            get => _apIds ?? (_apIds = new InputList<string>());
            set => _apIds = value;
        }

        /// <summary>
        /// bandwidth limiting for apps (applies to up/down)
        /// </summary>
        [Input("appLimit")]
        public Input<Inputs.WlanAppLimitArgs>? AppLimit { get; set; }

        /// <summary>
        /// app qos wlan settings
        /// </summary>
        [Input("appQos")]
        public Input<Inputs.WlanAppQosArgs>? AppQos { get; set; }

        /// <summary>
        /// enum: `aps`, `site`, `wxtags`
        /// </summary>
        [Input("applyTo")]
        public Input<string>? ApplyTo { get; set; }

        /// <summary>
        /// whether to enable smart arp filter
        /// </summary>
        [Input("arpFilter")]
        public Input<bool>? ArpFilter { get; set; }

        /// <summary>
        /// authentication wlan settings
        /// </summary>
        [Input("auth")]
        public Input<Inputs.WlanAuthArgs>? Auth { get; set; }

        /// <summary>
        /// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        /// </summary>
        [Input("authServerSelection")]
        public Input<string>? AuthServerSelection { get; set; }

        [Input("authServers")]
        private InputList<Inputs.WlanAuthServerArgs>? _authServers;

        /// <summary>
        /// list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        /// is treated as primary
        /// </summary>
        public InputList<Inputs.WlanAuthServerArgs> AuthServers
        {
            get => _authServers ?? (_authServers = new InputList<Inputs.WlanAuthServerArgs>());
            set => _authServers = value;
        }

        /// <summary>
        /// optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        /// </summary>
        [Input("authServersNasId")]
        public Input<string>? AuthServersNasId { get; set; }

        /// <summary>
        /// optional, NAS-IP-ADDRESS to use
        /// </summary>
        [Input("authServersNasIp")]
        public Input<string>? AuthServersNasIp { get; set; }

        /// <summary>
        /// radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
        /// set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
        /// default value to 3.
        /// </summary>
        [Input("authServersRetries")]
        public Input<int>? AuthServersRetries { get; set; }

        /// <summary>
        /// radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
        /// ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
        /// is also set when setting auth_servers_timeout and is set to default value of 10.
        /// </summary>
        [Input("authServersTimeout")]
        public Input<int>? AuthServersTimeout { get; set; }

        /// <summary>
        /// whether to enable band_steering, this works only when band==both
        /// </summary>
        [Input("bandSteer")]
        public Input<bool>? BandSteer { get; set; }

        /// <summary>
        /// force dual_band capable client to connect to 5G
        /// </summary>
        [Input("bandSteerForceBand5")]
        public Input<bool>? BandSteerForceBand5 { get; set; }

        [Input("bands")]
        private InputList<string>? _bands;

        /// <summary>
        /// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        /// </summary>
        public InputList<string> Bands
        {
            get => _bands ?? (_bands = new InputList<string>());
            set => _bands = value;
        }

        /// <summary>
        /// whether to block the clients in the blacklist (up to first 256 macs)
        /// </summary>
        [Input("blockBlacklistClients")]
        public Input<bool>? BlockBlacklistClients { get; set; }

        /// <summary>
        /// bonjour gateway wlan settings
        /// </summary>
        [Input("bonjour")]
        public Input<Inputs.WlanBonjourArgs>? Bonjour { get; set; }

        /// <summary>
        /// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        /// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        /// </summary>
        [Input("ciscoCwa")]
        public Input<Inputs.WlanCiscoCwaArgs>? CiscoCwa { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("clientLimitDown")]
        public Input<int>? ClientLimitDown { get; set; }

        /// <summary>
        /// if downlink limiting per-client is enabled
        /// </summary>
        [Input("clientLimitDownEnabled")]
        public Input<bool>? ClientLimitDownEnabled { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("clientLimitUp")]
        public Input<int>? ClientLimitUp { get; set; }

        /// <summary>
        /// if uplink limiting per-client is enabled
        /// </summary>
        [Input("clientLimitUpEnabled")]
        public Input<bool>? ClientLimitUpEnabled { get; set; }

        [Input("coaServers")]
        private InputList<Inputs.WlanCoaServerArgs>? _coaServers;

        /// <summary>
        /// list of COA (change of authorization) servers, optional
        /// </summary>
        public InputList<Inputs.WlanCoaServerArgs> CoaServers
        {
            get => _coaServers ?? (_coaServers = new InputList<Inputs.WlanCoaServerArgs>());
            set => _coaServers = value;
        }

        /// <summary>
        /// some old WLAN drivers may not be compatible
        /// </summary>
        [Input("disable11ax")]
        public Input<bool>? Disable11ax { get; set; }

        /// <summary>
        /// to disable ht or vht rates
        /// </summary>
        [Input("disableHtVhtRates")]
        public Input<bool>? DisableHtVhtRates { get; set; }

        /// <summary>
        /// whether to disable U-APSD
        /// </summary>
        [Input("disableUapsd")]
        public Input<bool>? DisableUapsd { get; set; }

        /// <summary>
        /// disable sending v2 roam notification messages
        /// </summary>
        [Input("disableV1RoamNotify")]
        public Input<bool>? DisableV1RoamNotify { get; set; }

        /// <summary>
        /// disable sending v2 roam notification messages
        /// </summary>
        [Input("disableV2RoamNotify")]
        public Input<bool>? DisableV2RoamNotify { get; set; }

        /// <summary>
        /// when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
        /// reach default gateway
        /// </summary>
        [Input("disableWhenGatewayUnreachable")]
        public Input<bool>? DisableWhenGatewayUnreachable { get; set; }

        [Input("disableWhenMxtunnelDown")]
        public Input<bool>? DisableWhenMxtunnelDown { get; set; }

        /// <summary>
        /// whether to disable WMM
        /// </summary>
        [Input("disableWmm")]
        public Input<bool>? DisableWmm { get; set; }

        /// <summary>
        /// for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        /// </summary>
        [Input("dnsServerRewrite")]
        public Input<Inputs.WlanDnsServerRewriteArgs>? DnsServerRewrite { get; set; }

        [Input("dtim")]
        public Input<int>? Dtim { get; set; }

        /// <summary>
        /// for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        /// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        /// AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        /// Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        /// be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        /// now, wpa3 support on the roadmap)
        /// </summary>
        [Input("dynamicPsk")]
        public Input<Inputs.WlanDynamicPskArgs>? DynamicPsk { get; set; }

        /// <summary>
        /// for 802.1x
        /// </summary>
        [Input("dynamicVlan")]
        public Input<Inputs.WlanDynamicVlanArgs>? DynamicVlan { get; set; }

        /// <summary>
        /// enable AP-AP keycaching via multicast
        /// </summary>
        [Input("enableLocalKeycaching")]
        public Input<bool>? EnableLocalKeycaching { get; set; }

        /// <summary>
        /// by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        /// client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        /// </summary>
        [Input("enableWirelessBridging")]
        public Input<bool>? EnableWirelessBridging { get; set; }

        /// <summary>
        /// if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        /// packets to be forwarded to wireless
        /// </summary>
        [Input("enableWirelessBridgingDhcpTracking")]
        public Input<bool>? EnableWirelessBridgingDhcpTracking { get; set; }

        /// <summary>
        /// if this wlan is enabled
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        /// ‘auth_server_retries’ .
        /// </summary>
        [Input("fastDot1xTimers")]
        public Input<bool>? FastDot1xTimers { get; set; }

        /// <summary>
        /// whether to hide SSID in beacon
        /// </summary>
        [Input("hideSsid")]
        public Input<bool>? HideSsid { get; set; }

        /// <summary>
        /// include hostname inside IE in AP beacons / probe responses
        /// </summary>
        [Input("hostnameIe")]
        public Input<bool>? HostnameIe { get; set; }

        /// <summary>
        /// hostspot 2.0 wlan settings
        /// </summary>
        [Input("hotspot20")]
        public Input<Inputs.WlanHotspot20Args>? Hotspot20 { get; set; }

        [Input("injectDhcpOption82")]
        public Input<Inputs.WlanInjectDhcpOption82Args>? InjectDhcpOption82 { get; set; }

        /// <summary>
        /// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        /// </summary>
        [Input("interface")]
        public Input<string>? Interface { get; set; }

        /// <summary>
        /// whether to stop clients to talk to each other
        /// </summary>
        [Input("isolation")]
        public Input<bool>? Isolation { get; set; }

        /// <summary>
        /// if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        /// </summary>
        [Input("l2Isolation")]
        public Input<bool>? L2Isolation { get; set; }

        /// <summary>
        /// legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        /// Enabling this will cause problem for iOS devices.
        /// </summary>
        [Input("legacyOverds")]
        public Input<bool>? LegacyOverds { get; set; }

        /// <summary>
        /// whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        /// </summary>
        [Input("limitBcast")]
        public Input<bool>? LimitBcast { get; set; }

        /// <summary>
        /// limit probe response base on some heuristic rules
        /// </summary>
        [Input("limitProbeResponse")]
        public Input<bool>? LimitProbeResponse { get; set; }

        /// <summary>
        /// max idle time in seconds
        /// </summary>
        [Input("maxIdletime")]
        public Input<int>? MaxIdletime { get; set; }

        /// <summary>
        /// maximum number of client connected to the SSID. `0` means unlimited
        /// </summary>
        [Input("maxNumClients")]
        public Input<int>? MaxNumClients { get; set; }

        [Input("mistNac")]
        public Input<Inputs.WlanMistNacArgs>? MistNac { get; set; }

        [Input("mxtunnelIds")]
        private InputList<string>? _mxtunnelIds;

        /// <summary>
        /// when `interface`=`mxtunnel`, id of the Mist Tunnel
        /// </summary>
        public InputList<string> MxtunnelIds
        {
            get => _mxtunnelIds ?? (_mxtunnelIds = new InputList<string>());
            set => _mxtunnelIds = value;
        }

        [Input("mxtunnelNames")]
        private InputList<string>? _mxtunnelNames;

        /// <summary>
        /// when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        /// </summary>
        public InputList<string> MxtunnelNames
        {
            get => _mxtunnelNames ?? (_mxtunnelNames = new InputList<string>());
            set => _mxtunnelNames = value;
        }

        /// <summary>
        /// whether to only allow client to use DNS that we’ve learned from DHCP response
        /// </summary>
        [Input("noStaticDns")]
        public Input<bool>? NoStaticDns { get; set; }

        /// <summary>
        /// whether to only allow client that we’ve learned from DHCP exchange to talk
        /// </summary>
        [Input("noStaticIp")]
        public Input<bool>? NoStaticIp { get; set; }

        [Input("orgId", required: true)]
        public Input<string> OrgId { get; set; } = null!;

        /// <summary>
        /// portal wlan settings
        /// </summary>
        [Input("portal")]
        public Input<Inputs.WlanPortalArgs>? Portal { get; set; }

        [Input("portalAllowedHostnames")]
        private InputList<string>? _portalAllowedHostnames;

        /// <summary>
        /// list of hostnames without http(s):// (matched by substring)
        /// </summary>
        public InputList<string> PortalAllowedHostnames
        {
            get => _portalAllowedHostnames ?? (_portalAllowedHostnames = new InputList<string>());
            set => _portalAllowedHostnames = value;
        }

        [Input("portalAllowedSubnets")]
        private InputList<string>? _portalAllowedSubnets;

        /// <summary>
        /// list of CIDRs
        /// </summary>
        public InputList<string> PortalAllowedSubnets
        {
            get => _portalAllowedSubnets ?? (_portalAllowedSubnets = new InputList<string>());
            set => _portalAllowedSubnets = value;
        }

        [Input("portalDeniedHostnames")]
        private InputList<string>? _portalDeniedHostnames;

        /// <summary>
        /// list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        /// </summary>
        public InputList<string> PortalDeniedHostnames
        {
            get => _portalDeniedHostnames ?? (_portalDeniedHostnames = new InputList<string>());
            set => _portalDeniedHostnames = value;
        }

        [Input("qos")]
        public Input<Inputs.WlanQosArgs>? Qos { get; set; }

        /// <summary>
        /// Radsec settings
        /// </summary>
        [Input("radsec")]
        public Input<Inputs.WlanRadsecArgs>? Radsec { get; set; }

        [Input("rateset")]
        private InputMap<Inputs.WlanRatesetArgs>? _rateset;

        /// <summary>
        /// Property key is the RF band. enum: `24`, `5`, `6`
        /// </summary>
        public InputMap<Inputs.WlanRatesetArgs> Rateset
        {
            get => _rateset ?? (_rateset = new InputMap<Inputs.WlanRatesetArgs>());
            set => _rateset = value;
        }

        /// <summary>
        /// when different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        /// </summary>
        [Input("reconnectClientsWhenRoamingMxcluster")]
        public Input<bool>? ReconnectClientsWhenRoamingMxcluster { get; set; }

        /// <summary>
        /// enum: `11r`, `OKC`, `NONE`
        /// </summary>
        [Input("roamMode")]
        public Input<string>? RoamMode { get; set; }

        /// <summary>
        /// WLAN operating schedule, default is disabled
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.WlanScheduleArgs>? Schedule { get; set; }

        /// <summary>
        /// whether to exclude this WLAN from SLE metrics
        /// </summary>
        [Input("sleExcluded")]
        public Input<bool>? SleExcluded { get; set; }

        /// <summary>
        /// the name of the SSID
        /// </summary>
        [Input("ssid", required: true)]
        public Input<string> Ssid { get; set; } = null!;

        [Input("templateId", required: true)]
        public Input<string> TemplateId { get; set; } = null!;

        /// <summary>
        /// if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        /// </summary>
        [Input("useEapolV1")]
        public Input<bool>? UseEapolV1 { get; set; }

        /// <summary>
        /// if vlan tagging is enabled
        /// </summary>
        [Input("vlanEnabled")]
        public Input<bool>? VlanEnabled { get; set; }

        [Input("vlanId")]
        public Input<string>? VlanId { get; set; }

        [Input("vlanIds")]
        private InputList<string>? _vlanIds;

        /// <summary>
        /// if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
        /// </summary>
        public InputList<string> VlanIds
        {
            get => _vlanIds ?? (_vlanIds = new InputList<string>());
            set => _vlanIds = value;
        }

        /// <summary>
        /// Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
        /// deterministic algorithm
        /// </summary>
        [Input("vlanPooling")]
        public Input<bool>? VlanPooling { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("wlanLimitDown")]
        public Input<int>? WlanLimitDown { get; set; }

        /// <summary>
        /// if downlink limiting for whole wlan is enabled
        /// </summary>
        [Input("wlanLimitDownEnabled")]
        public Input<bool>? WlanLimitDownEnabled { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("wlanLimitUp")]
        public Input<int>? WlanLimitUp { get; set; }

        /// <summary>
        /// if uplink limiting for whole wlan is enabled
        /// </summary>
        [Input("wlanLimitUpEnabled")]
        public Input<bool>? WlanLimitUpEnabled { get; set; }

        [Input("wxtagIds")]
        private InputList<string>? _wxtagIds;

        /// <summary>
        /// list of wxtag_ids
        /// </summary>
        public InputList<string> WxtagIds
        {
            get => _wxtagIds ?? (_wxtagIds = new InputList<string>());
            set => _wxtagIds = value;
        }

        /// <summary>
        /// when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        /// </summary>
        [Input("wxtunnelId")]
        public Input<string>? WxtunnelId { get; set; }

        /// <summary>
        /// when `interface`=`wxtunnel`, remote tunnel identifier
        /// </summary>
        [Input("wxtunnelRemoteId")]
        public Input<string>? WxtunnelRemoteId { get; set; }

        public WlanArgs()
        {
        }
        public static new WlanArgs Empty => new WlanArgs();
    }

    public sealed class WlanState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// enable coa-immediate-update and address-change-immediate-update on the access profile.
        /// </summary>
        [Input("acctImmediateUpdate")]
        public Input<bool>? AcctImmediateUpdate { get; set; }

        /// <summary>
        /// how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
        /// from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
        /// when enabled
        /// </summary>
        [Input("acctInterimInterval")]
        public Input<int>? AcctInterimInterval { get; set; }

        [Input("acctServers")]
        private InputList<Inputs.WlanAcctServerGetArgs>? _acctServers;

        /// <summary>
        /// list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
        /// </summary>
        public InputList<Inputs.WlanAcctServerGetArgs> AcctServers
        {
            get => _acctServers ?? (_acctServers = new InputList<Inputs.WlanAcctServerGetArgs>());
            set => _acctServers = value;
        }

        /// <summary>
        /// airwatch wlan settings
        /// </summary>
        [Input("airwatch")]
        public Input<Inputs.WlanAirwatchGetArgs>? Airwatch { get; set; }

        /// <summary>
        /// only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
        /// </summary>
        [Input("allowIpv6Ndp")]
        public Input<bool>? AllowIpv6Ndp { get; set; }

        /// <summary>
        /// only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
        /// </summary>
        [Input("allowMdns")]
        public Input<bool>? AllowMdns { get; set; }

        /// <summary>
        /// only applicable when `limit_bcast`==`true`, which allows SSDP
        /// </summary>
        [Input("allowSsdp")]
        public Input<bool>? AllowSsdp { get; set; }

        [Input("apIds")]
        private InputList<string>? _apIds;

        /// <summary>
        /// list of device ids
        /// </summary>
        public InputList<string> ApIds
        {
            get => _apIds ?? (_apIds = new InputList<string>());
            set => _apIds = value;
        }

        /// <summary>
        /// bandwidth limiting for apps (applies to up/down)
        /// </summary>
        [Input("appLimit")]
        public Input<Inputs.WlanAppLimitGetArgs>? AppLimit { get; set; }

        /// <summary>
        /// app qos wlan settings
        /// </summary>
        [Input("appQos")]
        public Input<Inputs.WlanAppQosGetArgs>? AppQos { get; set; }

        /// <summary>
        /// enum: `aps`, `site`, `wxtags`
        /// </summary>
        [Input("applyTo")]
        public Input<string>? ApplyTo { get; set; }

        /// <summary>
        /// whether to enable smart arp filter
        /// </summary>
        [Input("arpFilter")]
        public Input<bool>? ArpFilter { get; set; }

        /// <summary>
        /// authentication wlan settings
        /// </summary>
        [Input("auth")]
        public Input<Inputs.WlanAuthGetArgs>? Auth { get; set; }

        /// <summary>
        /// When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
        /// </summary>
        [Input("authServerSelection")]
        public Input<string>? AuthServerSelection { get; set; }

        [Input("authServers")]
        private InputList<Inputs.WlanAuthServerGetArgs>? _authServers;

        /// <summary>
        /// list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
        /// is treated as primary
        /// </summary>
        public InputList<Inputs.WlanAuthServerGetArgs> AuthServers
        {
            get => _authServers ?? (_authServers = new InputList<Inputs.WlanAuthServerGetArgs>());
            set => _authServers = value;
        }

        /// <summary>
        /// optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
        /// </summary>
        [Input("authServersNasId")]
        public Input<string>? AuthServersNasId { get; set; }

        /// <summary>
        /// optional, NAS-IP-ADDRESS to use
        /// </summary>
        [Input("authServersNasIp")]
        public Input<string>? AuthServersNasIp { get; set; }

        /// <summary>
        /// radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
        /// set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
        /// default value to 3.
        /// </summary>
        [Input("authServersRetries")]
        public Input<int>? AuthServersRetries { get; set; }

        /// <summary>
        /// radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
        /// ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
        /// is also set when setting auth_servers_timeout and is set to default value of 10.
        /// </summary>
        [Input("authServersTimeout")]
        public Input<int>? AuthServersTimeout { get; set; }

        /// <summary>
        /// whether to enable band_steering, this works only when band==both
        /// </summary>
        [Input("bandSteer")]
        public Input<bool>? BandSteer { get; set; }

        /// <summary>
        /// force dual_band capable client to connect to 5G
        /// </summary>
        [Input("bandSteerForceBand5")]
        public Input<bool>? BandSteerForceBand5 { get; set; }

        [Input("bands")]
        private InputList<string>? _bands;

        /// <summary>
        /// list of radios that the wlan should apply to. enum: `24`, `5`, `6`
        /// </summary>
        public InputList<string> Bands
        {
            get => _bands ?? (_bands = new InputList<string>());
            set => _bands = value;
        }

        /// <summary>
        /// whether to block the clients in the blacklist (up to first 256 macs)
        /// </summary>
        [Input("blockBlacklistClients")]
        public Input<bool>? BlockBlacklistClients { get; set; }

        /// <summary>
        /// bonjour gateway wlan settings
        /// </summary>
        [Input("bonjour")]
        public Input<Inputs.WlanBonjourGetArgs>? Bonjour { get; set; }

        /// <summary>
        /// Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
        /// https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
        /// </summary>
        [Input("ciscoCwa")]
        public Input<Inputs.WlanCiscoCwaGetArgs>? CiscoCwa { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("clientLimitDown")]
        public Input<int>? ClientLimitDown { get; set; }

        /// <summary>
        /// if downlink limiting per-client is enabled
        /// </summary>
        [Input("clientLimitDownEnabled")]
        public Input<bool>? ClientLimitDownEnabled { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("clientLimitUp")]
        public Input<int>? ClientLimitUp { get; set; }

        /// <summary>
        /// if uplink limiting per-client is enabled
        /// </summary>
        [Input("clientLimitUpEnabled")]
        public Input<bool>? ClientLimitUpEnabled { get; set; }

        [Input("coaServers")]
        private InputList<Inputs.WlanCoaServerGetArgs>? _coaServers;

        /// <summary>
        /// list of COA (change of authorization) servers, optional
        /// </summary>
        public InputList<Inputs.WlanCoaServerGetArgs> CoaServers
        {
            get => _coaServers ?? (_coaServers = new InputList<Inputs.WlanCoaServerGetArgs>());
            set => _coaServers = value;
        }

        /// <summary>
        /// some old WLAN drivers may not be compatible
        /// </summary>
        [Input("disable11ax")]
        public Input<bool>? Disable11ax { get; set; }

        /// <summary>
        /// to disable ht or vht rates
        /// </summary>
        [Input("disableHtVhtRates")]
        public Input<bool>? DisableHtVhtRates { get; set; }

        /// <summary>
        /// whether to disable U-APSD
        /// </summary>
        [Input("disableUapsd")]
        public Input<bool>? DisableUapsd { get; set; }

        /// <summary>
        /// disable sending v2 roam notification messages
        /// </summary>
        [Input("disableV1RoamNotify")]
        public Input<bool>? DisableV1RoamNotify { get; set; }

        /// <summary>
        /// disable sending v2 roam notification messages
        /// </summary>
        [Input("disableV2RoamNotify")]
        public Input<bool>? DisableV2RoamNotify { get; set; }

        /// <summary>
        /// when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
        /// reach default gateway
        /// </summary>
        [Input("disableWhenGatewayUnreachable")]
        public Input<bool>? DisableWhenGatewayUnreachable { get; set; }

        [Input("disableWhenMxtunnelDown")]
        public Input<bool>? DisableWhenMxtunnelDown { get; set; }

        /// <summary>
        /// whether to disable WMM
        /// </summary>
        [Input("disableWmm")]
        public Input<bool>? DisableWmm { get; set; }

        /// <summary>
        /// for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
        /// </summary>
        [Input("dnsServerRewrite")]
        public Input<Inputs.WlanDnsServerRewriteGetArgs>? DnsServerRewrite { get; set; }

        [Input("dtim")]
        public Input<int>? Dtim { get; set; }

        /// <summary>
        /// for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
        /// context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
        /// AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
        /// Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
        /// be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
        /// now, wpa3 support on the roadmap)
        /// </summary>
        [Input("dynamicPsk")]
        public Input<Inputs.WlanDynamicPskGetArgs>? DynamicPsk { get; set; }

        /// <summary>
        /// for 802.1x
        /// </summary>
        [Input("dynamicVlan")]
        public Input<Inputs.WlanDynamicVlanGetArgs>? DynamicVlan { get; set; }

        /// <summary>
        /// enable AP-AP keycaching via multicast
        /// </summary>
        [Input("enableLocalKeycaching")]
        public Input<bool>? EnableLocalKeycaching { get; set; }

        /// <summary>
        /// by default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
        /// client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
        /// </summary>
        [Input("enableWirelessBridging")]
        public Input<bool>? EnableWirelessBridging { get; set; }

        /// <summary>
        /// if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
        /// packets to be forwarded to wireless
        /// </summary>
        [Input("enableWirelessBridgingDhcpTracking")]
        public Input<bool>? EnableWirelessBridgingDhcpTracking { get; set; }

        /// <summary>
        /// if this wlan is enabled
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
        /// ‘auth_server_retries’ .
        /// </summary>
        [Input("fastDot1xTimers")]
        public Input<bool>? FastDot1xTimers { get; set; }

        /// <summary>
        /// whether to hide SSID in beacon
        /// </summary>
        [Input("hideSsid")]
        public Input<bool>? HideSsid { get; set; }

        /// <summary>
        /// include hostname inside IE in AP beacons / probe responses
        /// </summary>
        [Input("hostnameIe")]
        public Input<bool>? HostnameIe { get; set; }

        /// <summary>
        /// hostspot 2.0 wlan settings
        /// </summary>
        [Input("hotspot20")]
        public Input<Inputs.WlanHotspot20GetArgs>? Hotspot20 { get; set; }

        [Input("injectDhcpOption82")]
        public Input<Inputs.WlanInjectDhcpOption82GetArgs>? InjectDhcpOption82 { get; set; }

        /// <summary>
        /// where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
        /// </summary>
        [Input("interface")]
        public Input<string>? Interface { get; set; }

        /// <summary>
        /// whether to stop clients to talk to each other
        /// </summary>
        [Input("isolation")]
        public Input<bool>? Isolation { get; set; }

        /// <summary>
        /// if isolation is enabled, whether to deny clients to talk to L2 on the LAN
        /// </summary>
        [Input("l2Isolation")]
        public Input<bool>? L2Isolation { get; set; }

        /// <summary>
        /// legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
        /// Enabling this will cause problem for iOS devices.
        /// </summary>
        [Input("legacyOverds")]
        public Input<bool>? LegacyOverds { get; set; }

        /// <summary>
        /// whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
        /// </summary>
        [Input("limitBcast")]
        public Input<bool>? LimitBcast { get; set; }

        /// <summary>
        /// limit probe response base on some heuristic rules
        /// </summary>
        [Input("limitProbeResponse")]
        public Input<bool>? LimitProbeResponse { get; set; }

        /// <summary>
        /// max idle time in seconds
        /// </summary>
        [Input("maxIdletime")]
        public Input<int>? MaxIdletime { get; set; }

        /// <summary>
        /// maximum number of client connected to the SSID. `0` means unlimited
        /// </summary>
        [Input("maxNumClients")]
        public Input<int>? MaxNumClients { get; set; }

        [Input("mistNac")]
        public Input<Inputs.WlanMistNacGetArgs>? MistNac { get; set; }

        [Input("mspId")]
        public Input<string>? MspId { get; set; }

        [Input("mxtunnelIds")]
        private InputList<string>? _mxtunnelIds;

        /// <summary>
        /// when `interface`=`mxtunnel`, id of the Mist Tunnel
        /// </summary>
        public InputList<string> MxtunnelIds
        {
            get => _mxtunnelIds ?? (_mxtunnelIds = new InputList<string>());
            set => _mxtunnelIds = value;
        }

        [Input("mxtunnelNames")]
        private InputList<string>? _mxtunnelNames;

        /// <summary>
        /// when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
        /// </summary>
        public InputList<string> MxtunnelNames
        {
            get => _mxtunnelNames ?? (_mxtunnelNames = new InputList<string>());
            set => _mxtunnelNames = value;
        }

        /// <summary>
        /// whether to only allow client to use DNS that we’ve learned from DHCP response
        /// </summary>
        [Input("noStaticDns")]
        public Input<bool>? NoStaticDns { get; set; }

        /// <summary>
        /// whether to only allow client that we’ve learned from DHCP exchange to talk
        /// </summary>
        [Input("noStaticIp")]
        public Input<bool>? NoStaticIp { get; set; }

        [Input("orgId")]
        public Input<string>? OrgId { get; set; }

        /// <summary>
        /// portal wlan settings
        /// </summary>
        [Input("portal")]
        public Input<Inputs.WlanPortalGetArgs>? Portal { get; set; }

        [Input("portalAllowedHostnames")]
        private InputList<string>? _portalAllowedHostnames;

        /// <summary>
        /// list of hostnames without http(s):// (matched by substring)
        /// </summary>
        public InputList<string> PortalAllowedHostnames
        {
            get => _portalAllowedHostnames ?? (_portalAllowedHostnames = new InputList<string>());
            set => _portalAllowedHostnames = value;
        }

        [Input("portalAllowedSubnets")]
        private InputList<string>? _portalAllowedSubnets;

        /// <summary>
        /// list of CIDRs
        /// </summary>
        public InputList<string> PortalAllowedSubnets
        {
            get => _portalAllowedSubnets ?? (_portalAllowedSubnets = new InputList<string>());
            set => _portalAllowedSubnets = value;
        }

        /// <summary>
        /// api secret (auto-generated) that can be used to sign guest authorization requests
        /// </summary>
        [Input("portalApiSecret")]
        public Input<string>? PortalApiSecret { get; set; }

        [Input("portalDeniedHostnames")]
        private InputList<string>? _portalDeniedHostnames;

        /// <summary>
        /// list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
        /// </summary>
        public InputList<string> PortalDeniedHostnames
        {
            get => _portalDeniedHostnames ?? (_portalDeniedHostnames = new InputList<string>());
            set => _portalDeniedHostnames = value;
        }

        /// <summary>
        /// Url of portal background image
        /// </summary>
        [Input("portalImage")]
        public Input<string>? PortalImage { get; set; }

        [Input("portalSsoUrl")]
        public Input<string>? PortalSsoUrl { get; set; }

        [Input("qos")]
        public Input<Inputs.WlanQosGetArgs>? Qos { get; set; }

        /// <summary>
        /// Radsec settings
        /// </summary>
        [Input("radsec")]
        public Input<Inputs.WlanRadsecGetArgs>? Radsec { get; set; }

        [Input("rateset")]
        private InputMap<Inputs.WlanRatesetGetArgs>? _rateset;

        /// <summary>
        /// Property key is the RF band. enum: `24`, `5`, `6`
        /// </summary>
        public InputMap<Inputs.WlanRatesetGetArgs> Rateset
        {
            get => _rateset ?? (_rateset = new InputMap<Inputs.WlanRatesetGetArgs>());
            set => _rateset = value;
        }

        /// <summary>
        /// when different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)
        /// </summary>
        [Input("reconnectClientsWhenRoamingMxcluster")]
        public Input<bool>? ReconnectClientsWhenRoamingMxcluster { get; set; }

        /// <summary>
        /// enum: `11r`, `OKC`, `NONE`
        /// </summary>
        [Input("roamMode")]
        public Input<string>? RoamMode { get; set; }

        /// <summary>
        /// WLAN operating schedule, default is disabled
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.WlanScheduleGetArgs>? Schedule { get; set; }

        /// <summary>
        /// whether to exclude this WLAN from SLE metrics
        /// </summary>
        [Input("sleExcluded")]
        public Input<bool>? SleExcluded { get; set; }

        /// <summary>
        /// the name of the SSID
        /// </summary>
        [Input("ssid")]
        public Input<string>? Ssid { get; set; }

        [Input("templateId")]
        public Input<string>? TemplateId { get; set; }

        /// <summary>
        /// if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
        /// </summary>
        [Input("useEapolV1")]
        public Input<bool>? UseEapolV1 { get; set; }

        /// <summary>
        /// if vlan tagging is enabled
        /// </summary>
        [Input("vlanEnabled")]
        public Input<bool>? VlanEnabled { get; set; }

        [Input("vlanId")]
        public Input<string>? VlanId { get; set; }

        [Input("vlanIds")]
        private InputList<string>? _vlanIds;

        /// <summary>
        /// if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
        /// </summary>
        public InputList<string> VlanIds
        {
            get => _vlanIds ?? (_vlanIds = new InputList<string>());
            set => _vlanIds = value;
        }

        /// <summary>
        /// Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
        /// deterministic algorithm
        /// </summary>
        [Input("vlanPooling")]
        public Input<bool>? VlanPooling { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("wlanLimitDown")]
        public Input<int>? WlanLimitDown { get; set; }

        /// <summary>
        /// if downlink limiting for whole wlan is enabled
        /// </summary>
        [Input("wlanLimitDownEnabled")]
        public Input<bool>? WlanLimitDownEnabled { get; set; }

        /// <summary>
        /// kbps
        /// </summary>
        [Input("wlanLimitUp")]
        public Input<int>? WlanLimitUp { get; set; }

        /// <summary>
        /// if uplink limiting for whole wlan is enabled
        /// </summary>
        [Input("wlanLimitUpEnabled")]
        public Input<bool>? WlanLimitUpEnabled { get; set; }

        [Input("wxtagIds")]
        private InputList<string>? _wxtagIds;

        /// <summary>
        /// list of wxtag_ids
        /// </summary>
        public InputList<string> WxtagIds
        {
            get => _wxtagIds ?? (_wxtagIds = new InputList<string>());
            set => _wxtagIds = value;
        }

        /// <summary>
        /// when `interface`=`wxtunnel`, id of the WXLAN Tunnel
        /// </summary>
        [Input("wxtunnelId")]
        public Input<string>? WxtunnelId { get; set; }

        /// <summary>
        /// when `interface`=`wxtunnel`, remote tunnel identifier
        /// </summary>
        [Input("wxtunnelRemoteId")]
        public Input<string>? WxtunnelRemoteId { get; set; }

        public WlanState()
        {
        }
        public static new WlanState Empty => new WlanState();
    }
}
