// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.JuniperMist.Org.Inputs
{

    public sealed class WlanPortalGetArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional if `AmazonEnabled`==`True`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable RandomMac for seamless roaming)
        /// </summary>
        [Input("allowWlanIdRoam")]
        public Input<bool>? AllowWlanIdRoam { get; set; }

        /// <summary>
        /// Optional if `AmazonEnabled`==`True`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
        /// </summary>
        [Input("amazonClientId")]
        public Input<string>? AmazonClientId { get; set; }

        /// <summary>
        /// Optional if `AmazonEnabled`==`True`. Amazon OAuth2 client secret. If AmazonClientId was provided, provide a corresponding value. Else leave blank.
        /// </summary>
        [Input("amazonClientSecret")]
        public Input<string>? AmazonClientSecret { get; set; }

        [Input("amazonEmailDomains")]
        private InputList<string>? _amazonEmailDomains;

        /// <summary>
        /// Optional if `AmazonEnabled`==`True`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        /// </summary>
        public InputList<string> AmazonEmailDomains
        {
            get => _amazonEmailDomains ?? (_amazonEmailDomains = new InputList<string>());
            set => _amazonEmailDomains = value;
        }

        /// <summary>
        /// Whether amazon is enabled as a login method
        /// </summary>
        [Input("amazonEnabled")]
        public Input<bool>? AmazonEnabled { get; set; }

        /// <summary>
        /// Optional if `AmazonEnabled`==`True`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("amazonExpire")]
        public Input<int>? AmazonExpire { get; set; }

        /// <summary>
        /// authentication scheme. enum: `Amazon`, `Azure`, `Email`, `External`, `Facebook`, `Google`, `Microsoft`, `Multi`, `None`, `Password`, `Sms`, `Sponsor`, `Sso`
        /// </summary>
        [Input("auth")]
        public Input<string>? Auth { get; set; }

        /// <summary>
        /// Required if `AzureEnabled`==`True`. Azure active directory app client id
        /// </summary>
        [Input("azureClientId")]
        public Input<string>? AzureClientId { get; set; }

        /// <summary>
        /// Required if `AzureEnabled`==`True`. Azure active directory app client secret
        /// </summary>
        [Input("azureClientSecret")]
        public Input<string>? AzureClientSecret { get; set; }

        /// <summary>
        /// Whether Azure Active Directory is enabled as a login method
        /// </summary>
        [Input("azureEnabled")]
        public Input<bool>? AzureEnabled { get; set; }

        /// <summary>
        /// Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("azureExpire")]
        public Input<int>? AzureExpire { get; set; }

        /// <summary>
        /// Required if `AzureEnabled`==`True`. Azure active directory tenant id.
        /// </summary>
        [Input("azureTenantId")]
        public Input<string>? AzureTenantId { get; set; }

        [Input("broadnetPassword")]
        private Input<string>? _broadnetPassword;

        /// <summary>
        /// Required if `SmsProvider`==`Broadnet`
        /// </summary>
        public Input<string>? BroadnetPassword
        {
            get => _broadnetPassword;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _broadnetPassword = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Required if `SmsProvider`==`Broadnet`
        /// </summary>
        [Input("broadnetSid")]
        public Input<string>? BroadnetSid { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Broadnet`
        /// </summary>
        [Input("broadnetUserId")]
        public Input<string>? BroadnetUserId { get; set; }

        /// <summary>
        /// Whether to bypass the guest portal when cloud not reachable (and apply the default policies)
        /// </summary>
        [Input("bypassWhenCloudDown")]
        public Input<bool>? BypassWhenCloudDown { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Clickatell`
        /// </summary>
        [Input("clickatellApiKey")]
        public Input<string>? ClickatellApiKey { get; set; }

        /// <summary>
        /// Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable RandomMac for seamless roaming)
        /// </summary>
        [Input("crossSite")]
        public Input<bool>? CrossSite { get; set; }

        /// <summary>
        /// Whether email (access code verification) is enabled as a login method
        /// </summary>
        [Input("emailEnabled")]
        public Input<bool>? EmailEnabled { get; set; }

        /// <summary>
        /// Whether guest portal is enabled
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// How long to remain authorized, in minutes
        /// </summary>
        [Input("expire")]
        public Input<int>? Expire { get; set; }

        /// <summary>
        /// Required if `WlanPortalAuth`==`External`. External portal URL (e.g. https://host/url) where we can append our query parameters to
        /// </summary>
        [Input("externalPortalUrl")]
        public Input<string>? ExternalPortalUrl { get; set; }

        /// <summary>
        /// Required if `FacebookEnabled`==`True`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
        /// </summary>
        [Input("facebookClientId")]
        public Input<string>? FacebookClientId { get; set; }

        /// <summary>
        /// Required if `FacebookEnabled`==`True`. Facebook OAuth2 app secret. If FacebookClientId was provided, provide a corresponding value. Else leave blank.
        /// </summary>
        [Input("facebookClientSecret")]
        public Input<string>? FacebookClientSecret { get; set; }

        [Input("facebookEmailDomains")]
        private InputList<string>? _facebookEmailDomains;

        /// <summary>
        /// Optional if `FacebookEnabled`==`True`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        /// </summary>
        public InputList<string> FacebookEmailDomains
        {
            get => _facebookEmailDomains ?? (_facebookEmailDomains = new InputList<string>());
            set => _facebookEmailDomains = value;
        }

        /// <summary>
        /// Whether facebook is enabled as a login method
        /// </summary>
        [Input("facebookEnabled")]
        public Input<bool>? FacebookEnabled { get; set; }

        /// <summary>
        /// Optional if `FacebookEnabled`==`True`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("facebookExpire")]
        public Input<int>? FacebookExpire { get; set; }

        /// <summary>
        /// Whether to forward the user to another URL after authorized
        /// </summary>
        [Input("forward")]
        public Input<bool>? Forward { get; set; }

        /// <summary>
        /// URL to forward the user to
        /// </summary>
        [Input("forwardUrl")]
        public Input<string>? ForwardUrl { get; set; }

        /// <summary>
        /// Google OAuth2 app id. This is optional. If not provided, it will use a default one.
        /// </summary>
        [Input("googleClientId")]
        public Input<string>? GoogleClientId { get; set; }

        /// <summary>
        /// Optional if `GoogleEnabled`==`True`. Google OAuth2 app secret. If GoogleClientId was provided, provide a corresponding value. Else leave blank.
        /// </summary>
        [Input("googleClientSecret")]
        public Input<string>? GoogleClientSecret { get; set; }

        [Input("googleEmailDomains")]
        private InputList<string>? _googleEmailDomains;

        /// <summary>
        /// Optional if `GoogleEnabled`==`True`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        /// </summary>
        public InputList<string> GoogleEmailDomains
        {
            get => _googleEmailDomains ?? (_googleEmailDomains = new InputList<string>());
            set => _googleEmailDomains = value;
        }

        /// <summary>
        /// Whether Google is enabled as login method
        /// </summary>
        [Input("googleEnabled")]
        public Input<bool>? GoogleEnabled { get; set; }

        /// <summary>
        /// Optional if `GoogleEnabled`==`True`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("googleExpire")]
        public Input<int>? GoogleExpire { get; set; }

        [Input("gupshupPassword")]
        private Input<string>? _gupshupPassword;

        /// <summary>
        /// Required if `SmsProvider`==`Gupshup`
        /// </summary>
        public Input<string>? GupshupPassword
        {
            get => _gupshupPassword;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _gupshupPassword = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Required if `SmsProvider`==`Gupshup`
        /// </summary>
        [Input("gupshupUserid")]
        public Input<string>? GupshupUserid { get; set; }

        /// <summary>
        /// Optional if `MicrosoftEnabled`==`True`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
        /// </summary>
        [Input("microsoftClientId")]
        public Input<string>? MicrosoftClientId { get; set; }

        /// <summary>
        /// Optional if `MicrosoftEnabled`==`True`. Microsoft 365 OAuth2 client secret. If MicrosoftClientId was provided, provide a corresponding value. Else leave blank.
        /// </summary>
        [Input("microsoftClientSecret")]
        public Input<string>? MicrosoftClientSecret { get; set; }

        [Input("microsoftEmailDomains")]
        private InputList<string>? _microsoftEmailDomains;

        /// <summary>
        /// Optional if `MicrosoftEnabled`==`True`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
        /// </summary>
        public InputList<string> MicrosoftEmailDomains
        {
            get => _microsoftEmailDomains ?? (_microsoftEmailDomains = new InputList<string>());
            set => _microsoftEmailDomains = value;
        }

        /// <summary>
        /// Whether microsoft 365 is enabled as a login method
        /// </summary>
        [Input("microsoftEnabled")]
        public Input<bool>? MicrosoftEnabled { get; set; }

        /// <summary>
        /// Optional if `MicrosoftEnabled`==`True`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("microsoftExpire")]
        public Input<int>? MicrosoftExpire { get; set; }

        /// <summary>
        /// Whether password is enabled
        /// </summary>
        [Input("passphraseEnabled")]
        public Input<bool>? PassphraseEnabled { get; set; }

        /// <summary>
        /// Optional if `PassphraseEnabled`==`True`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `Expire`
        /// </summary>
        [Input("passphraseExpire")]
        public Input<int>? PassphraseExpire { get; set; }

        [Input("password")]
        private Input<string>? _password;

        /// <summary>
        /// Required if `PassphraseEnabled`==`True`.
        /// </summary>
        public Input<string>? Password
        {
            get => _password;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _password = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Whether to show list of sponsor emails mentioned in `Sponsors` object as a dropdown. If both `SponsorNotifyAll` and `PredefinedSponsorsEnabled` are false, behavior is acc to `SponsorEmailDomains`
        /// </summary>
        [Input("predefinedSponsorsEnabled")]
        public Input<bool>? PredefinedSponsorsEnabled { get; set; }

        /// <summary>
        /// Whether to hide sponsor’s email from list of sponsors
        /// </summary>
        [Input("predefinedSponsorsHideEmail")]
        public Input<bool>? PredefinedSponsorsHideEmail { get; set; }

        [Input("privacy")]
        public Input<bool>? Privacy { get; set; }

        [Input("puzzelPassword")]
        private Input<string>? _puzzelPassword;

        /// <summary>
        /// Required if `SmsProvider`==`Puzzel`
        /// </summary>
        public Input<string>? PuzzelPassword
        {
            get => _puzzelPassword;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _puzzelPassword = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Required if `SmsProvider`==`Puzzel`
        /// </summary>
        [Input("puzzelServiceId")]
        public Input<string>? PuzzelServiceId { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Puzzel`
        /// </summary>
        [Input("puzzelUsername")]
        public Input<string>? PuzzelUsername { get; set; }

        /// <summary>
        /// Whether sms is enabled as a login method
        /// </summary>
        [Input("smsEnabled")]
        public Input<bool>? SmsEnabled { get; set; }

        /// <summary>
        /// Optional if `SmsEnabled`==`True`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("smsExpire")]
        public Input<int>? SmsExpire { get; set; }

        /// <summary>
        /// Optional if `SmsEnabled`==`True`. SMS Message format
        /// </summary>
        [Input("smsMessageFormat")]
        public Input<string>? SmsMessageFormat { get; set; }

        /// <summary>
        /// Optional if `SmsEnabled`==`True`. enum: `Broadnet`, `Clickatell`, `Gupshup`, `Manual`, `Puzzel`, `Smsglobal`, `Telstra`, `Twilio`
        /// </summary>
        [Input("smsProvider")]
        public Input<string>? SmsProvider { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Smsglobal`, Client API Key
        /// </summary>
        [Input("smsglobalApiKey")]
        public Input<string>? SmsglobalApiKey { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Smsglobal`, Client secret
        /// </summary>
        [Input("smsglobalApiSecret")]
        public Input<string>? SmsglobalApiSecret { get; set; }

        /// <summary>
        /// Optional if `SponsorEnabled`==`True`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs PredefinedSponsorsEnabled enabled and SponsorNotifyAll disabled
        /// </summary>
        [Input("sponsorAutoApprove")]
        public Input<bool>? SponsorAutoApprove { get; set; }

        [Input("sponsorEmailDomains")]
        private InputList<string>? _sponsorEmailDomains;

        /// <summary>
        /// List of domain allowed for sponsor email. Required if `SponsorEnabled` is `True` and `Sponsors` is empty.
        /// </summary>
        public InputList<string> SponsorEmailDomains
        {
            get => _sponsorEmailDomains ?? (_sponsorEmailDomains = new InputList<string>());
            set => _sponsorEmailDomains = value;
        }

        /// <summary>
        /// Whether sponsor is enabled
        /// </summary>
        [Input("sponsorEnabled")]
        public Input<bool>? SponsorEnabled { get; set; }

        /// <summary>
        /// Optional if `SponsorEnabled`==`True`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
        /// </summary>
        [Input("sponsorExpire")]
        public Input<int>? SponsorExpire { get; set; }

        /// <summary>
        /// Optional if `SponsorEnabled`==`True`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes. Default is 60 minutes.
        /// </summary>
        [Input("sponsorLinkValidityDuration")]
        public Input<string>? SponsorLinkValidityDuration { get; set; }

        /// <summary>
        /// Optional if `SponsorEnabled`==`True`. whether to notify all sponsors that are mentioned in `Sponsors` object. Both `SponsorNotifyAll` and `PredefinedSponsorsEnabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
        /// </summary>
        [Input("sponsorNotifyAll")]
        public Input<bool>? SponsorNotifyAll { get; set; }

        /// <summary>
        /// Optional if `SponsorEnabled`==`True`. If enabled, guest will get email about sponsor's action (approve/deny)
        /// </summary>
        [Input("sponsorStatusNotify")]
        public Input<bool>? SponsorStatusNotify { get; set; }

        [Input("sponsors")]
        private InputMap<string>? _sponsors;

        /// <summary>
        /// object of allowed sponsors email with name. Required if `SponsorEnabled`
        ///             is `True` and `SponsorEmailDomains` is empty.
        /// 
        ///             Property key is the sponsor email, Property value is the sponsor name
        /// </summary>
        public InputMap<string> Sponsors
        {
            get => _sponsors ?? (_sponsors = new InputMap<string>());
            set => _sponsors = value;
        }

        /// <summary>
        /// Optional if `WlanPortalAuth`==`Sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
        /// </summary>
        [Input("ssoDefaultRole")]
        public Input<string>? SsoDefaultRole { get; set; }

        /// <summary>
        /// Optional if `WlanPortalAuth`==`Sso`
        /// </summary>
        [Input("ssoForcedRole")]
        public Input<string>? SsoForcedRole { get; set; }

        /// <summary>
        /// Required if `WlanPortalAuth`==`Sso`. IDP Cert (used to verify the signed response)
        /// </summary>
        [Input("ssoIdpCert")]
        public Input<string>? SsoIdpCert { get; set; }

        /// <summary>
        /// Optional if `WlanPortalAuth`==`Sso`, Signing algorithm for SAML Assertion. enum: `Sha1`, `Sha256`, `Sha384`, `Sha512`
        /// </summary>
        [Input("ssoIdpSignAlgo")]
        public Input<string>? SsoIdpSignAlgo { get; set; }

        /// <summary>
        /// Required if `WlanPortalAuth`==`Sso`, IDP Single-Sign-On URL
        /// </summary>
        [Input("ssoIdpSsoUrl")]
        public Input<string>? SsoIdpSsoUrl { get; set; }

        /// <summary>
        /// Required if `WlanPortalAuth`==`Sso`, IDP issuer URL
        /// </summary>
        [Input("ssoIssuer")]
        public Input<string>? SsoIssuer { get; set; }

        /// <summary>
        /// Optional if `WlanPortalAuth`==`Sso`. enum: `Email`, `Unspecified`
        /// </summary>
        [Input("ssoNameidFormat")]
        public Input<string>? SsoNameidFormat { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Telstra`, Client ID provided by Telstra
        /// </summary>
        [Input("telstraClientId")]
        public Input<string>? TelstraClientId { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Telstra`, Client secret provided by Telstra
        /// </summary>
        [Input("telstraClientSecret")]
        public Input<string>? TelstraClientSecret { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Twilio`, Auth token account with twilio account
        /// </summary>
        [Input("twilioAuthToken")]
        public Input<string>? TwilioAuthToken { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Twilio`, Twilio phone number associated with the account. See example for accepted format.
        /// </summary>
        [Input("twilioPhoneNumber")]
        public Input<string>? TwilioPhoneNumber { get; set; }

        /// <summary>
        /// Required if `SmsProvider`==`Twilio`, Account SID provided by Twilio
        /// </summary>
        [Input("twilioSid")]
        public Input<string>? TwilioSid { get; set; }

        public WlanPortalGetArgs()
        {
        }
        public static new WlanPortalGetArgs Empty => new WlanPortalGetArgs();
    }
}
