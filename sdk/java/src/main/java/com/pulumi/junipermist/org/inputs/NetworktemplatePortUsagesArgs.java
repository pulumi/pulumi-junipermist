// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.org.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.junipermist.org.inputs.NetworktemplatePortUsagesRuleArgs;
import com.pulumi.junipermist.org.inputs.NetworktemplatePortUsagesStormControlArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NetworktemplatePortUsagesArgs extends com.pulumi.resources.ResourceArgs {

    public static final NetworktemplatePortUsagesArgs Empty = new NetworktemplatePortUsagesArgs();

    /**
     * Only if `mode`==`trunk`. Whether to trunk all network/vlans
     * 
     */
    @Import(name="allNetworks")
    private @Nullable Output<Boolean> allNetworks;

    /**
     * @return Only if `mode`==`trunk`. Whether to trunk all network/vlans
     * 
     */
    public Optional<Output<Boolean>> allNetworks() {
        return Optional.ofNullable(this.allNetworks);
    }

    /**
     * Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is an access or trunk port.
     * 
     */
    @Import(name="allowDhcpd")
    private @Nullable Output<Boolean> allowDhcpd;

    /**
     * @return Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is an access or trunk port.
     * 
     */
    public Optional<Output<Boolean>> allowDhcpd() {
        return Optional.ofNullable(this.allowDhcpd);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="allowMultipleSupplicants")
    private @Nullable Output<Boolean> allowMultipleSupplicants;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<Boolean>> allowMultipleSupplicants() {
        return Optional.ofNullable(this.allowMultipleSupplicants);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Bypass auth for known clients if set to true when RADIUS server is down
     * 
     */
    @Import(name="bypassAuthWhenServerDown")
    private @Nullable Output<Boolean> bypassAuthWhenServerDown;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Bypass auth for known clients if set to true when RADIUS server is down
     * 
     */
    public Optional<Output<Boolean>> bypassAuthWhenServerDown() {
        return Optional.ofNullable(this.bypassAuthWhenServerDown);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`=`dot1x`. Bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     * 
     */
    @Import(name="bypassAuthWhenServerDownForUnknownClient")
    private @Nullable Output<Boolean> bypassAuthWhenServerDownForUnknownClient;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`=`dot1x`. Bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     * 
     */
    public Optional<Output<Boolean>> bypassAuthWhenServerDownForUnknownClient() {
        return Optional.ofNullable(this.bypassAuthWhenServerDownForUnknownClient);
    }

    /**
     * Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
     * 
     */
    @Import(name="communityVlanId")
    private @Nullable Output<Integer> communityVlanId;

    /**
     * @return Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
     * 
     */
    public Optional<Output<Integer>> communityVlanId() {
        return Optional.ofNullable(this.communityVlanId);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Only if `mode`!=`dynamic`. If speed and duplex are specified, whether to disable autonegotiation
     * 
     */
    @Import(name="disableAutoneg")
    private @Nullable Output<Boolean> disableAutoneg;

    /**
     * @return Only if `mode`!=`dynamic`. If speed and duplex are specified, whether to disable autonegotiation
     * 
     */
    public Optional<Output<Boolean>> disableAutoneg() {
        return Optional.ofNullable(this.disableAutoneg);
    }

    /**
     * Only if `mode`!=`dynamic`. Whether the port is disabled
     * 
     */
    @Import(name="disabled")
    private @Nullable Output<Boolean> disabled;

    /**
     * @return Only if `mode`!=`dynamic`. Whether the port is disabled
     * 
     */
    public Optional<Output<Boolean>> disabled() {
        return Optional.ofNullable(this.disabled);
    }

    /**
     * Only if `mode`!=`dynamic`. Link connection mode. enum: `auto`, `full`, `half`
     * 
     */
    @Import(name="duplex")
    private @Nullable Output<String> duplex;

    /**
     * @return Only if `mode`!=`dynamic`. Link connection mode. enum: `auto`, `full`, `half`
     * 
     */
    public Optional<Output<String>> duplex() {
        return Optional.ofNullable(this.duplex);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     * 
     */
    @Import(name="dynamicVlanNetworks")
    private @Nullable Output<List<String>> dynamicVlanNetworks;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     * 
     */
    public Optional<Output<List<String>>> dynamicVlanNetworks() {
        return Optional.ofNullable(this.dynamicVlanNetworks);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Whether to enable MAC Auth
     * 
     */
    @Import(name="enableMacAuth")
    private @Nullable Output<Boolean> enableMacAuth;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Whether to enable MAC Auth
     * 
     */
    public Optional<Output<Boolean>> enableMacAuth() {
        return Optional.ofNullable(this.enableMacAuth);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="enableQos")
    private @Nullable Output<Boolean> enableQos;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<Boolean>> enableQos() {
        return Optional.ofNullable(this.enableQos);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     * 
     */
    @Import(name="guestNetwork")
    private @Nullable Output<String> guestNetwork;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     * 
     */
    public Optional<Output<String>> guestNetwork() {
        return Optional.ofNullable(this.guestNetwork);
    }

    /**
     * Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: `interSwitchLink` works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    @Import(name="interIsolationNetworkLink")
    private @Nullable Output<Boolean> interIsolationNetworkLink;

    /**
     * @return Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: `interSwitchLink` works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    public Optional<Output<Boolean>> interIsolationNetworkLink() {
        return Optional.ofNullable(this.interIsolationNetworkLink);
    }

    /**
     * Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    @Import(name="interSwitchLink")
    private @Nullable Output<Boolean> interSwitchLink;

    /**
     * @return Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    public Optional<Output<Boolean>> interSwitchLink() {
        return Optional.ofNullable(this.interSwitchLink);
    }

    /**
     * Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
     * 
     */
    @Import(name="macAuthOnly")
    private @Nullable Output<Boolean> macAuthOnly;

    /**
     * @return Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
     * 
     */
    public Optional<Output<Boolean>> macAuthOnly() {
        return Optional.ofNullable(this.macAuthOnly);
    }

    /**
     * Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
     * 
     */
    @Import(name="macAuthPreferred")
    private @Nullable Output<Boolean> macAuthPreferred;

    /**
     * @return Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
     * 
     */
    public Optional<Output<Boolean>> macAuthPreferred() {
        return Optional.ofNullable(this.macAuthPreferred);
    }

    /**
     * Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     * 
     */
    @Import(name="macAuthProtocol")
    private @Nullable Output<String> macAuthProtocol;

    /**
     * @return Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     * 
     */
    public Optional<Output<String>> macAuthProtocol() {
        return Optional.ofNullable(this.macAuthProtocol);
    }

    /**
     * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
     * 
     */
    @Import(name="macLimit")
    private @Nullable Output<String> macLimit;

    /**
     * @return Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
     * 
     */
    public Optional<Output<String>> macLimit() {
        return Optional.ofNullable(this.macLimit);
    }

    /**
     * `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     * 
     */
    @Import(name="mode")
    private @Nullable Output<String> mode;

    /**
     * @return `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     * 
     */
    public Optional<Output<String>> mode() {
        return Optional.ofNullable(this.mode);
    }

    /**
     * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
     * 
     */
    @Import(name="mtu")
    private @Nullable Output<String> mtu;

    /**
     * @return Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
     * 
     */
    public Optional<Output<String>> mtu() {
        return Optional.ofNullable(this.mtu);
    }

    /**
     * Only if `mode`==`trunk`, the list of network/vlans
     * 
     */
    @Import(name="networks")
    private @Nullable Output<List<String>> networks;

    /**
     * @return Only if `mode`==`trunk`, the list of network/vlans
     * 
     */
    public Optional<Output<List<String>>> networks() {
        return Optional.ofNullable(this.networks);
    }

    /**
     * Only if `mode`==`access` and `portAuth`!=`dot1x`. Whether the port should retain dynamically learned MAC addresses
     * 
     */
    @Import(name="persistMac")
    private @Nullable Output<Boolean> persistMac;

    /**
     * @return Only if `mode`==`access` and `portAuth`!=`dot1x`. Whether the port should retain dynamically learned MAC addresses
     * 
     */
    public Optional<Output<Boolean>> persistMac() {
        return Optional.ofNullable(this.persistMac);
    }

    /**
     * Only if `mode`!=`dynamic`. Whether PoE capabilities are disabled for a port
     * 
     */
    @Import(name="poeDisabled")
    private @Nullable Output<Boolean> poeDisabled;

    /**
     * @return Only if `mode`!=`dynamic`. Whether PoE capabilities are disabled for a port
     * 
     */
    public Optional<Output<Boolean>> poeDisabled() {
        return Optional.ofNullable(this.poeDisabled);
    }

    /**
     * Only if `mode`!=`dynamic`. If dot1x is desired, set to dot1x. enum: `dot1x`
     * 
     */
    @Import(name="portAuth")
    private @Nullable Output<String> portAuth;

    /**
     * @return Only if `mode`!=`dynamic`. If dot1x is desired, set to dot1x. enum: `dot1x`
     * 
     */
    public Optional<Output<String>> portAuth() {
        return Optional.ofNullable(this.portAuth);
    }

    /**
     * Only if `mode`!=`dynamic`. Native network/vlan for untagged traffic
     * 
     */
    @Import(name="portNetwork")
    private @Nullable Output<String> portNetwork;

    /**
     * @return Only if `mode`!=`dynamic`. Native network/vlan for untagged traffic
     * 
     */
    public Optional<Output<String>> portNetwork() {
        return Optional.ofNullable(this.portNetwork);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
     * 
     */
    @Import(name="reauthInterval")
    private @Nullable Output<String> reauthInterval;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
     * 
     */
    public Optional<Output<String>> reauthInterval() {
        return Optional.ofNullable(this.reauthInterval);
    }

    /**
     * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
     * 
     */
    @Import(name="resetDefaultWhen")
    private @Nullable Output<String> resetDefaultWhen;

    /**
     * @return Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
     * 
     */
    public Optional<Output<String>> resetDefaultWhen() {
        return Optional.ofNullable(this.resetDefaultWhen);
    }

    /**
     * Only if `mode`==`dynamic`
     * 
     */
    @Import(name="rules")
    private @Nullable Output<List<NetworktemplatePortUsagesRuleArgs>> rules;

    /**
     * @return Only if `mode`==`dynamic`
     * 
     */
    public Optional<Output<List<NetworktemplatePortUsagesRuleArgs>>> rules() {
        return Optional.ofNullable(this.rules);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Sets server fail fallback vlan
     * 
     */
    @Import(name="serverFailNetwork")
    private @Nullable Output<String> serverFailNetwork;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Sets server fail fallback vlan
     * 
     */
    public Optional<Output<String>> serverFailNetwork() {
        return Optional.ofNullable(this.serverFailNetwork);
    }

    /**
     * Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. When radius server reject / fails
     * 
     */
    @Import(name="serverRejectNetwork")
    private @Nullable Output<String> serverRejectNetwork;

    /**
     * @return Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. When radius server reject / fails
     * 
     */
    public Optional<Output<String>> serverRejectNetwork() {
        return Optional.ofNullable(this.serverRejectNetwork);
    }

    /**
     * Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
     * 
     */
    @Import(name="speed")
    private @Nullable Output<String> speed;

    /**
     * @return Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
     * 
     */
    public Optional<Output<String>> speed() {
        return Optional.ofNullable(this.speed);
    }

    /**
     * Switch storm control. Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="stormControl")
    private @Nullable Output<NetworktemplatePortUsagesStormControlArgs> stormControl;

    /**
     * @return Switch storm control. Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<NetworktemplatePortUsagesStormControlArgs>> stormControl() {
        return Optional.ofNullable(this.stormControl);
    }

    /**
     * Only if `mode`!=`dynamic` and `stpRequired`==`false`. Drop bridge protocol data units (BPDUs ) that enter any interface or a specified interface
     * 
     */
    @Import(name="stpDisable")
    private @Nullable Output<Boolean> stpDisable;

    /**
     * @return Only if `mode`!=`dynamic` and `stpRequired`==`false`. Drop bridge protocol data units (BPDUs ) that enter any interface or a specified interface
     * 
     */
    public Optional<Output<Boolean>> stpDisable() {
        return Optional.ofNullable(this.stpDisable);
    }

    /**
     * Only if `mode`!=`dynamic`. When enabled, the port is not expected to receive BPDU frames
     * 
     */
    @Import(name="stpEdge")
    private @Nullable Output<Boolean> stpEdge;

    /**
     * @return Only if `mode`!=`dynamic`. When enabled, the port is not expected to receive BPDU frames
     * 
     */
    public Optional<Output<Boolean>> stpEdge() {
        return Optional.ofNullable(this.stpEdge);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="stpNoRootPort")
    private @Nullable Output<Boolean> stpNoRootPort;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<Boolean>> stpNoRootPort() {
        return Optional.ofNullable(this.stpNoRootPort);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="stpP2p")
    private @Nullable Output<Boolean> stpP2p;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<Boolean>> stpP2p() {
        return Optional.ofNullable(this.stpP2p);
    }

    /**
     * Only if `mode`!=`dynamic`. Whether to remain in block state if no BPDU is received
     * 
     */
    @Import(name="stpRequired")
    private @Nullable Output<Boolean> stpRequired;

    /**
     * @return Only if `mode`!=`dynamic`. Whether to remain in block state if no BPDU is received
     * 
     */
    public Optional<Output<Boolean>> stpRequired() {
        return Optional.ofNullable(this.stpRequired);
    }

    /**
     * Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
     * 
     */
    @Import(name="uiEvpntopoId")
    private @Nullable Output<String> uiEvpntopoId;

    /**
     * @return Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
     * 
     */
    public Optional<Output<String>> uiEvpntopoId() {
        return Optional.ofNullable(this.uiEvpntopoId);
    }

    /**
     * If this is connected to a vstp network
     * 
     */
    @Import(name="useVstp")
    private @Nullable Output<Boolean> useVstp;

    /**
     * @return If this is connected to a vstp network
     * 
     */
    public Optional<Output<Boolean>> useVstp() {
        return Optional.ofNullable(this.useVstp);
    }

    /**
     * Only if `mode`!=`dynamic`. Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     * 
     */
    @Import(name="voipNetwork")
    private @Nullable Output<String> voipNetwork;

    /**
     * @return Only if `mode`!=`dynamic`. Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     * 
     */
    public Optional<Output<String>> voipNetwork() {
        return Optional.ofNullable(this.voipNetwork);
    }

    private NetworktemplatePortUsagesArgs() {}

    private NetworktemplatePortUsagesArgs(NetworktemplatePortUsagesArgs $) {
        this.allNetworks = $.allNetworks;
        this.allowDhcpd = $.allowDhcpd;
        this.allowMultipleSupplicants = $.allowMultipleSupplicants;
        this.bypassAuthWhenServerDown = $.bypassAuthWhenServerDown;
        this.bypassAuthWhenServerDownForUnknownClient = $.bypassAuthWhenServerDownForUnknownClient;
        this.communityVlanId = $.communityVlanId;
        this.description = $.description;
        this.disableAutoneg = $.disableAutoneg;
        this.disabled = $.disabled;
        this.duplex = $.duplex;
        this.dynamicVlanNetworks = $.dynamicVlanNetworks;
        this.enableMacAuth = $.enableMacAuth;
        this.enableQos = $.enableQos;
        this.guestNetwork = $.guestNetwork;
        this.interIsolationNetworkLink = $.interIsolationNetworkLink;
        this.interSwitchLink = $.interSwitchLink;
        this.macAuthOnly = $.macAuthOnly;
        this.macAuthPreferred = $.macAuthPreferred;
        this.macAuthProtocol = $.macAuthProtocol;
        this.macLimit = $.macLimit;
        this.mode = $.mode;
        this.mtu = $.mtu;
        this.networks = $.networks;
        this.persistMac = $.persistMac;
        this.poeDisabled = $.poeDisabled;
        this.portAuth = $.portAuth;
        this.portNetwork = $.portNetwork;
        this.reauthInterval = $.reauthInterval;
        this.resetDefaultWhen = $.resetDefaultWhen;
        this.rules = $.rules;
        this.serverFailNetwork = $.serverFailNetwork;
        this.serverRejectNetwork = $.serverRejectNetwork;
        this.speed = $.speed;
        this.stormControl = $.stormControl;
        this.stpDisable = $.stpDisable;
        this.stpEdge = $.stpEdge;
        this.stpNoRootPort = $.stpNoRootPort;
        this.stpP2p = $.stpP2p;
        this.stpRequired = $.stpRequired;
        this.uiEvpntopoId = $.uiEvpntopoId;
        this.useVstp = $.useVstp;
        this.voipNetwork = $.voipNetwork;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NetworktemplatePortUsagesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NetworktemplatePortUsagesArgs $;

        public Builder() {
            $ = new NetworktemplatePortUsagesArgs();
        }

        public Builder(NetworktemplatePortUsagesArgs defaults) {
            $ = new NetworktemplatePortUsagesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allNetworks Only if `mode`==`trunk`. Whether to trunk all network/vlans
         * 
         * @return builder
         * 
         */
        public Builder allNetworks(@Nullable Output<Boolean> allNetworks) {
            $.allNetworks = allNetworks;
            return this;
        }

        /**
         * @param allNetworks Only if `mode`==`trunk`. Whether to trunk all network/vlans
         * 
         * @return builder
         * 
         */
        public Builder allNetworks(Boolean allNetworks) {
            return allNetworks(Output.of(allNetworks));
        }

        /**
         * @param allowDhcpd Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is an access or trunk port.
         * 
         * @return builder
         * 
         */
        public Builder allowDhcpd(@Nullable Output<Boolean> allowDhcpd) {
            $.allowDhcpd = allowDhcpd;
            return this;
        }

        /**
         * @param allowDhcpd Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allowDhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is an access or trunk port.
         * 
         * @return builder
         * 
         */
        public Builder allowDhcpd(Boolean allowDhcpd) {
            return allowDhcpd(Output.of(allowDhcpd));
        }

        /**
         * @param allowMultipleSupplicants Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder allowMultipleSupplicants(@Nullable Output<Boolean> allowMultipleSupplicants) {
            $.allowMultipleSupplicants = allowMultipleSupplicants;
            return this;
        }

        /**
         * @param allowMultipleSupplicants Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder allowMultipleSupplicants(Boolean allowMultipleSupplicants) {
            return allowMultipleSupplicants(Output.of(allowMultipleSupplicants));
        }

        /**
         * @param bypassAuthWhenServerDown Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Bypass auth for known clients if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDown(@Nullable Output<Boolean> bypassAuthWhenServerDown) {
            $.bypassAuthWhenServerDown = bypassAuthWhenServerDown;
            return this;
        }

        /**
         * @param bypassAuthWhenServerDown Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Bypass auth for known clients if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDown(Boolean bypassAuthWhenServerDown) {
            return bypassAuthWhenServerDown(Output.of(bypassAuthWhenServerDown));
        }

        /**
         * @param bypassAuthWhenServerDownForUnknownClient Only if `mode`!=`dynamic` and `portAuth`=`dot1x`. Bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDownForUnknownClient(@Nullable Output<Boolean> bypassAuthWhenServerDownForUnknownClient) {
            $.bypassAuthWhenServerDownForUnknownClient = bypassAuthWhenServerDownForUnknownClient;
            return this;
        }

        /**
         * @param bypassAuthWhenServerDownForUnknownClient Only if `mode`!=`dynamic` and `portAuth`=`dot1x`. Bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDownForUnknownClient(Boolean bypassAuthWhenServerDownForUnknownClient) {
            return bypassAuthWhenServerDownForUnknownClient(Output.of(bypassAuthWhenServerDownForUnknownClient));
        }

        /**
         * @param communityVlanId Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
         * 
         * @return builder
         * 
         */
        public Builder communityVlanId(@Nullable Output<Integer> communityVlanId) {
            $.communityVlanId = communityVlanId;
            return this;
        }

        /**
         * @param communityVlanId Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other
         * 
         * @return builder
         * 
         */
        public Builder communityVlanId(Integer communityVlanId) {
            return communityVlanId(Output.of(communityVlanId));
        }

        /**
         * @param description Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disableAutoneg Only if `mode`!=`dynamic`. If speed and duplex are specified, whether to disable autonegotiation
         * 
         * @return builder
         * 
         */
        public Builder disableAutoneg(@Nullable Output<Boolean> disableAutoneg) {
            $.disableAutoneg = disableAutoneg;
            return this;
        }

        /**
         * @param disableAutoneg Only if `mode`!=`dynamic`. If speed and duplex are specified, whether to disable autonegotiation
         * 
         * @return builder
         * 
         */
        public Builder disableAutoneg(Boolean disableAutoneg) {
            return disableAutoneg(Output.of(disableAutoneg));
        }

        /**
         * @param disabled Only if `mode`!=`dynamic`. Whether the port is disabled
         * 
         * @return builder
         * 
         */
        public Builder disabled(@Nullable Output<Boolean> disabled) {
            $.disabled = disabled;
            return this;
        }

        /**
         * @param disabled Only if `mode`!=`dynamic`. Whether the port is disabled
         * 
         * @return builder
         * 
         */
        public Builder disabled(Boolean disabled) {
            return disabled(Output.of(disabled));
        }

        /**
         * @param duplex Only if `mode`!=`dynamic`. Link connection mode. enum: `auto`, `full`, `half`
         * 
         * @return builder
         * 
         */
        public Builder duplex(@Nullable Output<String> duplex) {
            $.duplex = duplex;
            return this;
        }

        /**
         * @param duplex Only if `mode`!=`dynamic`. Link connection mode. enum: `auto`, `full`, `half`
         * 
         * @return builder
         * 
         */
        public Builder duplex(String duplex) {
            return duplex(Output.of(duplex));
        }

        /**
         * @param dynamicVlanNetworks Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(@Nullable Output<List<String>> dynamicVlanNetworks) {
            $.dynamicVlanNetworks = dynamicVlanNetworks;
            return this;
        }

        /**
         * @param dynamicVlanNetworks Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(List<String> dynamicVlanNetworks) {
            return dynamicVlanNetworks(Output.of(dynamicVlanNetworks));
        }

        /**
         * @param dynamicVlanNetworks Only if `mode`!=`dynamic` and `portAuth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(String... dynamicVlanNetworks) {
            return dynamicVlanNetworks(List.of(dynamicVlanNetworks));
        }

        /**
         * @param enableMacAuth Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Whether to enable MAC Auth
         * 
         * @return builder
         * 
         */
        public Builder enableMacAuth(@Nullable Output<Boolean> enableMacAuth) {
            $.enableMacAuth = enableMacAuth;
            return this;
        }

        /**
         * @param enableMacAuth Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Whether to enable MAC Auth
         * 
         * @return builder
         * 
         */
        public Builder enableMacAuth(Boolean enableMacAuth) {
            return enableMacAuth(Output.of(enableMacAuth));
        }

        /**
         * @param enableQos Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder enableQos(@Nullable Output<Boolean> enableQos) {
            $.enableQos = enableQos;
            return this;
        }

        /**
         * @param enableQos Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder enableQos(Boolean enableQos) {
            return enableQos(Output.of(enableQos));
        }

        /**
         * @param guestNetwork Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         * 
         * @return builder
         * 
         */
        public Builder guestNetwork(@Nullable Output<String> guestNetwork) {
            $.guestNetwork = guestNetwork;
            return this;
        }

        /**
         * @param guestNetwork Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         * 
         * @return builder
         * 
         */
        public Builder guestNetwork(String guestNetwork) {
            return guestNetwork(Output.of(guestNetwork));
        }

        /**
         * @param interIsolationNetworkLink Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: `interSwitchLink` works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interIsolationNetworkLink(@Nullable Output<Boolean> interIsolationNetworkLink) {
            $.interIsolationNetworkLink = interIsolationNetworkLink;
            return this;
        }

        /**
         * @param interIsolationNetworkLink Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: `interSwitchLink` works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interIsolationNetworkLink(Boolean interIsolationNetworkLink) {
            return interIsolationNetworkLink(Output.of(interIsolationNetworkLink));
        }

        /**
         * @param interSwitchLink Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interSwitchLink(@Nullable Output<Boolean> interSwitchLink) {
            $.interSwitchLink = interSwitchLink;
            return this;
        }

        /**
         * @param interSwitchLink Only if `mode`!=`dynamic`. `interSwitchLink` is used together with `isolation` under networks. NOTE: interSwitchLink works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interSwitchLink(Boolean interSwitchLink) {
            return interSwitchLink(Output.of(interSwitchLink));
        }

        /**
         * @param macAuthOnly Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         * 
         * @return builder
         * 
         */
        public Builder macAuthOnly(@Nullable Output<Boolean> macAuthOnly) {
            $.macAuthOnly = macAuthOnly;
            return this;
        }

        /**
         * @param macAuthOnly Only if `mode`!=`dynamic` and `enableMacAuth`==`true`
         * 
         * @return builder
         * 
         */
        public Builder macAuthOnly(Boolean macAuthOnly) {
            return macAuthOnly(Output.of(macAuthOnly));
        }

        /**
         * @param macAuthPreferred Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
         * 
         * @return builder
         * 
         */
        public Builder macAuthPreferred(@Nullable Output<Boolean> macAuthPreferred) {
            $.macAuthPreferred = macAuthPreferred;
            return this;
        }

        /**
         * @param macAuthPreferred Only if `mode`!=`dynamic` + `enableMacAuth`==`true` + `macAuthOnly`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer macAuth over dot1x.
         * 
         * @return builder
         * 
         */
        public Builder macAuthPreferred(Boolean macAuthPreferred) {
            return macAuthPreferred(Output.of(macAuthPreferred));
        }

        /**
         * @param macAuthProtocol Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         * 
         * @return builder
         * 
         */
        public Builder macAuthProtocol(@Nullable Output<String> macAuthProtocol) {
            $.macAuthProtocol = macAuthProtocol;
            return this;
        }

        /**
         * @param macAuthProtocol Only if `mode`!=`dynamic` and `enableMacAuth` ==`true`. This type is ignored if mistNac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         * 
         * @return builder
         * 
         */
        public Builder macAuthProtocol(String macAuthProtocol) {
            return macAuthProtocol(Output.of(macAuthProtocol));
        }

        /**
         * @param macLimit Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
         * 
         * @return builder
         * 
         */
        public Builder macLimit(@Nullable Output<String> macLimit) {
            $.macLimit = macLimit;
            return this;
        }

        /**
         * @param macLimit Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)
         * 
         * @return builder
         * 
         */
        public Builder macLimit(String macLimit) {
            return macLimit(Output.of(macLimit));
        }

        /**
         * @param mode `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         * 
         * @return builder
         * 
         */
        public Builder mode(@Nullable Output<String> mode) {
            $.mode = mode;
            return this;
        }

        /**
         * @param mode `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         * 
         * @return builder
         * 
         */
        public Builder mode(String mode) {
            return mode(Output.of(mode));
        }

        /**
         * @param mtu Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
         * 
         * @return builder
         * 
         */
        public Builder mtu(@Nullable Output<String> mtu) {
            $.mtu = mtu;
            return this;
        }

        /**
         * @param mtu Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.
         * 
         * @return builder
         * 
         */
        public Builder mtu(String mtu) {
            return mtu(Output.of(mtu));
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(@Nullable Output<List<String>> networks) {
            $.networks = networks;
            return this;
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(List<String> networks) {
            return networks(Output.of(networks));
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(String... networks) {
            return networks(List.of(networks));
        }

        /**
         * @param persistMac Only if `mode`==`access` and `portAuth`!=`dot1x`. Whether the port should retain dynamically learned MAC addresses
         * 
         * @return builder
         * 
         */
        public Builder persistMac(@Nullable Output<Boolean> persistMac) {
            $.persistMac = persistMac;
            return this;
        }

        /**
         * @param persistMac Only if `mode`==`access` and `portAuth`!=`dot1x`. Whether the port should retain dynamically learned MAC addresses
         * 
         * @return builder
         * 
         */
        public Builder persistMac(Boolean persistMac) {
            return persistMac(Output.of(persistMac));
        }

        /**
         * @param poeDisabled Only if `mode`!=`dynamic`. Whether PoE capabilities are disabled for a port
         * 
         * @return builder
         * 
         */
        public Builder poeDisabled(@Nullable Output<Boolean> poeDisabled) {
            $.poeDisabled = poeDisabled;
            return this;
        }

        /**
         * @param poeDisabled Only if `mode`!=`dynamic`. Whether PoE capabilities are disabled for a port
         * 
         * @return builder
         * 
         */
        public Builder poeDisabled(Boolean poeDisabled) {
            return poeDisabled(Output.of(poeDisabled));
        }

        /**
         * @param portAuth Only if `mode`!=`dynamic`. If dot1x is desired, set to dot1x. enum: `dot1x`
         * 
         * @return builder
         * 
         */
        public Builder portAuth(@Nullable Output<String> portAuth) {
            $.portAuth = portAuth;
            return this;
        }

        /**
         * @param portAuth Only if `mode`!=`dynamic`. If dot1x is desired, set to dot1x. enum: `dot1x`
         * 
         * @return builder
         * 
         */
        public Builder portAuth(String portAuth) {
            return portAuth(Output.of(portAuth));
        }

        /**
         * @param portNetwork Only if `mode`!=`dynamic`. Native network/vlan for untagged traffic
         * 
         * @return builder
         * 
         */
        public Builder portNetwork(@Nullable Output<String> portNetwork) {
            $.portNetwork = portNetwork;
            return this;
        }

        /**
         * @param portNetwork Only if `mode`!=`dynamic`. Native network/vlan for untagged traffic
         * 
         * @return builder
         * 
         */
        public Builder portNetwork(String portNetwork) {
            return portNetwork(Output.of(portNetwork));
        }

        /**
         * @param reauthInterval Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
         * 
         * @return builder
         * 
         */
        public Builder reauthInterval(@Nullable Output<String> reauthInterval) {
            $.reauthInterval = reauthInterval;
            return this;
        }

        /**
         * @param reauthInterval Only if `mode`!=`dynamic` and `portAuth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)
         * 
         * @return builder
         * 
         */
        public Builder reauthInterval(String reauthInterval) {
            return reauthInterval(Output.of(reauthInterval));
        }

        /**
         * @param resetDefaultWhen Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         * 
         * @return builder
         * 
         */
        public Builder resetDefaultWhen(@Nullable Output<String> resetDefaultWhen) {
            $.resetDefaultWhen = resetDefaultWhen;
            return this;
        }

        /**
         * @param resetDefaultWhen Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `linkDown`, `none` (let the DPC port keep at the current port usage)
         * 
         * @return builder
         * 
         */
        public Builder resetDefaultWhen(String resetDefaultWhen) {
            return resetDefaultWhen(Output.of(resetDefaultWhen));
        }

        /**
         * @param rules Only if `mode`==`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder rules(@Nullable Output<List<NetworktemplatePortUsagesRuleArgs>> rules) {
            $.rules = rules;
            return this;
        }

        /**
         * @param rules Only if `mode`==`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder rules(List<NetworktemplatePortUsagesRuleArgs> rules) {
            return rules(Output.of(rules));
        }

        /**
         * @param rules Only if `mode`==`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder rules(NetworktemplatePortUsagesRuleArgs... rules) {
            return rules(List.of(rules));
        }

        /**
         * @param serverFailNetwork Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Sets server fail fallback vlan
         * 
         * @return builder
         * 
         */
        public Builder serverFailNetwork(@Nullable Output<String> serverFailNetwork) {
            $.serverFailNetwork = serverFailNetwork;
            return this;
        }

        /**
         * @param serverFailNetwork Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. Sets server fail fallback vlan
         * 
         * @return builder
         * 
         */
        public Builder serverFailNetwork(String serverFailNetwork) {
            return serverFailNetwork(Output.of(serverFailNetwork));
        }

        /**
         * @param serverRejectNetwork Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. When radius server reject / fails
         * 
         * @return builder
         * 
         */
        public Builder serverRejectNetwork(@Nullable Output<String> serverRejectNetwork) {
            $.serverRejectNetwork = serverRejectNetwork;
            return this;
        }

        /**
         * @param serverRejectNetwork Only if `mode`!=`dynamic` and `portAuth`==`dot1x`. When radius server reject / fails
         * 
         * @return builder
         * 
         */
        public Builder serverRejectNetwork(String serverRejectNetwork) {
            return serverRejectNetwork(Output.of(serverRejectNetwork));
        }

        /**
         * @param speed Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         * 
         * @return builder
         * 
         */
        public Builder speed(@Nullable Output<String> speed) {
            $.speed = speed;
            return this;
        }

        /**
         * @param speed Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         * 
         * @return builder
         * 
         */
        public Builder speed(String speed) {
            return speed(Output.of(speed));
        }

        /**
         * @param stormControl Switch storm control. Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stormControl(@Nullable Output<NetworktemplatePortUsagesStormControlArgs> stormControl) {
            $.stormControl = stormControl;
            return this;
        }

        /**
         * @param stormControl Switch storm control. Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stormControl(NetworktemplatePortUsagesStormControlArgs stormControl) {
            return stormControl(Output.of(stormControl));
        }

        /**
         * @param stpDisable Only if `mode`!=`dynamic` and `stpRequired`==`false`. Drop bridge protocol data units (BPDUs ) that enter any interface or a specified interface
         * 
         * @return builder
         * 
         */
        public Builder stpDisable(@Nullable Output<Boolean> stpDisable) {
            $.stpDisable = stpDisable;
            return this;
        }

        /**
         * @param stpDisable Only if `mode`!=`dynamic` and `stpRequired`==`false`. Drop bridge protocol data units (BPDUs ) that enter any interface or a specified interface
         * 
         * @return builder
         * 
         */
        public Builder stpDisable(Boolean stpDisable) {
            return stpDisable(Output.of(stpDisable));
        }

        /**
         * @param stpEdge Only if `mode`!=`dynamic`. When enabled, the port is not expected to receive BPDU frames
         * 
         * @return builder
         * 
         */
        public Builder stpEdge(@Nullable Output<Boolean> stpEdge) {
            $.stpEdge = stpEdge;
            return this;
        }

        /**
         * @param stpEdge Only if `mode`!=`dynamic`. When enabled, the port is not expected to receive BPDU frames
         * 
         * @return builder
         * 
         */
        public Builder stpEdge(Boolean stpEdge) {
            return stpEdge(Output.of(stpEdge));
        }

        /**
         * @param stpNoRootPort Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stpNoRootPort(@Nullable Output<Boolean> stpNoRootPort) {
            $.stpNoRootPort = stpNoRootPort;
            return this;
        }

        /**
         * @param stpNoRootPort Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stpNoRootPort(Boolean stpNoRootPort) {
            return stpNoRootPort(Output.of(stpNoRootPort));
        }

        /**
         * @param stpP2p Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stpP2p(@Nullable Output<Boolean> stpP2p) {
            $.stpP2p = stpP2p;
            return this;
        }

        /**
         * @param stpP2p Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stpP2p(Boolean stpP2p) {
            return stpP2p(Output.of(stpP2p));
        }

        /**
         * @param stpRequired Only if `mode`!=`dynamic`. Whether to remain in block state if no BPDU is received
         * 
         * @return builder
         * 
         */
        public Builder stpRequired(@Nullable Output<Boolean> stpRequired) {
            $.stpRequired = stpRequired;
            return this;
        }

        /**
         * @param stpRequired Only if `mode`!=`dynamic`. Whether to remain in block state if no BPDU is received
         * 
         * @return builder
         * 
         */
        public Builder stpRequired(Boolean stpRequired) {
            return stpRequired(Output.of(stpRequired));
        }

        /**
         * @param uiEvpntopoId Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
         * 
         * @return builder
         * 
         */
        public Builder uiEvpntopoId(@Nullable Output<String> uiEvpntopoId) {
            $.uiEvpntopoId = uiEvpntopoId;
            return this;
        }

        /**
         * @param uiEvpntopoId Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches
         * 
         * @return builder
         * 
         */
        public Builder uiEvpntopoId(String uiEvpntopoId) {
            return uiEvpntopoId(Output.of(uiEvpntopoId));
        }

        /**
         * @param useVstp If this is connected to a vstp network
         * 
         * @return builder
         * 
         */
        public Builder useVstp(@Nullable Output<Boolean> useVstp) {
            $.useVstp = useVstp;
            return this;
        }

        /**
         * @param useVstp If this is connected to a vstp network
         * 
         * @return builder
         * 
         */
        public Builder useVstp(Boolean useVstp) {
            return useVstp(Output.of(useVstp));
        }

        /**
         * @param voipNetwork Only if `mode`!=`dynamic`. Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         * 
         * @return builder
         * 
         */
        public Builder voipNetwork(@Nullable Output<String> voipNetwork) {
            $.voipNetwork = voipNetwork;
            return this;
        }

        /**
         * @param voipNetwork Only if `mode`!=`dynamic`. Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         * 
         * @return builder
         * 
         */
        public Builder voipNetwork(String voipNetwork) {
            return voipNetwork(Output.of(voipNetwork));
        }

        public NetworktemplatePortUsagesArgs build() {
            return $;
        }
    }

}
