// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.site.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.junipermist.site.inputs.WlanAcctServerArgs;
import com.pulumi.junipermist.site.inputs.WlanAirwatchArgs;
import com.pulumi.junipermist.site.inputs.WlanAppLimitArgs;
import com.pulumi.junipermist.site.inputs.WlanAppQosArgs;
import com.pulumi.junipermist.site.inputs.WlanAuthArgs;
import com.pulumi.junipermist.site.inputs.WlanAuthServerArgs;
import com.pulumi.junipermist.site.inputs.WlanBonjourArgs;
import com.pulumi.junipermist.site.inputs.WlanCiscoCwaArgs;
import com.pulumi.junipermist.site.inputs.WlanCoaServerArgs;
import com.pulumi.junipermist.site.inputs.WlanDnsServerRewriteArgs;
import com.pulumi.junipermist.site.inputs.WlanDynamicPskArgs;
import com.pulumi.junipermist.site.inputs.WlanDynamicVlanArgs;
import com.pulumi.junipermist.site.inputs.WlanHotspot20Args;
import com.pulumi.junipermist.site.inputs.WlanInjectDhcpOption82Args;
import com.pulumi.junipermist.site.inputs.WlanMistNacArgs;
import com.pulumi.junipermist.site.inputs.WlanPortalArgs;
import com.pulumi.junipermist.site.inputs.WlanQosArgs;
import com.pulumi.junipermist.site.inputs.WlanRadsecArgs;
import com.pulumi.junipermist.site.inputs.WlanRatesetArgs;
import com.pulumi.junipermist.site.inputs.WlanScheduleArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class WlanState extends com.pulumi.resources.ResourceArgs {

    public static final WlanState Empty = new WlanState();

    /**
     * enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    @Import(name="acctImmediateUpdate")
    private @Nullable Output<Boolean> acctImmediateUpdate;

    /**
     * @return enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    public Optional<Output<Boolean>> acctImmediateUpdate() {
        return Optional.ofNullable(this.acctImmediateUpdate);
    }

    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     * 
     */
    @Import(name="acctInterimInterval")
    private @Nullable Output<Integer> acctInterimInterval;

    /**
     * @return how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     * 
     */
    public Optional<Output<Integer>> acctInterimInterval() {
        return Optional.ofNullable(this.acctInterimInterval);
    }

    /**
     * list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    @Import(name="acctServers")
    private @Nullable Output<List<WlanAcctServerArgs>> acctServers;

    /**
     * @return list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    public Optional<Output<List<WlanAcctServerArgs>>> acctServers() {
        return Optional.ofNullable(this.acctServers);
    }

    /**
     * airwatch wlan settings
     * 
     */
    @Import(name="airwatch")
    private @Nullable Output<WlanAirwatchArgs> airwatch;

    /**
     * @return airwatch wlan settings
     * 
     */
    public Optional<Output<WlanAirwatchArgs>> airwatch() {
        return Optional.ofNullable(this.airwatch);
    }

    /**
     * only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    @Import(name="allowIpv6Ndp")
    private @Nullable Output<Boolean> allowIpv6Ndp;

    /**
     * @return only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    public Optional<Output<Boolean>> allowIpv6Ndp() {
        return Optional.ofNullable(this.allowIpv6Ndp);
    }

    /**
     * only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    @Import(name="allowMdns")
    private @Nullable Output<Boolean> allowMdns;

    /**
     * @return only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    public Optional<Output<Boolean>> allowMdns() {
        return Optional.ofNullable(this.allowMdns);
    }

    /**
     * only applicable when `limit_bcast`==`true`, which allows SSDP
     * 
     */
    @Import(name="allowSsdp")
    private @Nullable Output<Boolean> allowSsdp;

    /**
     * @return only applicable when `limit_bcast`==`true`, which allows SSDP
     * 
     */
    public Optional<Output<Boolean>> allowSsdp() {
        return Optional.ofNullable(this.allowSsdp);
    }

    /**
     * list of device ids
     * 
     */
    @Import(name="apIds")
    private @Nullable Output<List<String>> apIds;

    /**
     * @return list of device ids
     * 
     */
    public Optional<Output<List<String>>> apIds() {
        return Optional.ofNullable(this.apIds);
    }

    /**
     * bandwidth limiting for apps (applies to up/down)
     * 
     */
    @Import(name="appLimit")
    private @Nullable Output<WlanAppLimitArgs> appLimit;

    /**
     * @return bandwidth limiting for apps (applies to up/down)
     * 
     */
    public Optional<Output<WlanAppLimitArgs>> appLimit() {
        return Optional.ofNullable(this.appLimit);
    }

    /**
     * app qos wlan settings
     * 
     */
    @Import(name="appQos")
    private @Nullable Output<WlanAppQosArgs> appQos;

    /**
     * @return app qos wlan settings
     * 
     */
    public Optional<Output<WlanAppQosArgs>> appQos() {
        return Optional.ofNullable(this.appQos);
    }

    /**
     * enum: `aps`, `site`, `wxtags`
     * 
     */
    @Import(name="applyTo")
    private @Nullable Output<String> applyTo;

    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    public Optional<Output<String>> applyTo() {
        return Optional.ofNullable(this.applyTo);
    }

    /**
     * whether to enable smart arp filter
     * 
     */
    @Import(name="arpFilter")
    private @Nullable Output<Boolean> arpFilter;

    /**
     * @return whether to enable smart arp filter
     * 
     */
    public Optional<Output<Boolean>> arpFilter() {
        return Optional.ofNullable(this.arpFilter);
    }

    /**
     * authentication wlan settings
     * 
     */
    @Import(name="auth")
    private @Nullable Output<WlanAuthArgs> auth;

    /**
     * @return authentication wlan settings
     * 
     */
    public Optional<Output<WlanAuthArgs>> auth() {
        return Optional.ofNullable(this.auth);
    }

    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    @Import(name="authServerSelection")
    private @Nullable Output<String> authServerSelection;

    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    public Optional<Output<String>> authServerSelection() {
        return Optional.ofNullable(this.authServerSelection);
    }

    /**
     * list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     * 
     */
    @Import(name="authServers")
    private @Nullable Output<List<WlanAuthServerArgs>> authServers;

    /**
     * @return list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     * 
     */
    public Optional<Output<List<WlanAuthServerArgs>>> authServers() {
        return Optional.ofNullable(this.authServers);
    }

    /**
     * optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    @Import(name="authServersNasId")
    private @Nullable Output<String> authServersNasId;

    /**
     * @return optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    public Optional<Output<String>> authServersNasId() {
        return Optional.ofNullable(this.authServersNasId);
    }

    /**
     * optional, NAS-IP-ADDRESS to use
     * 
     */
    @Import(name="authServersNasIp")
    private @Nullable Output<String> authServersNasIp;

    /**
     * @return optional, NAS-IP-ADDRESS to use
     * 
     */
    public Optional<Output<String>> authServersNasIp() {
        return Optional.ofNullable(this.authServersNasIp);
    }

    /**
     * radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
     * default value to 3.
     * 
     */
    @Import(name="authServersRetries")
    private @Nullable Output<Integer> authServersRetries;

    /**
     * @return radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
     * default value to 3.
     * 
     */
    public Optional<Output<Integer>> authServersRetries() {
        return Optional.ofNullable(this.authServersRetries);
    }

    /**
     * radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    @Import(name="authServersTimeout")
    private @Nullable Output<Integer> authServersTimeout;

    /**
     * @return radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    public Optional<Output<Integer>> authServersTimeout() {
        return Optional.ofNullable(this.authServersTimeout);
    }

    /**
     * whether to enable band_steering, this works only when band==both
     * 
     */
    @Import(name="bandSteer")
    private @Nullable Output<Boolean> bandSteer;

    /**
     * @return whether to enable band_steering, this works only when band==both
     * 
     */
    public Optional<Output<Boolean>> bandSteer() {
        return Optional.ofNullable(this.bandSteer);
    }

    /**
     * force dual_band capable client to connect to 5G
     * 
     */
    @Import(name="bandSteerForceBand5")
    private @Nullable Output<Boolean> bandSteerForceBand5;

    /**
     * @return force dual_band capable client to connect to 5G
     * 
     */
    public Optional<Output<Boolean>> bandSteerForceBand5() {
        return Optional.ofNullable(this.bandSteerForceBand5);
    }

    /**
     * list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     * 
     */
    @Import(name="bands")
    private @Nullable Output<List<String>> bands;

    /**
     * @return list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     * 
     */
    public Optional<Output<List<String>>> bands() {
        return Optional.ofNullable(this.bands);
    }

    /**
     * whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    @Import(name="blockBlacklistClients")
    private @Nullable Output<Boolean> blockBlacklistClients;

    /**
     * @return whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    public Optional<Output<Boolean>> blockBlacklistClients() {
        return Optional.ofNullable(this.blockBlacklistClients);
    }

    /**
     * bonjour gateway wlan settings
     * 
     */
    @Import(name="bonjour")
    private @Nullable Output<WlanBonjourArgs> bonjour;

    /**
     * @return bonjour gateway wlan settings
     * 
     */
    public Optional<Output<WlanBonjourArgs>> bonjour() {
        return Optional.ofNullable(this.bonjour);
    }

    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    @Import(name="ciscoCwa")
    private @Nullable Output<WlanCiscoCwaArgs> ciscoCwa;

    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    public Optional<Output<WlanCiscoCwaArgs>> ciscoCwa() {
        return Optional.ofNullable(this.ciscoCwa);
    }

    /**
     * kbps
     * 
     */
    @Import(name="clientLimitDown")
    private @Nullable Output<Integer> clientLimitDown;

    /**
     * @return kbps
     * 
     */
    public Optional<Output<Integer>> clientLimitDown() {
        return Optional.ofNullable(this.clientLimitDown);
    }

    /**
     * if downlink limiting per-client is enabled
     * 
     */
    @Import(name="clientLimitDownEnabled")
    private @Nullable Output<Boolean> clientLimitDownEnabled;

    /**
     * @return if downlink limiting per-client is enabled
     * 
     */
    public Optional<Output<Boolean>> clientLimitDownEnabled() {
        return Optional.ofNullable(this.clientLimitDownEnabled);
    }

    /**
     * kbps
     * 
     */
    @Import(name="clientLimitUp")
    private @Nullable Output<Integer> clientLimitUp;

    /**
     * @return kbps
     * 
     */
    public Optional<Output<Integer>> clientLimitUp() {
        return Optional.ofNullable(this.clientLimitUp);
    }

    /**
     * if uplink limiting per-client is enabled
     * 
     */
    @Import(name="clientLimitUpEnabled")
    private @Nullable Output<Boolean> clientLimitUpEnabled;

    /**
     * @return if uplink limiting per-client is enabled
     * 
     */
    public Optional<Output<Boolean>> clientLimitUpEnabled() {
        return Optional.ofNullable(this.clientLimitUpEnabled);
    }

    /**
     * list of COA (change of authorization) servers, optional
     * 
     */
    @Import(name="coaServers")
    private @Nullable Output<List<WlanCoaServerArgs>> coaServers;

    /**
     * @return list of COA (change of authorization) servers, optional
     * 
     */
    public Optional<Output<List<WlanCoaServerArgs>>> coaServers() {
        return Optional.ofNullable(this.coaServers);
    }

    /**
     * some old WLAN drivers may not be compatible
     * 
     */
    @Import(name="disable11ax")
    private @Nullable Output<Boolean> disable11ax;

    /**
     * @return some old WLAN drivers may not be compatible
     * 
     */
    public Optional<Output<Boolean>> disable11ax() {
        return Optional.ofNullable(this.disable11ax);
    }

    /**
     * to disable ht or vht rates
     * 
     */
    @Import(name="disableHtVhtRates")
    private @Nullable Output<Boolean> disableHtVhtRates;

    /**
     * @return to disable ht or vht rates
     * 
     */
    public Optional<Output<Boolean>> disableHtVhtRates() {
        return Optional.ofNullable(this.disableHtVhtRates);
    }

    /**
     * whether to disable U-APSD
     * 
     */
    @Import(name="disableUapsd")
    private @Nullable Output<Boolean> disableUapsd;

    /**
     * @return whether to disable U-APSD
     * 
     */
    public Optional<Output<Boolean>> disableUapsd() {
        return Optional.ofNullable(this.disableUapsd);
    }

    /**
     * disable sending v2 roam notification messages
     * 
     */
    @Import(name="disableV1RoamNotify")
    private @Nullable Output<Boolean> disableV1RoamNotify;

    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    public Optional<Output<Boolean>> disableV1RoamNotify() {
        return Optional.ofNullable(this.disableV1RoamNotify);
    }

    /**
     * disable sending v2 roam notification messages
     * 
     */
    @Import(name="disableV2RoamNotify")
    private @Nullable Output<Boolean> disableV2RoamNotify;

    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    public Optional<Output<Boolean>> disableV2RoamNotify() {
        return Optional.ofNullable(this.disableV2RoamNotify);
    }

    /**
     * when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
     * reach default gateway
     * 
     */
    @Import(name="disableWhenGatewayUnreachable")
    private @Nullable Output<Boolean> disableWhenGatewayUnreachable;

    /**
     * @return when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
     * reach default gateway
     * 
     */
    public Optional<Output<Boolean>> disableWhenGatewayUnreachable() {
        return Optional.ofNullable(this.disableWhenGatewayUnreachable);
    }

    @Import(name="disableWhenMxtunnelDown")
    private @Nullable Output<Boolean> disableWhenMxtunnelDown;

    public Optional<Output<Boolean>> disableWhenMxtunnelDown() {
        return Optional.ofNullable(this.disableWhenMxtunnelDown);
    }

    /**
     * whether to disable WMM
     * 
     */
    @Import(name="disableWmm")
    private @Nullable Output<Boolean> disableWmm;

    /**
     * @return whether to disable WMM
     * 
     */
    public Optional<Output<Boolean>> disableWmm() {
        return Optional.ofNullable(this.disableWmm);
    }

    /**
     * for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    @Import(name="dnsServerRewrite")
    private @Nullable Output<WlanDnsServerRewriteArgs> dnsServerRewrite;

    /**
     * @return for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    public Optional<Output<WlanDnsServerRewriteArgs>> dnsServerRewrite() {
        return Optional.ofNullable(this.dnsServerRewrite);
    }

    @Import(name="dtim")
    private @Nullable Output<Integer> dtim;

    public Optional<Output<Integer>> dtim() {
        return Optional.ofNullable(this.dtim);
    }

    /**
     * for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
     * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
     * now, wpa3 support on the roadmap)
     * 
     */
    @Import(name="dynamicPsk")
    private @Nullable Output<WlanDynamicPskArgs> dynamicPsk;

    /**
     * @return for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
     * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
     * now, wpa3 support on the roadmap)
     * 
     */
    public Optional<Output<WlanDynamicPskArgs>> dynamicPsk() {
        return Optional.ofNullable(this.dynamicPsk);
    }

    /**
     * for 802.1x
     * 
     */
    @Import(name="dynamicVlan")
    private @Nullable Output<WlanDynamicVlanArgs> dynamicVlan;

    /**
     * @return for 802.1x
     * 
     */
    public Optional<Output<WlanDynamicVlanArgs>> dynamicVlan() {
        return Optional.ofNullable(this.dynamicVlan);
    }

    /**
     * enable AP-AP keycaching via multicast
     * 
     */
    @Import(name="enableLocalKeycaching")
    private @Nullable Output<Boolean> enableLocalKeycaching;

    /**
     * @return enable AP-AP keycaching via multicast
     * 
     */
    public Optional<Output<Boolean>> enableLocalKeycaching() {
        return Optional.ofNullable(this.enableLocalKeycaching);
    }

    /**
     * by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
     * 
     */
    @Import(name="enableWirelessBridging")
    private @Nullable Output<Boolean> enableWirelessBridging;

    /**
     * @return by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
     * 
     */
    public Optional<Output<Boolean>> enableWirelessBridging() {
        return Optional.ofNullable(this.enableWirelessBridging);
    }

    /**
     * if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
     * packets to be forwarded to wireless
     * 
     */
    @Import(name="enableWirelessBridgingDhcpTracking")
    private @Nullable Output<Boolean> enableWirelessBridgingDhcpTracking;

    /**
     * @return if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
     * packets to be forwarded to wireless
     * 
     */
    public Optional<Output<Boolean>> enableWirelessBridgingDhcpTracking() {
        return Optional.ofNullable(this.enableWirelessBridgingDhcpTracking);
    }

    /**
     * if this wlan is enabled
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return if this wlan is enabled
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     * 
     */
    @Import(name="fastDot1xTimers")
    private @Nullable Output<Boolean> fastDot1xTimers;

    /**
     * @return if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     * 
     */
    public Optional<Output<Boolean>> fastDot1xTimers() {
        return Optional.ofNullable(this.fastDot1xTimers);
    }

    /**
     * whether to hide SSID in beacon
     * 
     */
    @Import(name="hideSsid")
    private @Nullable Output<Boolean> hideSsid;

    /**
     * @return whether to hide SSID in beacon
     * 
     */
    public Optional<Output<Boolean>> hideSsid() {
        return Optional.ofNullable(this.hideSsid);
    }

    /**
     * include hostname inside IE in AP beacons / probe responses
     * 
     */
    @Import(name="hostnameIe")
    private @Nullable Output<Boolean> hostnameIe;

    /**
     * @return include hostname inside IE in AP beacons / probe responses
     * 
     */
    public Optional<Output<Boolean>> hostnameIe() {
        return Optional.ofNullable(this.hostnameIe);
    }

    /**
     * hostspot 2.0 wlan settings
     * 
     */
    @Import(name="hotspot20")
    private @Nullable Output<WlanHotspot20Args> hotspot20;

    /**
     * @return hostspot 2.0 wlan settings
     * 
     */
    public Optional<Output<WlanHotspot20Args>> hotspot20() {
        return Optional.ofNullable(this.hotspot20);
    }

    @Import(name="injectDhcpOption82")
    private @Nullable Output<WlanInjectDhcpOption82Args> injectDhcpOption82;

    public Optional<Output<WlanInjectDhcpOption82Args>> injectDhcpOption82() {
        return Optional.ofNullable(this.injectDhcpOption82);
    }

    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    @Import(name="interface")
    private @Nullable Output<String> interface_;

    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    public Optional<Output<String>> interface_() {
        return Optional.ofNullable(this.interface_);
    }

    /**
     * whether to stop clients to talk to each other
     * 
     */
    @Import(name="isolation")
    private @Nullable Output<Boolean> isolation;

    /**
     * @return whether to stop clients to talk to each other
     * 
     */
    public Optional<Output<Boolean>> isolation() {
        return Optional.ofNullable(this.isolation);
    }

    /**
     * if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    @Import(name="l2Isolation")
    private @Nullable Output<Boolean> l2Isolation;

    /**
     * @return if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    public Optional<Output<Boolean>> l2Isolation() {
        return Optional.ofNullable(this.l2Isolation);
    }

    /**
     * legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     * 
     */
    @Import(name="legacyOverds")
    private @Nullable Output<Boolean> legacyOverds;

    /**
     * @return legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     * 
     */
    public Optional<Output<Boolean>> legacyOverds() {
        return Optional.ofNullable(this.legacyOverds);
    }

    /**
     * whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    @Import(name="limitBcast")
    private @Nullable Output<Boolean> limitBcast;

    /**
     * @return whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    public Optional<Output<Boolean>> limitBcast() {
        return Optional.ofNullable(this.limitBcast);
    }

    /**
     * limit probe response base on some heuristic rules
     * 
     */
    @Import(name="limitProbeResponse")
    private @Nullable Output<Boolean> limitProbeResponse;

    /**
     * @return limit probe response base on some heuristic rules
     * 
     */
    public Optional<Output<Boolean>> limitProbeResponse() {
        return Optional.ofNullable(this.limitProbeResponse);
    }

    /**
     * max idle time in seconds
     * 
     */
    @Import(name="maxIdletime")
    private @Nullable Output<Integer> maxIdletime;

    /**
     * @return max idle time in seconds
     * 
     */
    public Optional<Output<Integer>> maxIdletime() {
        return Optional.ofNullable(this.maxIdletime);
    }

    /**
     * maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    @Import(name="maxNumClients")
    private @Nullable Output<Integer> maxNumClients;

    /**
     * @return maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    public Optional<Output<Integer>> maxNumClients() {
        return Optional.ofNullable(this.maxNumClients);
    }

    @Import(name="mistNac")
    private @Nullable Output<WlanMistNacArgs> mistNac;

    public Optional<Output<WlanMistNacArgs>> mistNac() {
        return Optional.ofNullable(this.mistNac);
    }

    @Import(name="mspId")
    private @Nullable Output<String> mspId;

    public Optional<Output<String>> mspId() {
        return Optional.ofNullable(this.mspId);
    }

    /**
     * when `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    @Import(name="mxtunnelIds")
    private @Nullable Output<List<String>> mxtunnelIds;

    /**
     * @return when `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    public Optional<Output<List<String>>> mxtunnelIds() {
        return Optional.ofNullable(this.mxtunnelIds);
    }

    /**
     * when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    @Import(name="mxtunnelNames")
    private @Nullable Output<List<String>> mxtunnelNames;

    /**
     * @return when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    public Optional<Output<List<String>>> mxtunnelNames() {
        return Optional.ofNullable(this.mxtunnelNames);
    }

    /**
     * whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    @Import(name="noStaticDns")
    private @Nullable Output<Boolean> noStaticDns;

    /**
     * @return whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    public Optional<Output<Boolean>> noStaticDns() {
        return Optional.ofNullable(this.noStaticDns);
    }

    /**
     * whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    @Import(name="noStaticIp")
    private @Nullable Output<Boolean> noStaticIp;

    /**
     * @return whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    public Optional<Output<Boolean>> noStaticIp() {
        return Optional.ofNullable(this.noStaticIp);
    }

    @Import(name="orgId")
    private @Nullable Output<String> orgId;

    public Optional<Output<String>> orgId() {
        return Optional.ofNullable(this.orgId);
    }

    /**
     * portal wlan settings
     * 
     */
    @Import(name="portal")
    private @Nullable Output<WlanPortalArgs> portal;

    /**
     * @return portal wlan settings
     * 
     */
    public Optional<Output<WlanPortalArgs>> portal() {
        return Optional.ofNullable(this.portal);
    }

    /**
     * list of hostnames without http(s):// (matched by substring)
     * 
     */
    @Import(name="portalAllowedHostnames")
    private @Nullable Output<List<String>> portalAllowedHostnames;

    /**
     * @return list of hostnames without http(s):// (matched by substring)
     * 
     */
    public Optional<Output<List<String>>> portalAllowedHostnames() {
        return Optional.ofNullable(this.portalAllowedHostnames);
    }

    /**
     * list of CIDRs
     * 
     */
    @Import(name="portalAllowedSubnets")
    private @Nullable Output<List<String>> portalAllowedSubnets;

    /**
     * @return list of CIDRs
     * 
     */
    public Optional<Output<List<String>>> portalAllowedSubnets() {
        return Optional.ofNullable(this.portalAllowedSubnets);
    }

    /**
     * api secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    @Import(name="portalApiSecret")
    private @Nullable Output<String> portalApiSecret;

    /**
     * @return api secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    public Optional<Output<String>> portalApiSecret() {
        return Optional.ofNullable(this.portalApiSecret);
    }

    /**
     * list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    @Import(name="portalDeniedHostnames")
    private @Nullable Output<List<String>> portalDeniedHostnames;

    /**
     * @return list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    public Optional<Output<List<String>>> portalDeniedHostnames() {
        return Optional.ofNullable(this.portalDeniedHostnames);
    }

    /**
     * Url of portal background image
     * 
     */
    @Import(name="portalImage")
    private @Nullable Output<String> portalImage;

    /**
     * @return Url of portal background image
     * 
     */
    public Optional<Output<String>> portalImage() {
        return Optional.ofNullable(this.portalImage);
    }

    @Import(name="portalSsoUrl")
    private @Nullable Output<String> portalSsoUrl;

    public Optional<Output<String>> portalSsoUrl() {
        return Optional.ofNullable(this.portalSsoUrl);
    }

    @Import(name="qos")
    private @Nullable Output<WlanQosArgs> qos;

    public Optional<Output<WlanQosArgs>> qos() {
        return Optional.ofNullable(this.qos);
    }

    /**
     * Radsec settings
     * 
     */
    @Import(name="radsec")
    private @Nullable Output<WlanRadsecArgs> radsec;

    /**
     * @return Radsec settings
     * 
     */
    public Optional<Output<WlanRadsecArgs>> radsec() {
        return Optional.ofNullable(this.radsec);
    }

    /**
     * Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    @Import(name="rateset")
    private @Nullable Output<Map<String,WlanRatesetArgs>> rateset;

    /**
     * @return Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    public Optional<Output<Map<String,WlanRatesetArgs>>> rateset() {
        return Optional.ofNullable(this.rateset);
    }

    /**
     * when different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    @Import(name="reconnectClientsWhenRoamingMxcluster")
    private @Nullable Output<Boolean> reconnectClientsWhenRoamingMxcluster;

    /**
     * @return when different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    public Optional<Output<Boolean>> reconnectClientsWhenRoamingMxcluster() {
        return Optional.ofNullable(this.reconnectClientsWhenRoamingMxcluster);
    }

    /**
     * enum: `11r`, `OKC`, `NONE`
     * 
     */
    @Import(name="roamMode")
    private @Nullable Output<String> roamMode;

    /**
     * @return enum: `11r`, `OKC`, `NONE`
     * 
     */
    public Optional<Output<String>> roamMode() {
        return Optional.ofNullable(this.roamMode);
    }

    /**
     * WLAN operating schedule, default is disabled
     * 
     */
    @Import(name="schedule")
    private @Nullable Output<WlanScheduleArgs> schedule;

    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    public Optional<Output<WlanScheduleArgs>> schedule() {
        return Optional.ofNullable(this.schedule);
    }

    @Import(name="siteId")
    private @Nullable Output<String> siteId;

    public Optional<Output<String>> siteId() {
        return Optional.ofNullable(this.siteId);
    }

    /**
     * whether to exclude this WLAN from SLE metrics
     * 
     */
    @Import(name="sleExcluded")
    private @Nullable Output<Boolean> sleExcluded;

    /**
     * @return whether to exclude this WLAN from SLE metrics
     * 
     */
    public Optional<Output<Boolean>> sleExcluded() {
        return Optional.ofNullable(this.sleExcluded);
    }

    /**
     * the name of the SSID
     * 
     */
    @Import(name="ssid")
    private @Nullable Output<String> ssid;

    /**
     * @return the name of the SSID
     * 
     */
    public Optional<Output<String>> ssid() {
        return Optional.ofNullable(this.ssid);
    }

    /**
     * if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    @Import(name="useEapolV1")
    private @Nullable Output<Boolean> useEapolV1;

    /**
     * @return if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    public Optional<Output<Boolean>> useEapolV1() {
        return Optional.ofNullable(this.useEapolV1);
    }

    /**
     * if vlan tagging is enabled
     * 
     */
    @Import(name="vlanEnabled")
    private @Nullable Output<Boolean> vlanEnabled;

    /**
     * @return if vlan tagging is enabled
     * 
     */
    public Optional<Output<Boolean>> vlanEnabled() {
        return Optional.ofNullable(this.vlanEnabled);
    }

    @Import(name="vlanId")
    private @Nullable Output<String> vlanId;

    public Optional<Output<String>> vlanId() {
        return Optional.ofNullable(this.vlanId);
    }

    /**
     * if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
     * 
     */
    @Import(name="vlanIds")
    private @Nullable Output<List<String>> vlanIds;

    /**
     * @return if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
     * 
     */
    public Optional<Output<List<String>>> vlanIds() {
        return Optional.ofNullable(this.vlanIds);
    }

    /**
     * Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
     * deterministic algorithm
     * 
     */
    @Import(name="vlanPooling")
    private @Nullable Output<Boolean> vlanPooling;

    /**
     * @return Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
     * deterministic algorithm
     * 
     */
    public Optional<Output<Boolean>> vlanPooling() {
        return Optional.ofNullable(this.vlanPooling);
    }

    /**
     * kbps
     * 
     */
    @Import(name="wlanLimitDown")
    private @Nullable Output<Integer> wlanLimitDown;

    /**
     * @return kbps
     * 
     */
    public Optional<Output<Integer>> wlanLimitDown() {
        return Optional.ofNullable(this.wlanLimitDown);
    }

    /**
     * if downlink limiting for whole wlan is enabled
     * 
     */
    @Import(name="wlanLimitDownEnabled")
    private @Nullable Output<Boolean> wlanLimitDownEnabled;

    /**
     * @return if downlink limiting for whole wlan is enabled
     * 
     */
    public Optional<Output<Boolean>> wlanLimitDownEnabled() {
        return Optional.ofNullable(this.wlanLimitDownEnabled);
    }

    /**
     * kbps
     * 
     */
    @Import(name="wlanLimitUp")
    private @Nullable Output<Integer> wlanLimitUp;

    /**
     * @return kbps
     * 
     */
    public Optional<Output<Integer>> wlanLimitUp() {
        return Optional.ofNullable(this.wlanLimitUp);
    }

    /**
     * if uplink limiting for whole wlan is enabled
     * 
     */
    @Import(name="wlanLimitUpEnabled")
    private @Nullable Output<Boolean> wlanLimitUpEnabled;

    /**
     * @return if uplink limiting for whole wlan is enabled
     * 
     */
    public Optional<Output<Boolean>> wlanLimitUpEnabled() {
        return Optional.ofNullable(this.wlanLimitUpEnabled);
    }

    /**
     * list of wxtag_ids
     * 
     */
    @Import(name="wxtagIds")
    private @Nullable Output<List<String>> wxtagIds;

    /**
     * @return list of wxtag_ids
     * 
     */
    public Optional<Output<List<String>>> wxtagIds() {
        return Optional.ofNullable(this.wxtagIds);
    }

    /**
     * when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    @Import(name="wxtunnelId")
    private @Nullable Output<String> wxtunnelId;

    /**
     * @return when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    public Optional<Output<String>> wxtunnelId() {
        return Optional.ofNullable(this.wxtunnelId);
    }

    /**
     * when `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    @Import(name="wxtunnelRemoteId")
    private @Nullable Output<String> wxtunnelRemoteId;

    /**
     * @return when `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    public Optional<Output<String>> wxtunnelRemoteId() {
        return Optional.ofNullable(this.wxtunnelRemoteId);
    }

    private WlanState() {}

    private WlanState(WlanState $) {
        this.acctImmediateUpdate = $.acctImmediateUpdate;
        this.acctInterimInterval = $.acctInterimInterval;
        this.acctServers = $.acctServers;
        this.airwatch = $.airwatch;
        this.allowIpv6Ndp = $.allowIpv6Ndp;
        this.allowMdns = $.allowMdns;
        this.allowSsdp = $.allowSsdp;
        this.apIds = $.apIds;
        this.appLimit = $.appLimit;
        this.appQos = $.appQos;
        this.applyTo = $.applyTo;
        this.arpFilter = $.arpFilter;
        this.auth = $.auth;
        this.authServerSelection = $.authServerSelection;
        this.authServers = $.authServers;
        this.authServersNasId = $.authServersNasId;
        this.authServersNasIp = $.authServersNasIp;
        this.authServersRetries = $.authServersRetries;
        this.authServersTimeout = $.authServersTimeout;
        this.bandSteer = $.bandSteer;
        this.bandSteerForceBand5 = $.bandSteerForceBand5;
        this.bands = $.bands;
        this.blockBlacklistClients = $.blockBlacklistClients;
        this.bonjour = $.bonjour;
        this.ciscoCwa = $.ciscoCwa;
        this.clientLimitDown = $.clientLimitDown;
        this.clientLimitDownEnabled = $.clientLimitDownEnabled;
        this.clientLimitUp = $.clientLimitUp;
        this.clientLimitUpEnabled = $.clientLimitUpEnabled;
        this.coaServers = $.coaServers;
        this.disable11ax = $.disable11ax;
        this.disableHtVhtRates = $.disableHtVhtRates;
        this.disableUapsd = $.disableUapsd;
        this.disableV1RoamNotify = $.disableV1RoamNotify;
        this.disableV2RoamNotify = $.disableV2RoamNotify;
        this.disableWhenGatewayUnreachable = $.disableWhenGatewayUnreachable;
        this.disableWhenMxtunnelDown = $.disableWhenMxtunnelDown;
        this.disableWmm = $.disableWmm;
        this.dnsServerRewrite = $.dnsServerRewrite;
        this.dtim = $.dtim;
        this.dynamicPsk = $.dynamicPsk;
        this.dynamicVlan = $.dynamicVlan;
        this.enableLocalKeycaching = $.enableLocalKeycaching;
        this.enableWirelessBridging = $.enableWirelessBridging;
        this.enableWirelessBridgingDhcpTracking = $.enableWirelessBridgingDhcpTracking;
        this.enabled = $.enabled;
        this.fastDot1xTimers = $.fastDot1xTimers;
        this.hideSsid = $.hideSsid;
        this.hostnameIe = $.hostnameIe;
        this.hotspot20 = $.hotspot20;
        this.injectDhcpOption82 = $.injectDhcpOption82;
        this.interface_ = $.interface_;
        this.isolation = $.isolation;
        this.l2Isolation = $.l2Isolation;
        this.legacyOverds = $.legacyOverds;
        this.limitBcast = $.limitBcast;
        this.limitProbeResponse = $.limitProbeResponse;
        this.maxIdletime = $.maxIdletime;
        this.maxNumClients = $.maxNumClients;
        this.mistNac = $.mistNac;
        this.mspId = $.mspId;
        this.mxtunnelIds = $.mxtunnelIds;
        this.mxtunnelNames = $.mxtunnelNames;
        this.noStaticDns = $.noStaticDns;
        this.noStaticIp = $.noStaticIp;
        this.orgId = $.orgId;
        this.portal = $.portal;
        this.portalAllowedHostnames = $.portalAllowedHostnames;
        this.portalAllowedSubnets = $.portalAllowedSubnets;
        this.portalApiSecret = $.portalApiSecret;
        this.portalDeniedHostnames = $.portalDeniedHostnames;
        this.portalImage = $.portalImage;
        this.portalSsoUrl = $.portalSsoUrl;
        this.qos = $.qos;
        this.radsec = $.radsec;
        this.rateset = $.rateset;
        this.reconnectClientsWhenRoamingMxcluster = $.reconnectClientsWhenRoamingMxcluster;
        this.roamMode = $.roamMode;
        this.schedule = $.schedule;
        this.siteId = $.siteId;
        this.sleExcluded = $.sleExcluded;
        this.ssid = $.ssid;
        this.useEapolV1 = $.useEapolV1;
        this.vlanEnabled = $.vlanEnabled;
        this.vlanId = $.vlanId;
        this.vlanIds = $.vlanIds;
        this.vlanPooling = $.vlanPooling;
        this.wlanLimitDown = $.wlanLimitDown;
        this.wlanLimitDownEnabled = $.wlanLimitDownEnabled;
        this.wlanLimitUp = $.wlanLimitUp;
        this.wlanLimitUpEnabled = $.wlanLimitUpEnabled;
        this.wxtagIds = $.wxtagIds;
        this.wxtunnelId = $.wxtunnelId;
        this.wxtunnelRemoteId = $.wxtunnelRemoteId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(WlanState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private WlanState $;

        public Builder() {
            $ = new WlanState();
        }

        public Builder(WlanState defaults) {
            $ = new WlanState(Objects.requireNonNull(defaults));
        }

        /**
         * @param acctImmediateUpdate enable coa-immediate-update and address-change-immediate-update on the access profile.
         * 
         * @return builder
         * 
         */
        public Builder acctImmediateUpdate(@Nullable Output<Boolean> acctImmediateUpdate) {
            $.acctImmediateUpdate = acctImmediateUpdate;
            return this;
        }

        /**
         * @param acctImmediateUpdate enable coa-immediate-update and address-change-immediate-update on the access profile.
         * 
         * @return builder
         * 
         */
        public Builder acctImmediateUpdate(Boolean acctImmediateUpdate) {
            return acctImmediateUpdate(Output.of(acctImmediateUpdate));
        }

        /**
         * @param acctInterimInterval how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
         * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
         * when enabled
         * 
         * @return builder
         * 
         */
        public Builder acctInterimInterval(@Nullable Output<Integer> acctInterimInterval) {
            $.acctInterimInterval = acctInterimInterval;
            return this;
        }

        /**
         * @param acctInterimInterval how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
         * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
         * when enabled
         * 
         * @return builder
         * 
         */
        public Builder acctInterimInterval(Integer acctInterimInterval) {
            return acctInterimInterval(Output.of(acctInterimInterval));
        }

        /**
         * @param acctServers list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
         * 
         * @return builder
         * 
         */
        public Builder acctServers(@Nullable Output<List<WlanAcctServerArgs>> acctServers) {
            $.acctServers = acctServers;
            return this;
        }

        /**
         * @param acctServers list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
         * 
         * @return builder
         * 
         */
        public Builder acctServers(List<WlanAcctServerArgs> acctServers) {
            return acctServers(Output.of(acctServers));
        }

        /**
         * @param acctServers list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
         * 
         * @return builder
         * 
         */
        public Builder acctServers(WlanAcctServerArgs... acctServers) {
            return acctServers(List.of(acctServers));
        }

        /**
         * @param airwatch airwatch wlan settings
         * 
         * @return builder
         * 
         */
        public Builder airwatch(@Nullable Output<WlanAirwatchArgs> airwatch) {
            $.airwatch = airwatch;
            return this;
        }

        /**
         * @param airwatch airwatch wlan settings
         * 
         * @return builder
         * 
         */
        public Builder airwatch(WlanAirwatchArgs airwatch) {
            return airwatch(Output.of(airwatch));
        }

        /**
         * @param allowIpv6Ndp only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
         * 
         * @return builder
         * 
         */
        public Builder allowIpv6Ndp(@Nullable Output<Boolean> allowIpv6Ndp) {
            $.allowIpv6Ndp = allowIpv6Ndp;
            return this;
        }

        /**
         * @param allowIpv6Ndp only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
         * 
         * @return builder
         * 
         */
        public Builder allowIpv6Ndp(Boolean allowIpv6Ndp) {
            return allowIpv6Ndp(Output.of(allowIpv6Ndp));
        }

        /**
         * @param allowMdns only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
         * 
         * @return builder
         * 
         */
        public Builder allowMdns(@Nullable Output<Boolean> allowMdns) {
            $.allowMdns = allowMdns;
            return this;
        }

        /**
         * @param allowMdns only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
         * 
         * @return builder
         * 
         */
        public Builder allowMdns(Boolean allowMdns) {
            return allowMdns(Output.of(allowMdns));
        }

        /**
         * @param allowSsdp only applicable when `limit_bcast`==`true`, which allows SSDP
         * 
         * @return builder
         * 
         */
        public Builder allowSsdp(@Nullable Output<Boolean> allowSsdp) {
            $.allowSsdp = allowSsdp;
            return this;
        }

        /**
         * @param allowSsdp only applicable when `limit_bcast`==`true`, which allows SSDP
         * 
         * @return builder
         * 
         */
        public Builder allowSsdp(Boolean allowSsdp) {
            return allowSsdp(Output.of(allowSsdp));
        }

        /**
         * @param apIds list of device ids
         * 
         * @return builder
         * 
         */
        public Builder apIds(@Nullable Output<List<String>> apIds) {
            $.apIds = apIds;
            return this;
        }

        /**
         * @param apIds list of device ids
         * 
         * @return builder
         * 
         */
        public Builder apIds(List<String> apIds) {
            return apIds(Output.of(apIds));
        }

        /**
         * @param apIds list of device ids
         * 
         * @return builder
         * 
         */
        public Builder apIds(String... apIds) {
            return apIds(List.of(apIds));
        }

        /**
         * @param appLimit bandwidth limiting for apps (applies to up/down)
         * 
         * @return builder
         * 
         */
        public Builder appLimit(@Nullable Output<WlanAppLimitArgs> appLimit) {
            $.appLimit = appLimit;
            return this;
        }

        /**
         * @param appLimit bandwidth limiting for apps (applies to up/down)
         * 
         * @return builder
         * 
         */
        public Builder appLimit(WlanAppLimitArgs appLimit) {
            return appLimit(Output.of(appLimit));
        }

        /**
         * @param appQos app qos wlan settings
         * 
         * @return builder
         * 
         */
        public Builder appQos(@Nullable Output<WlanAppQosArgs> appQos) {
            $.appQos = appQos;
            return this;
        }

        /**
         * @param appQos app qos wlan settings
         * 
         * @return builder
         * 
         */
        public Builder appQos(WlanAppQosArgs appQos) {
            return appQos(Output.of(appQos));
        }

        /**
         * @param applyTo enum: `aps`, `site`, `wxtags`
         * 
         * @return builder
         * 
         */
        public Builder applyTo(@Nullable Output<String> applyTo) {
            $.applyTo = applyTo;
            return this;
        }

        /**
         * @param applyTo enum: `aps`, `site`, `wxtags`
         * 
         * @return builder
         * 
         */
        public Builder applyTo(String applyTo) {
            return applyTo(Output.of(applyTo));
        }

        /**
         * @param arpFilter whether to enable smart arp filter
         * 
         * @return builder
         * 
         */
        public Builder arpFilter(@Nullable Output<Boolean> arpFilter) {
            $.arpFilter = arpFilter;
            return this;
        }

        /**
         * @param arpFilter whether to enable smart arp filter
         * 
         * @return builder
         * 
         */
        public Builder arpFilter(Boolean arpFilter) {
            return arpFilter(Output.of(arpFilter));
        }

        /**
         * @param auth authentication wlan settings
         * 
         * @return builder
         * 
         */
        public Builder auth(@Nullable Output<WlanAuthArgs> auth) {
            $.auth = auth;
            return this;
        }

        /**
         * @param auth authentication wlan settings
         * 
         * @return builder
         * 
         */
        public Builder auth(WlanAuthArgs auth) {
            return auth(Output.of(auth));
        }

        /**
         * @param authServerSelection When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
         * 
         * @return builder
         * 
         */
        public Builder authServerSelection(@Nullable Output<String> authServerSelection) {
            $.authServerSelection = authServerSelection;
            return this;
        }

        /**
         * @param authServerSelection When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
         * 
         * @return builder
         * 
         */
        public Builder authServerSelection(String authServerSelection) {
            return authServerSelection(Output.of(authServerSelection));
        }

        /**
         * @param authServers list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
         * is treated as primary
         * 
         * @return builder
         * 
         */
        public Builder authServers(@Nullable Output<List<WlanAuthServerArgs>> authServers) {
            $.authServers = authServers;
            return this;
        }

        /**
         * @param authServers list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
         * is treated as primary
         * 
         * @return builder
         * 
         */
        public Builder authServers(List<WlanAuthServerArgs> authServers) {
            return authServers(Output.of(authServers));
        }

        /**
         * @param authServers list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
         * is treated as primary
         * 
         * @return builder
         * 
         */
        public Builder authServers(WlanAuthServerArgs... authServers) {
            return authServers(List.of(authServers));
        }

        /**
         * @param authServersNasId optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
         * 
         * @return builder
         * 
         */
        public Builder authServersNasId(@Nullable Output<String> authServersNasId) {
            $.authServersNasId = authServersNasId;
            return this;
        }

        /**
         * @param authServersNasId optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
         * 
         * @return builder
         * 
         */
        public Builder authServersNasId(String authServersNasId) {
            return authServersNasId(Output.of(authServersNasId));
        }

        /**
         * @param authServersNasIp optional, NAS-IP-ADDRESS to use
         * 
         * @return builder
         * 
         */
        public Builder authServersNasIp(@Nullable Output<String> authServersNasIp) {
            $.authServersNasIp = authServersNasIp;
            return this;
        }

        /**
         * @param authServersNasIp optional, NAS-IP-ADDRESS to use
         * 
         * @return builder
         * 
         */
        public Builder authServersNasIp(String authServersNasIp) {
            return authServersNasIp(Output.of(authServersNasIp));
        }

        /**
         * @param authServersRetries radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
         * set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
         * default value to 3.
         * 
         * @return builder
         * 
         */
        public Builder authServersRetries(@Nullable Output<Integer> authServersRetries) {
            $.authServersRetries = authServersRetries;
            return this;
        }

        /**
         * @param authServersRetries radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
         * set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
         * default value to 3.
         * 
         * @return builder
         * 
         */
        public Builder authServersRetries(Integer authServersRetries) {
            return authServersRetries(Output.of(authServersRetries));
        }

        /**
         * @param authServersTimeout radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
         * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
         * is also set when setting auth_servers_timeout and is set to default value of 10.
         * 
         * @return builder
         * 
         */
        public Builder authServersTimeout(@Nullable Output<Integer> authServersTimeout) {
            $.authServersTimeout = authServersTimeout;
            return this;
        }

        /**
         * @param authServersTimeout radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
         * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
         * is also set when setting auth_servers_timeout and is set to default value of 10.
         * 
         * @return builder
         * 
         */
        public Builder authServersTimeout(Integer authServersTimeout) {
            return authServersTimeout(Output.of(authServersTimeout));
        }

        /**
         * @param bandSteer whether to enable band_steering, this works only when band==both
         * 
         * @return builder
         * 
         */
        public Builder bandSteer(@Nullable Output<Boolean> bandSteer) {
            $.bandSteer = bandSteer;
            return this;
        }

        /**
         * @param bandSteer whether to enable band_steering, this works only when band==both
         * 
         * @return builder
         * 
         */
        public Builder bandSteer(Boolean bandSteer) {
            return bandSteer(Output.of(bandSteer));
        }

        /**
         * @param bandSteerForceBand5 force dual_band capable client to connect to 5G
         * 
         * @return builder
         * 
         */
        public Builder bandSteerForceBand5(@Nullable Output<Boolean> bandSteerForceBand5) {
            $.bandSteerForceBand5 = bandSteerForceBand5;
            return this;
        }

        /**
         * @param bandSteerForceBand5 force dual_band capable client to connect to 5G
         * 
         * @return builder
         * 
         */
        public Builder bandSteerForceBand5(Boolean bandSteerForceBand5) {
            return bandSteerForceBand5(Output.of(bandSteerForceBand5));
        }

        /**
         * @param bands list of radios that the wlan should apply to. enum: `24`, `5`, `6`
         * 
         * @return builder
         * 
         */
        public Builder bands(@Nullable Output<List<String>> bands) {
            $.bands = bands;
            return this;
        }

        /**
         * @param bands list of radios that the wlan should apply to. enum: `24`, `5`, `6`
         * 
         * @return builder
         * 
         */
        public Builder bands(List<String> bands) {
            return bands(Output.of(bands));
        }

        /**
         * @param bands list of radios that the wlan should apply to. enum: `24`, `5`, `6`
         * 
         * @return builder
         * 
         */
        public Builder bands(String... bands) {
            return bands(List.of(bands));
        }

        /**
         * @param blockBlacklistClients whether to block the clients in the blacklist (up to first 256 macs)
         * 
         * @return builder
         * 
         */
        public Builder blockBlacklistClients(@Nullable Output<Boolean> blockBlacklistClients) {
            $.blockBlacklistClients = blockBlacklistClients;
            return this;
        }

        /**
         * @param blockBlacklistClients whether to block the clients in the blacklist (up to first 256 macs)
         * 
         * @return builder
         * 
         */
        public Builder blockBlacklistClients(Boolean blockBlacklistClients) {
            return blockBlacklistClients(Output.of(blockBlacklistClients));
        }

        /**
         * @param bonjour bonjour gateway wlan settings
         * 
         * @return builder
         * 
         */
        public Builder bonjour(@Nullable Output<WlanBonjourArgs> bonjour) {
            $.bonjour = bonjour;
            return this;
        }

        /**
         * @param bonjour bonjour gateway wlan settings
         * 
         * @return builder
         * 
         */
        public Builder bonjour(WlanBonjourArgs bonjour) {
            return bonjour(Output.of(bonjour));
        }

        /**
         * @param ciscoCwa Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
         * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
         * 
         * @return builder
         * 
         */
        public Builder ciscoCwa(@Nullable Output<WlanCiscoCwaArgs> ciscoCwa) {
            $.ciscoCwa = ciscoCwa;
            return this;
        }

        /**
         * @param ciscoCwa Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
         * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
         * 
         * @return builder
         * 
         */
        public Builder ciscoCwa(WlanCiscoCwaArgs ciscoCwa) {
            return ciscoCwa(Output.of(ciscoCwa));
        }

        /**
         * @param clientLimitDown kbps
         * 
         * @return builder
         * 
         */
        public Builder clientLimitDown(@Nullable Output<Integer> clientLimitDown) {
            $.clientLimitDown = clientLimitDown;
            return this;
        }

        /**
         * @param clientLimitDown kbps
         * 
         * @return builder
         * 
         */
        public Builder clientLimitDown(Integer clientLimitDown) {
            return clientLimitDown(Output.of(clientLimitDown));
        }

        /**
         * @param clientLimitDownEnabled if downlink limiting per-client is enabled
         * 
         * @return builder
         * 
         */
        public Builder clientLimitDownEnabled(@Nullable Output<Boolean> clientLimitDownEnabled) {
            $.clientLimitDownEnabled = clientLimitDownEnabled;
            return this;
        }

        /**
         * @param clientLimitDownEnabled if downlink limiting per-client is enabled
         * 
         * @return builder
         * 
         */
        public Builder clientLimitDownEnabled(Boolean clientLimitDownEnabled) {
            return clientLimitDownEnabled(Output.of(clientLimitDownEnabled));
        }

        /**
         * @param clientLimitUp kbps
         * 
         * @return builder
         * 
         */
        public Builder clientLimitUp(@Nullable Output<Integer> clientLimitUp) {
            $.clientLimitUp = clientLimitUp;
            return this;
        }

        /**
         * @param clientLimitUp kbps
         * 
         * @return builder
         * 
         */
        public Builder clientLimitUp(Integer clientLimitUp) {
            return clientLimitUp(Output.of(clientLimitUp));
        }

        /**
         * @param clientLimitUpEnabled if uplink limiting per-client is enabled
         * 
         * @return builder
         * 
         */
        public Builder clientLimitUpEnabled(@Nullable Output<Boolean> clientLimitUpEnabled) {
            $.clientLimitUpEnabled = clientLimitUpEnabled;
            return this;
        }

        /**
         * @param clientLimitUpEnabled if uplink limiting per-client is enabled
         * 
         * @return builder
         * 
         */
        public Builder clientLimitUpEnabled(Boolean clientLimitUpEnabled) {
            return clientLimitUpEnabled(Output.of(clientLimitUpEnabled));
        }

        /**
         * @param coaServers list of COA (change of authorization) servers, optional
         * 
         * @return builder
         * 
         */
        public Builder coaServers(@Nullable Output<List<WlanCoaServerArgs>> coaServers) {
            $.coaServers = coaServers;
            return this;
        }

        /**
         * @param coaServers list of COA (change of authorization) servers, optional
         * 
         * @return builder
         * 
         */
        public Builder coaServers(List<WlanCoaServerArgs> coaServers) {
            return coaServers(Output.of(coaServers));
        }

        /**
         * @param coaServers list of COA (change of authorization) servers, optional
         * 
         * @return builder
         * 
         */
        public Builder coaServers(WlanCoaServerArgs... coaServers) {
            return coaServers(List.of(coaServers));
        }

        /**
         * @param disable11ax some old WLAN drivers may not be compatible
         * 
         * @return builder
         * 
         */
        public Builder disable11ax(@Nullable Output<Boolean> disable11ax) {
            $.disable11ax = disable11ax;
            return this;
        }

        /**
         * @param disable11ax some old WLAN drivers may not be compatible
         * 
         * @return builder
         * 
         */
        public Builder disable11ax(Boolean disable11ax) {
            return disable11ax(Output.of(disable11ax));
        }

        /**
         * @param disableHtVhtRates to disable ht or vht rates
         * 
         * @return builder
         * 
         */
        public Builder disableHtVhtRates(@Nullable Output<Boolean> disableHtVhtRates) {
            $.disableHtVhtRates = disableHtVhtRates;
            return this;
        }

        /**
         * @param disableHtVhtRates to disable ht or vht rates
         * 
         * @return builder
         * 
         */
        public Builder disableHtVhtRates(Boolean disableHtVhtRates) {
            return disableHtVhtRates(Output.of(disableHtVhtRates));
        }

        /**
         * @param disableUapsd whether to disable U-APSD
         * 
         * @return builder
         * 
         */
        public Builder disableUapsd(@Nullable Output<Boolean> disableUapsd) {
            $.disableUapsd = disableUapsd;
            return this;
        }

        /**
         * @param disableUapsd whether to disable U-APSD
         * 
         * @return builder
         * 
         */
        public Builder disableUapsd(Boolean disableUapsd) {
            return disableUapsd(Output.of(disableUapsd));
        }

        /**
         * @param disableV1RoamNotify disable sending v2 roam notification messages
         * 
         * @return builder
         * 
         */
        public Builder disableV1RoamNotify(@Nullable Output<Boolean> disableV1RoamNotify) {
            $.disableV1RoamNotify = disableV1RoamNotify;
            return this;
        }

        /**
         * @param disableV1RoamNotify disable sending v2 roam notification messages
         * 
         * @return builder
         * 
         */
        public Builder disableV1RoamNotify(Boolean disableV1RoamNotify) {
            return disableV1RoamNotify(Output.of(disableV1RoamNotify));
        }

        /**
         * @param disableV2RoamNotify disable sending v2 roam notification messages
         * 
         * @return builder
         * 
         */
        public Builder disableV2RoamNotify(@Nullable Output<Boolean> disableV2RoamNotify) {
            $.disableV2RoamNotify = disableV2RoamNotify;
            return this;
        }

        /**
         * @param disableV2RoamNotify disable sending v2 roam notification messages
         * 
         * @return builder
         * 
         */
        public Builder disableV2RoamNotify(Boolean disableV2RoamNotify) {
            return disableV2RoamNotify(Output.of(disableV2RoamNotify));
        }

        /**
         * @param disableWhenGatewayUnreachable when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
         * reach default gateway
         * 
         * @return builder
         * 
         */
        public Builder disableWhenGatewayUnreachable(@Nullable Output<Boolean> disableWhenGatewayUnreachable) {
            $.disableWhenGatewayUnreachable = disableWhenGatewayUnreachable;
            return this;
        }

        /**
         * @param disableWhenGatewayUnreachable when any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
         * reach default gateway
         * 
         * @return builder
         * 
         */
        public Builder disableWhenGatewayUnreachable(Boolean disableWhenGatewayUnreachable) {
            return disableWhenGatewayUnreachable(Output.of(disableWhenGatewayUnreachable));
        }

        public Builder disableWhenMxtunnelDown(@Nullable Output<Boolean> disableWhenMxtunnelDown) {
            $.disableWhenMxtunnelDown = disableWhenMxtunnelDown;
            return this;
        }

        public Builder disableWhenMxtunnelDown(Boolean disableWhenMxtunnelDown) {
            return disableWhenMxtunnelDown(Output.of(disableWhenMxtunnelDown));
        }

        /**
         * @param disableWmm whether to disable WMM
         * 
         * @return builder
         * 
         */
        public Builder disableWmm(@Nullable Output<Boolean> disableWmm) {
            $.disableWmm = disableWmm;
            return this;
        }

        /**
         * @param disableWmm whether to disable WMM
         * 
         * @return builder
         * 
         */
        public Builder disableWmm(Boolean disableWmm) {
            return disableWmm(Output.of(disableWmm));
        }

        /**
         * @param dnsServerRewrite for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
         * 
         * @return builder
         * 
         */
        public Builder dnsServerRewrite(@Nullable Output<WlanDnsServerRewriteArgs> dnsServerRewrite) {
            $.dnsServerRewrite = dnsServerRewrite;
            return this;
        }

        /**
         * @param dnsServerRewrite for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
         * 
         * @return builder
         * 
         */
        public Builder dnsServerRewrite(WlanDnsServerRewriteArgs dnsServerRewrite) {
            return dnsServerRewrite(Output.of(dnsServerRewrite));
        }

        public Builder dtim(@Nullable Output<Integer> dtim) {
            $.dtim = dtim;
            return this;
        }

        public Builder dtim(Integer dtim) {
            return dtim(Output.of(dtim));
        }

        /**
         * @param dynamicPsk for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
         * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
         * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
         * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
         * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
         * now, wpa3 support on the roadmap)
         * 
         * @return builder
         * 
         */
        public Builder dynamicPsk(@Nullable Output<WlanDynamicPskArgs> dynamicPsk) {
            $.dynamicPsk = dynamicPsk;
            return this;
        }

        /**
         * @param dynamicPsk for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
         * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
         * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
         * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
         * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
         * now, wpa3 support on the roadmap)
         * 
         * @return builder
         * 
         */
        public Builder dynamicPsk(WlanDynamicPskArgs dynamicPsk) {
            return dynamicPsk(Output.of(dynamicPsk));
        }

        /**
         * @param dynamicVlan for 802.1x
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlan(@Nullable Output<WlanDynamicVlanArgs> dynamicVlan) {
            $.dynamicVlan = dynamicVlan;
            return this;
        }

        /**
         * @param dynamicVlan for 802.1x
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlan(WlanDynamicVlanArgs dynamicVlan) {
            return dynamicVlan(Output.of(dynamicVlan));
        }

        /**
         * @param enableLocalKeycaching enable AP-AP keycaching via multicast
         * 
         * @return builder
         * 
         */
        public Builder enableLocalKeycaching(@Nullable Output<Boolean> enableLocalKeycaching) {
            $.enableLocalKeycaching = enableLocalKeycaching;
            return this;
        }

        /**
         * @param enableLocalKeycaching enable AP-AP keycaching via multicast
         * 
         * @return builder
         * 
         */
        public Builder enableLocalKeycaching(Boolean enableLocalKeycaching) {
            return enableLocalKeycaching(Output.of(enableLocalKeycaching));
        }

        /**
         * @param enableWirelessBridging by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
         * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
         * 
         * @return builder
         * 
         */
        public Builder enableWirelessBridging(@Nullable Output<Boolean> enableWirelessBridging) {
            $.enableWirelessBridging = enableWirelessBridging;
            return this;
        }

        /**
         * @param enableWirelessBridging by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
         * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
         * 
         * @return builder
         * 
         */
        public Builder enableWirelessBridging(Boolean enableWirelessBridging) {
            return enableWirelessBridging(Output.of(enableWirelessBridging));
        }

        /**
         * @param enableWirelessBridgingDhcpTracking if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
         * packets to be forwarded to wireless
         * 
         * @return builder
         * 
         */
        public Builder enableWirelessBridgingDhcpTracking(@Nullable Output<Boolean> enableWirelessBridgingDhcpTracking) {
            $.enableWirelessBridgingDhcpTracking = enableWirelessBridgingDhcpTracking;
            return this;
        }

        /**
         * @param enableWirelessBridgingDhcpTracking if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
         * packets to be forwarded to wireless
         * 
         * @return builder
         * 
         */
        public Builder enableWirelessBridgingDhcpTracking(Boolean enableWirelessBridgingDhcpTracking) {
            return enableWirelessBridgingDhcpTracking(Output.of(enableWirelessBridgingDhcpTracking));
        }

        /**
         * @param enabled if this wlan is enabled
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled if this wlan is enabled
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param fastDot1xTimers if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
         * ‘auth_server_retries’ .
         * 
         * @return builder
         * 
         */
        public Builder fastDot1xTimers(@Nullable Output<Boolean> fastDot1xTimers) {
            $.fastDot1xTimers = fastDot1xTimers;
            return this;
        }

        /**
         * @param fastDot1xTimers if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
         * ‘auth_server_retries’ .
         * 
         * @return builder
         * 
         */
        public Builder fastDot1xTimers(Boolean fastDot1xTimers) {
            return fastDot1xTimers(Output.of(fastDot1xTimers));
        }

        /**
         * @param hideSsid whether to hide SSID in beacon
         * 
         * @return builder
         * 
         */
        public Builder hideSsid(@Nullable Output<Boolean> hideSsid) {
            $.hideSsid = hideSsid;
            return this;
        }

        /**
         * @param hideSsid whether to hide SSID in beacon
         * 
         * @return builder
         * 
         */
        public Builder hideSsid(Boolean hideSsid) {
            return hideSsid(Output.of(hideSsid));
        }

        /**
         * @param hostnameIe include hostname inside IE in AP beacons / probe responses
         * 
         * @return builder
         * 
         */
        public Builder hostnameIe(@Nullable Output<Boolean> hostnameIe) {
            $.hostnameIe = hostnameIe;
            return this;
        }

        /**
         * @param hostnameIe include hostname inside IE in AP beacons / probe responses
         * 
         * @return builder
         * 
         */
        public Builder hostnameIe(Boolean hostnameIe) {
            return hostnameIe(Output.of(hostnameIe));
        }

        /**
         * @param hotspot20 hostspot 2.0 wlan settings
         * 
         * @return builder
         * 
         */
        public Builder hotspot20(@Nullable Output<WlanHotspot20Args> hotspot20) {
            $.hotspot20 = hotspot20;
            return this;
        }

        /**
         * @param hotspot20 hostspot 2.0 wlan settings
         * 
         * @return builder
         * 
         */
        public Builder hotspot20(WlanHotspot20Args hotspot20) {
            return hotspot20(Output.of(hotspot20));
        }

        public Builder injectDhcpOption82(@Nullable Output<WlanInjectDhcpOption82Args> injectDhcpOption82) {
            $.injectDhcpOption82 = injectDhcpOption82;
            return this;
        }

        public Builder injectDhcpOption82(WlanInjectDhcpOption82Args injectDhcpOption82) {
            return injectDhcpOption82(Output.of(injectDhcpOption82));
        }

        /**
         * @param interface_ where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
         * 
         * @return builder
         * 
         */
        public Builder interface_(@Nullable Output<String> interface_) {
            $.interface_ = interface_;
            return this;
        }

        /**
         * @param interface_ where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
         * 
         * @return builder
         * 
         */
        public Builder interface_(String interface_) {
            return interface_(Output.of(interface_));
        }

        /**
         * @param isolation whether to stop clients to talk to each other
         * 
         * @return builder
         * 
         */
        public Builder isolation(@Nullable Output<Boolean> isolation) {
            $.isolation = isolation;
            return this;
        }

        /**
         * @param isolation whether to stop clients to talk to each other
         * 
         * @return builder
         * 
         */
        public Builder isolation(Boolean isolation) {
            return isolation(Output.of(isolation));
        }

        /**
         * @param l2Isolation if isolation is enabled, whether to deny clients to talk to L2 on the LAN
         * 
         * @return builder
         * 
         */
        public Builder l2Isolation(@Nullable Output<Boolean> l2Isolation) {
            $.l2Isolation = l2Isolation;
            return this;
        }

        /**
         * @param l2Isolation if isolation is enabled, whether to deny clients to talk to L2 on the LAN
         * 
         * @return builder
         * 
         */
        public Builder l2Isolation(Boolean l2Isolation) {
            return l2Isolation(Output.of(l2Isolation));
        }

        /**
         * @param legacyOverds legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
         * Enabling this will cause problem for iOS devices.
         * 
         * @return builder
         * 
         */
        public Builder legacyOverds(@Nullable Output<Boolean> legacyOverds) {
            $.legacyOverds = legacyOverds;
            return this;
        }

        /**
         * @param legacyOverds legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
         * Enabling this will cause problem for iOS devices.
         * 
         * @return builder
         * 
         */
        public Builder legacyOverds(Boolean legacyOverds) {
            return legacyOverds(Output.of(legacyOverds));
        }

        /**
         * @param limitBcast whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
         * 
         * @return builder
         * 
         */
        public Builder limitBcast(@Nullable Output<Boolean> limitBcast) {
            $.limitBcast = limitBcast;
            return this;
        }

        /**
         * @param limitBcast whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
         * 
         * @return builder
         * 
         */
        public Builder limitBcast(Boolean limitBcast) {
            return limitBcast(Output.of(limitBcast));
        }

        /**
         * @param limitProbeResponse limit probe response base on some heuristic rules
         * 
         * @return builder
         * 
         */
        public Builder limitProbeResponse(@Nullable Output<Boolean> limitProbeResponse) {
            $.limitProbeResponse = limitProbeResponse;
            return this;
        }

        /**
         * @param limitProbeResponse limit probe response base on some heuristic rules
         * 
         * @return builder
         * 
         */
        public Builder limitProbeResponse(Boolean limitProbeResponse) {
            return limitProbeResponse(Output.of(limitProbeResponse));
        }

        /**
         * @param maxIdletime max idle time in seconds
         * 
         * @return builder
         * 
         */
        public Builder maxIdletime(@Nullable Output<Integer> maxIdletime) {
            $.maxIdletime = maxIdletime;
            return this;
        }

        /**
         * @param maxIdletime max idle time in seconds
         * 
         * @return builder
         * 
         */
        public Builder maxIdletime(Integer maxIdletime) {
            return maxIdletime(Output.of(maxIdletime));
        }

        /**
         * @param maxNumClients maximum number of client connected to the SSID. `0` means unlimited
         * 
         * @return builder
         * 
         */
        public Builder maxNumClients(@Nullable Output<Integer> maxNumClients) {
            $.maxNumClients = maxNumClients;
            return this;
        }

        /**
         * @param maxNumClients maximum number of client connected to the SSID. `0` means unlimited
         * 
         * @return builder
         * 
         */
        public Builder maxNumClients(Integer maxNumClients) {
            return maxNumClients(Output.of(maxNumClients));
        }

        public Builder mistNac(@Nullable Output<WlanMistNacArgs> mistNac) {
            $.mistNac = mistNac;
            return this;
        }

        public Builder mistNac(WlanMistNacArgs mistNac) {
            return mistNac(Output.of(mistNac));
        }

        public Builder mspId(@Nullable Output<String> mspId) {
            $.mspId = mspId;
            return this;
        }

        public Builder mspId(String mspId) {
            return mspId(Output.of(mspId));
        }

        /**
         * @param mxtunnelIds when `interface`=`mxtunnel`, id of the Mist Tunnel
         * 
         * @return builder
         * 
         */
        public Builder mxtunnelIds(@Nullable Output<List<String>> mxtunnelIds) {
            $.mxtunnelIds = mxtunnelIds;
            return this;
        }

        /**
         * @param mxtunnelIds when `interface`=`mxtunnel`, id of the Mist Tunnel
         * 
         * @return builder
         * 
         */
        public Builder mxtunnelIds(List<String> mxtunnelIds) {
            return mxtunnelIds(Output.of(mxtunnelIds));
        }

        /**
         * @param mxtunnelIds when `interface`=`mxtunnel`, id of the Mist Tunnel
         * 
         * @return builder
         * 
         */
        public Builder mxtunnelIds(String... mxtunnelIds) {
            return mxtunnelIds(List.of(mxtunnelIds));
        }

        /**
         * @param mxtunnelNames when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
         * 
         * @return builder
         * 
         */
        public Builder mxtunnelNames(@Nullable Output<List<String>> mxtunnelNames) {
            $.mxtunnelNames = mxtunnelNames;
            return this;
        }

        /**
         * @param mxtunnelNames when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
         * 
         * @return builder
         * 
         */
        public Builder mxtunnelNames(List<String> mxtunnelNames) {
            return mxtunnelNames(Output.of(mxtunnelNames));
        }

        /**
         * @param mxtunnelNames when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
         * 
         * @return builder
         * 
         */
        public Builder mxtunnelNames(String... mxtunnelNames) {
            return mxtunnelNames(List.of(mxtunnelNames));
        }

        /**
         * @param noStaticDns whether to only allow client to use DNS that we’ve learned from DHCP response
         * 
         * @return builder
         * 
         */
        public Builder noStaticDns(@Nullable Output<Boolean> noStaticDns) {
            $.noStaticDns = noStaticDns;
            return this;
        }

        /**
         * @param noStaticDns whether to only allow client to use DNS that we’ve learned from DHCP response
         * 
         * @return builder
         * 
         */
        public Builder noStaticDns(Boolean noStaticDns) {
            return noStaticDns(Output.of(noStaticDns));
        }

        /**
         * @param noStaticIp whether to only allow client that we’ve learned from DHCP exchange to talk
         * 
         * @return builder
         * 
         */
        public Builder noStaticIp(@Nullable Output<Boolean> noStaticIp) {
            $.noStaticIp = noStaticIp;
            return this;
        }

        /**
         * @param noStaticIp whether to only allow client that we’ve learned from DHCP exchange to talk
         * 
         * @return builder
         * 
         */
        public Builder noStaticIp(Boolean noStaticIp) {
            return noStaticIp(Output.of(noStaticIp));
        }

        public Builder orgId(@Nullable Output<String> orgId) {
            $.orgId = orgId;
            return this;
        }

        public Builder orgId(String orgId) {
            return orgId(Output.of(orgId));
        }

        /**
         * @param portal portal wlan settings
         * 
         * @return builder
         * 
         */
        public Builder portal(@Nullable Output<WlanPortalArgs> portal) {
            $.portal = portal;
            return this;
        }

        /**
         * @param portal portal wlan settings
         * 
         * @return builder
         * 
         */
        public Builder portal(WlanPortalArgs portal) {
            return portal(Output.of(portal));
        }

        /**
         * @param portalAllowedHostnames list of hostnames without http(s):// (matched by substring)
         * 
         * @return builder
         * 
         */
        public Builder portalAllowedHostnames(@Nullable Output<List<String>> portalAllowedHostnames) {
            $.portalAllowedHostnames = portalAllowedHostnames;
            return this;
        }

        /**
         * @param portalAllowedHostnames list of hostnames without http(s):// (matched by substring)
         * 
         * @return builder
         * 
         */
        public Builder portalAllowedHostnames(List<String> portalAllowedHostnames) {
            return portalAllowedHostnames(Output.of(portalAllowedHostnames));
        }

        /**
         * @param portalAllowedHostnames list of hostnames without http(s):// (matched by substring)
         * 
         * @return builder
         * 
         */
        public Builder portalAllowedHostnames(String... portalAllowedHostnames) {
            return portalAllowedHostnames(List.of(portalAllowedHostnames));
        }

        /**
         * @param portalAllowedSubnets list of CIDRs
         * 
         * @return builder
         * 
         */
        public Builder portalAllowedSubnets(@Nullable Output<List<String>> portalAllowedSubnets) {
            $.portalAllowedSubnets = portalAllowedSubnets;
            return this;
        }

        /**
         * @param portalAllowedSubnets list of CIDRs
         * 
         * @return builder
         * 
         */
        public Builder portalAllowedSubnets(List<String> portalAllowedSubnets) {
            return portalAllowedSubnets(Output.of(portalAllowedSubnets));
        }

        /**
         * @param portalAllowedSubnets list of CIDRs
         * 
         * @return builder
         * 
         */
        public Builder portalAllowedSubnets(String... portalAllowedSubnets) {
            return portalAllowedSubnets(List.of(portalAllowedSubnets));
        }

        /**
         * @param portalApiSecret api secret (auto-generated) that can be used to sign guest authorization requests
         * 
         * @return builder
         * 
         */
        public Builder portalApiSecret(@Nullable Output<String> portalApiSecret) {
            $.portalApiSecret = portalApiSecret;
            return this;
        }

        /**
         * @param portalApiSecret api secret (auto-generated) that can be used to sign guest authorization requests
         * 
         * @return builder
         * 
         */
        public Builder portalApiSecret(String portalApiSecret) {
            return portalApiSecret(Output.of(portalApiSecret));
        }

        /**
         * @param portalDeniedHostnames list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
         * 
         * @return builder
         * 
         */
        public Builder portalDeniedHostnames(@Nullable Output<List<String>> portalDeniedHostnames) {
            $.portalDeniedHostnames = portalDeniedHostnames;
            return this;
        }

        /**
         * @param portalDeniedHostnames list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
         * 
         * @return builder
         * 
         */
        public Builder portalDeniedHostnames(List<String> portalDeniedHostnames) {
            return portalDeniedHostnames(Output.of(portalDeniedHostnames));
        }

        /**
         * @param portalDeniedHostnames list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
         * 
         * @return builder
         * 
         */
        public Builder portalDeniedHostnames(String... portalDeniedHostnames) {
            return portalDeniedHostnames(List.of(portalDeniedHostnames));
        }

        /**
         * @param portalImage Url of portal background image
         * 
         * @return builder
         * 
         */
        public Builder portalImage(@Nullable Output<String> portalImage) {
            $.portalImage = portalImage;
            return this;
        }

        /**
         * @param portalImage Url of portal background image
         * 
         * @return builder
         * 
         */
        public Builder portalImage(String portalImage) {
            return portalImage(Output.of(portalImage));
        }

        public Builder portalSsoUrl(@Nullable Output<String> portalSsoUrl) {
            $.portalSsoUrl = portalSsoUrl;
            return this;
        }

        public Builder portalSsoUrl(String portalSsoUrl) {
            return portalSsoUrl(Output.of(portalSsoUrl));
        }

        public Builder qos(@Nullable Output<WlanQosArgs> qos) {
            $.qos = qos;
            return this;
        }

        public Builder qos(WlanQosArgs qos) {
            return qos(Output.of(qos));
        }

        /**
         * @param radsec Radsec settings
         * 
         * @return builder
         * 
         */
        public Builder radsec(@Nullable Output<WlanRadsecArgs> radsec) {
            $.radsec = radsec;
            return this;
        }

        /**
         * @param radsec Radsec settings
         * 
         * @return builder
         * 
         */
        public Builder radsec(WlanRadsecArgs radsec) {
            return radsec(Output.of(radsec));
        }

        /**
         * @param rateset Property key is the RF band. enum: `24`, `5`, `6`
         * 
         * @return builder
         * 
         */
        public Builder rateset(@Nullable Output<Map<String,WlanRatesetArgs>> rateset) {
            $.rateset = rateset;
            return this;
        }

        /**
         * @param rateset Property key is the RF band. enum: `24`, `5`, `6`
         * 
         * @return builder
         * 
         */
        public Builder rateset(Map<String,WlanRatesetArgs> rateset) {
            return rateset(Output.of(rateset));
        }

        /**
         * @param reconnectClientsWhenRoamingMxcluster when different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
         * 
         * @return builder
         * 
         */
        public Builder reconnectClientsWhenRoamingMxcluster(@Nullable Output<Boolean> reconnectClientsWhenRoamingMxcluster) {
            $.reconnectClientsWhenRoamingMxcluster = reconnectClientsWhenRoamingMxcluster;
            return this;
        }

        /**
         * @param reconnectClientsWhenRoamingMxcluster when different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
         * 
         * @return builder
         * 
         */
        public Builder reconnectClientsWhenRoamingMxcluster(Boolean reconnectClientsWhenRoamingMxcluster) {
            return reconnectClientsWhenRoamingMxcluster(Output.of(reconnectClientsWhenRoamingMxcluster));
        }

        /**
         * @param roamMode enum: `11r`, `OKC`, `NONE`
         * 
         * @return builder
         * 
         */
        public Builder roamMode(@Nullable Output<String> roamMode) {
            $.roamMode = roamMode;
            return this;
        }

        /**
         * @param roamMode enum: `11r`, `OKC`, `NONE`
         * 
         * @return builder
         * 
         */
        public Builder roamMode(String roamMode) {
            return roamMode(Output.of(roamMode));
        }

        /**
         * @param schedule WLAN operating schedule, default is disabled
         * 
         * @return builder
         * 
         */
        public Builder schedule(@Nullable Output<WlanScheduleArgs> schedule) {
            $.schedule = schedule;
            return this;
        }

        /**
         * @param schedule WLAN operating schedule, default is disabled
         * 
         * @return builder
         * 
         */
        public Builder schedule(WlanScheduleArgs schedule) {
            return schedule(Output.of(schedule));
        }

        public Builder siteId(@Nullable Output<String> siteId) {
            $.siteId = siteId;
            return this;
        }

        public Builder siteId(String siteId) {
            return siteId(Output.of(siteId));
        }

        /**
         * @param sleExcluded whether to exclude this WLAN from SLE metrics
         * 
         * @return builder
         * 
         */
        public Builder sleExcluded(@Nullable Output<Boolean> sleExcluded) {
            $.sleExcluded = sleExcluded;
            return this;
        }

        /**
         * @param sleExcluded whether to exclude this WLAN from SLE metrics
         * 
         * @return builder
         * 
         */
        public Builder sleExcluded(Boolean sleExcluded) {
            return sleExcluded(Output.of(sleExcluded));
        }

        /**
         * @param ssid the name of the SSID
         * 
         * @return builder
         * 
         */
        public Builder ssid(@Nullable Output<String> ssid) {
            $.ssid = ssid;
            return this;
        }

        /**
         * @param ssid the name of the SSID
         * 
         * @return builder
         * 
         */
        public Builder ssid(String ssid) {
            return ssid(Output.of(ssid));
        }

        /**
         * @param useEapolV1 if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
         * 
         * @return builder
         * 
         */
        public Builder useEapolV1(@Nullable Output<Boolean> useEapolV1) {
            $.useEapolV1 = useEapolV1;
            return this;
        }

        /**
         * @param useEapolV1 if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
         * 
         * @return builder
         * 
         */
        public Builder useEapolV1(Boolean useEapolV1) {
            return useEapolV1(Output.of(useEapolV1));
        }

        /**
         * @param vlanEnabled if vlan tagging is enabled
         * 
         * @return builder
         * 
         */
        public Builder vlanEnabled(@Nullable Output<Boolean> vlanEnabled) {
            $.vlanEnabled = vlanEnabled;
            return this;
        }

        /**
         * @param vlanEnabled if vlan tagging is enabled
         * 
         * @return builder
         * 
         */
        public Builder vlanEnabled(Boolean vlanEnabled) {
            return vlanEnabled(Output.of(vlanEnabled));
        }

        public Builder vlanId(@Nullable Output<String> vlanId) {
            $.vlanId = vlanId;
            return this;
        }

        public Builder vlanId(String vlanId) {
            return vlanId(Output.of(vlanId));
        }

        /**
         * @param vlanIds if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
         * 
         * @return builder
         * 
         */
        public Builder vlanIds(@Nullable Output<List<String>> vlanIds) {
            $.vlanIds = vlanIds;
            return this;
        }

        /**
         * @param vlanIds if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
         * 
         * @return builder
         * 
         */
        public Builder vlanIds(List<String> vlanIds) {
            return vlanIds(Output.of(vlanIds));
        }

        /**
         * @param vlanIds if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
         * 
         * @return builder
         * 
         */
        public Builder vlanIds(String... vlanIds) {
            return vlanIds(List.of(vlanIds));
        }

        /**
         * @param vlanPooling Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
         * deterministic algorithm
         * 
         * @return builder
         * 
         */
        public Builder vlanPooling(@Nullable Output<Boolean> vlanPooling) {
            $.vlanPooling = vlanPooling;
            return this;
        }

        /**
         * @param vlanPooling Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
         * deterministic algorithm
         * 
         * @return builder
         * 
         */
        public Builder vlanPooling(Boolean vlanPooling) {
            return vlanPooling(Output.of(vlanPooling));
        }

        /**
         * @param wlanLimitDown kbps
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitDown(@Nullable Output<Integer> wlanLimitDown) {
            $.wlanLimitDown = wlanLimitDown;
            return this;
        }

        /**
         * @param wlanLimitDown kbps
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitDown(Integer wlanLimitDown) {
            return wlanLimitDown(Output.of(wlanLimitDown));
        }

        /**
         * @param wlanLimitDownEnabled if downlink limiting for whole wlan is enabled
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitDownEnabled(@Nullable Output<Boolean> wlanLimitDownEnabled) {
            $.wlanLimitDownEnabled = wlanLimitDownEnabled;
            return this;
        }

        /**
         * @param wlanLimitDownEnabled if downlink limiting for whole wlan is enabled
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitDownEnabled(Boolean wlanLimitDownEnabled) {
            return wlanLimitDownEnabled(Output.of(wlanLimitDownEnabled));
        }

        /**
         * @param wlanLimitUp kbps
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitUp(@Nullable Output<Integer> wlanLimitUp) {
            $.wlanLimitUp = wlanLimitUp;
            return this;
        }

        /**
         * @param wlanLimitUp kbps
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitUp(Integer wlanLimitUp) {
            return wlanLimitUp(Output.of(wlanLimitUp));
        }

        /**
         * @param wlanLimitUpEnabled if uplink limiting for whole wlan is enabled
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitUpEnabled(@Nullable Output<Boolean> wlanLimitUpEnabled) {
            $.wlanLimitUpEnabled = wlanLimitUpEnabled;
            return this;
        }

        /**
         * @param wlanLimitUpEnabled if uplink limiting for whole wlan is enabled
         * 
         * @return builder
         * 
         */
        public Builder wlanLimitUpEnabled(Boolean wlanLimitUpEnabled) {
            return wlanLimitUpEnabled(Output.of(wlanLimitUpEnabled));
        }

        /**
         * @param wxtagIds list of wxtag_ids
         * 
         * @return builder
         * 
         */
        public Builder wxtagIds(@Nullable Output<List<String>> wxtagIds) {
            $.wxtagIds = wxtagIds;
            return this;
        }

        /**
         * @param wxtagIds list of wxtag_ids
         * 
         * @return builder
         * 
         */
        public Builder wxtagIds(List<String> wxtagIds) {
            return wxtagIds(Output.of(wxtagIds));
        }

        /**
         * @param wxtagIds list of wxtag_ids
         * 
         * @return builder
         * 
         */
        public Builder wxtagIds(String... wxtagIds) {
            return wxtagIds(List.of(wxtagIds));
        }

        /**
         * @param wxtunnelId when `interface`=`wxtunnel`, id of the WXLAN Tunnel
         * 
         * @return builder
         * 
         */
        public Builder wxtunnelId(@Nullable Output<String> wxtunnelId) {
            $.wxtunnelId = wxtunnelId;
            return this;
        }

        /**
         * @param wxtunnelId when `interface`=`wxtunnel`, id of the WXLAN Tunnel
         * 
         * @return builder
         * 
         */
        public Builder wxtunnelId(String wxtunnelId) {
            return wxtunnelId(Output.of(wxtunnelId));
        }

        /**
         * @param wxtunnelRemoteId when `interface`=`wxtunnel`, remote tunnel identifier
         * 
         * @return builder
         * 
         */
        public Builder wxtunnelRemoteId(@Nullable Output<String> wxtunnelRemoteId) {
            $.wxtunnelRemoteId = wxtunnelRemoteId;
            return this;
        }

        /**
         * @param wxtunnelRemoteId when `interface`=`wxtunnel`, remote tunnel identifier
         * 
         * @return builder
         * 
         */
        public Builder wxtunnelRemoteId(String wxtunnelRemoteId) {
            return wxtunnelRemoteId(Output.of(wxtunnelRemoteId));
        }

        public WlanState build() {
            return $;
        }
    }

}
