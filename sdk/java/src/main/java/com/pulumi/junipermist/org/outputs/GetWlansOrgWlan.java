// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.org.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanAcctServer;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanAirwatch;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanAppLimit;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanAppQos;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanAuth;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanAuthServer;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanBonjour;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanCiscoCwa;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanCoaServer;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanDnsServerRewrite;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanDynamicPsk;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanDynamicVlan;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanHotspot20;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanInjectDhcpOption82;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanMistNac;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanPortal;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanQos;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanRadsec;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanRateset;
import com.pulumi.junipermist.org.outputs.GetWlansOrgWlanSchedule;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetWlansOrgWlan {
    /**
     * @return Enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    private Boolean acctImmediateUpdate;
    /**
     * @return How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     * 
     */
    private Integer acctInterimInterval;
    /**
     * @return List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    private List<GetWlansOrgWlanAcctServer> acctServers;
    /**
     * @return Airwatch wlan settings
     * 
     */
    private GetWlansOrgWlanAirwatch airwatch;
    /**
     * @return Only applicable when `limitBcast`==`true`, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    private Boolean allowIpv6Ndp;
    /**
     * @return Only applicable when `limitBcast`==`true`, which allows mDNS / Bonjour packets to go through
     * 
     */
    private Boolean allowMdns;
    /**
     * @return Only applicable when `limitBcast`==`true`, which allows SSDP
     * 
     */
    private Boolean allowSsdp;
    /**
     * @return List of device ids
     * 
     */
    private List<String> apIds;
    /**
     * @return Bandwidth limiting for apps (applies to up/down)
     * 
     */
    private GetWlansOrgWlanAppLimit appLimit;
    /**
     * @return APP qos wlan settings
     * 
     */
    private GetWlansOrgWlanAppQos appQos;
    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    private String applyTo;
    /**
     * @return Whether to enable smart arp filter
     * 
     */
    private Boolean arpFilter;
    /**
     * @return Authentication wlan settings
     * 
     */
    private GetWlansOrgWlanAuth auth;
    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    private String authServerSelection;
    /**
     * @return List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     * 
     */
    private List<GetWlansOrgWlanAuthServer> authServers;
    /**
     * @return Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    private String authServersNasId;
    /**
     * @return Optional, NAS-IP-ADDRESS to use
     * 
     */
    private String authServersNasIp;
    /**
     * @return Radius auth session retries. Following fast timers are set if &#34;fastDot1xTimers&#34; knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default value to 3.
     * 
     */
    private Integer authServersRetries;
    /**
     * @return Radius auth session timeout. Following fast timers are set if &#34;fastDot1xTimers&#34; knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting authServersTimeout and is set to default value of 10.
     * 
     */
    private Integer authServersTimeout;
    /**
     * @return Whether to enable band_steering, this works only when band==both
     * 
     */
    private Boolean bandSteer;
    /**
     * @return Force dualBand capable client to connect to 5G
     * 
     */
    private Boolean bandSteerForceBand5;
    /**
     * @return List of radios that the wlan should apply to.
     * 
     */
    private List<String> bands;
    /**
     * @return Whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    private Boolean blockBlacklistClients;
    /**
     * @return Bonjour gateway wlan settings
     * 
     */
    private GetWlansOrgWlanBonjour bonjour;
    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    private GetWlansOrgWlanCiscoCwa ciscoCwa;
    private String clientLimitDown;
    /**
     * @return If downlink limiting per-client is enabled
     * 
     */
    private Boolean clientLimitDownEnabled;
    private String clientLimitUp;
    /**
     * @return If uplink limiting per-client is enabled
     * 
     */
    private Boolean clientLimitUpEnabled;
    /**
     * @return List of COA (change of authorization) servers, optional
     * 
     */
    private List<GetWlansOrgWlanCoaServer> coaServers;
    /**
     * @return When the object has been created, in epoch
     * 
     */
    private Double createdTime;
    /**
     * @return Some old WLAN drivers may not be compatible
     * 
     */
    private Boolean disable11ax;
    /**
     * @return To disable Wi-Fi 7 EHT IEs
     * 
     */
    private Boolean disable11be;
    /**
     * @return To disable ht or vht rates
     * 
     */
    private Boolean disableHtVhtRates;
    /**
     * @return Whether to disable U-APSD
     * 
     */
    private Boolean disableUapsd;
    /**
     * @return Disable sending v2 roam notification messages
     * 
     */
    private Boolean disableV1RoamNotify;
    /**
     * @return Disable sending v2 roam notification messages
     * 
     */
    private Boolean disableV2RoamNotify;
    /**
     * @return When any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     * 
     */
    private Boolean disableWhenGatewayUnreachable;
    private Boolean disableWhenMxtunnelDown;
    /**
     * @return Whether to disable WMM
     * 
     */
    private Boolean disableWmm;
    /**
     * @return For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    private GetWlansOrgWlanDnsServerRewrite dnsServerRewrite;
    private Integer dtim;
    /**
     * @return For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `authServers` is required
     *   * PSK will come from cloud WLC if source is cloudPsks
     *   * defaultPsk will be used if cloud WLC is not available
     *   * `multiPskOnly` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     * 
     */
    private GetWlansOrgWlanDynamicPsk dynamicPsk;
    /**
     * @return For 802.1x
     * 
     */
    private GetWlansOrgWlanDynamicVlan dynamicVlan;
    /**
     * @return Enable AP-AP keycaching via multicast
     * 
     */
    private Boolean enableLocalKeycaching;
    /**
     * @return By default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
     * 
     */
    private Boolean enableWirelessBridging;
    /**
     * @return If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response packets to be forwarded to wireless
     * 
     */
    private Boolean enableWirelessBridgingDhcpTracking;
    /**
     * @return If this wlan is enabled
     * 
     */
    private Boolean enabled;
    /**
     * @return If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     * 
     */
    private Boolean fastDot1xTimers;
    /**
     * @return Whether to hide SSID in beacon
     * 
     */
    private Boolean hideSsid;
    /**
     * @return Include hostname inside IE in AP beacons / probe responses
     * 
     */
    private Boolean hostnameIe;
    /**
     * @return Hostspot 2.0 wlan settings
     * 
     */
    private GetWlansOrgWlanHotspot20 hotspot20;
    /**
     * @return Unique ID of the object instance in the Mist Organization
     * 
     */
    private String id;
    private GetWlansOrgWlanInjectDhcpOption82 injectDhcpOption82;
    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     * 
     */
    private String interface_;
    /**
     * @return Whether to stop clients to talk to each other
     * 
     */
    private Boolean isolation;
    /**
     * @return If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    private Boolean l2Isolation;
    /**
     * @return Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     * 
     */
    private Boolean legacyOverds;
    /**
     * @return Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    private Boolean limitBcast;
    /**
     * @return Limit probe response base on some heuristic rules
     * 
     */
    private Boolean limitProbeResponse;
    /**
     * @return Max idle time in seconds
     * 
     */
    private Integer maxIdletime;
    /**
     * @return Maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    private Integer maxNumClients;
    private GetWlansOrgWlanMistNac mistNac;
    /**
     * @return When the object has been modified for the last time, in epoch
     * 
     */
    private Double modifiedTime;
    private String mspId;
    /**
     * @return When `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    private List<String> mxtunnelIds;
    /**
     * @return When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    private List<String> mxtunnelNames;
    /**
     * @return Whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    private Boolean noStaticDns;
    /**
     * @return Whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    private Boolean noStaticIp;
    private String orgId;
    /**
     * @return Portal wlan settings
     * 
     */
    private GetWlansOrgWlanPortal portal;
    /**
     * @return List of hostnames without http(s):// (matched by substring)
     * 
     */
    private List<String> portalAllowedHostnames;
    /**
     * @return List of CIDRs
     * 
     */
    private List<String> portalAllowedSubnets;
    /**
     * @return API secret (auto-generated) that can be used to sign guest authorization requests, only generated when auth is set to `external`
     * 
     */
    private String portalApiSecret;
    /**
     * @return List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    private List<String> portalDeniedHostnames;
    /**
     * @return Url of portal background image
     * 
     */
    private String portalImage;
    /**
     * @return URL used in the SSO process, auto-generated when auth is set to `sso`
     * 
     */
    private String portalSsoUrl;
    private GetWlansOrgWlanQos qos;
    /**
     * @return RadSec settings
     * 
     */
    private GetWlansOrgWlanRadsec radsec;
    /**
     * @return Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    private Map<String,GetWlansOrgWlanRateset> rateset;
    /**
     * @return When different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    private Boolean reconnectClientsWhenRoamingMxcluster;
    /**
     * @return enum: `11r`, `OKC`, `NONE`
     * 
     */
    private String roamMode;
    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    private GetWlansOrgWlanSchedule schedule;
    /**
     * @return Whether to exclude this WLAN from SLE metrics
     * 
     */
    private Boolean sleExcluded;
    /**
     * @return Name of the SSID
     * 
     */
    private String ssid;
    private String templateId;
    /**
     * @return If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    private Boolean useEapolV1;
    /**
     * @return If vlan tagging is enabled
     * 
     */
    private Boolean vlanEnabled;
    private String vlanId;
    /**
     * @return if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     * 
     */
    private List<String> vlanIds;
    /**
     * @return Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     * 
     */
    private Boolean vlanPooling;
    private String wlanLimitDown;
    /**
     * @return If downlink limiting for whole wlan is enabled
     * 
     */
    private Boolean wlanLimitDownEnabled;
    private String wlanLimitUp;
    /**
     * @return If uplink limiting for whole wlan is enabled
     * 
     */
    private Boolean wlanLimitUpEnabled;
    /**
     * @return List of wxtag_ids
     * 
     */
    private List<String> wxtagIds;
    /**
     * @return When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    private String wxtunnelId;
    /**
     * @return When `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    private String wxtunnelRemoteId;

    private GetWlansOrgWlan() {}
    /**
     * @return Enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    public Boolean acctImmediateUpdate() {
        return this.acctImmediateUpdate;
    }
    /**
     * @return How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     * 
     */
    public Integer acctInterimInterval() {
        return this.acctInterimInterval;
    }
    /**
     * @return List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    public List<GetWlansOrgWlanAcctServer> acctServers() {
        return this.acctServers;
    }
    /**
     * @return Airwatch wlan settings
     * 
     */
    public GetWlansOrgWlanAirwatch airwatch() {
        return this.airwatch;
    }
    /**
     * @return Only applicable when `limitBcast`==`true`, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    public Boolean allowIpv6Ndp() {
        return this.allowIpv6Ndp;
    }
    /**
     * @return Only applicable when `limitBcast`==`true`, which allows mDNS / Bonjour packets to go through
     * 
     */
    public Boolean allowMdns() {
        return this.allowMdns;
    }
    /**
     * @return Only applicable when `limitBcast`==`true`, which allows SSDP
     * 
     */
    public Boolean allowSsdp() {
        return this.allowSsdp;
    }
    /**
     * @return List of device ids
     * 
     */
    public List<String> apIds() {
        return this.apIds;
    }
    /**
     * @return Bandwidth limiting for apps (applies to up/down)
     * 
     */
    public GetWlansOrgWlanAppLimit appLimit() {
        return this.appLimit;
    }
    /**
     * @return APP qos wlan settings
     * 
     */
    public GetWlansOrgWlanAppQos appQos() {
        return this.appQos;
    }
    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    public String applyTo() {
        return this.applyTo;
    }
    /**
     * @return Whether to enable smart arp filter
     * 
     */
    public Boolean arpFilter() {
        return this.arpFilter;
    }
    /**
     * @return Authentication wlan settings
     * 
     */
    public GetWlansOrgWlanAuth auth() {
        return this.auth;
    }
    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    public String authServerSelection() {
        return this.authServerSelection;
    }
    /**
     * @return List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     * 
     */
    public List<GetWlansOrgWlanAuthServer> authServers() {
        return this.authServers;
    }
    /**
     * @return Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    public String authServersNasId() {
        return this.authServersNasId;
    }
    /**
     * @return Optional, NAS-IP-ADDRESS to use
     * 
     */
    public String authServersNasIp() {
        return this.authServersNasIp;
    }
    /**
     * @return Radius auth session retries. Following fast timers are set if &#34;fastDot1xTimers&#34; knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting authServersRetries and is set to default value to 3.
     * 
     */
    public Integer authServersRetries() {
        return this.authServersRetries;
    }
    /**
     * @return Radius auth session timeout. Following fast timers are set if &#34;fastDot1xTimers&#34; knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting authServersTimeout and is set to default value of 10.
     * 
     */
    public Integer authServersTimeout() {
        return this.authServersTimeout;
    }
    /**
     * @return Whether to enable band_steering, this works only when band==both
     * 
     */
    public Boolean bandSteer() {
        return this.bandSteer;
    }
    /**
     * @return Force dualBand capable client to connect to 5G
     * 
     */
    public Boolean bandSteerForceBand5() {
        return this.bandSteerForceBand5;
    }
    /**
     * @return List of radios that the wlan should apply to.
     * 
     */
    public List<String> bands() {
        return this.bands;
    }
    /**
     * @return Whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    public Boolean blockBlacklistClients() {
        return this.blockBlacklistClients;
    }
    /**
     * @return Bonjour gateway wlan settings
     * 
     */
    public GetWlansOrgWlanBonjour bonjour() {
        return this.bonjour;
    }
    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    public GetWlansOrgWlanCiscoCwa ciscoCwa() {
        return this.ciscoCwa;
    }
    public String clientLimitDown() {
        return this.clientLimitDown;
    }
    /**
     * @return If downlink limiting per-client is enabled
     * 
     */
    public Boolean clientLimitDownEnabled() {
        return this.clientLimitDownEnabled;
    }
    public String clientLimitUp() {
        return this.clientLimitUp;
    }
    /**
     * @return If uplink limiting per-client is enabled
     * 
     */
    public Boolean clientLimitUpEnabled() {
        return this.clientLimitUpEnabled;
    }
    /**
     * @return List of COA (change of authorization) servers, optional
     * 
     */
    public List<GetWlansOrgWlanCoaServer> coaServers() {
        return this.coaServers;
    }
    /**
     * @return When the object has been created, in epoch
     * 
     */
    public Double createdTime() {
        return this.createdTime;
    }
    /**
     * @return Some old WLAN drivers may not be compatible
     * 
     */
    public Boolean disable11ax() {
        return this.disable11ax;
    }
    /**
     * @return To disable Wi-Fi 7 EHT IEs
     * 
     */
    public Boolean disable11be() {
        return this.disable11be;
    }
    /**
     * @return To disable ht or vht rates
     * 
     */
    public Boolean disableHtVhtRates() {
        return this.disableHtVhtRates;
    }
    /**
     * @return Whether to disable U-APSD
     * 
     */
    public Boolean disableUapsd() {
        return this.disableUapsd;
    }
    /**
     * @return Disable sending v2 roam notification messages
     * 
     */
    public Boolean disableV1RoamNotify() {
        return this.disableV1RoamNotify;
    }
    /**
     * @return Disable sending v2 roam notification messages
     * 
     */
    public Boolean disableV2RoamNotify() {
        return this.disableV2RoamNotify;
    }
    /**
     * @return When any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     * 
     */
    public Boolean disableWhenGatewayUnreachable() {
        return this.disableWhenGatewayUnreachable;
    }
    public Boolean disableWhenMxtunnelDown() {
        return this.disableWhenMxtunnelDown;
    }
    /**
     * @return Whether to disable WMM
     * 
     */
    public Boolean disableWmm() {
        return this.disableWmm;
    }
    /**
     * @return For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    public GetWlansOrgWlanDnsServerRewrite dnsServerRewrite() {
        return this.dnsServerRewrite;
    }
    public Integer dtim() {
        return this.dtim;
    }
    /**
     * @return For dynamic PSK where we get perUser PSK from Radius. dynamicPsk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username and password (i.e. `enableMacAuth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `authServers` is required
     *   * PSK will come from cloud WLC if source is cloudPsks
     *   * defaultPsk will be used if cloud WLC is not available
     *   * `multiPskOnly` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     * 
     */
    public GetWlansOrgWlanDynamicPsk dynamicPsk() {
        return this.dynamicPsk;
    }
    /**
     * @return For 802.1x
     * 
     */
    public GetWlansOrgWlanDynamicVlan dynamicVlan() {
        return this.dynamicVlan;
    }
    /**
     * @return Enable AP-AP keycaching via multicast
     * 
     */
    public Boolean enableLocalKeycaching() {
        return this.enableLocalKeycaching;
    }
    /**
     * @return By default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wirelessBridging can be enabled
     * 
     */
    public Boolean enableWirelessBridging() {
        return this.enableWirelessBridging;
    }
    /**
     * @return If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcpTracking will cut down DHCP response packets to be forwarded to wireless
     * 
     */
    public Boolean enableWirelessBridgingDhcpTracking() {
        return this.enableWirelessBridgingDhcpTracking;
    }
    /**
     * @return If this wlan is enabled
     * 
     */
    public Boolean enabled() {
        return this.enabled;
    }
    /**
     * @return If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     * 
     */
    public Boolean fastDot1xTimers() {
        return this.fastDot1xTimers;
    }
    /**
     * @return Whether to hide SSID in beacon
     * 
     */
    public Boolean hideSsid() {
        return this.hideSsid;
    }
    /**
     * @return Include hostname inside IE in AP beacons / probe responses
     * 
     */
    public Boolean hostnameIe() {
        return this.hostnameIe;
    }
    /**
     * @return Hostspot 2.0 wlan settings
     * 
     */
    public GetWlansOrgWlanHotspot20 hotspot20() {
        return this.hotspot20;
    }
    /**
     * @return Unique ID of the object instance in the Mist Organization
     * 
     */
    public String id() {
        return this.id;
    }
    public GetWlansOrgWlanInjectDhcpOption82 injectDhcpOption82() {
        return this.injectDhcpOption82;
    }
    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `siteMxedge`, `wxtunnel`
     * 
     */
    public String interface_() {
        return this.interface_;
    }
    /**
     * @return Whether to stop clients to talk to each other
     * 
     */
    public Boolean isolation() {
        return this.isolation;
    }
    /**
     * @return If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    public Boolean l2Isolation() {
        return this.l2Isolation;
    }
    /**
     * @return Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     * 
     */
    public Boolean legacyOverds() {
        return this.legacyOverds;
    }
    /**
     * @return Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    public Boolean limitBcast() {
        return this.limitBcast;
    }
    /**
     * @return Limit probe response base on some heuristic rules
     * 
     */
    public Boolean limitProbeResponse() {
        return this.limitProbeResponse;
    }
    /**
     * @return Max idle time in seconds
     * 
     */
    public Integer maxIdletime() {
        return this.maxIdletime;
    }
    /**
     * @return Maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    public Integer maxNumClients() {
        return this.maxNumClients;
    }
    public GetWlansOrgWlanMistNac mistNac() {
        return this.mistNac;
    }
    /**
     * @return When the object has been modified for the last time, in epoch
     * 
     */
    public Double modifiedTime() {
        return this.modifiedTime;
    }
    public String mspId() {
        return this.mspId;
    }
    /**
     * @return When `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    public List<String> mxtunnelIds() {
        return this.mxtunnelIds;
    }
    /**
     * @return When `interface`=`siteMxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    public List<String> mxtunnelNames() {
        return this.mxtunnelNames;
    }
    /**
     * @return Whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    public Boolean noStaticDns() {
        return this.noStaticDns;
    }
    /**
     * @return Whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    public Boolean noStaticIp() {
        return this.noStaticIp;
    }
    public String orgId() {
        return this.orgId;
    }
    /**
     * @return Portal wlan settings
     * 
     */
    public GetWlansOrgWlanPortal portal() {
        return this.portal;
    }
    /**
     * @return List of hostnames without http(s):// (matched by substring)
     * 
     */
    public List<String> portalAllowedHostnames() {
        return this.portalAllowedHostnames;
    }
    /**
     * @return List of CIDRs
     * 
     */
    public List<String> portalAllowedSubnets() {
        return this.portalAllowedSubnets;
    }
    /**
     * @return API secret (auto-generated) that can be used to sign guest authorization requests, only generated when auth is set to `external`
     * 
     */
    public String portalApiSecret() {
        return this.portalApiSecret;
    }
    /**
     * @return List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    public List<String> portalDeniedHostnames() {
        return this.portalDeniedHostnames;
    }
    /**
     * @return Url of portal background image
     * 
     */
    public String portalImage() {
        return this.portalImage;
    }
    /**
     * @return URL used in the SSO process, auto-generated when auth is set to `sso`
     * 
     */
    public String portalSsoUrl() {
        return this.portalSsoUrl;
    }
    public GetWlansOrgWlanQos qos() {
        return this.qos;
    }
    /**
     * @return RadSec settings
     * 
     */
    public GetWlansOrgWlanRadsec radsec() {
        return this.radsec;
    }
    /**
     * @return Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    public Map<String,GetWlansOrgWlanRateset> rateset() {
        return this.rateset;
    }
    /**
     * @return When different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    public Boolean reconnectClientsWhenRoamingMxcluster() {
        return this.reconnectClientsWhenRoamingMxcluster;
    }
    /**
     * @return enum: `11r`, `OKC`, `NONE`
     * 
     */
    public String roamMode() {
        return this.roamMode;
    }
    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    public GetWlansOrgWlanSchedule schedule() {
        return this.schedule;
    }
    /**
     * @return Whether to exclude this WLAN from SLE metrics
     * 
     */
    public Boolean sleExcluded() {
        return this.sleExcluded;
    }
    /**
     * @return Name of the SSID
     * 
     */
    public String ssid() {
        return this.ssid;
    }
    public String templateId() {
        return this.templateId;
    }
    /**
     * @return If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    public Boolean useEapolV1() {
        return this.useEapolV1;
    }
    /**
     * @return If vlan tagging is enabled
     * 
     */
    public Boolean vlanEnabled() {
        return this.vlanEnabled;
    }
    public String vlanId() {
        return this.vlanId;
    }
    /**
     * @return if `vlanEnabled`==`true` and `vlanPooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     * 
     */
    public List<String> vlanIds() {
        return this.vlanIds;
    }
    /**
     * @return Requires `vlanEnabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     * 
     */
    public Boolean vlanPooling() {
        return this.vlanPooling;
    }
    public String wlanLimitDown() {
        return this.wlanLimitDown;
    }
    /**
     * @return If downlink limiting for whole wlan is enabled
     * 
     */
    public Boolean wlanLimitDownEnabled() {
        return this.wlanLimitDownEnabled;
    }
    public String wlanLimitUp() {
        return this.wlanLimitUp;
    }
    /**
     * @return If uplink limiting for whole wlan is enabled
     * 
     */
    public Boolean wlanLimitUpEnabled() {
        return this.wlanLimitUpEnabled;
    }
    /**
     * @return List of wxtag_ids
     * 
     */
    public List<String> wxtagIds() {
        return this.wxtagIds;
    }
    /**
     * @return When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    public String wxtunnelId() {
        return this.wxtunnelId;
    }
    /**
     * @return When `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    public String wxtunnelRemoteId() {
        return this.wxtunnelRemoteId;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetWlansOrgWlan defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean acctImmediateUpdate;
        private Integer acctInterimInterval;
        private List<GetWlansOrgWlanAcctServer> acctServers;
        private GetWlansOrgWlanAirwatch airwatch;
        private Boolean allowIpv6Ndp;
        private Boolean allowMdns;
        private Boolean allowSsdp;
        private List<String> apIds;
        private GetWlansOrgWlanAppLimit appLimit;
        private GetWlansOrgWlanAppQos appQos;
        private String applyTo;
        private Boolean arpFilter;
        private GetWlansOrgWlanAuth auth;
        private String authServerSelection;
        private List<GetWlansOrgWlanAuthServer> authServers;
        private String authServersNasId;
        private String authServersNasIp;
        private Integer authServersRetries;
        private Integer authServersTimeout;
        private Boolean bandSteer;
        private Boolean bandSteerForceBand5;
        private List<String> bands;
        private Boolean blockBlacklistClients;
        private GetWlansOrgWlanBonjour bonjour;
        private GetWlansOrgWlanCiscoCwa ciscoCwa;
        private String clientLimitDown;
        private Boolean clientLimitDownEnabled;
        private String clientLimitUp;
        private Boolean clientLimitUpEnabled;
        private List<GetWlansOrgWlanCoaServer> coaServers;
        private Double createdTime;
        private Boolean disable11ax;
        private Boolean disable11be;
        private Boolean disableHtVhtRates;
        private Boolean disableUapsd;
        private Boolean disableV1RoamNotify;
        private Boolean disableV2RoamNotify;
        private Boolean disableWhenGatewayUnreachable;
        private Boolean disableWhenMxtunnelDown;
        private Boolean disableWmm;
        private GetWlansOrgWlanDnsServerRewrite dnsServerRewrite;
        private Integer dtim;
        private GetWlansOrgWlanDynamicPsk dynamicPsk;
        private GetWlansOrgWlanDynamicVlan dynamicVlan;
        private Boolean enableLocalKeycaching;
        private Boolean enableWirelessBridging;
        private Boolean enableWirelessBridgingDhcpTracking;
        private Boolean enabled;
        private Boolean fastDot1xTimers;
        private Boolean hideSsid;
        private Boolean hostnameIe;
        private GetWlansOrgWlanHotspot20 hotspot20;
        private String id;
        private GetWlansOrgWlanInjectDhcpOption82 injectDhcpOption82;
        private String interface_;
        private Boolean isolation;
        private Boolean l2Isolation;
        private Boolean legacyOverds;
        private Boolean limitBcast;
        private Boolean limitProbeResponse;
        private Integer maxIdletime;
        private Integer maxNumClients;
        private GetWlansOrgWlanMistNac mistNac;
        private Double modifiedTime;
        private String mspId;
        private List<String> mxtunnelIds;
        private List<String> mxtunnelNames;
        private Boolean noStaticDns;
        private Boolean noStaticIp;
        private String orgId;
        private GetWlansOrgWlanPortal portal;
        private List<String> portalAllowedHostnames;
        private List<String> portalAllowedSubnets;
        private String portalApiSecret;
        private List<String> portalDeniedHostnames;
        private String portalImage;
        private String portalSsoUrl;
        private GetWlansOrgWlanQos qos;
        private GetWlansOrgWlanRadsec radsec;
        private Map<String,GetWlansOrgWlanRateset> rateset;
        private Boolean reconnectClientsWhenRoamingMxcluster;
        private String roamMode;
        private GetWlansOrgWlanSchedule schedule;
        private Boolean sleExcluded;
        private String ssid;
        private String templateId;
        private Boolean useEapolV1;
        private Boolean vlanEnabled;
        private String vlanId;
        private List<String> vlanIds;
        private Boolean vlanPooling;
        private String wlanLimitDown;
        private Boolean wlanLimitDownEnabled;
        private String wlanLimitUp;
        private Boolean wlanLimitUpEnabled;
        private List<String> wxtagIds;
        private String wxtunnelId;
        private String wxtunnelRemoteId;
        public Builder() {}
        public Builder(GetWlansOrgWlan defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.acctImmediateUpdate = defaults.acctImmediateUpdate;
    	      this.acctInterimInterval = defaults.acctInterimInterval;
    	      this.acctServers = defaults.acctServers;
    	      this.airwatch = defaults.airwatch;
    	      this.allowIpv6Ndp = defaults.allowIpv6Ndp;
    	      this.allowMdns = defaults.allowMdns;
    	      this.allowSsdp = defaults.allowSsdp;
    	      this.apIds = defaults.apIds;
    	      this.appLimit = defaults.appLimit;
    	      this.appQos = defaults.appQos;
    	      this.applyTo = defaults.applyTo;
    	      this.arpFilter = defaults.arpFilter;
    	      this.auth = defaults.auth;
    	      this.authServerSelection = defaults.authServerSelection;
    	      this.authServers = defaults.authServers;
    	      this.authServersNasId = defaults.authServersNasId;
    	      this.authServersNasIp = defaults.authServersNasIp;
    	      this.authServersRetries = defaults.authServersRetries;
    	      this.authServersTimeout = defaults.authServersTimeout;
    	      this.bandSteer = defaults.bandSteer;
    	      this.bandSteerForceBand5 = defaults.bandSteerForceBand5;
    	      this.bands = defaults.bands;
    	      this.blockBlacklistClients = defaults.blockBlacklistClients;
    	      this.bonjour = defaults.bonjour;
    	      this.ciscoCwa = defaults.ciscoCwa;
    	      this.clientLimitDown = defaults.clientLimitDown;
    	      this.clientLimitDownEnabled = defaults.clientLimitDownEnabled;
    	      this.clientLimitUp = defaults.clientLimitUp;
    	      this.clientLimitUpEnabled = defaults.clientLimitUpEnabled;
    	      this.coaServers = defaults.coaServers;
    	      this.createdTime = defaults.createdTime;
    	      this.disable11ax = defaults.disable11ax;
    	      this.disable11be = defaults.disable11be;
    	      this.disableHtVhtRates = defaults.disableHtVhtRates;
    	      this.disableUapsd = defaults.disableUapsd;
    	      this.disableV1RoamNotify = defaults.disableV1RoamNotify;
    	      this.disableV2RoamNotify = defaults.disableV2RoamNotify;
    	      this.disableWhenGatewayUnreachable = defaults.disableWhenGatewayUnreachable;
    	      this.disableWhenMxtunnelDown = defaults.disableWhenMxtunnelDown;
    	      this.disableWmm = defaults.disableWmm;
    	      this.dnsServerRewrite = defaults.dnsServerRewrite;
    	      this.dtim = defaults.dtim;
    	      this.dynamicPsk = defaults.dynamicPsk;
    	      this.dynamicVlan = defaults.dynamicVlan;
    	      this.enableLocalKeycaching = defaults.enableLocalKeycaching;
    	      this.enableWirelessBridging = defaults.enableWirelessBridging;
    	      this.enableWirelessBridgingDhcpTracking = defaults.enableWirelessBridgingDhcpTracking;
    	      this.enabled = defaults.enabled;
    	      this.fastDot1xTimers = defaults.fastDot1xTimers;
    	      this.hideSsid = defaults.hideSsid;
    	      this.hostnameIe = defaults.hostnameIe;
    	      this.hotspot20 = defaults.hotspot20;
    	      this.id = defaults.id;
    	      this.injectDhcpOption82 = defaults.injectDhcpOption82;
    	      this.interface_ = defaults.interface_;
    	      this.isolation = defaults.isolation;
    	      this.l2Isolation = defaults.l2Isolation;
    	      this.legacyOverds = defaults.legacyOverds;
    	      this.limitBcast = defaults.limitBcast;
    	      this.limitProbeResponse = defaults.limitProbeResponse;
    	      this.maxIdletime = defaults.maxIdletime;
    	      this.maxNumClients = defaults.maxNumClients;
    	      this.mistNac = defaults.mistNac;
    	      this.modifiedTime = defaults.modifiedTime;
    	      this.mspId = defaults.mspId;
    	      this.mxtunnelIds = defaults.mxtunnelIds;
    	      this.mxtunnelNames = defaults.mxtunnelNames;
    	      this.noStaticDns = defaults.noStaticDns;
    	      this.noStaticIp = defaults.noStaticIp;
    	      this.orgId = defaults.orgId;
    	      this.portal = defaults.portal;
    	      this.portalAllowedHostnames = defaults.portalAllowedHostnames;
    	      this.portalAllowedSubnets = defaults.portalAllowedSubnets;
    	      this.portalApiSecret = defaults.portalApiSecret;
    	      this.portalDeniedHostnames = defaults.portalDeniedHostnames;
    	      this.portalImage = defaults.portalImage;
    	      this.portalSsoUrl = defaults.portalSsoUrl;
    	      this.qos = defaults.qos;
    	      this.radsec = defaults.radsec;
    	      this.rateset = defaults.rateset;
    	      this.reconnectClientsWhenRoamingMxcluster = defaults.reconnectClientsWhenRoamingMxcluster;
    	      this.roamMode = defaults.roamMode;
    	      this.schedule = defaults.schedule;
    	      this.sleExcluded = defaults.sleExcluded;
    	      this.ssid = defaults.ssid;
    	      this.templateId = defaults.templateId;
    	      this.useEapolV1 = defaults.useEapolV1;
    	      this.vlanEnabled = defaults.vlanEnabled;
    	      this.vlanId = defaults.vlanId;
    	      this.vlanIds = defaults.vlanIds;
    	      this.vlanPooling = defaults.vlanPooling;
    	      this.wlanLimitDown = defaults.wlanLimitDown;
    	      this.wlanLimitDownEnabled = defaults.wlanLimitDownEnabled;
    	      this.wlanLimitUp = defaults.wlanLimitUp;
    	      this.wlanLimitUpEnabled = defaults.wlanLimitUpEnabled;
    	      this.wxtagIds = defaults.wxtagIds;
    	      this.wxtunnelId = defaults.wxtunnelId;
    	      this.wxtunnelRemoteId = defaults.wxtunnelRemoteId;
        }

        @CustomType.Setter
        public Builder acctImmediateUpdate(Boolean acctImmediateUpdate) {
            if (acctImmediateUpdate == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "acctImmediateUpdate");
            }
            this.acctImmediateUpdate = acctImmediateUpdate;
            return this;
        }
        @CustomType.Setter
        public Builder acctInterimInterval(Integer acctInterimInterval) {
            if (acctInterimInterval == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "acctInterimInterval");
            }
            this.acctInterimInterval = acctInterimInterval;
            return this;
        }
        @CustomType.Setter
        public Builder acctServers(List<GetWlansOrgWlanAcctServer> acctServers) {
            if (acctServers == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "acctServers");
            }
            this.acctServers = acctServers;
            return this;
        }
        public Builder acctServers(GetWlansOrgWlanAcctServer... acctServers) {
            return acctServers(List.of(acctServers));
        }
        @CustomType.Setter
        public Builder airwatch(GetWlansOrgWlanAirwatch airwatch) {
            if (airwatch == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "airwatch");
            }
            this.airwatch = airwatch;
            return this;
        }
        @CustomType.Setter
        public Builder allowIpv6Ndp(Boolean allowIpv6Ndp) {
            if (allowIpv6Ndp == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "allowIpv6Ndp");
            }
            this.allowIpv6Ndp = allowIpv6Ndp;
            return this;
        }
        @CustomType.Setter
        public Builder allowMdns(Boolean allowMdns) {
            if (allowMdns == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "allowMdns");
            }
            this.allowMdns = allowMdns;
            return this;
        }
        @CustomType.Setter
        public Builder allowSsdp(Boolean allowSsdp) {
            if (allowSsdp == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "allowSsdp");
            }
            this.allowSsdp = allowSsdp;
            return this;
        }
        @CustomType.Setter
        public Builder apIds(List<String> apIds) {
            if (apIds == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "apIds");
            }
            this.apIds = apIds;
            return this;
        }
        public Builder apIds(String... apIds) {
            return apIds(List.of(apIds));
        }
        @CustomType.Setter
        public Builder appLimit(GetWlansOrgWlanAppLimit appLimit) {
            if (appLimit == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "appLimit");
            }
            this.appLimit = appLimit;
            return this;
        }
        @CustomType.Setter
        public Builder appQos(GetWlansOrgWlanAppQos appQos) {
            if (appQos == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "appQos");
            }
            this.appQos = appQos;
            return this;
        }
        @CustomType.Setter
        public Builder applyTo(String applyTo) {
            if (applyTo == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "applyTo");
            }
            this.applyTo = applyTo;
            return this;
        }
        @CustomType.Setter
        public Builder arpFilter(Boolean arpFilter) {
            if (arpFilter == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "arpFilter");
            }
            this.arpFilter = arpFilter;
            return this;
        }
        @CustomType.Setter
        public Builder auth(GetWlansOrgWlanAuth auth) {
            if (auth == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "auth");
            }
            this.auth = auth;
            return this;
        }
        @CustomType.Setter
        public Builder authServerSelection(String authServerSelection) {
            if (authServerSelection == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "authServerSelection");
            }
            this.authServerSelection = authServerSelection;
            return this;
        }
        @CustomType.Setter
        public Builder authServers(List<GetWlansOrgWlanAuthServer> authServers) {
            if (authServers == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "authServers");
            }
            this.authServers = authServers;
            return this;
        }
        public Builder authServers(GetWlansOrgWlanAuthServer... authServers) {
            return authServers(List.of(authServers));
        }
        @CustomType.Setter
        public Builder authServersNasId(String authServersNasId) {
            if (authServersNasId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "authServersNasId");
            }
            this.authServersNasId = authServersNasId;
            return this;
        }
        @CustomType.Setter
        public Builder authServersNasIp(String authServersNasIp) {
            if (authServersNasIp == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "authServersNasIp");
            }
            this.authServersNasIp = authServersNasIp;
            return this;
        }
        @CustomType.Setter
        public Builder authServersRetries(Integer authServersRetries) {
            if (authServersRetries == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "authServersRetries");
            }
            this.authServersRetries = authServersRetries;
            return this;
        }
        @CustomType.Setter
        public Builder authServersTimeout(Integer authServersTimeout) {
            if (authServersTimeout == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "authServersTimeout");
            }
            this.authServersTimeout = authServersTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder bandSteer(Boolean bandSteer) {
            if (bandSteer == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "bandSteer");
            }
            this.bandSteer = bandSteer;
            return this;
        }
        @CustomType.Setter
        public Builder bandSteerForceBand5(Boolean bandSteerForceBand5) {
            if (bandSteerForceBand5 == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "bandSteerForceBand5");
            }
            this.bandSteerForceBand5 = bandSteerForceBand5;
            return this;
        }
        @CustomType.Setter
        public Builder bands(List<String> bands) {
            if (bands == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "bands");
            }
            this.bands = bands;
            return this;
        }
        public Builder bands(String... bands) {
            return bands(List.of(bands));
        }
        @CustomType.Setter
        public Builder blockBlacklistClients(Boolean blockBlacklistClients) {
            if (blockBlacklistClients == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "blockBlacklistClients");
            }
            this.blockBlacklistClients = blockBlacklistClients;
            return this;
        }
        @CustomType.Setter
        public Builder bonjour(GetWlansOrgWlanBonjour bonjour) {
            if (bonjour == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "bonjour");
            }
            this.bonjour = bonjour;
            return this;
        }
        @CustomType.Setter
        public Builder ciscoCwa(GetWlansOrgWlanCiscoCwa ciscoCwa) {
            if (ciscoCwa == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "ciscoCwa");
            }
            this.ciscoCwa = ciscoCwa;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitDown(String clientLimitDown) {
            if (clientLimitDown == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "clientLimitDown");
            }
            this.clientLimitDown = clientLimitDown;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitDownEnabled(Boolean clientLimitDownEnabled) {
            if (clientLimitDownEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "clientLimitDownEnabled");
            }
            this.clientLimitDownEnabled = clientLimitDownEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitUp(String clientLimitUp) {
            if (clientLimitUp == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "clientLimitUp");
            }
            this.clientLimitUp = clientLimitUp;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitUpEnabled(Boolean clientLimitUpEnabled) {
            if (clientLimitUpEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "clientLimitUpEnabled");
            }
            this.clientLimitUpEnabled = clientLimitUpEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder coaServers(List<GetWlansOrgWlanCoaServer> coaServers) {
            if (coaServers == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "coaServers");
            }
            this.coaServers = coaServers;
            return this;
        }
        public Builder coaServers(GetWlansOrgWlanCoaServer... coaServers) {
            return coaServers(List.of(coaServers));
        }
        @CustomType.Setter
        public Builder createdTime(Double createdTime) {
            if (createdTime == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "createdTime");
            }
            this.createdTime = createdTime;
            return this;
        }
        @CustomType.Setter
        public Builder disable11ax(Boolean disable11ax) {
            if (disable11ax == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disable11ax");
            }
            this.disable11ax = disable11ax;
            return this;
        }
        @CustomType.Setter
        public Builder disable11be(Boolean disable11be) {
            if (disable11be == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disable11be");
            }
            this.disable11be = disable11be;
            return this;
        }
        @CustomType.Setter
        public Builder disableHtVhtRates(Boolean disableHtVhtRates) {
            if (disableHtVhtRates == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableHtVhtRates");
            }
            this.disableHtVhtRates = disableHtVhtRates;
            return this;
        }
        @CustomType.Setter
        public Builder disableUapsd(Boolean disableUapsd) {
            if (disableUapsd == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableUapsd");
            }
            this.disableUapsd = disableUapsd;
            return this;
        }
        @CustomType.Setter
        public Builder disableV1RoamNotify(Boolean disableV1RoamNotify) {
            if (disableV1RoamNotify == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableV1RoamNotify");
            }
            this.disableV1RoamNotify = disableV1RoamNotify;
            return this;
        }
        @CustomType.Setter
        public Builder disableV2RoamNotify(Boolean disableV2RoamNotify) {
            if (disableV2RoamNotify == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableV2RoamNotify");
            }
            this.disableV2RoamNotify = disableV2RoamNotify;
            return this;
        }
        @CustomType.Setter
        public Builder disableWhenGatewayUnreachable(Boolean disableWhenGatewayUnreachable) {
            if (disableWhenGatewayUnreachable == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableWhenGatewayUnreachable");
            }
            this.disableWhenGatewayUnreachable = disableWhenGatewayUnreachable;
            return this;
        }
        @CustomType.Setter
        public Builder disableWhenMxtunnelDown(Boolean disableWhenMxtunnelDown) {
            if (disableWhenMxtunnelDown == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableWhenMxtunnelDown");
            }
            this.disableWhenMxtunnelDown = disableWhenMxtunnelDown;
            return this;
        }
        @CustomType.Setter
        public Builder disableWmm(Boolean disableWmm) {
            if (disableWmm == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "disableWmm");
            }
            this.disableWmm = disableWmm;
            return this;
        }
        @CustomType.Setter
        public Builder dnsServerRewrite(GetWlansOrgWlanDnsServerRewrite dnsServerRewrite) {
            if (dnsServerRewrite == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "dnsServerRewrite");
            }
            this.dnsServerRewrite = dnsServerRewrite;
            return this;
        }
        @CustomType.Setter
        public Builder dtim(Integer dtim) {
            if (dtim == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "dtim");
            }
            this.dtim = dtim;
            return this;
        }
        @CustomType.Setter
        public Builder dynamicPsk(GetWlansOrgWlanDynamicPsk dynamicPsk) {
            if (dynamicPsk == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "dynamicPsk");
            }
            this.dynamicPsk = dynamicPsk;
            return this;
        }
        @CustomType.Setter
        public Builder dynamicVlan(GetWlansOrgWlanDynamicVlan dynamicVlan) {
            if (dynamicVlan == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "dynamicVlan");
            }
            this.dynamicVlan = dynamicVlan;
            return this;
        }
        @CustomType.Setter
        public Builder enableLocalKeycaching(Boolean enableLocalKeycaching) {
            if (enableLocalKeycaching == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "enableLocalKeycaching");
            }
            this.enableLocalKeycaching = enableLocalKeycaching;
            return this;
        }
        @CustomType.Setter
        public Builder enableWirelessBridging(Boolean enableWirelessBridging) {
            if (enableWirelessBridging == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "enableWirelessBridging");
            }
            this.enableWirelessBridging = enableWirelessBridging;
            return this;
        }
        @CustomType.Setter
        public Builder enableWirelessBridgingDhcpTracking(Boolean enableWirelessBridgingDhcpTracking) {
            if (enableWirelessBridgingDhcpTracking == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "enableWirelessBridgingDhcpTracking");
            }
            this.enableWirelessBridgingDhcpTracking = enableWirelessBridgingDhcpTracking;
            return this;
        }
        @CustomType.Setter
        public Builder enabled(Boolean enabled) {
            if (enabled == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "enabled");
            }
            this.enabled = enabled;
            return this;
        }
        @CustomType.Setter
        public Builder fastDot1xTimers(Boolean fastDot1xTimers) {
            if (fastDot1xTimers == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "fastDot1xTimers");
            }
            this.fastDot1xTimers = fastDot1xTimers;
            return this;
        }
        @CustomType.Setter
        public Builder hideSsid(Boolean hideSsid) {
            if (hideSsid == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "hideSsid");
            }
            this.hideSsid = hideSsid;
            return this;
        }
        @CustomType.Setter
        public Builder hostnameIe(Boolean hostnameIe) {
            if (hostnameIe == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "hostnameIe");
            }
            this.hostnameIe = hostnameIe;
            return this;
        }
        @CustomType.Setter
        public Builder hotspot20(GetWlansOrgWlanHotspot20 hotspot20) {
            if (hotspot20 == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "hotspot20");
            }
            this.hotspot20 = hotspot20;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder injectDhcpOption82(GetWlansOrgWlanInjectDhcpOption82 injectDhcpOption82) {
            if (injectDhcpOption82 == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "injectDhcpOption82");
            }
            this.injectDhcpOption82 = injectDhcpOption82;
            return this;
        }
        @CustomType.Setter("interface")
        public Builder interface_(String interface_) {
            if (interface_ == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "interface_");
            }
            this.interface_ = interface_;
            return this;
        }
        @CustomType.Setter
        public Builder isolation(Boolean isolation) {
            if (isolation == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "isolation");
            }
            this.isolation = isolation;
            return this;
        }
        @CustomType.Setter
        public Builder l2Isolation(Boolean l2Isolation) {
            if (l2Isolation == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "l2Isolation");
            }
            this.l2Isolation = l2Isolation;
            return this;
        }
        @CustomType.Setter
        public Builder legacyOverds(Boolean legacyOverds) {
            if (legacyOverds == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "legacyOverds");
            }
            this.legacyOverds = legacyOverds;
            return this;
        }
        @CustomType.Setter
        public Builder limitBcast(Boolean limitBcast) {
            if (limitBcast == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "limitBcast");
            }
            this.limitBcast = limitBcast;
            return this;
        }
        @CustomType.Setter
        public Builder limitProbeResponse(Boolean limitProbeResponse) {
            if (limitProbeResponse == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "limitProbeResponse");
            }
            this.limitProbeResponse = limitProbeResponse;
            return this;
        }
        @CustomType.Setter
        public Builder maxIdletime(Integer maxIdletime) {
            if (maxIdletime == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "maxIdletime");
            }
            this.maxIdletime = maxIdletime;
            return this;
        }
        @CustomType.Setter
        public Builder maxNumClients(Integer maxNumClients) {
            if (maxNumClients == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "maxNumClients");
            }
            this.maxNumClients = maxNumClients;
            return this;
        }
        @CustomType.Setter
        public Builder mistNac(GetWlansOrgWlanMistNac mistNac) {
            if (mistNac == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "mistNac");
            }
            this.mistNac = mistNac;
            return this;
        }
        @CustomType.Setter
        public Builder modifiedTime(Double modifiedTime) {
            if (modifiedTime == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "modifiedTime");
            }
            this.modifiedTime = modifiedTime;
            return this;
        }
        @CustomType.Setter
        public Builder mspId(String mspId) {
            if (mspId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "mspId");
            }
            this.mspId = mspId;
            return this;
        }
        @CustomType.Setter
        public Builder mxtunnelIds(List<String> mxtunnelIds) {
            if (mxtunnelIds == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "mxtunnelIds");
            }
            this.mxtunnelIds = mxtunnelIds;
            return this;
        }
        public Builder mxtunnelIds(String... mxtunnelIds) {
            return mxtunnelIds(List.of(mxtunnelIds));
        }
        @CustomType.Setter
        public Builder mxtunnelNames(List<String> mxtunnelNames) {
            if (mxtunnelNames == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "mxtunnelNames");
            }
            this.mxtunnelNames = mxtunnelNames;
            return this;
        }
        public Builder mxtunnelNames(String... mxtunnelNames) {
            return mxtunnelNames(List.of(mxtunnelNames));
        }
        @CustomType.Setter
        public Builder noStaticDns(Boolean noStaticDns) {
            if (noStaticDns == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "noStaticDns");
            }
            this.noStaticDns = noStaticDns;
            return this;
        }
        @CustomType.Setter
        public Builder noStaticIp(Boolean noStaticIp) {
            if (noStaticIp == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "noStaticIp");
            }
            this.noStaticIp = noStaticIp;
            return this;
        }
        @CustomType.Setter
        public Builder orgId(String orgId) {
            if (orgId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "orgId");
            }
            this.orgId = orgId;
            return this;
        }
        @CustomType.Setter
        public Builder portal(GetWlansOrgWlanPortal portal) {
            if (portal == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portal");
            }
            this.portal = portal;
            return this;
        }
        @CustomType.Setter
        public Builder portalAllowedHostnames(List<String> portalAllowedHostnames) {
            if (portalAllowedHostnames == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portalAllowedHostnames");
            }
            this.portalAllowedHostnames = portalAllowedHostnames;
            return this;
        }
        public Builder portalAllowedHostnames(String... portalAllowedHostnames) {
            return portalAllowedHostnames(List.of(portalAllowedHostnames));
        }
        @CustomType.Setter
        public Builder portalAllowedSubnets(List<String> portalAllowedSubnets) {
            if (portalAllowedSubnets == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portalAllowedSubnets");
            }
            this.portalAllowedSubnets = portalAllowedSubnets;
            return this;
        }
        public Builder portalAllowedSubnets(String... portalAllowedSubnets) {
            return portalAllowedSubnets(List.of(portalAllowedSubnets));
        }
        @CustomType.Setter
        public Builder portalApiSecret(String portalApiSecret) {
            if (portalApiSecret == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portalApiSecret");
            }
            this.portalApiSecret = portalApiSecret;
            return this;
        }
        @CustomType.Setter
        public Builder portalDeniedHostnames(List<String> portalDeniedHostnames) {
            if (portalDeniedHostnames == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portalDeniedHostnames");
            }
            this.portalDeniedHostnames = portalDeniedHostnames;
            return this;
        }
        public Builder portalDeniedHostnames(String... portalDeniedHostnames) {
            return portalDeniedHostnames(List.of(portalDeniedHostnames));
        }
        @CustomType.Setter
        public Builder portalImage(String portalImage) {
            if (portalImage == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portalImage");
            }
            this.portalImage = portalImage;
            return this;
        }
        @CustomType.Setter
        public Builder portalSsoUrl(String portalSsoUrl) {
            if (portalSsoUrl == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "portalSsoUrl");
            }
            this.portalSsoUrl = portalSsoUrl;
            return this;
        }
        @CustomType.Setter
        public Builder qos(GetWlansOrgWlanQos qos) {
            if (qos == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "qos");
            }
            this.qos = qos;
            return this;
        }
        @CustomType.Setter
        public Builder radsec(GetWlansOrgWlanRadsec radsec) {
            if (radsec == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "radsec");
            }
            this.radsec = radsec;
            return this;
        }
        @CustomType.Setter
        public Builder rateset(Map<String,GetWlansOrgWlanRateset> rateset) {
            if (rateset == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "rateset");
            }
            this.rateset = rateset;
            return this;
        }
        @CustomType.Setter
        public Builder reconnectClientsWhenRoamingMxcluster(Boolean reconnectClientsWhenRoamingMxcluster) {
            if (reconnectClientsWhenRoamingMxcluster == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "reconnectClientsWhenRoamingMxcluster");
            }
            this.reconnectClientsWhenRoamingMxcluster = reconnectClientsWhenRoamingMxcluster;
            return this;
        }
        @CustomType.Setter
        public Builder roamMode(String roamMode) {
            if (roamMode == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "roamMode");
            }
            this.roamMode = roamMode;
            return this;
        }
        @CustomType.Setter
        public Builder schedule(GetWlansOrgWlanSchedule schedule) {
            if (schedule == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "schedule");
            }
            this.schedule = schedule;
            return this;
        }
        @CustomType.Setter
        public Builder sleExcluded(Boolean sleExcluded) {
            if (sleExcluded == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "sleExcluded");
            }
            this.sleExcluded = sleExcluded;
            return this;
        }
        @CustomType.Setter
        public Builder ssid(String ssid) {
            if (ssid == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "ssid");
            }
            this.ssid = ssid;
            return this;
        }
        @CustomType.Setter
        public Builder templateId(String templateId) {
            if (templateId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "templateId");
            }
            this.templateId = templateId;
            return this;
        }
        @CustomType.Setter
        public Builder useEapolV1(Boolean useEapolV1) {
            if (useEapolV1 == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "useEapolV1");
            }
            this.useEapolV1 = useEapolV1;
            return this;
        }
        @CustomType.Setter
        public Builder vlanEnabled(Boolean vlanEnabled) {
            if (vlanEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "vlanEnabled");
            }
            this.vlanEnabled = vlanEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder vlanId(String vlanId) {
            if (vlanId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "vlanId");
            }
            this.vlanId = vlanId;
            return this;
        }
        @CustomType.Setter
        public Builder vlanIds(List<String> vlanIds) {
            if (vlanIds == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "vlanIds");
            }
            this.vlanIds = vlanIds;
            return this;
        }
        public Builder vlanIds(String... vlanIds) {
            return vlanIds(List.of(vlanIds));
        }
        @CustomType.Setter
        public Builder vlanPooling(Boolean vlanPooling) {
            if (vlanPooling == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "vlanPooling");
            }
            this.vlanPooling = vlanPooling;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitDown(String wlanLimitDown) {
            if (wlanLimitDown == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wlanLimitDown");
            }
            this.wlanLimitDown = wlanLimitDown;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitDownEnabled(Boolean wlanLimitDownEnabled) {
            if (wlanLimitDownEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wlanLimitDownEnabled");
            }
            this.wlanLimitDownEnabled = wlanLimitDownEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitUp(String wlanLimitUp) {
            if (wlanLimitUp == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wlanLimitUp");
            }
            this.wlanLimitUp = wlanLimitUp;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitUpEnabled(Boolean wlanLimitUpEnabled) {
            if (wlanLimitUpEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wlanLimitUpEnabled");
            }
            this.wlanLimitUpEnabled = wlanLimitUpEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder wxtagIds(List<String> wxtagIds) {
            if (wxtagIds == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wxtagIds");
            }
            this.wxtagIds = wxtagIds;
            return this;
        }
        public Builder wxtagIds(String... wxtagIds) {
            return wxtagIds(List.of(wxtagIds));
        }
        @CustomType.Setter
        public Builder wxtunnelId(String wxtunnelId) {
            if (wxtunnelId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wxtunnelId");
            }
            this.wxtunnelId = wxtunnelId;
            return this;
        }
        @CustomType.Setter
        public Builder wxtunnelRemoteId(String wxtunnelRemoteId) {
            if (wxtunnelRemoteId == null) {
              throw new MissingRequiredPropertyException("GetWlansOrgWlan", "wxtunnelRemoteId");
            }
            this.wxtunnelRemoteId = wxtunnelRemoteId;
            return this;
        }
        public GetWlansOrgWlan build() {
            final var _resultValue = new GetWlansOrgWlan();
            _resultValue.acctImmediateUpdate = acctImmediateUpdate;
            _resultValue.acctInterimInterval = acctInterimInterval;
            _resultValue.acctServers = acctServers;
            _resultValue.airwatch = airwatch;
            _resultValue.allowIpv6Ndp = allowIpv6Ndp;
            _resultValue.allowMdns = allowMdns;
            _resultValue.allowSsdp = allowSsdp;
            _resultValue.apIds = apIds;
            _resultValue.appLimit = appLimit;
            _resultValue.appQos = appQos;
            _resultValue.applyTo = applyTo;
            _resultValue.arpFilter = arpFilter;
            _resultValue.auth = auth;
            _resultValue.authServerSelection = authServerSelection;
            _resultValue.authServers = authServers;
            _resultValue.authServersNasId = authServersNasId;
            _resultValue.authServersNasIp = authServersNasIp;
            _resultValue.authServersRetries = authServersRetries;
            _resultValue.authServersTimeout = authServersTimeout;
            _resultValue.bandSteer = bandSteer;
            _resultValue.bandSteerForceBand5 = bandSteerForceBand5;
            _resultValue.bands = bands;
            _resultValue.blockBlacklistClients = blockBlacklistClients;
            _resultValue.bonjour = bonjour;
            _resultValue.ciscoCwa = ciscoCwa;
            _resultValue.clientLimitDown = clientLimitDown;
            _resultValue.clientLimitDownEnabled = clientLimitDownEnabled;
            _resultValue.clientLimitUp = clientLimitUp;
            _resultValue.clientLimitUpEnabled = clientLimitUpEnabled;
            _resultValue.coaServers = coaServers;
            _resultValue.createdTime = createdTime;
            _resultValue.disable11ax = disable11ax;
            _resultValue.disable11be = disable11be;
            _resultValue.disableHtVhtRates = disableHtVhtRates;
            _resultValue.disableUapsd = disableUapsd;
            _resultValue.disableV1RoamNotify = disableV1RoamNotify;
            _resultValue.disableV2RoamNotify = disableV2RoamNotify;
            _resultValue.disableWhenGatewayUnreachable = disableWhenGatewayUnreachable;
            _resultValue.disableWhenMxtunnelDown = disableWhenMxtunnelDown;
            _resultValue.disableWmm = disableWmm;
            _resultValue.dnsServerRewrite = dnsServerRewrite;
            _resultValue.dtim = dtim;
            _resultValue.dynamicPsk = dynamicPsk;
            _resultValue.dynamicVlan = dynamicVlan;
            _resultValue.enableLocalKeycaching = enableLocalKeycaching;
            _resultValue.enableWirelessBridging = enableWirelessBridging;
            _resultValue.enableWirelessBridgingDhcpTracking = enableWirelessBridgingDhcpTracking;
            _resultValue.enabled = enabled;
            _resultValue.fastDot1xTimers = fastDot1xTimers;
            _resultValue.hideSsid = hideSsid;
            _resultValue.hostnameIe = hostnameIe;
            _resultValue.hotspot20 = hotspot20;
            _resultValue.id = id;
            _resultValue.injectDhcpOption82 = injectDhcpOption82;
            _resultValue.interface_ = interface_;
            _resultValue.isolation = isolation;
            _resultValue.l2Isolation = l2Isolation;
            _resultValue.legacyOverds = legacyOverds;
            _resultValue.limitBcast = limitBcast;
            _resultValue.limitProbeResponse = limitProbeResponse;
            _resultValue.maxIdletime = maxIdletime;
            _resultValue.maxNumClients = maxNumClients;
            _resultValue.mistNac = mistNac;
            _resultValue.modifiedTime = modifiedTime;
            _resultValue.mspId = mspId;
            _resultValue.mxtunnelIds = mxtunnelIds;
            _resultValue.mxtunnelNames = mxtunnelNames;
            _resultValue.noStaticDns = noStaticDns;
            _resultValue.noStaticIp = noStaticIp;
            _resultValue.orgId = orgId;
            _resultValue.portal = portal;
            _resultValue.portalAllowedHostnames = portalAllowedHostnames;
            _resultValue.portalAllowedSubnets = portalAllowedSubnets;
            _resultValue.portalApiSecret = portalApiSecret;
            _resultValue.portalDeniedHostnames = portalDeniedHostnames;
            _resultValue.portalImage = portalImage;
            _resultValue.portalSsoUrl = portalSsoUrl;
            _resultValue.qos = qos;
            _resultValue.radsec = radsec;
            _resultValue.rateset = rateset;
            _resultValue.reconnectClientsWhenRoamingMxcluster = reconnectClientsWhenRoamingMxcluster;
            _resultValue.roamMode = roamMode;
            _resultValue.schedule = schedule;
            _resultValue.sleExcluded = sleExcluded;
            _resultValue.ssid = ssid;
            _resultValue.templateId = templateId;
            _resultValue.useEapolV1 = useEapolV1;
            _resultValue.vlanEnabled = vlanEnabled;
            _resultValue.vlanId = vlanId;
            _resultValue.vlanIds = vlanIds;
            _resultValue.vlanPooling = vlanPooling;
            _resultValue.wlanLimitDown = wlanLimitDown;
            _resultValue.wlanLimitDownEnabled = wlanLimitDownEnabled;
            _resultValue.wlanLimitUp = wlanLimitUp;
            _resultValue.wlanLimitUpEnabled = wlanLimitUpEnabled;
            _resultValue.wxtagIds = wxtagIds;
            _resultValue.wxtunnelId = wxtunnelId;
            _resultValue.wxtunnelRemoteId = wxtunnelRemoteId;
            return _resultValue;
        }
    }
}
