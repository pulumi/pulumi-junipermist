// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.site;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.junipermist.Utilities;
import com.pulumi.junipermist.site.WlanArgs;
import com.pulumi.junipermist.site.inputs.WlanState;
import com.pulumi.junipermist.site.outputs.WlanAcctServer;
import com.pulumi.junipermist.site.outputs.WlanAirwatch;
import com.pulumi.junipermist.site.outputs.WlanAppLimit;
import com.pulumi.junipermist.site.outputs.WlanAppQos;
import com.pulumi.junipermist.site.outputs.WlanAuth;
import com.pulumi.junipermist.site.outputs.WlanAuthServer;
import com.pulumi.junipermist.site.outputs.WlanBonjour;
import com.pulumi.junipermist.site.outputs.WlanCiscoCwa;
import com.pulumi.junipermist.site.outputs.WlanCoaServer;
import com.pulumi.junipermist.site.outputs.WlanDnsServerRewrite;
import com.pulumi.junipermist.site.outputs.WlanDynamicPsk;
import com.pulumi.junipermist.site.outputs.WlanDynamicVlan;
import com.pulumi.junipermist.site.outputs.WlanHotspot20;
import com.pulumi.junipermist.site.outputs.WlanInjectDhcpOption82;
import com.pulumi.junipermist.site.outputs.WlanMistNac;
import com.pulumi.junipermist.site.outputs.WlanPortal;
import com.pulumi.junipermist.site.outputs.WlanQos;
import com.pulumi.junipermist.site.outputs.WlanRadsec;
import com.pulumi.junipermist.site.outputs.WlanRateset;
import com.pulumi.junipermist.site.outputs.WlanSchedule;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * This resource manages the Site Wlans.
 * The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)
 * 
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.junipermist.site.Wlan;
 * import com.pulumi.junipermist.site.WlanArgs;
 * import com.pulumi.junipermist.site.inputs.WlanAuthArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var wlanOne = new Wlan("wlanOne", WlanArgs.builder()
 *             .ssid("wlan_one")
 *             .siteId(terraformTest.id())
 *             .bands(            
 *                 "5",
 *                 "6")
 *             .vlanEnabled(true)
 *             .vlanId("143")
 *             .wlanLimitUp("10000")
 *             .wlanLimitDown("20000")
 *             .clientLimitUp("512")
 *             .clientLimitDown("1000")
 *             .auth(WlanAuthArgs.builder()
 *                 .type("psk")
 *                 .psk("secretpsk")
 *                 .build())
 *             .interface_("all")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * Using `pulumi import`, import `mist_site_wlan` with:
 * 
 * Site WLAN can be imported by specifying the site_id and the wlan_id
 * 
 * ```sh
 * $ pulumi import junipermist:site/wlan:Wlan wlan_one 17b46405-3a6d-4715-8bb4-6bb6d06f316a.d3c42998-9012-4859-9743-6b9bee475309
 * ```
 * 
 */
@ResourceType(type="junipermist:site/wlan:Wlan")
public class Wlan extends com.pulumi.resources.CustomResource {
    /**
     * Enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    @Export(name="acctImmediateUpdate", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> acctImmediateUpdate;

    /**
     * @return Enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    public Output<Boolean> acctImmediateUpdate() {
        return this.acctImmediateUpdate;
    }
    /**
     * How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     * 
     */
    @Export(name="acctInterimInterval", refs={Integer.class}, tree="[0]")
    private Output<Integer> acctInterimInterval;

    /**
     * @return How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     * 
     */
    public Output<Integer> acctInterimInterval() {
        return this.acctInterimInterval;
    }
    /**
     * List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    @Export(name="acctServers", refs={List.class,WlanAcctServer.class}, tree="[0,1]")
    private Output<List<WlanAcctServer>> acctServers;

    /**
     * @return List of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    public Output<List<WlanAcctServer>> acctServers() {
        return this.acctServers;
    }
    /**
     * Airwatch wlan settings
     * 
     */
    @Export(name="airwatch", refs={WlanAirwatch.class}, tree="[0]")
    private Output<WlanAirwatch> airwatch;

    /**
     * @return Airwatch wlan settings
     * 
     */
    public Output<WlanAirwatch> airwatch() {
        return this.airwatch;
    }
    /**
     * Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    @Export(name="allowIpv6Ndp", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowIpv6Ndp;

    /**
     * @return Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    public Output<Boolean> allowIpv6Ndp() {
        return this.allowIpv6Ndp;
    }
    /**
     * Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    @Export(name="allowMdns", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowMdns;

    /**
     * @return Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    public Output<Boolean> allowMdns() {
        return this.allowMdns;
    }
    /**
     * Only applicable when `limit_bcast`==`true`, which allows SSDP
     * 
     */
    @Export(name="allowSsdp", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowSsdp;

    /**
     * @return Only applicable when `limit_bcast`==`true`, which allows SSDP
     * 
     */
    public Output<Boolean> allowSsdp() {
        return this.allowSsdp;
    }
    /**
     * List of device ids
     * 
     */
    @Export(name="apIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> apIds;

    /**
     * @return List of device ids
     * 
     */
    public Output<List<String>> apIds() {
        return this.apIds;
    }
    /**
     * Bandwidth limiting for apps (applies to up/down)
     * 
     */
    @Export(name="appLimit", refs={WlanAppLimit.class}, tree="[0]")
    private Output</* @Nullable */ WlanAppLimit> appLimit;

    /**
     * @return Bandwidth limiting for apps (applies to up/down)
     * 
     */
    public Output<Optional<WlanAppLimit>> appLimit() {
        return Codegen.optional(this.appLimit);
    }
    /**
     * APp qos wlan settings
     * 
     */
    @Export(name="appQos", refs={WlanAppQos.class}, tree="[0]")
    private Output<WlanAppQos> appQos;

    /**
     * @return APp qos wlan settings
     * 
     */
    public Output<WlanAppQos> appQos() {
        return this.appQos;
    }
    /**
     * enum: `aps`, `site`, `wxtags`
     * 
     */
    @Export(name="applyTo", refs={String.class}, tree="[0]")
    private Output<String> applyTo;

    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    public Output<String> applyTo() {
        return this.applyTo;
    }
    /**
     * Whether to enable smart arp filter
     * 
     */
    @Export(name="arpFilter", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> arpFilter;

    /**
     * @return Whether to enable smart arp filter
     * 
     */
    public Output<Boolean> arpFilter() {
        return this.arpFilter;
    }
    /**
     * Authentication wlan settings
     * 
     */
    @Export(name="auth", refs={WlanAuth.class}, tree="[0]")
    private Output</* @Nullable */ WlanAuth> auth;

    /**
     * @return Authentication wlan settings
     * 
     */
    public Output<Optional<WlanAuth>> auth() {
        return Codegen.optional(this.auth);
    }
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    @Export(name="authServerSelection", refs={String.class}, tree="[0]")
    private Output<String> authServerSelection;

    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    public Output<String> authServerSelection() {
        return this.authServerSelection;
    }
    /**
     * List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     * 
     */
    @Export(name="authServers", refs={List.class,WlanAuthServer.class}, tree="[0,1]")
    private Output<List<WlanAuthServer>> authServers;

    /**
     * @return List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     * 
     */
    public Output<List<WlanAuthServer>> authServers() {
        return this.authServers;
    }
    /**
     * Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    @Export(name="authServersNasId", refs={String.class}, tree="[0]")
    private Output<String> authServersNasId;

    /**
     * @return Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    public Output<String> authServersNasId() {
        return this.authServersNasId;
    }
    /**
     * Optional, NAS-IP-ADDRESS to use
     * 
     */
    @Export(name="authServersNasIp", refs={String.class}, tree="[0]")
    private Output<String> authServersNasIp;

    /**
     * @return Optional, NAS-IP-ADDRESS to use
     * 
     */
    public Output<String> authServersNasIp() {
        return this.authServersNasIp;
    }
    /**
     * Radius auth session retries. Following fast timers are set if &#34;fast_dot1x_timers&#34; knob is enabled. ‘retries’ are set
     * to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
     * value to 3.
     * 
     */
    @Export(name="authServersRetries", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> authServersRetries;

    /**
     * @return Radius auth session retries. Following fast timers are set if &#34;fast_dot1x_timers&#34; knob is enabled. ‘retries’ are set
     * to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default
     * value to 3.
     * 
     */
    public Output<Optional<Integer>> authServersRetries() {
        return Codegen.optional(this.authServersRetries);
    }
    /**
     * Radius auth session timeout. Following fast timers are set if &#34;fast_dot1x_timers&#34; knob is enabled. ‘quite-period’
     * and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
     * setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    @Export(name="authServersTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> authServersTimeout;

    /**
     * @return Radius auth session timeout. Following fast timers are set if &#34;fast_dot1x_timers&#34; knob is enabled. ‘quite-period’
     * and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when
     * setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    public Output<Optional<Integer>> authServersTimeout() {
        return Codegen.optional(this.authServersTimeout);
    }
    /**
     * Whether to enable band_steering, this works only when band==both
     * 
     */
    @Export(name="bandSteer", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> bandSteer;

    /**
     * @return Whether to enable band_steering, this works only when band==both
     * 
     */
    public Output<Boolean> bandSteer() {
        return this.bandSteer;
    }
    /**
     * Force dual_band capable client to connect to 5G
     * 
     */
    @Export(name="bandSteerForceBand5", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> bandSteerForceBand5;

    /**
     * @return Force dual_band capable client to connect to 5G
     * 
     */
    public Output<Optional<Boolean>> bandSteerForceBand5() {
        return Codegen.optional(this.bandSteerForceBand5);
    }
    /**
     * list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     * 
     */
    @Export(name="bands", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> bands;

    /**
     * @return list of radios that the wlan should apply to. enum: `24`, `5`, `6`
     * 
     */
    public Output<Optional<List<String>>> bands() {
        return Codegen.optional(this.bands);
    }
    /**
     * Whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    @Export(name="blockBlacklistClients", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> blockBlacklistClients;

    /**
     * @return Whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    public Output<Optional<Boolean>> blockBlacklistClients() {
        return Codegen.optional(this.blockBlacklistClients);
    }
    /**
     * Bonjour gateway wlan settings
     * 
     */
    @Export(name="bonjour", refs={WlanBonjour.class}, tree="[0]")
    private Output</* @Nullable */ WlanBonjour> bonjour;

    /**
     * @return Bonjour gateway wlan settings
     * 
     */
    public Output<Optional<WlanBonjour>> bonjour() {
        return Codegen.optional(this.bonjour);
    }
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    @Export(name="ciscoCwa", refs={WlanCiscoCwa.class}, tree="[0]")
    private Output<WlanCiscoCwa> ciscoCwa;

    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    public Output<WlanCiscoCwa> ciscoCwa() {
        return this.ciscoCwa;
    }
    @Export(name="clientLimitDown", refs={String.class}, tree="[0]")
    private Output<String> clientLimitDown;

    public Output<String> clientLimitDown() {
        return this.clientLimitDown;
    }
    /**
     * If downlink limiting per-client is enabled
     * 
     */
    @Export(name="clientLimitDownEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> clientLimitDownEnabled;

    /**
     * @return If downlink limiting per-client is enabled
     * 
     */
    public Output<Optional<Boolean>> clientLimitDownEnabled() {
        return Codegen.optional(this.clientLimitDownEnabled);
    }
    @Export(name="clientLimitUp", refs={String.class}, tree="[0]")
    private Output<String> clientLimitUp;

    public Output<String> clientLimitUp() {
        return this.clientLimitUp;
    }
    /**
     * If uplink limiting per-client is enabled
     * 
     */
    @Export(name="clientLimitUpEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> clientLimitUpEnabled;

    /**
     * @return If uplink limiting per-client is enabled
     * 
     */
    public Output<Optional<Boolean>> clientLimitUpEnabled() {
        return Codegen.optional(this.clientLimitUpEnabled);
    }
    /**
     * List of COA (change of authorization) servers, optional
     * 
     */
    @Export(name="coaServers", refs={List.class,WlanCoaServer.class}, tree="[0,1]")
    private Output</* @Nullable */ List<WlanCoaServer>> coaServers;

    /**
     * @return List of COA (change of authorization) servers, optional
     * 
     */
    public Output<Optional<List<WlanCoaServer>>> coaServers() {
        return Codegen.optional(this.coaServers);
    }
    /**
     * Some old WLAN drivers may not be compatible
     * 
     */
    @Export(name="disable11ax", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disable11ax;

    /**
     * @return Some old WLAN drivers may not be compatible
     * 
     */
    public Output<Boolean> disable11ax() {
        return this.disable11ax;
    }
    /**
     * To disable Wi-Fi 7 EHT IEs
     * 
     */
    @Export(name="disable11be", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disable11be;

    /**
     * @return To disable Wi-Fi 7 EHT IEs
     * 
     */
    public Output<Optional<Boolean>> disable11be() {
        return Codegen.optional(this.disable11be);
    }
    /**
     * To disable ht or vht rates
     * 
     */
    @Export(name="disableHtVhtRates", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableHtVhtRates;

    /**
     * @return To disable ht or vht rates
     * 
     */
    public Output<Optional<Boolean>> disableHtVhtRates() {
        return Codegen.optional(this.disableHtVhtRates);
    }
    /**
     * Whether to disable U-APSD
     * 
     */
    @Export(name="disableUapsd", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableUapsd;

    /**
     * @return Whether to disable U-APSD
     * 
     */
    public Output<Boolean> disableUapsd() {
        return this.disableUapsd;
    }
    /**
     * Disable sending v2 roam notification messages
     * 
     */
    @Export(name="disableV1RoamNotify", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableV1RoamNotify;

    /**
     * @return Disable sending v2 roam notification messages
     * 
     */
    public Output<Optional<Boolean>> disableV1RoamNotify() {
        return Codegen.optional(this.disableV1RoamNotify);
    }
    /**
     * Disable sending v2 roam notification messages
     * 
     */
    @Export(name="disableV2RoamNotify", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableV2RoamNotify;

    /**
     * @return Disable sending v2 roam notification messages
     * 
     */
    public Output<Optional<Boolean>> disableV2RoamNotify() {
        return Codegen.optional(this.disableV2RoamNotify);
    }
    /**
     * When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
     * reach default gateway
     * 
     */
    @Export(name="disableWhenGatewayUnreachable", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableWhenGatewayUnreachable;

    /**
     * @return When any of the following is true, this WLAN will be disabled * cannot get IP * cannot obtain default gateway * cannot
     * reach default gateway
     * 
     */
    public Output<Optional<Boolean>> disableWhenGatewayUnreachable() {
        return Codegen.optional(this.disableWhenGatewayUnreachable);
    }
    @Export(name="disableWhenMxtunnelDown", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disableWhenMxtunnelDown;

    public Output<Optional<Boolean>> disableWhenMxtunnelDown() {
        return Codegen.optional(this.disableWhenMxtunnelDown);
    }
    /**
     * Whether to disable WMM
     * 
     */
    @Export(name="disableWmm", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableWmm;

    /**
     * @return Whether to disable WMM
     * 
     */
    public Output<Boolean> disableWmm() {
        return this.disableWmm;
    }
    /**
     * For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    @Export(name="dnsServerRewrite", refs={WlanDnsServerRewrite.class}, tree="[0]")
    private Output</* @Nullable */ WlanDnsServerRewrite> dnsServerRewrite;

    /**
     * @return For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    public Output<Optional<WlanDnsServerRewrite>> dnsServerRewrite() {
        return Codegen.optional(this.dnsServerRewrite);
    }
    @Export(name="dtim", refs={Integer.class}, tree="[0]")
    private Output<Integer> dtim;

    public Output<Integer> dtim() {
        return this.dtim;
    }
    /**
     * For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
     * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
     * now, wpa3 support on the roadmap)
     * 
     */
    @Export(name="dynamicPsk", refs={WlanDynamicPsk.class}, tree="[0]")
    private Output</* @Nullable */ WlanDynamicPsk> dynamicPsk;

    /**
     * @return For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
     * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
     * now, wpa3 support on the roadmap)
     * 
     */
    public Output<Optional<WlanDynamicPsk>> dynamicPsk() {
        return Codegen.optional(this.dynamicPsk);
    }
    /**
     * For 802.1x
     * 
     */
    @Export(name="dynamicVlan", refs={WlanDynamicVlan.class}, tree="[0]")
    private Output</* @Nullable */ WlanDynamicVlan> dynamicVlan;

    /**
     * @return For 802.1x
     * 
     */
    public Output<Optional<WlanDynamicVlan>> dynamicVlan() {
        return Codegen.optional(this.dynamicVlan);
    }
    /**
     * Enable AP-AP keycaching via multicast
     * 
     */
    @Export(name="enableLocalKeycaching", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableLocalKeycaching;

    /**
     * @return Enable AP-AP keycaching via multicast
     * 
     */
    public Output<Optional<Boolean>> enableLocalKeycaching() {
        return Codegen.optional(this.enableLocalKeycaching);
    }
    /**
     * By default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
     * 
     */
    @Export(name="enableWirelessBridging", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableWirelessBridging;

    /**
     * @return By default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be forwarded), wireless_bridging can be enabled
     * 
     */
    public Output<Optional<Boolean>> enableWirelessBridging() {
        return Codegen.optional(this.enableWirelessBridging);
    }
    /**
     * If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
     * packets to be forwarded to wireless
     * 
     */
    @Export(name="enableWirelessBridgingDhcpTracking", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableWirelessBridgingDhcpTracking;

    /**
     * @return If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
     * packets to be forwarded to wireless
     * 
     */
    public Output<Optional<Boolean>> enableWirelessBridgingDhcpTracking() {
        return Codegen.optional(this.enableWirelessBridgingDhcpTracking);
    }
    /**
     * If this wlan is enabled
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enabled;

    /**
     * @return If this wlan is enabled
     * 
     */
    public Output<Boolean> enabled() {
        return this.enabled;
    }
    /**
     * If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     * 
     */
    @Export(name="fastDot1xTimers", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> fastDot1xTimers;

    /**
     * @return If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     * 
     */
    public Output<Optional<Boolean>> fastDot1xTimers() {
        return Codegen.optional(this.fastDot1xTimers);
    }
    /**
     * Whether to hide SSID in beacon
     * 
     */
    @Export(name="hideSsid", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> hideSsid;

    /**
     * @return Whether to hide SSID in beacon
     * 
     */
    public Output<Boolean> hideSsid() {
        return this.hideSsid;
    }
    /**
     * Include hostname inside IE in AP beacons / probe responses
     * 
     */
    @Export(name="hostnameIe", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> hostnameIe;

    /**
     * @return Include hostname inside IE in AP beacons / probe responses
     * 
     */
    public Output<Boolean> hostnameIe() {
        return this.hostnameIe;
    }
    /**
     * Hostspot 2.0 wlan settings
     * 
     */
    @Export(name="hotspot20", refs={WlanHotspot20.class}, tree="[0]")
    private Output</* @Nullable */ WlanHotspot20> hotspot20;

    /**
     * @return Hostspot 2.0 wlan settings
     * 
     */
    public Output<Optional<WlanHotspot20>> hotspot20() {
        return Codegen.optional(this.hotspot20);
    }
    @Export(name="injectDhcpOption82", refs={WlanInjectDhcpOption82.class}, tree="[0]")
    private Output</* @Nullable */ WlanInjectDhcpOption82> injectDhcpOption82;

    public Output<Optional<WlanInjectDhcpOption82>> injectDhcpOption82() {
        return Codegen.optional(this.injectDhcpOption82);
    }
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    @Export(name="interface", refs={String.class}, tree="[0]")
    private Output<String> interface_;

    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    public Output<String> interface_() {
        return this.interface_;
    }
    /**
     * Whether to stop clients to talk to each other
     * 
     */
    @Export(name="isolation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> isolation;

    /**
     * @return Whether to stop clients to talk to each other
     * 
     */
    public Output<Optional<Boolean>> isolation() {
        return Codegen.optional(this.isolation);
    }
    /**
     * If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    @Export(name="l2Isolation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> l2Isolation;

    /**
     * @return If isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    public Output<Optional<Boolean>> l2Isolation() {
        return Codegen.optional(this.l2Isolation);
    }
    /**
     * Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     * 
     */
    @Export(name="legacyOverds", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> legacyOverds;

    /**
     * @return Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     * 
     */
    public Output<Optional<Boolean>> legacyOverds() {
        return Codegen.optional(this.legacyOverds);
    }
    /**
     * Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    @Export(name="limitBcast", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> limitBcast;

    /**
     * @return Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    public Output<Boolean> limitBcast() {
        return this.limitBcast;
    }
    /**
     * Limit probe response base on some heuristic rules
     * 
     */
    @Export(name="limitProbeResponse", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> limitProbeResponse;

    /**
     * @return Limit probe response base on some heuristic rules
     * 
     */
    public Output<Boolean> limitProbeResponse() {
        return this.limitProbeResponse;
    }
    /**
     * Max idle time in seconds
     * 
     */
    @Export(name="maxIdletime", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxIdletime;

    /**
     * @return Max idle time in seconds
     * 
     */
    public Output<Integer> maxIdletime() {
        return this.maxIdletime;
    }
    /**
     * Maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    @Export(name="maxNumClients", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> maxNumClients;

    /**
     * @return Maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    public Output<Optional<Integer>> maxNumClients() {
        return Codegen.optional(this.maxNumClients);
    }
    @Export(name="mistNac", refs={WlanMistNac.class}, tree="[0]")
    private Output<WlanMistNac> mistNac;

    public Output<WlanMistNac> mistNac() {
        return this.mistNac;
    }
    @Export(name="mspId", refs={String.class}, tree="[0]")
    private Output<String> mspId;

    public Output<String> mspId() {
        return this.mspId;
    }
    /**
     * When `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    @Export(name="mxtunnelIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> mxtunnelIds;

    /**
     * @return When `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    public Output<List<String>> mxtunnelIds() {
        return this.mxtunnelIds;
    }
    /**
     * When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    @Export(name="mxtunnelNames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> mxtunnelNames;

    /**
     * @return When `interface`=`site_mxedge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    public Output<List<String>> mxtunnelNames() {
        return this.mxtunnelNames;
    }
    /**
     * Whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    @Export(name="noStaticDns", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> noStaticDns;

    /**
     * @return Whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    public Output<Boolean> noStaticDns() {
        return this.noStaticDns;
    }
    /**
     * Whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    @Export(name="noStaticIp", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> noStaticIp;

    /**
     * @return Whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    public Output<Boolean> noStaticIp() {
        return this.noStaticIp;
    }
    @Export(name="orgId", refs={String.class}, tree="[0]")
    private Output<String> orgId;

    public Output<String> orgId() {
        return this.orgId;
    }
    /**
     * Portal wlan settings
     * 
     */
    @Export(name="portal", refs={WlanPortal.class}, tree="[0]")
    private Output<WlanPortal> portal;

    /**
     * @return Portal wlan settings
     * 
     */
    public Output<WlanPortal> portal() {
        return this.portal;
    }
    /**
     * List of hostnames without http(s):// (matched by substring)
     * 
     */
    @Export(name="portalAllowedHostnames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> portalAllowedHostnames;

    /**
     * @return List of hostnames without http(s):// (matched by substring)
     * 
     */
    public Output<List<String>> portalAllowedHostnames() {
        return this.portalAllowedHostnames;
    }
    /**
     * List of CIDRs
     * 
     */
    @Export(name="portalAllowedSubnets", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> portalAllowedSubnets;

    /**
     * @return List of CIDRs
     * 
     */
    public Output<List<String>> portalAllowedSubnets() {
        return this.portalAllowedSubnets;
    }
    /**
     * APi secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    @Export(name="portalApiSecret", refs={String.class}, tree="[0]")
    private Output<String> portalApiSecret;

    /**
     * @return APi secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    public Output<String> portalApiSecret() {
        return this.portalApiSecret;
    }
    /**
     * List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    @Export(name="portalDeniedHostnames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> portalDeniedHostnames;

    /**
     * @return List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    public Output<List<String>> portalDeniedHostnames() {
        return this.portalDeniedHostnames;
    }
    /**
     * Url of portal background image
     * 
     */
    @Export(name="portalImage", refs={String.class}, tree="[0]")
    private Output<String> portalImage;

    /**
     * @return Url of portal background image
     * 
     */
    public Output<String> portalImage() {
        return this.portalImage;
    }
    @Export(name="portalSsoUrl", refs={String.class}, tree="[0]")
    private Output<String> portalSsoUrl;

    public Output<String> portalSsoUrl() {
        return this.portalSsoUrl;
    }
    @Export(name="qos", refs={WlanQos.class}, tree="[0]")
    private Output<WlanQos> qos;

    public Output<WlanQos> qos() {
        return this.qos;
    }
    /**
     * RadSec settings
     * 
     */
    @Export(name="radsec", refs={WlanRadsec.class}, tree="[0]")
    private Output<WlanRadsec> radsec;

    /**
     * @return RadSec settings
     * 
     */
    public Output<WlanRadsec> radsec() {
        return this.radsec;
    }
    /**
     * Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    @Export(name="rateset", refs={Map.class,String.class,WlanRateset.class}, tree="[0,1,2]")
    private Output<Map<String,WlanRateset>> rateset;

    /**
     * @return Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    public Output<Map<String,WlanRateset>> rateset() {
        return this.rateset;
    }
    /**
     * When different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    @Export(name="reconnectClientsWhenRoamingMxcluster", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> reconnectClientsWhenRoamingMxcluster;

    /**
     * @return When different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    public Output<Optional<Boolean>> reconnectClientsWhenRoamingMxcluster() {
        return Codegen.optional(this.reconnectClientsWhenRoamingMxcluster);
    }
    /**
     * enum: `11r`, `OKC`, `NONE`
     * 
     */
    @Export(name="roamMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> roamMode;

    /**
     * @return enum: `11r`, `OKC`, `NONE`
     * 
     */
    public Output<Optional<String>> roamMode() {
        return Codegen.optional(this.roamMode);
    }
    /**
     * WLAN operating schedule, default is disabled
     * 
     */
    @Export(name="schedule", refs={WlanSchedule.class}, tree="[0]")
    private Output<WlanSchedule> schedule;

    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    public Output<WlanSchedule> schedule() {
        return this.schedule;
    }
    @Export(name="siteId", refs={String.class}, tree="[0]")
    private Output<String> siteId;

    public Output<String> siteId() {
        return this.siteId;
    }
    /**
     * Whether to exclude this WLAN from SLE metrics
     * 
     */
    @Export(name="sleExcluded", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> sleExcluded;

    /**
     * @return Whether to exclude this WLAN from SLE metrics
     * 
     */
    public Output<Optional<Boolean>> sleExcluded() {
        return Codegen.optional(this.sleExcluded);
    }
    /**
     * Name of the SSID
     * 
     */
    @Export(name="ssid", refs={String.class}, tree="[0]")
    private Output<String> ssid;

    /**
     * @return Name of the SSID
     * 
     */
    public Output<String> ssid() {
        return this.ssid;
    }
    /**
     * If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    @Export(name="useEapolV1", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> useEapolV1;

    /**
     * @return If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    public Output<Boolean> useEapolV1() {
        return this.useEapolV1;
    }
    /**
     * If vlan tagging is enabled
     * 
     */
    @Export(name="vlanEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> vlanEnabled;

    /**
     * @return If vlan tagging is enabled
     * 
     */
    public Output<Boolean> vlanEnabled() {
        return this.vlanEnabled;
    }
    @Export(name="vlanId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> vlanId;

    public Output<Optional<String>> vlanId() {
        return Codegen.optional(this.vlanId);
    }
    /**
     * if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     * 
     */
    @Export(name="vlanIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> vlanIds;

    /**
     * @return if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separated) to be used in the VLAN Pool
     * 
     */
    public Output<List<String>> vlanIds() {
        return this.vlanIds;
    }
    /**
     * Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
     * deterministic algorithm
     * 
     */
    @Export(name="vlanPooling", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> vlanPooling;

    /**
     * @return Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a
     * deterministic algorithm
     * 
     */
    public Output<Boolean> vlanPooling() {
        return this.vlanPooling;
    }
    @Export(name="wlanLimitDown", refs={String.class}, tree="[0]")
    private Output<String> wlanLimitDown;

    public Output<String> wlanLimitDown() {
        return this.wlanLimitDown;
    }
    /**
     * If downlink limiting for whole wlan is enabled
     * 
     */
    @Export(name="wlanLimitDownEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> wlanLimitDownEnabled;

    /**
     * @return If downlink limiting for whole wlan is enabled
     * 
     */
    public Output<Optional<Boolean>> wlanLimitDownEnabled() {
        return Codegen.optional(this.wlanLimitDownEnabled);
    }
    @Export(name="wlanLimitUp", refs={String.class}, tree="[0]")
    private Output<String> wlanLimitUp;

    public Output<String> wlanLimitUp() {
        return this.wlanLimitUp;
    }
    /**
     * If uplink limiting for whole wlan is enabled
     * 
     */
    @Export(name="wlanLimitUpEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> wlanLimitUpEnabled;

    /**
     * @return If uplink limiting for whole wlan is enabled
     * 
     */
    public Output<Optional<Boolean>> wlanLimitUpEnabled() {
        return Codegen.optional(this.wlanLimitUpEnabled);
    }
    /**
     * List of wxtag_ids
     * 
     */
    @Export(name="wxtagIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> wxtagIds;

    /**
     * @return List of wxtag_ids
     * 
     */
    public Output<List<String>> wxtagIds() {
        return this.wxtagIds;
    }
    /**
     * When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    @Export(name="wxtunnelId", refs={String.class}, tree="[0]")
    private Output<String> wxtunnelId;

    /**
     * @return When `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    public Output<String> wxtunnelId() {
        return this.wxtunnelId;
    }
    /**
     * When `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    @Export(name="wxtunnelRemoteId", refs={String.class}, tree="[0]")
    private Output<String> wxtunnelRemoteId;

    /**
     * @return When `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    public Output<String> wxtunnelRemoteId() {
        return this.wxtunnelRemoteId;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Wlan(java.lang.String name) {
        this(name, WlanArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Wlan(java.lang.String name, WlanArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Wlan(java.lang.String name, WlanArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("junipermist:site/wlan:Wlan", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Wlan(java.lang.String name, Output<java.lang.String> id, @Nullable WlanState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("junipermist:site/wlan:Wlan", name, state, makeResourceOptions(options, id), false);
    }

    private static WlanArgs makeArgs(WlanArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? WlanArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .pluginDownloadURL("github://api.github.com/pulumi/pulumi-junipermist")
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Wlan get(java.lang.String name, Output<java.lang.String> id, @Nullable WlanState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Wlan(name, id, state, options);
    }
}
