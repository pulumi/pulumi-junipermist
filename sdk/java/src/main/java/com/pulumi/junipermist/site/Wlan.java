// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.site;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.junipermist.Utilities;
import com.pulumi.junipermist.site.WlanArgs;
import com.pulumi.junipermist.site.inputs.WlanState;
import com.pulumi.junipermist.site.outputs.WlanAcctServer;
import com.pulumi.junipermist.site.outputs.WlanAirwatch;
import com.pulumi.junipermist.site.outputs.WlanAppLimit;
import com.pulumi.junipermist.site.outputs.WlanAppQos;
import com.pulumi.junipermist.site.outputs.WlanAuth;
import com.pulumi.junipermist.site.outputs.WlanAuthServer;
import com.pulumi.junipermist.site.outputs.WlanBonjour;
import com.pulumi.junipermist.site.outputs.WlanCiscoCwa;
import com.pulumi.junipermist.site.outputs.WlanCoaServer;
import com.pulumi.junipermist.site.outputs.WlanDnsServerRewrite;
import com.pulumi.junipermist.site.outputs.WlanDynamicPsk;
import com.pulumi.junipermist.site.outputs.WlanDynamicVlan;
import com.pulumi.junipermist.site.outputs.WlanHotspot20;
import com.pulumi.junipermist.site.outputs.WlanInjectDhcpOption82;
import com.pulumi.junipermist.site.outputs.WlanMistNac;
import com.pulumi.junipermist.site.outputs.WlanPortal;
import com.pulumi.junipermist.site.outputs.WlanQos;
import com.pulumi.junipermist.site.outputs.WlanRadsec;
import com.pulumi.junipermist.site.outputs.WlanSchedule;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * This resource manages the Site Wlans.The WLAN object contains all the required configuration to broadcast an SSID (Authentication, VLAN, ...)
 * 
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.junipermist.site.Wlan;
 * import com.pulumi.junipermist.site.WlanArgs;
 * import com.pulumi.junipermist.site.inputs.WlanAuthArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var wlanOne = new Wlan("wlanOne", WlanArgs.builder()
 *             .ssid("wlan_one")
 *             .siteId(terraformTest.id())
 *             .bands(            
 *                 "5",
 *                 "6")
 *             .vlanId(143)
 *             .wlanLimitUp(10000)
 *             .wlanLimitDown(20000)
 *             .clientLimitUp(512)
 *             .clientLimitDown(1000)
 *             .auth(WlanAuthArgs.builder()
 *                 .type("psk")
 *                 .psk("secretpsk")
 *                 .build())
 *             .interface_("all")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 */
@ResourceType(type="junipermist:site/wlan:Wlan")
public class Wlan extends com.pulumi.resources.CustomResource {
    /**
     * enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    @Export(name="acctImmediateUpdate", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> acctImmediateUpdate;

    /**
     * @return enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    public Output<Boolean> acctImmediateUpdate() {
        return this.acctImmediateUpdate;
    }
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     * 
     */
    @Export(name="acctInterimInterval", refs={Integer.class}, tree="[0]")
    private Output<Integer> acctInterimInterval;

    /**
     * @return how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request
     * from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended
     * when enabled
     * 
     */
    public Output<Integer> acctInterimInterval() {
        return this.acctInterimInterval;
    }
    /**
     * list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    @Export(name="acctServers", refs={List.class,WlanAcctServer.class}, tree="[0,1]")
    private Output<List<WlanAcctServer>> acctServers;

    /**
     * @return list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    public Output<List<WlanAcctServer>> acctServers() {
        return this.acctServers;
    }
    /**
     * airwatch wlan settings
     * 
     */
    @Export(name="airwatch", refs={WlanAirwatch.class}, tree="[0]")
    private Output</* @Nullable */ WlanAirwatch> airwatch;

    /**
     * @return airwatch wlan settings
     * 
     */
    public Output<Optional<WlanAirwatch>> airwatch() {
        return Codegen.optional(this.airwatch);
    }
    /**
     * only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    @Export(name="allowIpv6Ndp", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowIpv6Ndp;

    /**
     * @return only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    public Output<Boolean> allowIpv6Ndp() {
        return this.allowIpv6Ndp;
    }
    /**
     * only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    @Export(name="allowMdns", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowMdns;

    /**
     * @return only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    public Output<Boolean> allowMdns() {
        return this.allowMdns;
    }
    /**
     * only applicable when `limit_bcast`==`tru`e, which allows SSDP
     * 
     */
    @Export(name="allowSsdp", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowSsdp;

    /**
     * @return only applicable when `limit_bcast`==`tru`e, which allows SSDP
     * 
     */
    public Output<Boolean> allowSsdp() {
        return this.allowSsdp;
    }
    /**
     * list of device ids
     * 
     */
    @Export(name="apIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> apIds;

    /**
     * @return list of device ids
     * 
     */
    public Output<List<String>> apIds() {
        return this.apIds;
    }
    /**
     * bandwidth limiting for apps (applies to up/down)
     * 
     */
    @Export(name="appLimit", refs={WlanAppLimit.class}, tree="[0]")
    private Output</* @Nullable */ WlanAppLimit> appLimit;

    /**
     * @return bandwidth limiting for apps (applies to up/down)
     * 
     */
    public Output<Optional<WlanAppLimit>> appLimit() {
        return Codegen.optional(this.appLimit);
    }
    /**
     * app qos wlan settings
     * 
     */
    @Export(name="appQos", refs={WlanAppQos.class}, tree="[0]")
    private Output</* @Nullable */ WlanAppQos> appQos;

    /**
     * @return app qos wlan settings
     * 
     */
    public Output<Optional<WlanAppQos>> appQos() {
        return Codegen.optional(this.appQos);
    }
    /**
     * enum: `aps`, `site`, `wxtags`
     * 
     */
    @Export(name="applyTo", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> applyTo;

    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    public Output<Optional<String>> applyTo() {
        return Codegen.optional(this.applyTo);
    }
    /**
     * whether to enable smart arp filter
     * 
     */
    @Export(name="arpFilter", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> arpFilter;

    /**
     * @return whether to enable smart arp filter
     * 
     */
    public Output<Boolean> arpFilter() {
        return this.arpFilter;
    }
    /**
     * authentication wlan settings
     * 
     */
    @Export(name="auth", refs={WlanAuth.class}, tree="[0]")
    private Output</* @Nullable */ WlanAuth> auth;

    /**
     * @return authentication wlan settings
     * 
     */
    public Output<Optional<WlanAuth>> auth() {
        return Codegen.optional(this.auth);
    }
    /**
     * When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    @Export(name="authServerSelection", refs={String.class}, tree="[0]")
    private Output<String> authServerSelection;

    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    public Output<String> authServerSelection() {
        return this.authServerSelection;
    }
    /**
     * list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     * 
     */
    @Export(name="authServers", refs={List.class,WlanAuthServer.class}, tree="[0,1]")
    private Output<List<WlanAuthServer>> authServers;

    /**
     * @return list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one
     * is treated as primary
     * 
     */
    public Output<List<WlanAuthServer>> authServers() {
        return this.authServers;
    }
    /**
     * optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    @Export(name="authServersNasId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> authServersNasId;

    /**
     * @return optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    public Output<Optional<String>> authServersNasId() {
        return Codegen.optional(this.authServersNasId);
    }
    /**
     * optional, NAS-IP-ADDRESS to use
     * 
     */
    @Export(name="authServersNasIp", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> authServersNasIp;

    /**
     * @return optional, NAS-IP-ADDRESS to use
     * 
     */
    public Output<Optional<String>> authServersNasIp() {
        return Codegen.optional(this.authServersNasIp);
    }
    /**
     * radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
     * default value to 3.
     * 
     */
    @Export(name="authServersRetries", refs={Integer.class}, tree="[0]")
    private Output<Integer> authServersRetries;

    /**
     * @return radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’ are
     * set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to
     * default value to 3.
     * 
     */
    public Output<Integer> authServersRetries() {
        return this.authServersRetries;
    }
    /**
     * radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    @Export(name="authServersTimeout", refs={Integer.class}, tree="[0]")
    private Output<Integer> authServersTimeout;

    /**
     * @return radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled.
     * ‘quite-period’ and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’
     * is also set when setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    public Output<Integer> authServersTimeout() {
        return this.authServersTimeout;
    }
    /**
     * whether to enable band_steering, this works only when band==both
     * 
     */
    @Export(name="bandSteer", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> bandSteer;

    /**
     * @return whether to enable band_steering, this works only when band==both
     * 
     */
    public Output<Boolean> bandSteer() {
        return this.bandSteer;
    }
    /**
     * force dual_band capable client to connect to 5G
     * 
     */
    @Export(name="bandSteerForceBand5", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> bandSteerForceBand5;

    /**
     * @return force dual_band capable client to connect to 5G
     * 
     */
    public Output<Boolean> bandSteerForceBand5() {
        return this.bandSteerForceBand5;
    }
    /**
     * list of radios that the wlan should apply to
     * 
     */
    @Export(name="bands", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> bands;

    /**
     * @return list of radios that the wlan should apply to
     * 
     */
    public Output<Optional<List<String>>> bands() {
        return Codegen.optional(this.bands);
    }
    /**
     * whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    @Export(name="blockBlacklistClients", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> blockBlacklistClients;

    /**
     * @return whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    public Output<Boolean> blockBlacklistClients() {
        return this.blockBlacklistClients;
    }
    /**
     * bonjour gateway wlan settings
     * 
     */
    @Export(name="bonjour", refs={WlanBonjour.class}, tree="[0]")
    private Output</* @Nullable */ WlanBonjour> bonjour;

    /**
     * @return bonjour gateway wlan settings
     * 
     */
    public Output<Optional<WlanBonjour>> bonjour() {
        return Codegen.optional(this.bonjour);
    }
    /**
     * Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    @Export(name="ciscoCwa", refs={WlanCiscoCwa.class}, tree="[0]")
    private Output</* @Nullable */ WlanCiscoCwa> ciscoCwa;

    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA:
     * https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    public Output<Optional<WlanCiscoCwa>> ciscoCwa() {
        return Codegen.optional(this.ciscoCwa);
    }
    /**
     * kbps
     * 
     */
    @Export(name="clientLimitDown", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> clientLimitDown;

    /**
     * @return kbps
     * 
     */
    public Output<Optional<Integer>> clientLimitDown() {
        return Codegen.optional(this.clientLimitDown);
    }
    /**
     * if downlink limiting per-client is enabled
     * 
     */
    @Export(name="clientLimitDownEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> clientLimitDownEnabled;

    /**
     * @return if downlink limiting per-client is enabled
     * 
     */
    public Output<Boolean> clientLimitDownEnabled() {
        return this.clientLimitDownEnabled;
    }
    /**
     * kbps
     * 
     */
    @Export(name="clientLimitUp", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> clientLimitUp;

    /**
     * @return kbps
     * 
     */
    public Output<Optional<Integer>> clientLimitUp() {
        return Codegen.optional(this.clientLimitUp);
    }
    /**
     * if uplink limiting per-client is enabled
     * 
     */
    @Export(name="clientLimitUpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> clientLimitUpEnabled;

    /**
     * @return if uplink limiting per-client is enabled
     * 
     */
    public Output<Boolean> clientLimitUpEnabled() {
        return this.clientLimitUpEnabled;
    }
    /**
     * list of COA (change of authorization) servers, optional
     * 
     */
    @Export(name="coaServers", refs={List.class,WlanCoaServer.class}, tree="[0,1]")
    private Output<List<WlanCoaServer>> coaServers;

    /**
     * @return list of COA (change of authorization) servers, optional
     * 
     */
    public Output<List<WlanCoaServer>> coaServers() {
        return this.coaServers;
    }
    /**
     * some old WLAN drivers may not be compatible
     * 
     */
    @Export(name="disable11ax", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disable11ax;

    /**
     * @return some old WLAN drivers may not be compatible
     * 
     */
    public Output<Boolean> disable11ax() {
        return this.disable11ax;
    }
    /**
     * to disable ht or vht rates
     * 
     */
    @Export(name="disableHtVhtRates", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableHtVhtRates;

    /**
     * @return to disable ht or vht rates
     * 
     */
    public Output<Boolean> disableHtVhtRates() {
        return this.disableHtVhtRates;
    }
    /**
     * whether to disable U-APSD
     * 
     */
    @Export(name="disableUapsd", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableUapsd;

    /**
     * @return whether to disable U-APSD
     * 
     */
    public Output<Boolean> disableUapsd() {
        return this.disableUapsd;
    }
    /**
     * disable sending v2 roam notification messages
     * 
     */
    @Export(name="disableV1RoamNotify", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableV1RoamNotify;

    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    public Output<Boolean> disableV1RoamNotify() {
        return this.disableV1RoamNotify;
    }
    /**
     * disable sending v2 roam notification messages
     * 
     */
    @Export(name="disableV2RoamNotify", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableV2RoamNotify;

    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    public Output<Boolean> disableV2RoamNotify() {
        return this.disableV2RoamNotify;
    }
    /**
     * whether to disable WMM
     * 
     */
    @Export(name="disableWmm", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> disableWmm;

    /**
     * @return whether to disable WMM
     * 
     */
    public Output<Boolean> disableWmm() {
        return this.disableWmm;
    }
    /**
     * for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    @Export(name="dnsServerRewrite", refs={WlanDnsServerRewrite.class}, tree="[0]")
    private Output</* @Nullable */ WlanDnsServerRewrite> dnsServerRewrite;

    /**
     * @return for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    public Output<Optional<WlanDnsServerRewrite>> dnsServerRewrite() {
        return Codegen.optional(this.dnsServerRewrite);
    }
    @Export(name="dtim", refs={Integer.class}, tree="[0]")
    private Output<Integer> dtim;

    public Output<Integer> dtim() {
        return this.dtim;
    }
    /**
     * for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
     * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
     * now, wpa3 support on the roadmap)
     * 
     */
    @Export(name="dynamicPsk", refs={WlanDynamicPsk.class}, tree="[0]")
    private Output</* @Nullable */ WlanDynamicPsk> dynamicPsk;

    /**
     * @return for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on
     * context (wlan/site/user/...) thus following configurations are assumed (currently) * PSK will come from RADIUS server *
     * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed) * AP sends BSSID:SSID as
     * Caller-Station-ID * `auth_servers` is required * PSK will come from cloud WLC if source is cloud_psks * default_psk will
     * be used if cloud WLC is not available * `multi_psk_only` and `psk` is ignored * `pairwise` can only be wpa2-ccmp (for
     * now, wpa3 support on the roadmap)
     * 
     */
    public Output<Optional<WlanDynamicPsk>> dynamicPsk() {
        return Codegen.optional(this.dynamicPsk);
    }
    /**
     * for 802.1x
     * 
     */
    @Export(name="dynamicVlan", refs={WlanDynamicVlan.class}, tree="[0]")
    private Output</* @Nullable */ WlanDynamicVlan> dynamicVlan;

    /**
     * @return for 802.1x
     * 
     */
    public Output<Optional<WlanDynamicVlan>> dynamicVlan() {
        return Codegen.optional(this.dynamicVlan);
    }
    /**
     * enable AP-AP keycaching via multicast
     * 
     */
    @Export(name="enableLocalKeycaching", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableLocalKeycaching;

    /**
     * @return enable AP-AP keycaching via multicast
     * 
     */
    public Output<Boolean> enableLocalKeycaching() {
        return this.enableLocalKeycaching;
    }
    /**
     * by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
     * 
     */
    @Export(name="enableWirelessBridging", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableWirelessBridging;

    /**
     * @return by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where
     * client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
     * 
     */
    public Output<Boolean> enableWirelessBridging() {
        return this.enableWirelessBridging;
    }
    /**
     * if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
     * packets to be forwarded to wireless
     * 
     */
    @Export(name="enableWirelessBridgingDhcpTracking", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableWirelessBridgingDhcpTracking;

    /**
     * @return if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response
     * packets to be forwarded to wireless
     * 
     */
    public Output<Boolean> enableWirelessBridgingDhcpTracking() {
        return this.enableWirelessBridgingDhcpTracking;
    }
    /**
     * if this wlan is enabled
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enabled;

    /**
     * @return if this wlan is enabled
     * 
     */
    public Output<Boolean> enabled() {
        return this.enabled;
    }
    /**
     * if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     * 
     */
    @Export(name="fastDot1xTimers", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> fastDot1xTimers;

    /**
     * @return if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and
     * ‘auth_server_retries’ .
     * 
     */
    public Output<Boolean> fastDot1xTimers() {
        return this.fastDot1xTimers;
    }
    /**
     * whether to hide SSID in beacon
     * 
     */
    @Export(name="hideSsid", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> hideSsid;

    /**
     * @return whether to hide SSID in beacon
     * 
     */
    public Output<Boolean> hideSsid() {
        return this.hideSsid;
    }
    /**
     * include hostname inside IE in AP beacons / probe responses
     * 
     */
    @Export(name="hostnameIe", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> hostnameIe;

    /**
     * @return include hostname inside IE in AP beacons / probe responses
     * 
     */
    public Output<Boolean> hostnameIe() {
        return this.hostnameIe;
    }
    /**
     * hostspot 2.0 wlan settings
     * 
     */
    @Export(name="hotspot20", refs={WlanHotspot20.class}, tree="[0]")
    private Output</* @Nullable */ WlanHotspot20> hotspot20;

    /**
     * @return hostspot 2.0 wlan settings
     * 
     */
    public Output<Optional<WlanHotspot20>> hotspot20() {
        return Codegen.optional(this.hotspot20);
    }
    @Export(name="injectDhcpOption82", refs={WlanInjectDhcpOption82.class}, tree="[0]")
    private Output</* @Nullable */ WlanInjectDhcpOption82> injectDhcpOption82;

    public Output<Optional<WlanInjectDhcpOption82>> injectDhcpOption82() {
        return Codegen.optional(this.injectDhcpOption82);
    }
    /**
     * where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    @Export(name="interface", refs={String.class}, tree="[0]")
    private Output<String> interface_;

    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    public Output<String> interface_() {
        return this.interface_;
    }
    /**
     * whether to stop clients to talk to each other
     * 
     */
    @Export(name="isolation", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isolation;

    /**
     * @return whether to stop clients to talk to each other
     * 
     */
    public Output<Boolean> isolation() {
        return this.isolation;
    }
    /**
     * if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    @Export(name="l2Isolation", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> l2Isolation;

    /**
     * @return if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    public Output<Boolean> l2Isolation() {
        return this.l2Isolation;
    }
    /**
     * legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     * 
     */
    @Export(name="legacyOverds", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> legacyOverds;

    /**
     * @return legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning!
     * Enabling this will cause problem for iOS devices.
     * 
     */
    public Output<Boolean> legacyOverds() {
        return this.legacyOverds;
    }
    /**
     * whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    @Export(name="limitBcast", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> limitBcast;

    /**
     * @return whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    public Output<Boolean> limitBcast() {
        return this.limitBcast;
    }
    /**
     * limit probe response base on some heuristic rules
     * 
     */
    @Export(name="limitProbeResponse", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> limitProbeResponse;

    /**
     * @return limit probe response base on some heuristic rules
     * 
     */
    public Output<Boolean> limitProbeResponse() {
        return this.limitProbeResponse;
    }
    /**
     * max idle time in seconds
     * 
     */
    @Export(name="maxIdletime", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxIdletime;

    /**
     * @return max idle time in seconds
     * 
     */
    public Output<Integer> maxIdletime() {
        return this.maxIdletime;
    }
    @Export(name="mistNac", refs={WlanMistNac.class}, tree="[0]")
    private Output</* @Nullable */ WlanMistNac> mistNac;

    public Output<Optional<WlanMistNac>> mistNac() {
        return Codegen.optional(this.mistNac);
    }
    @Export(name="mspId", refs={String.class}, tree="[0]")
    private Output<String> mspId;

    public Output<String> mspId() {
        return this.mspId;
    }
    /**
     * when `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    @Export(name="mxtunnelIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> mxtunnelIds;

    /**
     * @return when `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    public Output<List<String>> mxtunnelIds() {
        return this.mxtunnelIds;
    }
    /**
     * when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    @Export(name="mxtunnelNames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> mxtunnelNames;

    /**
     * @return when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    public Output<List<String>> mxtunnelNames() {
        return this.mxtunnelNames;
    }
    /**
     * whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    @Export(name="noStaticDns", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> noStaticDns;

    /**
     * @return whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    public Output<Boolean> noStaticDns() {
        return this.noStaticDns;
    }
    /**
     * whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    @Export(name="noStaticIp", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> noStaticIp;

    /**
     * @return whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    public Output<Boolean> noStaticIp() {
        return this.noStaticIp;
    }
    @Export(name="orgId", refs={String.class}, tree="[0]")
    private Output<String> orgId;

    public Output<String> orgId() {
        return this.orgId;
    }
    /**
     * portal wlan settings
     * 
     */
    @Export(name="portal", refs={WlanPortal.class}, tree="[0]")
    private Output</* @Nullable */ WlanPortal> portal;

    /**
     * @return portal wlan settings
     * 
     */
    public Output<Optional<WlanPortal>> portal() {
        return Codegen.optional(this.portal);
    }
    /**
     * list of hostnames without http(s):// (matched by substring)
     * 
     */
    @Export(name="portalAllowedHostnames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> portalAllowedHostnames;

    /**
     * @return list of hostnames without http(s):// (matched by substring)
     * 
     */
    public Output<List<String>> portalAllowedHostnames() {
        return this.portalAllowedHostnames;
    }
    /**
     * list of CIDRs
     * 
     */
    @Export(name="portalAllowedSubnets", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> portalAllowedSubnets;

    /**
     * @return list of CIDRs
     * 
     */
    public Output<List<String>> portalAllowedSubnets() {
        return this.portalAllowedSubnets;
    }
    /**
     * api secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    @Export(name="portalApiSecret", refs={String.class}, tree="[0]")
    private Output<String> portalApiSecret;

    /**
     * @return api secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    public Output<String> portalApiSecret() {
        return this.portalApiSecret;
    }
    /**
     * list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    @Export(name="portalDeniedHostnames", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> portalDeniedHostnames;

    /**
     * @return list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    public Output<List<String>> portalDeniedHostnames() {
        return this.portalDeniedHostnames;
    }
    /**
     * Url of portal background image
     * 
     */
    @Export(name="portalImage", refs={String.class}, tree="[0]")
    private Output<String> portalImage;

    /**
     * @return Url of portal background image
     * 
     */
    public Output<String> portalImage() {
        return this.portalImage;
    }
    @Export(name="portalSsoUrl", refs={String.class}, tree="[0]")
    private Output<String> portalSsoUrl;

    public Output<String> portalSsoUrl() {
        return this.portalSsoUrl;
    }
    /**
     * N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
     * To update portal_template, use Wlan Portal Template.
     * 
     */
    @Export(name="portalTemplateUrl", refs={String.class}, tree="[0]")
    private Output<String> portalTemplateUrl;

    /**
     * @return N.B portal_template will be forked out of wlan objects soon. To fetch portal_template, please query portal_template_url.
     * To update portal_template, use Wlan Portal Template.
     * 
     */
    public Output<String> portalTemplateUrl() {
        return this.portalTemplateUrl;
    }
    @Export(name="qos", refs={WlanQos.class}, tree="[0]")
    private Output</* @Nullable */ WlanQos> qos;

    public Output<Optional<WlanQos>> qos() {
        return Codegen.optional(this.qos);
    }
    /**
     * Radsec settings
     * 
     */
    @Export(name="radsec", refs={WlanRadsec.class}, tree="[0]")
    private Output</* @Nullable */ WlanRadsec> radsec;

    /**
     * @return Radsec settings
     * 
     */
    public Output<Optional<WlanRadsec>> radsec() {
        return Codegen.optional(this.radsec);
    }
    /**
     * enum: `11r`, `OKC`, `none`
     * 
     */
    @Export(name="roamMode", refs={String.class}, tree="[0]")
    private Output<String> roamMode;

    /**
     * @return enum: `11r`, `OKC`, `none`
     * 
     */
    public Output<String> roamMode() {
        return this.roamMode;
    }
    /**
     * WLAN operating schedule, default is disabled
     * 
     */
    @Export(name="schedule", refs={WlanSchedule.class}, tree="[0]")
    private Output</* @Nullable */ WlanSchedule> schedule;

    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    public Output<Optional<WlanSchedule>> schedule() {
        return Codegen.optional(this.schedule);
    }
    @Export(name="siteId", refs={String.class}, tree="[0]")
    private Output<String> siteId;

    public Output<String> siteId() {
        return this.siteId;
    }
    /**
     * whether to exclude this WLAN from SLE metrics
     * 
     */
    @Export(name="sleExcluded", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> sleExcluded;

    /**
     * @return whether to exclude this WLAN from SLE metrics
     * 
     */
    public Output<Boolean> sleExcluded() {
        return this.sleExcluded;
    }
    /**
     * the name of the SSID
     * 
     */
    @Export(name="ssid", refs={String.class}, tree="[0]")
    private Output<String> ssid;

    /**
     * @return the name of the SSID
     * 
     */
    public Output<String> ssid() {
        return this.ssid;
    }
    /**
     * Url of portal background image thumbnail
     * 
     */
    @Export(name="thumbnail", refs={String.class}, tree="[0]")
    private Output<String> thumbnail;

    /**
     * @return Url of portal background image thumbnail
     * 
     */
    public Output<String> thumbnail() {
        return this.thumbnail;
    }
    /**
     * if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    @Export(name="useEapolV1", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> useEapolV1;

    /**
     * @return if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    public Output<Boolean> useEapolV1() {
        return this.useEapolV1;
    }
    /**
     * if vlan tagging is enabled
     * 
     */
    @Export(name="vlanEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> vlanEnabled;

    /**
     * @return if vlan tagging is enabled
     * 
     */
    public Output<Boolean> vlanEnabled() {
        return this.vlanEnabled;
    }
    @Export(name="vlanId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> vlanId;

    public Output<Optional<String>> vlanId() {
        return Codegen.optional(this.vlanId);
    }
    /**
     * vlan_ids to use when there’s no match from RA
     * 
     */
    @Export(name="vlanIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> vlanIds;

    /**
     * @return vlan_ids to use when there’s no match from RA
     * 
     */
    public Output<List<String>> vlanIds() {
        return this.vlanIds;
    }
    /**
     * vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     * 
     */
    @Export(name="vlanPooling", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> vlanPooling;

    /**
     * @return vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     * 
     */
    public Output<Boolean> vlanPooling() {
        return this.vlanPooling;
    }
    /**
     * kbps
     * 
     */
    @Export(name="wlanLimitDown", refs={Integer.class}, tree="[0]")
    private Output<Integer> wlanLimitDown;

    /**
     * @return kbps
     * 
     */
    public Output<Integer> wlanLimitDown() {
        return this.wlanLimitDown;
    }
    /**
     * if downlink limiting for whole wlan is enabled
     * 
     */
    @Export(name="wlanLimitDownEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> wlanLimitDownEnabled;

    /**
     * @return if downlink limiting for whole wlan is enabled
     * 
     */
    public Output<Boolean> wlanLimitDownEnabled() {
        return this.wlanLimitDownEnabled;
    }
    /**
     * kbps
     * 
     */
    @Export(name="wlanLimitUp", refs={Integer.class}, tree="[0]")
    private Output<Integer> wlanLimitUp;

    /**
     * @return kbps
     * 
     */
    public Output<Integer> wlanLimitUp() {
        return this.wlanLimitUp;
    }
    /**
     * if uplink limiting for whole wlan is enabled
     * 
     */
    @Export(name="wlanLimitUpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> wlanLimitUpEnabled;

    /**
     * @return if uplink limiting for whole wlan is enabled
     * 
     */
    public Output<Boolean> wlanLimitUpEnabled() {
        return this.wlanLimitUpEnabled;
    }
    /**
     * list of wxtag_ids
     * 
     */
    @Export(name="wxtagIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> wxtagIds;

    /**
     * @return list of wxtag_ids
     * 
     */
    public Output<List<String>> wxtagIds() {
        return this.wxtagIds;
    }
    /**
     * when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    @Export(name="wxtunnelId", refs={String.class}, tree="[0]")
    private Output<String> wxtunnelId;

    /**
     * @return when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    public Output<String> wxtunnelId() {
        return this.wxtunnelId;
    }
    /**
     * when `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    @Export(name="wxtunnelRemoteId", refs={String.class}, tree="[0]")
    private Output<String> wxtunnelRemoteId;

    /**
     * @return when `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    public Output<String> wxtunnelRemoteId() {
        return this.wxtunnelRemoteId;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Wlan(java.lang.String name) {
        this(name, WlanArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Wlan(java.lang.String name, WlanArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Wlan(java.lang.String name, WlanArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("junipermist:site/wlan:Wlan", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Wlan(java.lang.String name, Output<java.lang.String> id, @Nullable WlanState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("junipermist:site/wlan:Wlan", name, state, makeResourceOptions(options, id), false);
    }

    private static WlanArgs makeArgs(WlanArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? WlanArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Wlan get(java.lang.String name, Output<java.lang.String> id, @Nullable WlanState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Wlan(name, id, state, options);
    }
}
