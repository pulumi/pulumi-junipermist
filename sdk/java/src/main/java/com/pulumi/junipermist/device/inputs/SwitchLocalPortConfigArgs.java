// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.device.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.junipermist.device.inputs.SwitchLocalPortConfigStormControlArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class SwitchLocalPortConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final SwitchLocalPortConfigArgs Empty = new SwitchLocalPortConfigArgs();

    /**
     * Only if `mode`==`trunk` whether to trunk all network/vlans
     * 
     */
    @Import(name="allNetworks")
    private @Nullable Output<Boolean> allNetworks;

    /**
     * @return Only if `mode`==`trunk` whether to trunk all network/vlans
     * 
     */
    public Optional<Output<Boolean>> allNetworks() {
        return Optional.ofNullable(this.allNetworks);
    }

    /**
     * If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
     * 
     */
    @Import(name="allowDhcpd")
    private @Nullable Output<Boolean> allowDhcpd;

    /**
     * @return If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
     * 
     */
    public Optional<Output<Boolean>> allowDhcpd() {
        return Optional.ofNullable(this.allowDhcpd);
    }

    @Import(name="allowMultipleSupplicants")
    private @Nullable Output<Boolean> allowMultipleSupplicants;

    public Optional<Output<Boolean>> allowMultipleSupplicants() {
        return Optional.ofNullable(this.allowMultipleSupplicants);
    }

    /**
     * Only if `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     * 
     */
    @Import(name="bypassAuthWhenServerDown")
    private @Nullable Output<Boolean> bypassAuthWhenServerDown;

    /**
     * @return Only if `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     * 
     */
    public Optional<Output<Boolean>> bypassAuthWhenServerDown() {
        return Optional.ofNullable(this.bypassAuthWhenServerDown);
    }

    /**
     * Only if `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     * 
     */
    @Import(name="bypassAuthWhenServerDownForUnkonwnClient")
    private @Nullable Output<Boolean> bypassAuthWhenServerDownForUnkonwnClient;

    /**
     * @return Only if `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     * 
     */
    public Optional<Output<Boolean>> bypassAuthWhenServerDownForUnkonwnClient() {
        return Optional.ofNullable(this.bypassAuthWhenServerDownForUnkonwnClient);
    }

    @Import(name="description")
    private @Nullable Output<String> description;

    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     * 
     */
    @Import(name="disableAutoneg")
    private @Nullable Output<Boolean> disableAutoneg;

    /**
     * @return Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     * 
     */
    public Optional<Output<Boolean>> disableAutoneg() {
        return Optional.ofNullable(this.disableAutoneg);
    }

    /**
     * whether the port is disabled
     * 
     */
    @Import(name="disabled")
    private @Nullable Output<Boolean> disabled;

    /**
     * @return whether the port is disabled
     * 
     */
    public Optional<Output<Boolean>> disabled() {
        return Optional.ofNullable(this.disabled);
    }

    /**
     * link connection mode. enum: `auto`, `full`, `half`
     * 
     */
    @Import(name="duplex")
    private @Nullable Output<String> duplex;

    /**
     * @return link connection mode. enum: `auto`, `full`, `half`
     * 
     */
    public Optional<Output<String>> duplex() {
        return Optional.ofNullable(this.duplex);
    }

    /**
     * Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     * 
     */
    @Import(name="dynamicVlanNetworks")
    private @Nullable Output<List<String>> dynamicVlanNetworks;

    /**
     * @return Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     * 
     */
    public Optional<Output<List<String>>> dynamicVlanNetworks() {
        return Optional.ofNullable(this.dynamicVlanNetworks);
    }

    /**
     * Only if `port_auth`==`dot1x` whether to enable MAC Auth
     * 
     */
    @Import(name="enableMacAuth")
    private @Nullable Output<Boolean> enableMacAuth;

    /**
     * @return Only if `port_auth`==`dot1x` whether to enable MAC Auth
     * 
     */
    public Optional<Output<Boolean>> enableMacAuth() {
        return Optional.ofNullable(this.enableMacAuth);
    }

    @Import(name="enableQos")
    private @Nullable Output<Boolean> enableQos;

    public Optional<Output<Boolean>> enableQos() {
        return Optional.ofNullable(this.enableQos);
    }

    /**
     * Only if `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     * 
     */
    @Import(name="guestNetwork")
    private @Nullable Output<String> guestNetwork;

    /**
     * @return Only if `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     * 
     */
    public Optional<Output<String>> guestNetwork() {
        return Optional.ofNullable(this.guestNetwork);
    }

    /**
     * inter_switch_link is used together with &#34;isolation&#34; under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    @Import(name="interSwitchLink")
    private @Nullable Output<Boolean> interSwitchLink;

    /**
     * @return inter_switch_link is used together with &#34;isolation&#34; under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    public Optional<Output<Boolean>> interSwitchLink() {
        return Optional.ofNullable(this.interSwitchLink);
    }

    /**
     * Only if `enable_mac_auth`==`true`
     * 
     */
    @Import(name="macAuthOnly")
    private @Nullable Output<Boolean> macAuthOnly;

    /**
     * @return Only if `enable_mac_auth`==`true`
     * 
     */
    public Optional<Output<Boolean>> macAuthOnly() {
        return Optional.ofNullable(this.macAuthOnly);
    }

    /**
     * Only if `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
     * 
     */
    @Import(name="macAuthPreferred")
    private @Nullable Output<Boolean> macAuthPreferred;

    /**
     * @return Only if `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
     * 
     */
    public Optional<Output<Boolean>> macAuthPreferred() {
        return Optional.ofNullable(this.macAuthPreferred);
    }

    /**
     * Only if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     * 
     */
    @Import(name="macAuthProtocol")
    private @Nullable Output<String> macAuthProtocol;

    /**
     * @return Only if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     * 
     */
    public Optional<Output<String>> macAuthProtocol() {
        return Optional.ofNullable(this.macAuthProtocol);
    }

    /**
     * max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     * 
     */
    @Import(name="macLimit")
    private @Nullable Output<Integer> macLimit;

    /**
     * @return max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     * 
     */
    public Optional<Output<Integer>> macLimit() {
        return Optional.ofNullable(this.macLimit);
    }

    /**
     * enum: `access`, `inet`, `trunk`
     * 
     */
    @Import(name="mode")
    private @Nullable Output<String> mode;

    /**
     * @return enum: `access`, `inet`, `trunk`
     * 
     */
    public Optional<Output<String>> mode() {
        return Optional.ofNullable(this.mode);
    }

    /**
     * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     * 
     */
    @Import(name="mtu")
    private @Nullable Output<Integer> mtu;

    /**
     * @return media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     * 
     */
    public Optional<Output<Integer>> mtu() {
        return Optional.ofNullable(this.mtu);
    }

    /**
     * Only if `mode`==`trunk`, the list of network/vlans
     * 
     */
    @Import(name="networks")
    private @Nullable Output<List<String>> networks;

    /**
     * @return Only if `mode`==`trunk`, the list of network/vlans
     * 
     */
    public Optional<Output<List<String>>> networks() {
        return Optional.ofNullable(this.networks);
    }

    /**
     * Additional note for the port config override
     * 
     */
    @Import(name="note")
    private @Nullable Output<String> note;

    /**
     * @return Additional note for the port config override
     * 
     */
    public Optional<Output<String>> note() {
        return Optional.ofNullable(this.note);
    }

    /**
     * Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     * 
     */
    @Import(name="persistMac")
    private @Nullable Output<Boolean> persistMac;

    /**
     * @return Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     * 
     */
    public Optional<Output<Boolean>> persistMac() {
        return Optional.ofNullable(this.persistMac);
    }

    /**
     * whether PoE capabilities are disabled for a port
     * 
     */
    @Import(name="poeDisabled")
    private @Nullable Output<Boolean> poeDisabled;

    /**
     * @return whether PoE capabilities are disabled for a port
     * 
     */
    public Optional<Output<Boolean>> poeDisabled() {
        return Optional.ofNullable(this.poeDisabled);
    }

    /**
     * if dot1x is desired, set to dot1x. enum: `dot1x`
     * 
     */
    @Import(name="portAuth")
    private @Nullable Output<String> portAuth;

    /**
     * @return if dot1x is desired, set to dot1x. enum: `dot1x`
     * 
     */
    public Optional<Output<String>> portAuth() {
        return Optional.ofNullable(this.portAuth);
    }

    /**
     * native network/vlan for untagged traffic
     * 
     */
    @Import(name="portNetwork")
    private @Nullable Output<String> portNetwork;

    /**
     * @return native network/vlan for untagged traffic
     * 
     */
    public Optional<Output<String>> portNetwork() {
        return Optional.ofNullable(this.portNetwork);
    }

    /**
     * Only if `port_auth`=`dot1x` reauthentication interval range
     * 
     */
    @Import(name="reauthInterval")
    private @Nullable Output<Integer> reauthInterval;

    /**
     * @return Only if `port_auth`=`dot1x` reauthentication interval range
     * 
     */
    public Optional<Output<Integer>> reauthInterval() {
        return Optional.ofNullable(this.reauthInterval);
    }

    /**
     * Only if `port_auth`==`dot1x` sets server fail fallback vlan
     * 
     */
    @Import(name="serverFailNetwork")
    private @Nullable Output<String> serverFailNetwork;

    /**
     * @return Only if `port_auth`==`dot1x` sets server fail fallback vlan
     * 
     */
    public Optional<Output<String>> serverFailNetwork() {
        return Optional.ofNullable(this.serverFailNetwork);
    }

    /**
     * Only if `port_auth`==`dot1x` when radius server reject / fails
     * 
     */
    @Import(name="serverRejectNetwork")
    private @Nullable Output<String> serverRejectNetwork;

    /**
     * @return Only if `port_auth`==`dot1x` when radius server reject / fails
     * 
     */
    public Optional<Output<String>> serverRejectNetwork() {
        return Optional.ofNullable(this.serverRejectNetwork);
    }

    /**
     * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
     * 
     */
    @Import(name="speed")
    private @Nullable Output<String> speed;

    /**
     * @return enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
     * 
     */
    public Optional<Output<String>> speed() {
        return Optional.ofNullable(this.speed);
    }

    /**
     * Switch storm control
     * 
     */
    @Import(name="stormControl")
    private @Nullable Output<SwitchLocalPortConfigStormControlArgs> stormControl;

    /**
     * @return Switch storm control
     * 
     */
    public Optional<Output<SwitchLocalPortConfigStormControlArgs>> stormControl() {
        return Optional.ofNullable(this.stormControl);
    }

    /**
     * when enabled, the port is not expected to receive BPDU frames
     * 
     */
    @Import(name="stpEdge")
    private @Nullable Output<Boolean> stpEdge;

    /**
     * @return when enabled, the port is not expected to receive BPDU frames
     * 
     */
    public Optional<Output<Boolean>> stpEdge() {
        return Optional.ofNullable(this.stpEdge);
    }

    @Import(name="stpNoRootPort")
    private @Nullable Output<Boolean> stpNoRootPort;

    public Optional<Output<Boolean>> stpNoRootPort() {
        return Optional.ofNullable(this.stpNoRootPort);
    }

    @Import(name="stpP2p")
    private @Nullable Output<Boolean> stpP2p;

    public Optional<Output<Boolean>> stpP2p() {
        return Optional.ofNullable(this.stpP2p);
    }

    /**
     * port usage name.
     * 
     */
    @Import(name="usage", required=true)
    private Output<String> usage;

    /**
     * @return port usage name.
     * 
     */
    public Output<String> usage() {
        return this.usage;
    }

    /**
     * if this is connected to a vstp network
     * 
     */
    @Import(name="useVstp")
    private @Nullable Output<Boolean> useVstp;

    /**
     * @return if this is connected to a vstp network
     * 
     */
    public Optional<Output<Boolean>> useVstp() {
        return Optional.ofNullable(this.useVstp);
    }

    /**
     * network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     * 
     */
    @Import(name="voipNetwork")
    private @Nullable Output<String> voipNetwork;

    /**
     * @return network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     * 
     */
    public Optional<Output<String>> voipNetwork() {
        return Optional.ofNullable(this.voipNetwork);
    }

    private SwitchLocalPortConfigArgs() {}

    private SwitchLocalPortConfigArgs(SwitchLocalPortConfigArgs $) {
        this.allNetworks = $.allNetworks;
        this.allowDhcpd = $.allowDhcpd;
        this.allowMultipleSupplicants = $.allowMultipleSupplicants;
        this.bypassAuthWhenServerDown = $.bypassAuthWhenServerDown;
        this.bypassAuthWhenServerDownForUnkonwnClient = $.bypassAuthWhenServerDownForUnkonwnClient;
        this.description = $.description;
        this.disableAutoneg = $.disableAutoneg;
        this.disabled = $.disabled;
        this.duplex = $.duplex;
        this.dynamicVlanNetworks = $.dynamicVlanNetworks;
        this.enableMacAuth = $.enableMacAuth;
        this.enableQos = $.enableQos;
        this.guestNetwork = $.guestNetwork;
        this.interSwitchLink = $.interSwitchLink;
        this.macAuthOnly = $.macAuthOnly;
        this.macAuthPreferred = $.macAuthPreferred;
        this.macAuthProtocol = $.macAuthProtocol;
        this.macLimit = $.macLimit;
        this.mode = $.mode;
        this.mtu = $.mtu;
        this.networks = $.networks;
        this.note = $.note;
        this.persistMac = $.persistMac;
        this.poeDisabled = $.poeDisabled;
        this.portAuth = $.portAuth;
        this.portNetwork = $.portNetwork;
        this.reauthInterval = $.reauthInterval;
        this.serverFailNetwork = $.serverFailNetwork;
        this.serverRejectNetwork = $.serverRejectNetwork;
        this.speed = $.speed;
        this.stormControl = $.stormControl;
        this.stpEdge = $.stpEdge;
        this.stpNoRootPort = $.stpNoRootPort;
        this.stpP2p = $.stpP2p;
        this.usage = $.usage;
        this.useVstp = $.useVstp;
        this.voipNetwork = $.voipNetwork;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(SwitchLocalPortConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private SwitchLocalPortConfigArgs $;

        public Builder() {
            $ = new SwitchLocalPortConfigArgs();
        }

        public Builder(SwitchLocalPortConfigArgs defaults) {
            $ = new SwitchLocalPortConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allNetworks Only if `mode`==`trunk` whether to trunk all network/vlans
         * 
         * @return builder
         * 
         */
        public Builder allNetworks(@Nullable Output<Boolean> allNetworks) {
            $.allNetworks = allNetworks;
            return this;
        }

        /**
         * @param allNetworks Only if `mode`==`trunk` whether to trunk all network/vlans
         * 
         * @return builder
         * 
         */
        public Builder allNetworks(Boolean allNetworks) {
            return allNetworks(Output.of(allNetworks));
        }

        /**
         * @param allowDhcpd If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
         * 
         * @return builder
         * 
         */
        public Builder allowDhcpd(@Nullable Output<Boolean> allowDhcpd) {
            $.allowDhcpd = allowDhcpd;
            return this;
        }

        /**
         * @param allowDhcpd If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state. When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
         * 
         * @return builder
         * 
         */
        public Builder allowDhcpd(Boolean allowDhcpd) {
            return allowDhcpd(Output.of(allowDhcpd));
        }

        public Builder allowMultipleSupplicants(@Nullable Output<Boolean> allowMultipleSupplicants) {
            $.allowMultipleSupplicants = allowMultipleSupplicants;
            return this;
        }

        public Builder allowMultipleSupplicants(Boolean allowMultipleSupplicants) {
            return allowMultipleSupplicants(Output.of(allowMultipleSupplicants));
        }

        /**
         * @param bypassAuthWhenServerDown Only if `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDown(@Nullable Output<Boolean> bypassAuthWhenServerDown) {
            $.bypassAuthWhenServerDown = bypassAuthWhenServerDown;
            return this;
        }

        /**
         * @param bypassAuthWhenServerDown Only if `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDown(Boolean bypassAuthWhenServerDown) {
            return bypassAuthWhenServerDown(Output.of(bypassAuthWhenServerDown));
        }

        /**
         * @param bypassAuthWhenServerDownForUnkonwnClient Only if `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDownForUnkonwnClient(@Nullable Output<Boolean> bypassAuthWhenServerDownForUnkonwnClient) {
            $.bypassAuthWhenServerDownForUnkonwnClient = bypassAuthWhenServerDownForUnkonwnClient;
            return this;
        }

        /**
         * @param bypassAuthWhenServerDownForUnkonwnClient Only if `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDownForUnkonwnClient(Boolean bypassAuthWhenServerDownForUnkonwnClient) {
            return bypassAuthWhenServerDownForUnkonwnClient(Output.of(bypassAuthWhenServerDownForUnkonwnClient));
        }

        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disableAutoneg Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         * 
         * @return builder
         * 
         */
        public Builder disableAutoneg(@Nullable Output<Boolean> disableAutoneg) {
            $.disableAutoneg = disableAutoneg;
            return this;
        }

        /**
         * @param disableAutoneg Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         * 
         * @return builder
         * 
         */
        public Builder disableAutoneg(Boolean disableAutoneg) {
            return disableAutoneg(Output.of(disableAutoneg));
        }

        /**
         * @param disabled whether the port is disabled
         * 
         * @return builder
         * 
         */
        public Builder disabled(@Nullable Output<Boolean> disabled) {
            $.disabled = disabled;
            return this;
        }

        /**
         * @param disabled whether the port is disabled
         * 
         * @return builder
         * 
         */
        public Builder disabled(Boolean disabled) {
            return disabled(Output.of(disabled));
        }

        /**
         * @param duplex link connection mode. enum: `auto`, `full`, `half`
         * 
         * @return builder
         * 
         */
        public Builder duplex(@Nullable Output<String> duplex) {
            $.duplex = duplex;
            return this;
        }

        /**
         * @param duplex link connection mode. enum: `auto`, `full`, `half`
         * 
         * @return builder
         * 
         */
        public Builder duplex(String duplex) {
            return duplex(Output.of(duplex));
        }

        /**
         * @param dynamicVlanNetworks Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(@Nullable Output<List<String>> dynamicVlanNetworks) {
            $.dynamicVlanNetworks = dynamicVlanNetworks;
            return this;
        }

        /**
         * @param dynamicVlanNetworks Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(List<String> dynamicVlanNetworks) {
            return dynamicVlanNetworks(Output.of(dynamicVlanNetworks));
        }

        /**
         * @param dynamicVlanNetworks Only if `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(String... dynamicVlanNetworks) {
            return dynamicVlanNetworks(List.of(dynamicVlanNetworks));
        }

        /**
         * @param enableMacAuth Only if `port_auth`==`dot1x` whether to enable MAC Auth
         * 
         * @return builder
         * 
         */
        public Builder enableMacAuth(@Nullable Output<Boolean> enableMacAuth) {
            $.enableMacAuth = enableMacAuth;
            return this;
        }

        /**
         * @param enableMacAuth Only if `port_auth`==`dot1x` whether to enable MAC Auth
         * 
         * @return builder
         * 
         */
        public Builder enableMacAuth(Boolean enableMacAuth) {
            return enableMacAuth(Output.of(enableMacAuth));
        }

        public Builder enableQos(@Nullable Output<Boolean> enableQos) {
            $.enableQos = enableQos;
            return this;
        }

        public Builder enableQos(Boolean enableQos) {
            return enableQos(Output.of(enableQos));
        }

        /**
         * @param guestNetwork Only if `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         * 
         * @return builder
         * 
         */
        public Builder guestNetwork(@Nullable Output<String> guestNetwork) {
            $.guestNetwork = guestNetwork;
            return this;
        }

        /**
         * @param guestNetwork Only if `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         * 
         * @return builder
         * 
         */
        public Builder guestNetwork(String guestNetwork) {
            return guestNetwork(Output.of(guestNetwork));
        }

        /**
         * @param interSwitchLink inter_switch_link is used together with &#34;isolation&#34; under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interSwitchLink(@Nullable Output<Boolean> interSwitchLink) {
            $.interSwitchLink = interSwitchLink;
            return this;
        }

        /**
         * @param interSwitchLink inter_switch_link is used together with &#34;isolation&#34; under networks. NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interSwitchLink(Boolean interSwitchLink) {
            return interSwitchLink(Output.of(interSwitchLink));
        }

        /**
         * @param macAuthOnly Only if `enable_mac_auth`==`true`
         * 
         * @return builder
         * 
         */
        public Builder macAuthOnly(@Nullable Output<Boolean> macAuthOnly) {
            $.macAuthOnly = macAuthOnly;
            return this;
        }

        /**
         * @param macAuthOnly Only if `enable_mac_auth`==`true`
         * 
         * @return builder
         * 
         */
        public Builder macAuthOnly(Boolean macAuthOnly) {
            return macAuthOnly(Output.of(macAuthOnly));
        }

        /**
         * @param macAuthPreferred Only if `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
         * 
         * @return builder
         * 
         */
        public Builder macAuthPreferred(@Nullable Output<Boolean> macAuthPreferred) {
            $.macAuthPreferred = macAuthPreferred;
            return this;
        }

        /**
         * @param macAuthPreferred Only if `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
         * 
         * @return builder
         * 
         */
        public Builder macAuthPreferred(Boolean macAuthPreferred) {
            return macAuthPreferred(Output.of(macAuthPreferred));
        }

        /**
         * @param macAuthProtocol Only if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         * 
         * @return builder
         * 
         */
        public Builder macAuthProtocol(@Nullable Output<String> macAuthProtocol) {
            $.macAuthProtocol = macAuthProtocol;
            return this;
        }

        /**
         * @param macAuthProtocol Only if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         * 
         * @return builder
         * 
         */
        public Builder macAuthProtocol(String macAuthProtocol) {
            return macAuthProtocol(Output.of(macAuthProtocol));
        }

        /**
         * @param macLimit max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         * 
         * @return builder
         * 
         */
        public Builder macLimit(@Nullable Output<Integer> macLimit) {
            $.macLimit = macLimit;
            return this;
        }

        /**
         * @param macLimit max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         * 
         * @return builder
         * 
         */
        public Builder macLimit(Integer macLimit) {
            return macLimit(Output.of(macLimit));
        }

        /**
         * @param mode enum: `access`, `inet`, `trunk`
         * 
         * @return builder
         * 
         */
        public Builder mode(@Nullable Output<String> mode) {
            $.mode = mode;
            return this;
        }

        /**
         * @param mode enum: `access`, `inet`, `trunk`
         * 
         * @return builder
         * 
         */
        public Builder mode(String mode) {
            return mode(Output.of(mode));
        }

        /**
         * @param mtu media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         * 
         * @return builder
         * 
         */
        public Builder mtu(@Nullable Output<Integer> mtu) {
            $.mtu = mtu;
            return this;
        }

        /**
         * @param mtu media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         * 
         * @return builder
         * 
         */
        public Builder mtu(Integer mtu) {
            return mtu(Output.of(mtu));
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(@Nullable Output<List<String>> networks) {
            $.networks = networks;
            return this;
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(List<String> networks) {
            return networks(Output.of(networks));
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(String... networks) {
            return networks(List.of(networks));
        }

        /**
         * @param note Additional note for the port config override
         * 
         * @return builder
         * 
         */
        public Builder note(@Nullable Output<String> note) {
            $.note = note;
            return this;
        }

        /**
         * @param note Additional note for the port config override
         * 
         * @return builder
         * 
         */
        public Builder note(String note) {
            return note(Output.of(note));
        }

        /**
         * @param persistMac Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         * 
         * @return builder
         * 
         */
        public Builder persistMac(@Nullable Output<Boolean> persistMac) {
            $.persistMac = persistMac;
            return this;
        }

        /**
         * @param persistMac Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         * 
         * @return builder
         * 
         */
        public Builder persistMac(Boolean persistMac) {
            return persistMac(Output.of(persistMac));
        }

        /**
         * @param poeDisabled whether PoE capabilities are disabled for a port
         * 
         * @return builder
         * 
         */
        public Builder poeDisabled(@Nullable Output<Boolean> poeDisabled) {
            $.poeDisabled = poeDisabled;
            return this;
        }

        /**
         * @param poeDisabled whether PoE capabilities are disabled for a port
         * 
         * @return builder
         * 
         */
        public Builder poeDisabled(Boolean poeDisabled) {
            return poeDisabled(Output.of(poeDisabled));
        }

        /**
         * @param portAuth if dot1x is desired, set to dot1x. enum: `dot1x`
         * 
         * @return builder
         * 
         */
        public Builder portAuth(@Nullable Output<String> portAuth) {
            $.portAuth = portAuth;
            return this;
        }

        /**
         * @param portAuth if dot1x is desired, set to dot1x. enum: `dot1x`
         * 
         * @return builder
         * 
         */
        public Builder portAuth(String portAuth) {
            return portAuth(Output.of(portAuth));
        }

        /**
         * @param portNetwork native network/vlan for untagged traffic
         * 
         * @return builder
         * 
         */
        public Builder portNetwork(@Nullable Output<String> portNetwork) {
            $.portNetwork = portNetwork;
            return this;
        }

        /**
         * @param portNetwork native network/vlan for untagged traffic
         * 
         * @return builder
         * 
         */
        public Builder portNetwork(String portNetwork) {
            return portNetwork(Output.of(portNetwork));
        }

        /**
         * @param reauthInterval Only if `port_auth`=`dot1x` reauthentication interval range
         * 
         * @return builder
         * 
         */
        public Builder reauthInterval(@Nullable Output<Integer> reauthInterval) {
            $.reauthInterval = reauthInterval;
            return this;
        }

        /**
         * @param reauthInterval Only if `port_auth`=`dot1x` reauthentication interval range
         * 
         * @return builder
         * 
         */
        public Builder reauthInterval(Integer reauthInterval) {
            return reauthInterval(Output.of(reauthInterval));
        }

        /**
         * @param serverFailNetwork Only if `port_auth`==`dot1x` sets server fail fallback vlan
         * 
         * @return builder
         * 
         */
        public Builder serverFailNetwork(@Nullable Output<String> serverFailNetwork) {
            $.serverFailNetwork = serverFailNetwork;
            return this;
        }

        /**
         * @param serverFailNetwork Only if `port_auth`==`dot1x` sets server fail fallback vlan
         * 
         * @return builder
         * 
         */
        public Builder serverFailNetwork(String serverFailNetwork) {
            return serverFailNetwork(Output.of(serverFailNetwork));
        }

        /**
         * @param serverRejectNetwork Only if `port_auth`==`dot1x` when radius server reject / fails
         * 
         * @return builder
         * 
         */
        public Builder serverRejectNetwork(@Nullable Output<String> serverRejectNetwork) {
            $.serverRejectNetwork = serverRejectNetwork;
            return this;
        }

        /**
         * @param serverRejectNetwork Only if `port_auth`==`dot1x` when radius server reject / fails
         * 
         * @return builder
         * 
         */
        public Builder serverRejectNetwork(String serverRejectNetwork) {
            return serverRejectNetwork(Output.of(serverRejectNetwork));
        }

        /**
         * @param speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         * 
         * @return builder
         * 
         */
        public Builder speed(@Nullable Output<String> speed) {
            $.speed = speed;
            return this;
        }

        /**
         * @param speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         * 
         * @return builder
         * 
         */
        public Builder speed(String speed) {
            return speed(Output.of(speed));
        }

        /**
         * @param stormControl Switch storm control
         * 
         * @return builder
         * 
         */
        public Builder stormControl(@Nullable Output<SwitchLocalPortConfigStormControlArgs> stormControl) {
            $.stormControl = stormControl;
            return this;
        }

        /**
         * @param stormControl Switch storm control
         * 
         * @return builder
         * 
         */
        public Builder stormControl(SwitchLocalPortConfigStormControlArgs stormControl) {
            return stormControl(Output.of(stormControl));
        }

        /**
         * @param stpEdge when enabled, the port is not expected to receive BPDU frames
         * 
         * @return builder
         * 
         */
        public Builder stpEdge(@Nullable Output<Boolean> stpEdge) {
            $.stpEdge = stpEdge;
            return this;
        }

        /**
         * @param stpEdge when enabled, the port is not expected to receive BPDU frames
         * 
         * @return builder
         * 
         */
        public Builder stpEdge(Boolean stpEdge) {
            return stpEdge(Output.of(stpEdge));
        }

        public Builder stpNoRootPort(@Nullable Output<Boolean> stpNoRootPort) {
            $.stpNoRootPort = stpNoRootPort;
            return this;
        }

        public Builder stpNoRootPort(Boolean stpNoRootPort) {
            return stpNoRootPort(Output.of(stpNoRootPort));
        }

        public Builder stpP2p(@Nullable Output<Boolean> stpP2p) {
            $.stpP2p = stpP2p;
            return this;
        }

        public Builder stpP2p(Boolean stpP2p) {
            return stpP2p(Output.of(stpP2p));
        }

        /**
         * @param usage port usage name.
         * 
         * @return builder
         * 
         */
        public Builder usage(Output<String> usage) {
            $.usage = usage;
            return this;
        }

        /**
         * @param usage port usage name.
         * 
         * @return builder
         * 
         */
        public Builder usage(String usage) {
            return usage(Output.of(usage));
        }

        /**
         * @param useVstp if this is connected to a vstp network
         * 
         * @return builder
         * 
         */
        public Builder useVstp(@Nullable Output<Boolean> useVstp) {
            $.useVstp = useVstp;
            return this;
        }

        /**
         * @param useVstp if this is connected to a vstp network
         * 
         * @return builder
         * 
         */
        public Builder useVstp(Boolean useVstp) {
            return useVstp(Output.of(useVstp));
        }

        /**
         * @param voipNetwork network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         * 
         * @return builder
         * 
         */
        public Builder voipNetwork(@Nullable Output<String> voipNetwork) {
            $.voipNetwork = voipNetwork;
            return this;
        }

        /**
         * @param voipNetwork network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         * 
         * @return builder
         * 
         */
        public Builder voipNetwork(String voipNetwork) {
            return voipNetwork(Output.of(voipNetwork));
        }

        public SwitchLocalPortConfigArgs build() {
            if ($.usage == null) {
                throw new MissingRequiredPropertyException("SwitchLocalPortConfigArgs", "usage");
            }
            return $;
        }
    }

}
