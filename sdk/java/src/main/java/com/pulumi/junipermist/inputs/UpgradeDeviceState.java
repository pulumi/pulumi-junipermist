// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.junipermist.inputs.UpgradeDeviceFwupdateArgs;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class UpgradeDeviceState extends com.pulumi.resources.ResourceArgs {

    public static final UpgradeDeviceState Empty = new UpgradeDeviceState();

    @Import(name="deviceId")
    private @Nullable Output<String> deviceId;

    public Optional<Output<String>> deviceId() {
        return Optional.ofNullable(this.deviceId);
    }

    /**
     * current device firmware version
     * 
     */
    @Import(name="deviceVersion")
    private @Nullable Output<String> deviceVersion;

    /**
     * @return current device firmware version
     * 
     */
    public Optional<Output<String>> deviceVersion() {
        return Optional.ofNullable(this.deviceVersion);
    }

    @Import(name="fwupdate")
    private @Nullable Output<UpgradeDeviceFwupdateArgs> fwupdate;

    public Optional<Output<UpgradeDeviceFwupdateArgs>> fwupdate() {
        return Optional.ofNullable(this.fwupdate);
    }

    /**
     * For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
     * 
     */
    @Import(name="reboot")
    private @Nullable Output<Boolean> reboot;

    /**
     * @return For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
     * 
     */
    public Optional<Output<Boolean>> reboot() {
        return Optional.ofNullable(this.reboot);
    }

    /**
     * For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
     * 
     */
    @Import(name="rebootAt")
    private @Nullable Output<Integer> rebootAt;

    /**
     * @return For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
     * 
     */
    public Optional<Output<Integer>> rebootAt() {
        return Optional.ofNullable(this.rebootAt);
    }

    @Import(name="siteId")
    private @Nullable Output<String> siteId;

    public Optional<Output<String>> siteId() {
        return Optional.ofNullable(this.siteId);
    }

    /**
     * For Junos devices only. Perform recovery snapshot after device is rebooted
     * 
     */
    @Import(name="snapshot")
    private @Nullable Output<Boolean> snapshot;

    /**
     * @return For Junos devices only. Perform recovery snapshot after device is rebooted
     * 
     */
    public Optional<Output<Boolean>> snapshot() {
        return Optional.ofNullable(this.snapshot);
    }

    /**
     * Firmware download start time in epoch
     * 
     */
    @Import(name="startTime")
    private @Nullable Output<Integer> startTime;

    /**
     * @return Firmware download start time in epoch
     * 
     */
    public Optional<Output<Integer>> startTime() {
        return Optional.ofNullable(this.startTime);
    }

    /**
     * enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
     * 
     */
    @Import(name="status")
    private @Nullable Output<String> status;

    /**
     * @return enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
     * 
     */
    public Optional<Output<String>> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
     * 
     */
    @Import(name="syncUpgrade")
    private @Nullable Output<Boolean> syncUpgrade;

    /**
     * @return if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
     * 
     */
    public Optional<Output<Boolean>> syncUpgrade() {
        return Optional.ofNullable(this.syncUpgrade);
    }

    /**
     * if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
     * 
     */
    @Import(name="syncUpgradeRefreshInterval")
    private @Nullable Output<Integer> syncUpgradeRefreshInterval;

    /**
     * @return if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
     * 
     */
    public Optional<Output<Integer>> syncUpgradeRefreshInterval() {
        return Optional.ofNullable(this.syncUpgradeRefreshInterval);
    }

    /**
     * if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
     * 
     */
    @Import(name="syncUpgradeStartTimeout")
    private @Nullable Output<Integer> syncUpgradeStartTimeout;

    /**
     * @return if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
     * 
     */
    public Optional<Output<Integer>> syncUpgradeStartTimeout() {
        return Optional.ofNullable(this.syncUpgradeStartTimeout);
    }

    /**
     * if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
     * 
     */
    @Import(name="syncUpgradeTimeout")
    private @Nullable Output<Integer> syncUpgradeTimeout;

    /**
     * @return if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
     * 
     */
    public Optional<Output<Integer>> syncUpgradeTimeout() {
        return Optional.ofNullable(this.syncUpgradeTimeout);
    }

    /**
     * firmware version to deploy to the device. Use the `junipermist.device.getVersions` datasource to get the list of available firmware versions
     * 
     */
    @Import(name="targetVersion")
    private @Nullable Output<String> targetVersion;

    /**
     * @return firmware version to deploy to the device. Use the `junipermist.device.getVersions` datasource to get the list of available firmware versions
     * 
     */
    public Optional<Output<String>> targetVersion() {
        return Optional.ofNullable(this.targetVersion);
    }

    /**
     * Epoch (seconds)
     * 
     */
    @Import(name="timestamp")
    private @Nullable Output<Double> timestamp;

    /**
     * @return Epoch (seconds)
     * 
     */
    public Optional<Output<Double>> timestamp() {
        return Optional.ofNullable(this.timestamp);
    }

    private UpgradeDeviceState() {}

    private UpgradeDeviceState(UpgradeDeviceState $) {
        this.deviceId = $.deviceId;
        this.deviceVersion = $.deviceVersion;
        this.fwupdate = $.fwupdate;
        this.reboot = $.reboot;
        this.rebootAt = $.rebootAt;
        this.siteId = $.siteId;
        this.snapshot = $.snapshot;
        this.startTime = $.startTime;
        this.status = $.status;
        this.syncUpgrade = $.syncUpgrade;
        this.syncUpgradeRefreshInterval = $.syncUpgradeRefreshInterval;
        this.syncUpgradeStartTimeout = $.syncUpgradeStartTimeout;
        this.syncUpgradeTimeout = $.syncUpgradeTimeout;
        this.targetVersion = $.targetVersion;
        this.timestamp = $.timestamp;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(UpgradeDeviceState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private UpgradeDeviceState $;

        public Builder() {
            $ = new UpgradeDeviceState();
        }

        public Builder(UpgradeDeviceState defaults) {
            $ = new UpgradeDeviceState(Objects.requireNonNull(defaults));
        }

        public Builder deviceId(@Nullable Output<String> deviceId) {
            $.deviceId = deviceId;
            return this;
        }

        public Builder deviceId(String deviceId) {
            return deviceId(Output.of(deviceId));
        }

        /**
         * @param deviceVersion current device firmware version
         * 
         * @return builder
         * 
         */
        public Builder deviceVersion(@Nullable Output<String> deviceVersion) {
            $.deviceVersion = deviceVersion;
            return this;
        }

        /**
         * @param deviceVersion current device firmware version
         * 
         * @return builder
         * 
         */
        public Builder deviceVersion(String deviceVersion) {
            return deviceVersion(Output.of(deviceVersion));
        }

        public Builder fwupdate(@Nullable Output<UpgradeDeviceFwupdateArgs> fwupdate) {
            $.fwupdate = fwupdate;
            return this;
        }

        public Builder fwupdate(UpgradeDeviceFwupdateArgs fwupdate) {
            return fwupdate(Output.of(fwupdate));
        }

        /**
         * @param reboot For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
         * 
         * @return builder
         * 
         */
        public Builder reboot(@Nullable Output<Boolean> reboot) {
            $.reboot = reboot;
            return this;
        }

        /**
         * @param reboot For Switches and Gateways only (APs are automatically rebooted). Reboot device immediately after upgrade is completed
         * 
         * @return builder
         * 
         */
        public Builder reboot(Boolean reboot) {
            return reboot(Output.of(reboot));
        }

        /**
         * @param rebootAt For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
         * 
         * @return builder
         * 
         */
        public Builder rebootAt(@Nullable Output<Integer> rebootAt) {
            $.rebootAt = rebootAt;
            return this;
        }

        /**
         * @param rebootAt For Switches and Gateways only and if `reboot`==`true`. Reboot start time in epoch seconds, default is `startTime`
         * 
         * @return builder
         * 
         */
        public Builder rebootAt(Integer rebootAt) {
            return rebootAt(Output.of(rebootAt));
        }

        public Builder siteId(@Nullable Output<String> siteId) {
            $.siteId = siteId;
            return this;
        }

        public Builder siteId(String siteId) {
            return siteId(Output.of(siteId));
        }

        /**
         * @param snapshot For Junos devices only. Perform recovery snapshot after device is rebooted
         * 
         * @return builder
         * 
         */
        public Builder snapshot(@Nullable Output<Boolean> snapshot) {
            $.snapshot = snapshot;
            return this;
        }

        /**
         * @param snapshot For Junos devices only. Perform recovery snapshot after device is rebooted
         * 
         * @return builder
         * 
         */
        public Builder snapshot(Boolean snapshot) {
            return snapshot(Output.of(snapshot));
        }

        /**
         * @param startTime Firmware download start time in epoch
         * 
         * @return builder
         * 
         */
        public Builder startTime(@Nullable Output<Integer> startTime) {
            $.startTime = startTime;
            return this;
        }

        /**
         * @param startTime Firmware download start time in epoch
         * 
         * @return builder
         * 
         */
        public Builder startTime(Integer startTime) {
            return startTime(Output.of(startTime));
        }

        /**
         * @param status enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
         * 
         * @return builder
         * 
         */
        public Builder status(@Nullable Output<String> status) {
            $.status = status;
            return this;
        }

        /**
         * @param status enum: `error`, `inprogress`, `scheduled`, `starting`, `success`
         * 
         * @return builder
         * 
         */
        public Builder status(String status) {
            return status(Output.of(status));
        }

        /**
         * @param syncUpgrade if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
         * 
         * @return builder
         * 
         */
        public Builder syncUpgrade(@Nullable Output<Boolean> syncUpgrade) {
            $.syncUpgrade = syncUpgrade;
            return this;
        }

        /**
         * @param syncUpgrade if set to `false`, the provider will just trigger the upgrade and not wait for the end of the upgrade process. Default is `true`
         * 
         * @return builder
         * 
         */
        public Builder syncUpgrade(Boolean syncUpgrade) {
            return syncUpgrade(Output.of(syncUpgrade));
        }

        /**
         * @param syncUpgradeRefreshInterval if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
         * 
         * @return builder
         * 
         */
        public Builder syncUpgradeRefreshInterval(@Nullable Output<Integer> syncUpgradeRefreshInterval) {
            $.syncUpgradeRefreshInterval = syncUpgradeRefreshInterval;
            return this;
        }

        /**
         * @param syncUpgradeRefreshInterval if set to `syncUpgrade`==`true`, how long to wait between each refresh of the upgrade status, in seconds. Default is 30, minimum is 15
         * 
         * @return builder
         * 
         */
        public Builder syncUpgradeRefreshInterval(Integer syncUpgradeRefreshInterval) {
            return syncUpgradeRefreshInterval(Output.of(syncUpgradeRefreshInterval));
        }

        /**
         * @param syncUpgradeStartTimeout if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
         * 
         * @return builder
         * 
         */
        public Builder syncUpgradeStartTimeout(@Nullable Output<Integer> syncUpgradeStartTimeout) {
            $.syncUpgradeStartTimeout = syncUpgradeStartTimeout;
            return this;
        }

        /**
         * @param syncUpgradeStartTimeout if set to `syncUpgrade`==`true`, how long to wait for the upgrade to start before raising an error, in seconds. Default is 60, minimum is 60
         * 
         * @return builder
         * 
         */
        public Builder syncUpgradeStartTimeout(Integer syncUpgradeStartTimeout) {
            return syncUpgradeStartTimeout(Output.of(syncUpgradeStartTimeout));
        }

        /**
         * @param syncUpgradeTimeout if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
         * 
         * @return builder
         * 
         */
        public Builder syncUpgradeTimeout(@Nullable Output<Integer> syncUpgradeTimeout) {
            $.syncUpgradeTimeout = syncUpgradeTimeout;
            return this;
        }

        /**
         * @param syncUpgradeTimeout if set to `syncUpgrade`==`true`, how long to wait for the upgrade to end before raising an error, in seconds. Default is 1800
         * 
         * @return builder
         * 
         */
        public Builder syncUpgradeTimeout(Integer syncUpgradeTimeout) {
            return syncUpgradeTimeout(Output.of(syncUpgradeTimeout));
        }

        /**
         * @param targetVersion firmware version to deploy to the device. Use the `junipermist.device.getVersions` datasource to get the list of available firmware versions
         * 
         * @return builder
         * 
         */
        public Builder targetVersion(@Nullable Output<String> targetVersion) {
            $.targetVersion = targetVersion;
            return this;
        }

        /**
         * @param targetVersion firmware version to deploy to the device. Use the `junipermist.device.getVersions` datasource to get the list of available firmware versions
         * 
         * @return builder
         * 
         */
        public Builder targetVersion(String targetVersion) {
            return targetVersion(Output.of(targetVersion));
        }

        /**
         * @param timestamp Epoch (seconds)
         * 
         * @return builder
         * 
         */
        public Builder timestamp(@Nullable Output<Double> timestamp) {
            $.timestamp = timestamp;
            return this;
        }

        /**
         * @param timestamp Epoch (seconds)
         * 
         * @return builder
         * 
         */
        public Builder timestamp(Double timestamp) {
            return timestamp(Output.of(timestamp));
        }

        public UpgradeDeviceState build() {
            return $;
        }
    }

}
