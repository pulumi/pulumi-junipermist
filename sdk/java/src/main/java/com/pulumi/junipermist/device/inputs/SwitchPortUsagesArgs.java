// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.device.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.junipermist.device.inputs.SwitchPortUsagesRuleArgs;
import com.pulumi.junipermist.device.inputs.SwitchPortUsagesStormControlArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class SwitchPortUsagesArgs extends com.pulumi.resources.ResourceArgs {

    public static final SwitchPortUsagesArgs Empty = new SwitchPortUsagesArgs();

    /**
     * Only if `mode`==`trunk` whether to trunk all network/vlans
     * 
     */
    @Import(name="allNetworks")
    private @Nullable Output<Boolean> allNetworks;

    /**
     * @return Only if `mode`==`trunk` whether to trunk all network/vlans
     * 
     */
    public Optional<Output<Boolean>> allNetworks() {
        return Optional.ofNullable(this.allNetworks);
    }

    /**
     * Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
     * All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
     * When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
     * 
     */
    @Import(name="allowDhcpd")
    private @Nullable Output<Boolean> allowDhcpd;

    /**
     * @return Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
     * All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
     * When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
     * 
     */
    public Optional<Output<Boolean>> allowDhcpd() {
        return Optional.ofNullable(this.allowDhcpd);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="allowMultipleSupplicants")
    private @Nullable Output<Boolean> allowMultipleSupplicants;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<Boolean>> allowMultipleSupplicants() {
        return Optional.ofNullable(this.allowMultipleSupplicants);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     * 
     */
    @Import(name="bypassAuthWhenServerDown")
    private @Nullable Output<Boolean> bypassAuthWhenServerDown;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     * 
     */
    public Optional<Output<Boolean>> bypassAuthWhenServerDown() {
        return Optional.ofNullable(this.bypassAuthWhenServerDown);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     * 
     */
    @Import(name="bypassAuthWhenServerDownForUnkonwnClient")
    private @Nullable Output<Boolean> bypassAuthWhenServerDownForUnkonwnClient;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     * 
     */
    public Optional<Output<Boolean>> bypassAuthWhenServerDownForUnkonwnClient() {
        return Optional.ofNullable(this.bypassAuthWhenServerDownForUnkonwnClient);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     * 
     */
    @Import(name="disableAutoneg")
    private @Nullable Output<Boolean> disableAutoneg;

    /**
     * @return Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     * 
     */
    public Optional<Output<Boolean>> disableAutoneg() {
        return Optional.ofNullable(this.disableAutoneg);
    }

    /**
     * Only if `mode`!=`dynamic` whether the port is disabled
     * 
     */
    @Import(name="disabled")
    private @Nullable Output<Boolean> disabled;

    /**
     * @return Only if `mode`!=`dynamic` whether the port is disabled
     * 
     */
    public Optional<Output<Boolean>> disabled() {
        return Optional.ofNullable(this.disabled);
    }

    /**
     * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
     * 
     */
    @Import(name="duplex")
    private @Nullable Output<String> duplex;

    /**
     * @return Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
     * 
     */
    public Optional<Output<String>> duplex() {
        return Optional.ofNullable(this.duplex);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     * 
     */
    @Import(name="dynamicVlanNetworks")
    private @Nullable Output<List<String>> dynamicVlanNetworks;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     * 
     */
    public Optional<Output<List<String>>> dynamicVlanNetworks() {
        return Optional.ofNullable(this.dynamicVlanNetworks);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
     * 
     */
    @Import(name="enableMacAuth")
    private @Nullable Output<Boolean> enableMacAuth;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
     * 
     */
    public Optional<Output<Boolean>> enableMacAuth() {
        return Optional.ofNullable(this.enableMacAuth);
    }

    /**
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="enableQos")
    private @Nullable Output<Boolean> enableQos;

    /**
     * @return Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<Boolean>> enableQos() {
        return Optional.ofNullable(this.enableQos);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     * 
     */
    @Import(name="guestNetwork")
    private @Nullable Output<String> guestNetwork;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     * 
     */
    public Optional<Output<String>> guestNetwork() {
        return Optional.ofNullable(this.guestNetwork);
    }

    /**
     * Only if `mode`!=`dynamic` inter_switch_link is used together with &#34;isolation&#34; under networks
     * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    @Import(name="interSwitchLink")
    private @Nullable Output<Boolean> interSwitchLink;

    /**
     * @return Only if `mode`!=`dynamic` inter_switch_link is used together with &#34;isolation&#34; under networks
     * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     * 
     */
    public Optional<Output<Boolean>> interSwitchLink() {
        return Optional.ofNullable(this.interSwitchLink);
    }

    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
     * 
     */
    @Import(name="macAuthOnly")
    private @Nullable Output<Boolean> macAuthOnly;

    /**
     * @return Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
     * 
     */
    public Optional<Output<Boolean>> macAuthOnly() {
        return Optional.ofNullable(this.macAuthOnly);
    }

    /**
     * Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
     * 
     */
    @Import(name="macAuthPreferred")
    private @Nullable Output<Boolean> macAuthPreferred;

    /**
     * @return Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
     * 
     */
    public Optional<Output<Boolean>> macAuthPreferred() {
        return Optional.ofNullable(this.macAuthPreferred);
    }

    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     * 
     */
    @Import(name="macAuthProtocol")
    private @Nullable Output<String> macAuthProtocol;

    /**
     * @return Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     * 
     */
    public Optional<Output<String>> macAuthProtocol() {
        return Optional.ofNullable(this.macAuthProtocol);
    }

    /**
     * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     * 
     */
    @Import(name="macLimit")
    private @Nullable Output<Integer> macLimit;

    /**
     * @return Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     * 
     */
    public Optional<Output<Integer>> macLimit() {
        return Optional.ofNullable(this.macLimit);
    }

    /**
     * `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     * 
     */
    @Import(name="mode")
    private @Nullable Output<String> mode;

    /**
     * @return `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     * 
     */
    public Optional<Output<String>> mode() {
        return Optional.ofNullable(this.mode);
    }

    /**
     * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     * 
     */
    @Import(name="mtu")
    private @Nullable Output<Integer> mtu;

    /**
     * @return Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     * 
     */
    public Optional<Output<Integer>> mtu() {
        return Optional.ofNullable(this.mtu);
    }

    /**
     * Only if `mode`==`trunk`, the list of network/vlans
     * 
     */
    @Import(name="networks")
    private @Nullable Output<List<String>> networks;

    /**
     * @return Only if `mode`==`trunk`, the list of network/vlans
     * 
     */
    public Optional<Output<List<String>>> networks() {
        return Optional.ofNullable(this.networks);
    }

    /**
     * Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     * 
     */
    @Import(name="persistMac")
    private @Nullable Output<Boolean> persistMac;

    /**
     * @return Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     * 
     */
    public Optional<Output<Boolean>> persistMac() {
        return Optional.ofNullable(this.persistMac);
    }

    /**
     * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
     * 
     */
    @Import(name="poeDisabled")
    private @Nullable Output<Boolean> poeDisabled;

    /**
     * @return Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
     * 
     */
    public Optional<Output<Boolean>> poeDisabled() {
        return Optional.ofNullable(this.poeDisabled);
    }

    /**
     * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
     * 
     */
    @Import(name="portAuth")
    private @Nullable Output<String> portAuth;

    /**
     * @return Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
     * 
     */
    public Optional<Output<String>> portAuth() {
        return Optional.ofNullable(this.portAuth);
    }

    /**
     * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
     * 
     */
    @Import(name="portNetwork")
    private @Nullable Output<String> portNetwork;

    /**
     * @return Only if `mode`!=`dynamic` native network/vlan for untagged traffic
     * 
     */
    public Optional<Output<String>> portNetwork() {
        return Optional.ofNullable(this.portNetwork);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
     * 
     */
    @Import(name="reauthInterval")
    private @Nullable Output<Integer> reauthInterval;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
     * 
     */
    public Optional<Output<Integer>> reauthInterval() {
        return Optional.ofNullable(this.reauthInterval);
    }

    /**
     * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
     * 
     */
    @Import(name="resetDefaultWhen")
    private @Nullable Output<String> resetDefaultWhen;

    /**
     * @return Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
     * 
     */
    public Optional<Output<String>> resetDefaultWhen() {
        return Optional.ofNullable(this.resetDefaultWhen);
    }

    /**
     * Only if `mode`==`dynamic`
     * 
     */
    @Import(name="rules")
    private @Nullable Output<List<SwitchPortUsagesRuleArgs>> rules;

    /**
     * @return Only if `mode`==`dynamic`
     * 
     */
    public Optional<Output<List<SwitchPortUsagesRuleArgs>>> rules() {
        return Optional.ofNullable(this.rules);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
     * 
     */
    @Import(name="serverFailNetwork")
    private @Nullable Output<String> serverFailNetwork;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
     * 
     */
    public Optional<Output<String>> serverFailNetwork() {
        return Optional.ofNullable(this.serverFailNetwork);
    }

    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
     * 
     */
    @Import(name="serverRejectNetwork")
    private @Nullable Output<String> serverRejectNetwork;

    /**
     * @return Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
     * 
     */
    public Optional<Output<String>> serverRejectNetwork() {
        return Optional.ofNullable(this.serverRejectNetwork);
    }

    /**
     * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
     * 
     */
    @Import(name="speed")
    private @Nullable Output<String> speed;

    /**
     * @return Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
     * 
     */
    public Optional<Output<String>> speed() {
        return Optional.ofNullable(this.speed);
    }

    /**
     * Switch storm control
     * Only if `mode`!=`dynamic`
     * 
     */
    @Import(name="stormControl")
    private @Nullable Output<SwitchPortUsagesStormControlArgs> stormControl;

    /**
     * @return Switch storm control
     * Only if `mode`!=`dynamic`
     * 
     */
    public Optional<Output<SwitchPortUsagesStormControlArgs>> stormControl() {
        return Optional.ofNullable(this.stormControl);
    }

    /**
     * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
     * 
     */
    @Import(name="stpEdge")
    private @Nullable Output<Boolean> stpEdge;

    /**
     * @return Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
     * 
     */
    public Optional<Output<Boolean>> stpEdge() {
        return Optional.ofNullable(this.stpEdge);
    }

    @Import(name="stpNoRootPort")
    private @Nullable Output<Boolean> stpNoRootPort;

    public Optional<Output<Boolean>> stpNoRootPort() {
        return Optional.ofNullable(this.stpNoRootPort);
    }

    @Import(name="stpP2p")
    private @Nullable Output<Boolean> stpP2p;

    public Optional<Output<Boolean>> stpP2p() {
        return Optional.ofNullable(this.stpP2p);
    }

    /**
     * if this is connected to a vstp network
     * 
     */
    @Import(name="useVstp")
    private @Nullable Output<Boolean> useVstp;

    /**
     * @return if this is connected to a vstp network
     * 
     */
    public Optional<Output<Boolean>> useVstp() {
        return Optional.ofNullable(this.useVstp);
    }

    /**
     * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     * 
     */
    @Import(name="voipNetwork")
    private @Nullable Output<String> voipNetwork;

    /**
     * @return Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     * 
     */
    public Optional<Output<String>> voipNetwork() {
        return Optional.ofNullable(this.voipNetwork);
    }

    private SwitchPortUsagesArgs() {}

    private SwitchPortUsagesArgs(SwitchPortUsagesArgs $) {
        this.allNetworks = $.allNetworks;
        this.allowDhcpd = $.allowDhcpd;
        this.allowMultipleSupplicants = $.allowMultipleSupplicants;
        this.bypassAuthWhenServerDown = $.bypassAuthWhenServerDown;
        this.bypassAuthWhenServerDownForUnkonwnClient = $.bypassAuthWhenServerDownForUnkonwnClient;
        this.description = $.description;
        this.disableAutoneg = $.disableAutoneg;
        this.disabled = $.disabled;
        this.duplex = $.duplex;
        this.dynamicVlanNetworks = $.dynamicVlanNetworks;
        this.enableMacAuth = $.enableMacAuth;
        this.enableQos = $.enableQos;
        this.guestNetwork = $.guestNetwork;
        this.interSwitchLink = $.interSwitchLink;
        this.macAuthOnly = $.macAuthOnly;
        this.macAuthPreferred = $.macAuthPreferred;
        this.macAuthProtocol = $.macAuthProtocol;
        this.macLimit = $.macLimit;
        this.mode = $.mode;
        this.mtu = $.mtu;
        this.networks = $.networks;
        this.persistMac = $.persistMac;
        this.poeDisabled = $.poeDisabled;
        this.portAuth = $.portAuth;
        this.portNetwork = $.portNetwork;
        this.reauthInterval = $.reauthInterval;
        this.resetDefaultWhen = $.resetDefaultWhen;
        this.rules = $.rules;
        this.serverFailNetwork = $.serverFailNetwork;
        this.serverRejectNetwork = $.serverRejectNetwork;
        this.speed = $.speed;
        this.stormControl = $.stormControl;
        this.stpEdge = $.stpEdge;
        this.stpNoRootPort = $.stpNoRootPort;
        this.stpP2p = $.stpP2p;
        this.useVstp = $.useVstp;
        this.voipNetwork = $.voipNetwork;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(SwitchPortUsagesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private SwitchPortUsagesArgs $;

        public Builder() {
            $ = new SwitchPortUsagesArgs();
        }

        public Builder(SwitchPortUsagesArgs defaults) {
            $ = new SwitchPortUsagesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allNetworks Only if `mode`==`trunk` whether to trunk all network/vlans
         * 
         * @return builder
         * 
         */
        public Builder allNetworks(@Nullable Output<Boolean> allNetworks) {
            $.allNetworks = allNetworks;
            return this;
        }

        /**
         * @param allNetworks Only if `mode`==`trunk` whether to trunk all network/vlans
         * 
         * @return builder
         * 
         */
        public Builder allNetworks(Boolean allNetworks) {
            return allNetworks(Output.of(allNetworks));
        }

        /**
         * @param allowDhcpd Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
         * All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
         * When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
         * 
         * @return builder
         * 
         */
        public Builder allowDhcpd(@Nullable Output<Boolean> allowDhcpd) {
            $.allowDhcpd = allowDhcpd;
            return this;
        }

        /**
         * @param allowDhcpd Only if `mode`!=`dynamic`. If DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with.
         * All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
         * When it is not defined, it means using the system&#39;s default setting which depends on whether the port is a access or trunk port.
         * 
         * @return builder
         * 
         */
        public Builder allowDhcpd(Boolean allowDhcpd) {
            return allowDhcpd(Output.of(allowDhcpd));
        }

        /**
         * @param allowMultipleSupplicants Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder allowMultipleSupplicants(@Nullable Output<Boolean> allowMultipleSupplicants) {
            $.allowMultipleSupplicants = allowMultipleSupplicants;
            return this;
        }

        /**
         * @param allowMultipleSupplicants Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder allowMultipleSupplicants(Boolean allowMultipleSupplicants) {
            return allowMultipleSupplicants(Output.of(allowMultipleSupplicants));
        }

        /**
         * @param bypassAuthWhenServerDown Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDown(@Nullable Output<Boolean> bypassAuthWhenServerDown) {
            $.bypassAuthWhenServerDown = bypassAuthWhenServerDown;
            return this;
        }

        /**
         * @param bypassAuthWhenServerDown Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDown(Boolean bypassAuthWhenServerDown) {
            return bypassAuthWhenServerDown(Output.of(bypassAuthWhenServerDown));
        }

        /**
         * @param bypassAuthWhenServerDownForUnkonwnClient Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDownForUnkonwnClient(@Nullable Output<Boolean> bypassAuthWhenServerDownForUnkonwnClient) {
            $.bypassAuthWhenServerDownForUnkonwnClient = bypassAuthWhenServerDownForUnkonwnClient;
            return this;
        }

        /**
         * @param bypassAuthWhenServerDownForUnkonwnClient Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
         * 
         * @return builder
         * 
         */
        public Builder bypassAuthWhenServerDownForUnkonwnClient(Boolean bypassAuthWhenServerDownForUnkonwnClient) {
            return bypassAuthWhenServerDownForUnkonwnClient(Output.of(bypassAuthWhenServerDownForUnkonwnClient));
        }

        /**
         * @param description Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disableAutoneg Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         * 
         * @return builder
         * 
         */
        public Builder disableAutoneg(@Nullable Output<Boolean> disableAutoneg) {
            $.disableAutoneg = disableAutoneg;
            return this;
        }

        /**
         * @param disableAutoneg Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
         * 
         * @return builder
         * 
         */
        public Builder disableAutoneg(Boolean disableAutoneg) {
            return disableAutoneg(Output.of(disableAutoneg));
        }

        /**
         * @param disabled Only if `mode`!=`dynamic` whether the port is disabled
         * 
         * @return builder
         * 
         */
        public Builder disabled(@Nullable Output<Boolean> disabled) {
            $.disabled = disabled;
            return this;
        }

        /**
         * @param disabled Only if `mode`!=`dynamic` whether the port is disabled
         * 
         * @return builder
         * 
         */
        public Builder disabled(Boolean disabled) {
            return disabled(Output.of(disabled));
        }

        /**
         * @param duplex Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         * 
         * @return builder
         * 
         */
        public Builder duplex(@Nullable Output<String> duplex) {
            $.duplex = duplex;
            return this;
        }

        /**
         * @param duplex Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
         * 
         * @return builder
         * 
         */
        public Builder duplex(String duplex) {
            return duplex(Output.of(duplex));
        }

        /**
         * @param dynamicVlanNetworks Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(@Nullable Output<List<String>> dynamicVlanNetworks) {
            $.dynamicVlanNetworks = dynamicVlanNetworks;
            return this;
        }

        /**
         * @param dynamicVlanNetworks Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(List<String> dynamicVlanNetworks) {
            return dynamicVlanNetworks(Output.of(dynamicVlanNetworks));
        }

        /**
         * @param dynamicVlanNetworks Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
         * 
         * @return builder
         * 
         */
        public Builder dynamicVlanNetworks(String... dynamicVlanNetworks) {
            return dynamicVlanNetworks(List.of(dynamicVlanNetworks));
        }

        /**
         * @param enableMacAuth Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
         * 
         * @return builder
         * 
         */
        public Builder enableMacAuth(@Nullable Output<Boolean> enableMacAuth) {
            $.enableMacAuth = enableMacAuth;
            return this;
        }

        /**
         * @param enableMacAuth Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
         * 
         * @return builder
         * 
         */
        public Builder enableMacAuth(Boolean enableMacAuth) {
            return enableMacAuth(Output.of(enableMacAuth));
        }

        /**
         * @param enableQos Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder enableQos(@Nullable Output<Boolean> enableQos) {
            $.enableQos = enableQos;
            return this;
        }

        /**
         * @param enableQos Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder enableQos(Boolean enableQos) {
            return enableQos(Output.of(enableQos));
        }

        /**
         * @param guestNetwork Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         * 
         * @return builder
         * 
         */
        public Builder guestNetwork(@Nullable Output<String> guestNetwork) {
            $.guestNetwork = guestNetwork;
            return this;
        }

        /**
         * @param guestNetwork Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
         * 
         * @return builder
         * 
         */
        public Builder guestNetwork(String guestNetwork) {
            return guestNetwork(Output.of(guestNetwork));
        }

        /**
         * @param interSwitchLink Only if `mode`!=`dynamic` inter_switch_link is used together with &#34;isolation&#34; under networks
         * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interSwitchLink(@Nullable Output<Boolean> interSwitchLink) {
            $.interSwitchLink = interSwitchLink;
            return this;
        }

        /**
         * @param interSwitchLink Only if `mode`!=`dynamic` inter_switch_link is used together with &#34;isolation&#34; under networks
         * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
         * 
         * @return builder
         * 
         */
        public Builder interSwitchLink(Boolean interSwitchLink) {
            return interSwitchLink(Output.of(interSwitchLink));
        }

        /**
         * @param macAuthOnly Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
         * 
         * @return builder
         * 
         */
        public Builder macAuthOnly(@Nullable Output<Boolean> macAuthOnly) {
            $.macAuthOnly = macAuthOnly;
            return this;
        }

        /**
         * @param macAuthOnly Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
         * 
         * @return builder
         * 
         */
        public Builder macAuthOnly(Boolean macAuthOnly) {
            return macAuthOnly(Output.of(macAuthOnly));
        }

        /**
         * @param macAuthPreferred Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
         * 
         * @return builder
         * 
         */
        public Builder macAuthPreferred(@Nullable Output<Boolean> macAuthPreferred) {
            $.macAuthPreferred = macAuthPreferred;
            return this;
        }

        /**
         * @param macAuthPreferred Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.
         * 
         * @return builder
         * 
         */
        public Builder macAuthPreferred(Boolean macAuthPreferred) {
            return macAuthPreferred(Output.of(macAuthPreferred));
        }

        /**
         * @param macAuthProtocol Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         * 
         * @return builder
         * 
         */
        public Builder macAuthProtocol(@Nullable Output<String> macAuthProtocol) {
            $.macAuthProtocol = macAuthProtocol;
            return this;
        }

        /**
         * @param macAuthProtocol Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
         * 
         * @return builder
         * 
         */
        public Builder macAuthProtocol(String macAuthProtocol) {
            return macAuthProtocol(Output.of(macAuthProtocol));
        }

        /**
         * @param macLimit Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         * 
         * @return builder
         * 
         */
        public Builder macLimit(@Nullable Output<Integer> macLimit) {
            $.macLimit = macLimit;
            return this;
        }

        /**
         * @param macLimit Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
         * 
         * @return builder
         * 
         */
        public Builder macLimit(Integer macLimit) {
            return macLimit(Output.of(macLimit));
        }

        /**
         * @param mode `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         * 
         * @return builder
         * 
         */
        public Builder mode(@Nullable Output<String> mode) {
            $.mode = mode;
            return this;
        }

        /**
         * @param mode `mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
         * 
         * @return builder
         * 
         */
        public Builder mode(String mode) {
            return mode(Output.of(mode));
        }

        /**
         * @param mtu Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         * 
         * @return builder
         * 
         */
        public Builder mtu(@Nullable Output<Integer> mtu) {
            $.mtu = mtu;
            return this;
        }

        /**
         * @param mtu Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
         * 
         * @return builder
         * 
         */
        public Builder mtu(Integer mtu) {
            return mtu(Output.of(mtu));
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(@Nullable Output<List<String>> networks) {
            $.networks = networks;
            return this;
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(List<String> networks) {
            return networks(Output.of(networks));
        }

        /**
         * @param networks Only if `mode`==`trunk`, the list of network/vlans
         * 
         * @return builder
         * 
         */
        public Builder networks(String... networks) {
            return networks(List.of(networks));
        }

        /**
         * @param persistMac Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         * 
         * @return builder
         * 
         */
        public Builder persistMac(@Nullable Output<Boolean> persistMac) {
            $.persistMac = persistMac;
            return this;
        }

        /**
         * @param persistMac Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
         * 
         * @return builder
         * 
         */
        public Builder persistMac(Boolean persistMac) {
            return persistMac(Output.of(persistMac));
        }

        /**
         * @param poeDisabled Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         * 
         * @return builder
         * 
         */
        public Builder poeDisabled(@Nullable Output<Boolean> poeDisabled) {
            $.poeDisabled = poeDisabled;
            return this;
        }

        /**
         * @param poeDisabled Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
         * 
         * @return builder
         * 
         */
        public Builder poeDisabled(Boolean poeDisabled) {
            return poeDisabled(Output.of(poeDisabled));
        }

        /**
         * @param portAuth Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         * 
         * @return builder
         * 
         */
        public Builder portAuth(@Nullable Output<String> portAuth) {
            $.portAuth = portAuth;
            return this;
        }

        /**
         * @param portAuth Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
         * 
         * @return builder
         * 
         */
        public Builder portAuth(String portAuth) {
            return portAuth(Output.of(portAuth));
        }

        /**
         * @param portNetwork Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         * 
         * @return builder
         * 
         */
        public Builder portNetwork(@Nullable Output<String> portNetwork) {
            $.portNetwork = portNetwork;
            return this;
        }

        /**
         * @param portNetwork Only if `mode`!=`dynamic` native network/vlan for untagged traffic
         * 
         * @return builder
         * 
         */
        public Builder portNetwork(String portNetwork) {
            return portNetwork(Output.of(portNetwork));
        }

        /**
         * @param reauthInterval Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
         * 
         * @return builder
         * 
         */
        public Builder reauthInterval(@Nullable Output<Integer> reauthInterval) {
            $.reauthInterval = reauthInterval;
            return this;
        }

        /**
         * @param reauthInterval Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
         * 
         * @return builder
         * 
         */
        public Builder reauthInterval(Integer reauthInterval) {
            return reauthInterval(Output.of(reauthInterval));
        }

        /**
         * @param resetDefaultWhen Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
         * 
         * @return builder
         * 
         */
        public Builder resetDefaultWhen(@Nullable Output<String> resetDefaultWhen) {
            $.resetDefaultWhen = resetDefaultWhen;
            return this;
        }

        /**
         * @param resetDefaultWhen Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
         * 
         * @return builder
         * 
         */
        public Builder resetDefaultWhen(String resetDefaultWhen) {
            return resetDefaultWhen(Output.of(resetDefaultWhen));
        }

        /**
         * @param rules Only if `mode`==`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder rules(@Nullable Output<List<SwitchPortUsagesRuleArgs>> rules) {
            $.rules = rules;
            return this;
        }

        /**
         * @param rules Only if `mode`==`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder rules(List<SwitchPortUsagesRuleArgs> rules) {
            return rules(Output.of(rules));
        }

        /**
         * @param rules Only if `mode`==`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder rules(SwitchPortUsagesRuleArgs... rules) {
            return rules(List.of(rules));
        }

        /**
         * @param serverFailNetwork Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
         * 
         * @return builder
         * 
         */
        public Builder serverFailNetwork(@Nullable Output<String> serverFailNetwork) {
            $.serverFailNetwork = serverFailNetwork;
            return this;
        }

        /**
         * @param serverFailNetwork Only if `mode`!=`dynamic` and `port_auth`==`dot1x` sets server fail fallback vlan
         * 
         * @return builder
         * 
         */
        public Builder serverFailNetwork(String serverFailNetwork) {
            return serverFailNetwork(Output.of(serverFailNetwork));
        }

        /**
         * @param serverRejectNetwork Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
         * 
         * @return builder
         * 
         */
        public Builder serverRejectNetwork(@Nullable Output<String> serverRejectNetwork) {
            $.serverRejectNetwork = serverRejectNetwork;
            return this;
        }

        /**
         * @param serverRejectNetwork Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
         * 
         * @return builder
         * 
         */
        public Builder serverRejectNetwork(String serverRejectNetwork) {
            return serverRejectNetwork(Output.of(serverRejectNetwork));
        }

        /**
         * @param speed Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         * 
         * @return builder
         * 
         */
        public Builder speed(@Nullable Output<String> speed) {
            $.speed = speed;
            return this;
        }

        /**
         * @param speed Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`
         * 
         * @return builder
         * 
         */
        public Builder speed(String speed) {
            return speed(Output.of(speed));
        }

        /**
         * @param stormControl Switch storm control
         * Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stormControl(@Nullable Output<SwitchPortUsagesStormControlArgs> stormControl) {
            $.stormControl = stormControl;
            return this;
        }

        /**
         * @param stormControl Switch storm control
         * Only if `mode`!=`dynamic`
         * 
         * @return builder
         * 
         */
        public Builder stormControl(SwitchPortUsagesStormControlArgs stormControl) {
            return stormControl(Output.of(stormControl));
        }

        /**
         * @param stpEdge Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         * 
         * @return builder
         * 
         */
        public Builder stpEdge(@Nullable Output<Boolean> stpEdge) {
            $.stpEdge = stpEdge;
            return this;
        }

        /**
         * @param stpEdge Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
         * 
         * @return builder
         * 
         */
        public Builder stpEdge(Boolean stpEdge) {
            return stpEdge(Output.of(stpEdge));
        }

        public Builder stpNoRootPort(@Nullable Output<Boolean> stpNoRootPort) {
            $.stpNoRootPort = stpNoRootPort;
            return this;
        }

        public Builder stpNoRootPort(Boolean stpNoRootPort) {
            return stpNoRootPort(Output.of(stpNoRootPort));
        }

        public Builder stpP2p(@Nullable Output<Boolean> stpP2p) {
            $.stpP2p = stpP2p;
            return this;
        }

        public Builder stpP2p(Boolean stpP2p) {
            return stpP2p(Output.of(stpP2p));
        }

        /**
         * @param useVstp if this is connected to a vstp network
         * 
         * @return builder
         * 
         */
        public Builder useVstp(@Nullable Output<Boolean> useVstp) {
            $.useVstp = useVstp;
            return this;
        }

        /**
         * @param useVstp if this is connected to a vstp network
         * 
         * @return builder
         * 
         */
        public Builder useVstp(Boolean useVstp) {
            return useVstp(Output.of(useVstp));
        }

        /**
         * @param voipNetwork Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         * 
         * @return builder
         * 
         */
        public Builder voipNetwork(@Nullable Output<String> voipNetwork) {
            $.voipNetwork = voipNetwork;
            return this;
        }

        /**
         * @param voipNetwork Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
         * 
         * @return builder
         * 
         */
        public Builder voipNetwork(String voipNetwork) {
            return voipNetwork(Output.of(voipNetwork));
        }

        public SwitchPortUsagesArgs build() {
            return $;
        }
    }

}
