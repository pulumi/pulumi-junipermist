// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.org;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NactagArgs extends com.pulumi.resources.ResourceArgs {

    public static final NactagArgs Empty = new NactagArgs();

    /**
     * can be set to true to allow the override by usermac result
     * 
     */
    @Import(name="allowUsermacOverride")
    private @Nullable Output<Boolean> allowUsermacOverride;

    /**
     * @return can be set to true to allow the override by usermac result
     * 
     */
    public Optional<Output<Boolean>> allowUsermacOverride() {
        return Optional.ofNullable(this.allowUsermacOverride);
    }

    /**
     * if `type`==`egress_vlan_names`, list of egress vlans to return
     * 
     */
    @Import(name="egressVlanNames")
    private @Nullable Output<List<String>> egressVlanNames;

    /**
     * @return if `type`==`egress_vlan_names`, list of egress vlans to return
     * 
     */
    public Optional<Output<List<String>>> egressVlanNames() {
        return Optional.ofNullable(this.egressVlanNames);
    }

    /**
     * if `type`==`gbp_tag`
     * 
     */
    @Import(name="gbpTag")
    private @Nullable Output<Integer> gbpTag;

    /**
     * @return if `type`==`gbp_tag`
     * 
     */
    public Optional<Output<Integer>> gbpTag() {
        return Optional.ofNullable(this.gbpTag);
    }

    /**
     * if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `client_mac`, `idp_role`,
     * `mdm_status`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
     * 
     */
    @Import(name="match")
    private @Nullable Output<String> match;

    /**
     * @return if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `client_mac`, `idp_role`,
     * `mdm_status`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
     * 
     */
    public Optional<Output<String>> match() {
        return Optional.ofNullable(this.match);
    }

    /**
     * This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
     * match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
     * set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`&#39;
     * 
     */
    @Import(name="matchAll")
    private @Nullable Output<Boolean> matchAll;

    /**
     * @return This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
     * match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
     * set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`&#39;
     * 
     */
    public Optional<Output<Boolean>> matchAll() {
        return Optional.ofNullable(this.matchAll);
    }

    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    @Import(name="orgId", required=true)
    private Output<String> orgId;

    public Output<String> orgId() {
        return this.orgId;
    }

    /**
     * if `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field &#34;radius_attrs&#34;. It is
     * the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
     * that it is allowed to have more than one radius_attrs in the result of a given rule.
     * 
     */
    @Import(name="radiusAttrs")
    private @Nullable Output<List<String>> radiusAttrs;

    /**
     * @return if `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field &#34;radius_attrs&#34;. It is
     * the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
     * that it is allowed to have more than one radius_attrs in the result of a given rule.
     * 
     */
    public Optional<Output<List<String>>> radiusAttrs() {
        return Optional.ofNullable(this.radiusAttrs);
    }

    /**
     * if `type`==`radius_group`
     * 
     */
    @Import(name="radiusGroup")
    private @Nullable Output<String> radiusGroup;

    /**
     * @return if `type`==`radius_group`
     * 
     */
    public Optional<Output<String>> radiusGroup() {
        return Optional.ofNullable(this.radiusGroup);
    }

    /**
     * if `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
     * &#34;radius_vendor_attrs&#34;. It is the responsibility of the user to provide a syntactically correct string, otherwise it may
     * not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
     * 
     */
    @Import(name="radiusVendorAttrs")
    private @Nullable Output<List<String>> radiusVendorAttrs;

    /**
     * @return if `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
     * &#34;radius_vendor_attrs&#34;. It is the responsibility of the user to provide a syntactically correct string, otherwise it may
     * not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
     * 
     */
    public Optional<Output<List<String>>> radiusVendorAttrs() {
        return Optional.ofNullable(this.radiusVendorAttrs);
    }

    /**
     * if `type`==`session_timeout, in seconds
     * 
     */
    @Import(name="sessionTimeout")
    private @Nullable Output<Integer> sessionTimeout;

    /**
     * @return if `type`==`session_timeout, in seconds
     * 
     */
    public Optional<Output<Integer>> sessionTimeout() {
        return Optional.ofNullable(this.sessionTimeout);
    }

    /**
     * enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
     * `vlan`
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
     * `vlan`
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    /**
     * if `type`==`match`
     * 
     */
    @Import(name="values")
    private @Nullable Output<List<String>> values;

    /**
     * @return if `type`==`match`
     * 
     */
    public Optional<Output<List<String>>> values() {
        return Optional.ofNullable(this.values);
    }

    /**
     * if `type`==`vlan`
     * 
     */
    @Import(name="vlan")
    private @Nullable Output<String> vlan;

    /**
     * @return if `type`==`vlan`
     * 
     */
    public Optional<Output<String>> vlan() {
        return Optional.ofNullable(this.vlan);
    }

    private NactagArgs() {}

    private NactagArgs(NactagArgs $) {
        this.allowUsermacOverride = $.allowUsermacOverride;
        this.egressVlanNames = $.egressVlanNames;
        this.gbpTag = $.gbpTag;
        this.match = $.match;
        this.matchAll = $.matchAll;
        this.name = $.name;
        this.orgId = $.orgId;
        this.radiusAttrs = $.radiusAttrs;
        this.radiusGroup = $.radiusGroup;
        this.radiusVendorAttrs = $.radiusVendorAttrs;
        this.sessionTimeout = $.sessionTimeout;
        this.type = $.type;
        this.values = $.values;
        this.vlan = $.vlan;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NactagArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NactagArgs $;

        public Builder() {
            $ = new NactagArgs();
        }

        public Builder(NactagArgs defaults) {
            $ = new NactagArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowUsermacOverride can be set to true to allow the override by usermac result
         * 
         * @return builder
         * 
         */
        public Builder allowUsermacOverride(@Nullable Output<Boolean> allowUsermacOverride) {
            $.allowUsermacOverride = allowUsermacOverride;
            return this;
        }

        /**
         * @param allowUsermacOverride can be set to true to allow the override by usermac result
         * 
         * @return builder
         * 
         */
        public Builder allowUsermacOverride(Boolean allowUsermacOverride) {
            return allowUsermacOverride(Output.of(allowUsermacOverride));
        }

        /**
         * @param egressVlanNames if `type`==`egress_vlan_names`, list of egress vlans to return
         * 
         * @return builder
         * 
         */
        public Builder egressVlanNames(@Nullable Output<List<String>> egressVlanNames) {
            $.egressVlanNames = egressVlanNames;
            return this;
        }

        /**
         * @param egressVlanNames if `type`==`egress_vlan_names`, list of egress vlans to return
         * 
         * @return builder
         * 
         */
        public Builder egressVlanNames(List<String> egressVlanNames) {
            return egressVlanNames(Output.of(egressVlanNames));
        }

        /**
         * @param egressVlanNames if `type`==`egress_vlan_names`, list of egress vlans to return
         * 
         * @return builder
         * 
         */
        public Builder egressVlanNames(String... egressVlanNames) {
            return egressVlanNames(List.of(egressVlanNames));
        }

        /**
         * @param gbpTag if `type`==`gbp_tag`
         * 
         * @return builder
         * 
         */
        public Builder gbpTag(@Nullable Output<Integer> gbpTag) {
            $.gbpTag = gbpTag;
            return this;
        }

        /**
         * @param gbpTag if `type`==`gbp_tag`
         * 
         * @return builder
         * 
         */
        public Builder gbpTag(Integer gbpTag) {
            return gbpTag(Output.of(gbpTag));
        }

        /**
         * @param match if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `client_mac`, `idp_role`,
         * `mdm_status`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
         * 
         * @return builder
         * 
         */
        public Builder match(@Nullable Output<String> match) {
            $.match = match;
            return this;
        }

        /**
         * @param match if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `client_mac`, `idp_role`,
         * `mdm_status`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
         * 
         * @return builder
         * 
         */
        public Builder match(String match) {
            return match(Output.of(match));
        }

        /**
         * @param matchAll This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
         * match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
         * set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`&#39;
         * 
         * @return builder
         * 
         */
        public Builder matchAll(@Nullable Output<Boolean> matchAll) {
            $.matchAll = matchAll;
            return this;
        }

        /**
         * @param matchAll This field is applicable only when `type`==`match` * `false`: means it is sufficient to match any of the values (i.e.,
         * match-any behavior) * `true`: means all values should be matched (i.e., match-all behavior) Currently it makes sense to
         * set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`&#39;
         * 
         * @return builder
         * 
         */
        public Builder matchAll(Boolean matchAll) {
            return matchAll(Output.of(matchAll));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder orgId(Output<String> orgId) {
            $.orgId = orgId;
            return this;
        }

        public Builder orgId(String orgId) {
            return orgId(Output.of(orgId));
        }

        /**
         * @param radiusAttrs if `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field &#34;radius_attrs&#34;. It is
         * the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
         * that it is allowed to have more than one radius_attrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusAttrs(@Nullable Output<List<String>> radiusAttrs) {
            $.radiusAttrs = radiusAttrs;
            return this;
        }

        /**
         * @param radiusAttrs if `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field &#34;radius_attrs&#34;. It is
         * the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
         * that it is allowed to have more than one radius_attrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusAttrs(List<String> radiusAttrs) {
            return radiusAttrs(Output.of(radiusAttrs));
        }

        /**
         * @param radiusAttrs if `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field &#34;radius_attrs&#34;. It is
         * the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected. Note
         * that it is allowed to have more than one radius_attrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusAttrs(String... radiusAttrs) {
            return radiusAttrs(List.of(radiusAttrs));
        }

        /**
         * @param radiusGroup if `type`==`radius_group`
         * 
         * @return builder
         * 
         */
        public Builder radiusGroup(@Nullable Output<String> radiusGroup) {
            $.radiusGroup = radiusGroup;
            return this;
        }

        /**
         * @param radiusGroup if `type`==`radius_group`
         * 
         * @return builder
         * 
         */
        public Builder radiusGroup(String radiusGroup) {
            return radiusGroup(Output.of(radiusGroup));
        }

        /**
         * @param radiusVendorAttrs if `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
         * &#34;radius_vendor_attrs&#34;. It is the responsibility of the user to provide a syntactically correct string, otherwise it may
         * not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusVendorAttrs(@Nullable Output<List<String>> radiusVendorAttrs) {
            $.radiusVendorAttrs = radiusVendorAttrs;
            return this;
        }

        /**
         * @param radiusVendorAttrs if `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
         * &#34;radius_vendor_attrs&#34;. It is the responsibility of the user to provide a syntactically correct string, otherwise it may
         * not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusVendorAttrs(List<String> radiusVendorAttrs) {
            return radiusVendorAttrs(Output.of(radiusVendorAttrs));
        }

        /**
         * @param radiusVendorAttrs if `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field
         * &#34;radius_vendor_attrs&#34;. It is the responsibility of the user to provide a syntactically correct string, otherwise it may
         * not work as expected. Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusVendorAttrs(String... radiusVendorAttrs) {
            return radiusVendorAttrs(List.of(radiusVendorAttrs));
        }

        /**
         * @param sessionTimeout if `type`==`session_timeout, in seconds
         * 
         * @return builder
         * 
         */
        public Builder sessionTimeout(@Nullable Output<Integer> sessionTimeout) {
            $.sessionTimeout = sessionTimeout;
            return this;
        }

        /**
         * @param sessionTimeout if `type`==`session_timeout, in seconds
         * 
         * @return builder
         * 
         */
        public Builder sessionTimeout(Integer sessionTimeout) {
            return sessionTimeout(Output.of(sessionTimeout));
        }

        /**
         * @param type enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
         * `vlan`
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`,
         * `vlan`
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param values if `type`==`match`
         * 
         * @return builder
         * 
         */
        public Builder values(@Nullable Output<List<String>> values) {
            $.values = values;
            return this;
        }

        /**
         * @param values if `type`==`match`
         * 
         * @return builder
         * 
         */
        public Builder values(List<String> values) {
            return values(Output.of(values));
        }

        /**
         * @param values if `type`==`match`
         * 
         * @return builder
         * 
         */
        public Builder values(String... values) {
            return values(List.of(values));
        }

        /**
         * @param vlan if `type`==`vlan`
         * 
         * @return builder
         * 
         */
        public Builder vlan(@Nullable Output<String> vlan) {
            $.vlan = vlan;
            return this;
        }

        /**
         * @param vlan if `type`==`vlan`
         * 
         * @return builder
         * 
         */
        public Builder vlan(String vlan) {
            return vlan(Output.of(vlan));
        }

        public NactagArgs build() {
            if ($.orgId == null) {
                throw new MissingRequiredPropertyException("NactagArgs", "orgId");
            }
            if ($.type == null) {
                throw new MissingRequiredPropertyException("NactagArgs", "type");
            }
            return $;
        }
    }

}
