// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.org;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NactagArgs extends com.pulumi.resources.ResourceArgs {

    public static final NactagArgs Empty = new NactagArgs();

    /**
     * Can be set to true to allow the override by usermac result
     * 
     */
    @Import(name="allowUsermacOverride")
    private @Nullable Output<Boolean> allowUsermacOverride;

    /**
     * @return Can be set to true to allow the override by usermac result
     * 
     */
    public Optional<Output<Boolean>> allowUsermacOverride() {
        return Optional.ofNullable(this.allowUsermacOverride);
    }

    /**
     * If `type`==`egressVlanNames`, list of egress vlans to return
     * 
     */
    @Import(name="egressVlanNames")
    private @Nullable Output<List<String>> egressVlanNames;

    /**
     * @return If `type`==`egressVlanNames`, list of egress vlans to return
     * 
     */
    public Optional<Output<List<String>>> egressVlanNames() {
        return Optional.ofNullable(this.egressVlanNames);
    }

    @Import(name="gbpTag")
    private @Nullable Output<String> gbpTag;

    public Optional<Output<String>> gbpTag() {
        return Optional.ofNullable(this.gbpTag);
    }

    /**
     * if `type`==`match`. enum: `certCn`, `certEku`, `certIssuer`, `certSan`, `certSerial`, `certSub`, `certTemplate`, `clientMac`, `edrStatus`, `gbpTag`, `hostname`, `idpRole`, `ingressVlan`, `mdmStatus`, `nasIp`, `radiusGroup`, `realm`, `ssid`, `userName`, `usermacLabel`
     * 
     */
    @Import(name="match")
    private @Nullable Output<String> match;

    /**
     * @return if `type`==`match`. enum: `certCn`, `certEku`, `certIssuer`, `certSan`, `certSerial`, `certSub`, `certTemplate`, `clientMac`, `edrStatus`, `gbpTag`, `hostname`, `idpRole`, `ingressVlan`, `mdmStatus`, `nasIp`, `radiusGroup`, `realm`, `ssid`, `userName`, `usermacLabel`
     * 
     */
    public Optional<Output<String>> match() {
        return Optional.ofNullable(this.match);
    }

    /**
     * This field is applicable only when `type`==`match`
     *   * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
     *   * `true`: means all values should be matched (i.e., match-all behavior)
     * 
     * Currently it makes sense to set this field to `true` only if the `match`==`idpRole`, `match`==`usermacLabel` and `edrStatus`
     * 
     */
    @Import(name="matchAll")
    private @Nullable Output<Boolean> matchAll;

    /**
     * @return This field is applicable only when `type`==`match`
     *   * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
     *   * `true`: means all values should be matched (i.e., match-all behavior)
     * 
     * Currently it makes sense to set this field to `true` only if the `match`==`idpRole`, `match`==`usermacLabel` and `edrStatus`
     * 
     */
    public Optional<Output<Boolean>> matchAll() {
        return Optional.ofNullable(this.matchAll);
    }

    /**
     * If `type`==`redirectNacportalId`, the ID of the NAC portal to redirect to
     * 
     */
    @Import(name="nacportalId")
    private @Nullable Output<String> nacportalId;

    /**
     * @return If `type`==`redirectNacportalId`, the ID of the NAC portal to redirect to
     * 
     */
    public Optional<Output<String>> nacportalId() {
        return Optional.ofNullable(this.nacportalId);
    }

    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    @Import(name="orgId", required=true)
    private Output<String> orgId;

    public Output<String> orgId() {
        return this.orgId;
    }

    /**
     * If `type`==`radiusAttrs`, user can specify a list of one or more standard attributes in the field &#34;radiusAttrs&#34;.
     * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
     * Note that it is allowed to have more than one radiusAttrs in the result of a given rule.
     * 
     */
    @Import(name="radiusAttrs")
    private @Nullable Output<List<String>> radiusAttrs;

    /**
     * @return If `type`==`radiusAttrs`, user can specify a list of one or more standard attributes in the field &#34;radiusAttrs&#34;.
     * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
     * Note that it is allowed to have more than one radiusAttrs in the result of a given rule.
     * 
     */
    public Optional<Output<List<String>>> radiusAttrs() {
        return Optional.ofNullable(this.radiusAttrs);
    }

    /**
     * If `type`==`radiusGroup`
     * 
     */
    @Import(name="radiusGroup")
    private @Nullable Output<String> radiusGroup;

    /**
     * @return If `type`==`radiusGroup`
     * 
     */
    public Optional<Output<String>> radiusGroup() {
        return Optional.ofNullable(this.radiusGroup);
    }

    /**
     * If `type`==`radiusVendorAttrs`, user can specify a list of one or more vendor-specific attributes in the field &#34;radiusVendorAttrs&#34;.
     * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
     * Note that it is allowed to have more than one radiusVendorAttrs in the result of a given rule.
     * 
     */
    @Import(name="radiusVendorAttrs")
    private @Nullable Output<List<String>> radiusVendorAttrs;

    /**
     * @return If `type`==`radiusVendorAttrs`, user can specify a list of one or more vendor-specific attributes in the field &#34;radiusVendorAttrs&#34;.
     * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
     * Note that it is allowed to have more than one radiusVendorAttrs in the result of a given rule.
     * 
     */
    public Optional<Output<List<String>>> radiusVendorAttrs() {
        return Optional.ofNullable(this.radiusVendorAttrs);
    }

    /**
     * If `type`==`session_timeout, in seconds
     * 
     */
    @Import(name="sessionTimeout")
    private @Nullable Output<Integer> sessionTimeout;

    /**
     * @return If `type`==`session_timeout, in seconds
     * 
     */
    public Optional<Output<Integer>> sessionTimeout() {
        return Optional.ofNullable(this.sessionTimeout);
    }

    /**
     * enum: `egressVlanNames`, `gbpTag`, `match`, `radiusAttrs`, `radiusGroup`, `radiusVendorAttrs`, `redirectNacportalId`, `sessionTimeout`, `usernameAttr`, `vlan`
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return enum: `egressVlanNames`, `gbpTag`, `match`, `radiusAttrs`, `radiusGroup`, `radiusVendorAttrs`, `redirectNacportalId`, `sessionTimeout`, `usernameAttr`, `vlan`
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    /**
     * enum: `automatic`, `cn`, `dns`, `email`, `upn`
     * 
     */
    @Import(name="usernameAttr")
    private @Nullable Output<String> usernameAttr;

    /**
     * @return enum: `automatic`, `cn`, `dns`, `email`, `upn`
     * 
     */
    public Optional<Output<String>> usernameAttr() {
        return Optional.ofNullable(this.usernameAttr);
    }

    /**
     * If `type`==`match`
     * 
     */
    @Import(name="values")
    private @Nullable Output<List<String>> values;

    /**
     * @return If `type`==`match`
     * 
     */
    public Optional<Output<List<String>>> values() {
        return Optional.ofNullable(this.values);
    }

    /**
     * If `type`==`vlan`
     * 
     */
    @Import(name="vlan")
    private @Nullable Output<String> vlan;

    /**
     * @return If `type`==`vlan`
     * 
     */
    public Optional<Output<String>> vlan() {
        return Optional.ofNullable(this.vlan);
    }

    private NactagArgs() {}

    private NactagArgs(NactagArgs $) {
        this.allowUsermacOverride = $.allowUsermacOverride;
        this.egressVlanNames = $.egressVlanNames;
        this.gbpTag = $.gbpTag;
        this.match = $.match;
        this.matchAll = $.matchAll;
        this.nacportalId = $.nacportalId;
        this.name = $.name;
        this.orgId = $.orgId;
        this.radiusAttrs = $.radiusAttrs;
        this.radiusGroup = $.radiusGroup;
        this.radiusVendorAttrs = $.radiusVendorAttrs;
        this.sessionTimeout = $.sessionTimeout;
        this.type = $.type;
        this.usernameAttr = $.usernameAttr;
        this.values = $.values;
        this.vlan = $.vlan;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NactagArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NactagArgs $;

        public Builder() {
            $ = new NactagArgs();
        }

        public Builder(NactagArgs defaults) {
            $ = new NactagArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowUsermacOverride Can be set to true to allow the override by usermac result
         * 
         * @return builder
         * 
         */
        public Builder allowUsermacOverride(@Nullable Output<Boolean> allowUsermacOverride) {
            $.allowUsermacOverride = allowUsermacOverride;
            return this;
        }

        /**
         * @param allowUsermacOverride Can be set to true to allow the override by usermac result
         * 
         * @return builder
         * 
         */
        public Builder allowUsermacOverride(Boolean allowUsermacOverride) {
            return allowUsermacOverride(Output.of(allowUsermacOverride));
        }

        /**
         * @param egressVlanNames If `type`==`egressVlanNames`, list of egress vlans to return
         * 
         * @return builder
         * 
         */
        public Builder egressVlanNames(@Nullable Output<List<String>> egressVlanNames) {
            $.egressVlanNames = egressVlanNames;
            return this;
        }

        /**
         * @param egressVlanNames If `type`==`egressVlanNames`, list of egress vlans to return
         * 
         * @return builder
         * 
         */
        public Builder egressVlanNames(List<String> egressVlanNames) {
            return egressVlanNames(Output.of(egressVlanNames));
        }

        /**
         * @param egressVlanNames If `type`==`egressVlanNames`, list of egress vlans to return
         * 
         * @return builder
         * 
         */
        public Builder egressVlanNames(String... egressVlanNames) {
            return egressVlanNames(List.of(egressVlanNames));
        }

        public Builder gbpTag(@Nullable Output<String> gbpTag) {
            $.gbpTag = gbpTag;
            return this;
        }

        public Builder gbpTag(String gbpTag) {
            return gbpTag(Output.of(gbpTag));
        }

        /**
         * @param match if `type`==`match`. enum: `certCn`, `certEku`, `certIssuer`, `certSan`, `certSerial`, `certSub`, `certTemplate`, `clientMac`, `edrStatus`, `gbpTag`, `hostname`, `idpRole`, `ingressVlan`, `mdmStatus`, `nasIp`, `radiusGroup`, `realm`, `ssid`, `userName`, `usermacLabel`
         * 
         * @return builder
         * 
         */
        public Builder match(@Nullable Output<String> match) {
            $.match = match;
            return this;
        }

        /**
         * @param match if `type`==`match`. enum: `certCn`, `certEku`, `certIssuer`, `certSan`, `certSerial`, `certSub`, `certTemplate`, `clientMac`, `edrStatus`, `gbpTag`, `hostname`, `idpRole`, `ingressVlan`, `mdmStatus`, `nasIp`, `radiusGroup`, `realm`, `ssid`, `userName`, `usermacLabel`
         * 
         * @return builder
         * 
         */
        public Builder match(String match) {
            return match(Output.of(match));
        }

        /**
         * @param matchAll This field is applicable only when `type`==`match`
         *   * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
         *   * `true`: means all values should be matched (i.e., match-all behavior)
         * 
         * Currently it makes sense to set this field to `true` only if the `match`==`idpRole`, `match`==`usermacLabel` and `edrStatus`
         * 
         * @return builder
         * 
         */
        public Builder matchAll(@Nullable Output<Boolean> matchAll) {
            $.matchAll = matchAll;
            return this;
        }

        /**
         * @param matchAll This field is applicable only when `type`==`match`
         *   * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
         *   * `true`: means all values should be matched (i.e., match-all behavior)
         * 
         * Currently it makes sense to set this field to `true` only if the `match`==`idpRole`, `match`==`usermacLabel` and `edrStatus`
         * 
         * @return builder
         * 
         */
        public Builder matchAll(Boolean matchAll) {
            return matchAll(Output.of(matchAll));
        }

        /**
         * @param nacportalId If `type`==`redirectNacportalId`, the ID of the NAC portal to redirect to
         * 
         * @return builder
         * 
         */
        public Builder nacportalId(@Nullable Output<String> nacportalId) {
            $.nacportalId = nacportalId;
            return this;
        }

        /**
         * @param nacportalId If `type`==`redirectNacportalId`, the ID of the NAC portal to redirect to
         * 
         * @return builder
         * 
         */
        public Builder nacportalId(String nacportalId) {
            return nacportalId(Output.of(nacportalId));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder orgId(Output<String> orgId) {
            $.orgId = orgId;
            return this;
        }

        public Builder orgId(String orgId) {
            return orgId(Output.of(orgId));
        }

        /**
         * @param radiusAttrs If `type`==`radiusAttrs`, user can specify a list of one or more standard attributes in the field &#34;radiusAttrs&#34;.
         * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
         * Note that it is allowed to have more than one radiusAttrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusAttrs(@Nullable Output<List<String>> radiusAttrs) {
            $.radiusAttrs = radiusAttrs;
            return this;
        }

        /**
         * @param radiusAttrs If `type`==`radiusAttrs`, user can specify a list of one or more standard attributes in the field &#34;radiusAttrs&#34;.
         * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
         * Note that it is allowed to have more than one radiusAttrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusAttrs(List<String> radiusAttrs) {
            return radiusAttrs(Output.of(radiusAttrs));
        }

        /**
         * @param radiusAttrs If `type`==`radiusAttrs`, user can specify a list of one or more standard attributes in the field &#34;radiusAttrs&#34;.
         * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
         * Note that it is allowed to have more than one radiusAttrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusAttrs(String... radiusAttrs) {
            return radiusAttrs(List.of(radiusAttrs));
        }

        /**
         * @param radiusGroup If `type`==`radiusGroup`
         * 
         * @return builder
         * 
         */
        public Builder radiusGroup(@Nullable Output<String> radiusGroup) {
            $.radiusGroup = radiusGroup;
            return this;
        }

        /**
         * @param radiusGroup If `type`==`radiusGroup`
         * 
         * @return builder
         * 
         */
        public Builder radiusGroup(String radiusGroup) {
            return radiusGroup(Output.of(radiusGroup));
        }

        /**
         * @param radiusVendorAttrs If `type`==`radiusVendorAttrs`, user can specify a list of one or more vendor-specific attributes in the field &#34;radiusVendorAttrs&#34;.
         * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
         * Note that it is allowed to have more than one radiusVendorAttrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusVendorAttrs(@Nullable Output<List<String>> radiusVendorAttrs) {
            $.radiusVendorAttrs = radiusVendorAttrs;
            return this;
        }

        /**
         * @param radiusVendorAttrs If `type`==`radiusVendorAttrs`, user can specify a list of one or more vendor-specific attributes in the field &#34;radiusVendorAttrs&#34;.
         * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
         * Note that it is allowed to have more than one radiusVendorAttrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusVendorAttrs(List<String> radiusVendorAttrs) {
            return radiusVendorAttrs(Output.of(radiusVendorAttrs));
        }

        /**
         * @param radiusVendorAttrs If `type`==`radiusVendorAttrs`, user can specify a list of one or more vendor-specific attributes in the field &#34;radiusVendorAttrs&#34;.
         * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
         * Note that it is allowed to have more than one radiusVendorAttrs in the result of a given rule.
         * 
         * @return builder
         * 
         */
        public Builder radiusVendorAttrs(String... radiusVendorAttrs) {
            return radiusVendorAttrs(List.of(radiusVendorAttrs));
        }

        /**
         * @param sessionTimeout If `type`==`session_timeout, in seconds
         * 
         * @return builder
         * 
         */
        public Builder sessionTimeout(@Nullable Output<Integer> sessionTimeout) {
            $.sessionTimeout = sessionTimeout;
            return this;
        }

        /**
         * @param sessionTimeout If `type`==`session_timeout, in seconds
         * 
         * @return builder
         * 
         */
        public Builder sessionTimeout(Integer sessionTimeout) {
            return sessionTimeout(Output.of(sessionTimeout));
        }

        /**
         * @param type enum: `egressVlanNames`, `gbpTag`, `match`, `radiusAttrs`, `radiusGroup`, `radiusVendorAttrs`, `redirectNacportalId`, `sessionTimeout`, `usernameAttr`, `vlan`
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type enum: `egressVlanNames`, `gbpTag`, `match`, `radiusAttrs`, `radiusGroup`, `radiusVendorAttrs`, `redirectNacportalId`, `sessionTimeout`, `usernameAttr`, `vlan`
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param usernameAttr enum: `automatic`, `cn`, `dns`, `email`, `upn`
         * 
         * @return builder
         * 
         */
        public Builder usernameAttr(@Nullable Output<String> usernameAttr) {
            $.usernameAttr = usernameAttr;
            return this;
        }

        /**
         * @param usernameAttr enum: `automatic`, `cn`, `dns`, `email`, `upn`
         * 
         * @return builder
         * 
         */
        public Builder usernameAttr(String usernameAttr) {
            return usernameAttr(Output.of(usernameAttr));
        }

        /**
         * @param values If `type`==`match`
         * 
         * @return builder
         * 
         */
        public Builder values(@Nullable Output<List<String>> values) {
            $.values = values;
            return this;
        }

        /**
         * @param values If `type`==`match`
         * 
         * @return builder
         * 
         */
        public Builder values(List<String> values) {
            return values(Output.of(values));
        }

        /**
         * @param values If `type`==`match`
         * 
         * @return builder
         * 
         */
        public Builder values(String... values) {
            return values(List.of(values));
        }

        /**
         * @param vlan If `type`==`vlan`
         * 
         * @return builder
         * 
         */
        public Builder vlan(@Nullable Output<String> vlan) {
            $.vlan = vlan;
            return this;
        }

        /**
         * @param vlan If `type`==`vlan`
         * 
         * @return builder
         * 
         */
        public Builder vlan(String vlan) {
            return vlan(Output.of(vlan));
        }

        public NactagArgs build() {
            if ($.orgId == null) {
                throw new MissingRequiredPropertyException("NactagArgs", "orgId");
            }
            if ($.type == null) {
                throw new MissingRequiredPropertyException("NactagArgs", "type");
            }
            return $;
        }
    }

}
