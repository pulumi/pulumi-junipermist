// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.junipermist.site.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanAcctServer;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanAirwatch;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanAppLimit;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanAppQos;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanAuth;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanAuthServer;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanBonjour;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanCiscoCwa;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanCoaServer;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanDnsServerRewrite;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanDynamicPsk;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanDynamicVlan;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanHotspot20;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanInjectDhcpOption82;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanMistNac;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanPortal;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanQos;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanRadsec;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanRateset;
import com.pulumi.junipermist.site.outputs.GetWlansSiteWlanSchedule;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetWlansSiteWlan {
    /**
     * @return enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    private Boolean acctImmediateUpdate;
    /**
     * @return how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     * 
     */
    private Integer acctInterimInterval;
    /**
     * @return list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    private List<GetWlansSiteWlanAcctServer> acctServers;
    /**
     * @return airwatch wlan settings
     * 
     */
    private GetWlansSiteWlanAirwatch airwatch;
    /**
     * @return only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    private Boolean allowIpv6Ndp;
    /**
     * @return only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    private Boolean allowMdns;
    /**
     * @return only applicable when `limit_bcast`==`true`, which allows SSDP
     * 
     */
    private Boolean allowSsdp;
    /**
     * @return list of device ids
     * 
     */
    private List<String> apIds;
    /**
     * @return bandwidth limiting for apps (applies to up/down)
     * 
     */
    private GetWlansSiteWlanAppLimit appLimit;
    /**
     * @return app qos wlan settings
     * 
     */
    private GetWlansSiteWlanAppQos appQos;
    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    private String applyTo;
    /**
     * @return whether to enable smart arp filter
     * 
     */
    private Boolean arpFilter;
    /**
     * @return authentication wlan settings
     * 
     */
    private GetWlansSiteWlanAuth auth;
    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    private String authServerSelection;
    /**
     * @return list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     * 
     */
    private List<GetWlansSiteWlanAuthServer> authServers;
    /**
     * @return optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    private String authServersNasId;
    /**
     * @return optional, NAS-IP-ADDRESS to use
     * 
     */
    private String authServersNasIp;
    /**
     * @return radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.
     * 
     */
    private Integer authServersRetries;
    /**
     * @return radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    private Integer authServersTimeout;
    /**
     * @return whether to enable band_steering, this works only when band==both
     * 
     */
    private Boolean bandSteer;
    /**
     * @return force dual_band capable client to connect to 5G
     * 
     */
    private Boolean bandSteerForceBand5;
    /**
     * @return list of radios that the wlan should apply to.
     * 
     */
    private List<String> bands;
    /**
     * @return whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    private Boolean blockBlacklistClients;
    /**
     * @return bonjour gateway wlan settings
     * 
     */
    private GetWlansSiteWlanBonjour bonjour;
    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    private GetWlansSiteWlanCiscoCwa ciscoCwa;
    /**
     * @return kbps
     * 
     */
    private Integer clientLimitDown;
    /**
     * @return if downlink limiting per-client is enabled
     * 
     */
    private Boolean clientLimitDownEnabled;
    /**
     * @return kbps
     * 
     */
    private Integer clientLimitUp;
    /**
     * @return if uplink limiting per-client is enabled
     * 
     */
    private Boolean clientLimitUpEnabled;
    /**
     * @return list of COA (change of authorization) servers, optional
     * 
     */
    private List<GetWlansSiteWlanCoaServer> coaServers;
    /**
     * @return when the object has been created, in epoch
     * 
     */
    private Double createdTime;
    /**
     * @return some old WLAN drivers may not be compatible
     * 
     */
    private Boolean disable11ax;
    /**
     * @return to disable ht or vht rates
     * 
     */
    private Boolean disableHtVhtRates;
    /**
     * @return whether to disable U-APSD
     * 
     */
    private Boolean disableUapsd;
    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    private Boolean disableV1RoamNotify;
    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    private Boolean disableV2RoamNotify;
    /**
     * @return when any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     * 
     */
    private Boolean disableWhenGatewayUnreachable;
    private Boolean disableWhenMxtunnelDown;
    /**
     * @return whether to disable WMM
     * 
     */
    private Boolean disableWmm;
    /**
     * @return for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    private GetWlansSiteWlanDnsServerRewrite dnsServerRewrite;
    private Integer dtim;
    /**
     * @return for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `auth_servers` is required
     *   * PSK will come from cloud WLC if source is cloud_psks
     *   * default_psk will be used if cloud WLC is not available
     *   * `multi_psk_only` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     * 
     */
    private GetWlansSiteWlanDynamicPsk dynamicPsk;
    /**
     * @return for 802.1x
     * 
     */
    private GetWlansSiteWlanDynamicVlan dynamicVlan;
    /**
     * @return enable AP-AP keycaching via multicast
     * 
     */
    private Boolean enableLocalKeycaching;
    /**
     * @return by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
     * 
     */
    private Boolean enableWirelessBridging;
    /**
     * @return if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless
     * 
     */
    private Boolean enableWirelessBridgingDhcpTracking;
    /**
     * @return if this wlan is enabled
     * 
     */
    private Boolean enabled;
    /**
     * @return if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     * 
     */
    private Boolean fastDot1xTimers;
    /**
     * @return whether to hide SSID in beacon
     * 
     */
    private Boolean hideSsid;
    /**
     * @return include hostname inside IE in AP beacons / probe responses
     * 
     */
    private Boolean hostnameIe;
    /**
     * @return hostspot 2.0 wlan settings
     * 
     */
    private GetWlansSiteWlanHotspot20 hotspot20;
    /**
     * @return Unique ID of the object instance in the Mist Organnization
     * 
     */
    private String id;
    private GetWlansSiteWlanInjectDhcpOption82 injectDhcpOption82;
    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    private String interface_;
    /**
     * @return whether to stop clients to talk to each other
     * 
     */
    private Boolean isolation;
    /**
     * @return if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    private Boolean l2Isolation;
    /**
     * @return legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     * 
     */
    private Boolean legacyOverds;
    /**
     * @return whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    private Boolean limitBcast;
    /**
     * @return limit probe response base on some heuristic rules
     * 
     */
    private Boolean limitProbeResponse;
    /**
     * @return max idle time in seconds
     * 
     */
    private Integer maxIdletime;
    /**
     * @return maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    private Integer maxNumClients;
    private GetWlansSiteWlanMistNac mistNac;
    /**
     * @return when the object has been modified for the last time, in epoch
     * 
     */
    private Double modifiedTime;
    private String mspId;
    /**
     * @return when `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    private List<String> mxtunnelIds;
    /**
     * @return when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    private List<String> mxtunnelNames;
    /**
     * @return whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    private Boolean noStaticDns;
    /**
     * @return whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    private Boolean noStaticIp;
    private String orgId;
    /**
     * @return portal wlan settings
     * 
     */
    private GetWlansSiteWlanPortal portal;
    /**
     * @return list of hostnames without http(s):// (matched by substring)
     * 
     */
    private List<String> portalAllowedHostnames;
    /**
     * @return list of CIDRs
     * 
     */
    private List<String> portalAllowedSubnets;
    /**
     * @return api secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    private String portalApiSecret;
    /**
     * @return list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    private List<String> portalDeniedHostnames;
    /**
     * @return Url of portal background image
     * 
     */
    private String portalImage;
    private String portalSsoUrl;
    private GetWlansSiteWlanQos qos;
    /**
     * @return Radsec settings
     * 
     */
    private GetWlansSiteWlanRadsec radsec;
    /**
     * @return Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    private Map<String,GetWlansSiteWlanRateset> rateset;
    /**
     * @return when different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    private Boolean reconnectClientsWhenRoamingMxcluster;
    /**
     * @return enum: `11r`, `OKC`, `NONE`
     * 
     */
    private String roamMode;
    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    private GetWlansSiteWlanSchedule schedule;
    private String siteId;
    /**
     * @return whether to exclude this WLAN from SLE metrics
     * 
     */
    private Boolean sleExcluded;
    /**
     * @return the name of the SSID
     * 
     */
    private String ssid;
    /**
     * @return if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    private Boolean useEapolV1;
    /**
     * @return if vlan tagging is enabled
     * 
     */
    private Boolean vlanEnabled;
    private String vlanId;
    /**
     * @return if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
     * 
     */
    private List<String> vlanIds;
    /**
     * @return Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     * 
     */
    private Boolean vlanPooling;
    /**
     * @return kbps
     * 
     */
    private Integer wlanLimitDown;
    /**
     * @return if downlink limiting for whole wlan is enabled
     * 
     */
    private Boolean wlanLimitDownEnabled;
    /**
     * @return kbps
     * 
     */
    private Integer wlanLimitUp;
    /**
     * @return if uplink limiting for whole wlan is enabled
     * 
     */
    private Boolean wlanLimitUpEnabled;
    /**
     * @return list of wxtag_ids
     * 
     */
    private List<String> wxtagIds;
    /**
     * @return when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    private String wxtunnelId;
    /**
     * @return when `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    private String wxtunnelRemoteId;

    private GetWlansSiteWlan() {}
    /**
     * @return enable coa-immediate-update and address-change-immediate-update on the access profile.
     * 
     */
    public Boolean acctImmediateUpdate() {
        return this.acctImmediateUpdate;
    }
    /**
     * @return how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     * 
     */
    public Integer acctInterimInterval() {
        return this.acctInterimInterval;
    }
    /**
     * @return list of RADIUS accounting servers, optional, order matters where the first one is treated as primary
     * 
     */
    public List<GetWlansSiteWlanAcctServer> acctServers() {
        return this.acctServers;
    }
    /**
     * @return airwatch wlan settings
     * 
     */
    public GetWlansSiteWlanAirwatch airwatch() {
        return this.airwatch;
    }
    /**
     * @return only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through
     * 
     */
    public Boolean allowIpv6Ndp() {
        return this.allowIpv6Ndp;
    }
    /**
     * @return only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through
     * 
     */
    public Boolean allowMdns() {
        return this.allowMdns;
    }
    /**
     * @return only applicable when `limit_bcast`==`true`, which allows SSDP
     * 
     */
    public Boolean allowSsdp() {
        return this.allowSsdp;
    }
    /**
     * @return list of device ids
     * 
     */
    public List<String> apIds() {
        return this.apIds;
    }
    /**
     * @return bandwidth limiting for apps (applies to up/down)
     * 
     */
    public GetWlansSiteWlanAppLimit appLimit() {
        return this.appLimit;
    }
    /**
     * @return app qos wlan settings
     * 
     */
    public GetWlansSiteWlanAppQos appQos() {
        return this.appQos;
    }
    /**
     * @return enum: `aps`, `site`, `wxtags`
     * 
     */
    public String applyTo() {
        return this.applyTo;
    }
    /**
     * @return whether to enable smart arp filter
     * 
     */
    public Boolean arpFilter() {
        return this.arpFilter;
    }
    /**
     * @return authentication wlan settings
     * 
     */
    public GetWlansSiteWlanAuth auth() {
        return this.auth;
    }
    /**
     * @return When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`
     * 
     */
    public String authServerSelection() {
        return this.authServerSelection;
    }
    /**
     * @return list of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary
     * 
     */
    public List<GetWlansSiteWlanAuthServer> authServers() {
        return this.authServers;
    }
    /**
     * @return optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers
     * 
     */
    public String authServersNasId() {
        return this.authServersNasId;
    }
    /**
     * @return optional, NAS-IP-ADDRESS to use
     * 
     */
    public String authServersNasIp() {
        return this.authServersNasIp;
    }
    /**
     * @return radius auth session retries. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.
     * 
     */
    public Integer authServersRetries() {
        return this.authServersRetries;
    }
    /**
     * @return radius auth session timeout. Following fast timers are set if “fast_dot1x_timers” knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.
     * 
     */
    public Integer authServersTimeout() {
        return this.authServersTimeout;
    }
    /**
     * @return whether to enable band_steering, this works only when band==both
     * 
     */
    public Boolean bandSteer() {
        return this.bandSteer;
    }
    /**
     * @return force dual_band capable client to connect to 5G
     * 
     */
    public Boolean bandSteerForceBand5() {
        return this.bandSteerForceBand5;
    }
    /**
     * @return list of radios that the wlan should apply to.
     * 
     */
    public List<String> bands() {
        return this.bands;
    }
    /**
     * @return whether to block the clients in the blacklist (up to first 256 macs)
     * 
     */
    public Boolean blockBlacklistClients() {
        return this.blockBlacklistClients;
    }
    /**
     * @return bonjour gateway wlan settings
     * 
     */
    public GetWlansSiteWlanBonjour bonjour() {
        return this.bonjour;
    }
    /**
     * @return Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html
     * 
     */
    public GetWlansSiteWlanCiscoCwa ciscoCwa() {
        return this.ciscoCwa;
    }
    /**
     * @return kbps
     * 
     */
    public Integer clientLimitDown() {
        return this.clientLimitDown;
    }
    /**
     * @return if downlink limiting per-client is enabled
     * 
     */
    public Boolean clientLimitDownEnabled() {
        return this.clientLimitDownEnabled;
    }
    /**
     * @return kbps
     * 
     */
    public Integer clientLimitUp() {
        return this.clientLimitUp;
    }
    /**
     * @return if uplink limiting per-client is enabled
     * 
     */
    public Boolean clientLimitUpEnabled() {
        return this.clientLimitUpEnabled;
    }
    /**
     * @return list of COA (change of authorization) servers, optional
     * 
     */
    public List<GetWlansSiteWlanCoaServer> coaServers() {
        return this.coaServers;
    }
    /**
     * @return when the object has been created, in epoch
     * 
     */
    public Double createdTime() {
        return this.createdTime;
    }
    /**
     * @return some old WLAN drivers may not be compatible
     * 
     */
    public Boolean disable11ax() {
        return this.disable11ax;
    }
    /**
     * @return to disable ht or vht rates
     * 
     */
    public Boolean disableHtVhtRates() {
        return this.disableHtVhtRates;
    }
    /**
     * @return whether to disable U-APSD
     * 
     */
    public Boolean disableUapsd() {
        return this.disableUapsd;
    }
    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    public Boolean disableV1RoamNotify() {
        return this.disableV1RoamNotify;
    }
    /**
     * @return disable sending v2 roam notification messages
     * 
     */
    public Boolean disableV2RoamNotify() {
        return this.disableV2RoamNotify;
    }
    /**
     * @return when any of the following is true, this WLAN will be disabled
     *    * cannot get IP
     *    * cannot obtain default gateway
     *    * cannot reach default gateway
     * 
     */
    public Boolean disableWhenGatewayUnreachable() {
        return this.disableWhenGatewayUnreachable;
    }
    public Boolean disableWhenMxtunnelDown() {
        return this.disableWhenMxtunnelDown;
    }
    /**
     * @return whether to disable WMM
     * 
     */
    public Boolean disableWmm() {
        return this.disableWmm;
    }
    /**
     * @return for radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)
     * 
     */
    public GetWlansSiteWlanDnsServerRewrite dnsServerRewrite() {
        return this.dnsServerRewrite;
    }
    public Integer dtim() {
        return this.dtim;
    }
    /**
     * @return for dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)
     *   * PSK will come from RADIUS server
     *   * AP sends client MAC as username ans password (i.e. `enable_mac_auth` is assumed)
     *   * AP sends BSSID:SSID as Caller-Station-ID
     *   * `auth_servers` is required
     *   * PSK will come from cloud WLC if source is cloud_psks
     *   * default_psk will be used if cloud WLC is not available
     *   * `multi_psk_only` and `psk` is ignored
     *   * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)
     * 
     */
    public GetWlansSiteWlanDynamicPsk dynamicPsk() {
        return this.dynamicPsk;
    }
    /**
     * @return for 802.1x
     * 
     */
    public GetWlansSiteWlanDynamicVlan dynamicVlan() {
        return this.dynamicVlan;
    }
    /**
     * @return enable AP-AP keycaching via multicast
     * 
     */
    public Boolean enableLocalKeycaching() {
        return this.enableLocalKeycaching;
    }
    /**
     * @return by default, we&#39;d inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled
     * 
     */
    public Boolean enableWirelessBridging() {
        return this.enableWirelessBridging;
    }
    /**
     * @return if the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless
     * 
     */
    public Boolean enableWirelessBridgingDhcpTracking() {
        return this.enableWirelessBridgingDhcpTracking;
    }
    /**
     * @return if this wlan is enabled
     * 
     */
    public Boolean enabled() {
        return this.enabled;
    }
    /**
     * @return if set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .
     * 
     */
    public Boolean fastDot1xTimers() {
        return this.fastDot1xTimers;
    }
    /**
     * @return whether to hide SSID in beacon
     * 
     */
    public Boolean hideSsid() {
        return this.hideSsid;
    }
    /**
     * @return include hostname inside IE in AP beacons / probe responses
     * 
     */
    public Boolean hostnameIe() {
        return this.hostnameIe;
    }
    /**
     * @return hostspot 2.0 wlan settings
     * 
     */
    public GetWlansSiteWlanHotspot20 hotspot20() {
        return this.hotspot20;
    }
    /**
     * @return Unique ID of the object instance in the Mist Organnization
     * 
     */
    public String id() {
        return this.id;
    }
    public GetWlansSiteWlanInjectDhcpOption82 injectDhcpOption82() {
        return this.injectDhcpOption82;
    }
    /**
     * @return where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`
     * 
     */
    public String interface_() {
        return this.interface_;
    }
    /**
     * @return whether to stop clients to talk to each other
     * 
     */
    public Boolean isolation() {
        return this.isolation;
    }
    /**
     * @return if isolation is enabled, whether to deny clients to talk to L2 on the LAN
     * 
     */
    public Boolean l2Isolation() {
        return this.l2Isolation;
    }
    /**
     * @return legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.
     * 
     */
    public Boolean legacyOverds() {
        return this.legacyOverds;
    }
    /**
     * @return whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)
     * 
     */
    public Boolean limitBcast() {
        return this.limitBcast;
    }
    /**
     * @return limit probe response base on some heuristic rules
     * 
     */
    public Boolean limitProbeResponse() {
        return this.limitProbeResponse;
    }
    /**
     * @return max idle time in seconds
     * 
     */
    public Integer maxIdletime() {
        return this.maxIdletime;
    }
    /**
     * @return maximum number of client connected to the SSID. `0` means unlimited
     * 
     */
    public Integer maxNumClients() {
        return this.maxNumClients;
    }
    public GetWlansSiteWlanMistNac mistNac() {
        return this.mistNac;
    }
    /**
     * @return when the object has been modified for the last time, in epoch
     * 
     */
    public Double modifiedTime() {
        return this.modifiedTime;
    }
    public String mspId() {
        return this.mspId;
    }
    /**
     * @return when `interface`=`mxtunnel`, id of the Mist Tunnel
     * 
     */
    public List<String> mxtunnelIds() {
        return this.mxtunnelIds;
    }
    /**
     * @return when `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting
     * 
     */
    public List<String> mxtunnelNames() {
        return this.mxtunnelNames;
    }
    /**
     * @return whether to only allow client to use DNS that we’ve learned from DHCP response
     * 
     */
    public Boolean noStaticDns() {
        return this.noStaticDns;
    }
    /**
     * @return whether to only allow client that we’ve learned from DHCP exchange to talk
     * 
     */
    public Boolean noStaticIp() {
        return this.noStaticIp;
    }
    public String orgId() {
        return this.orgId;
    }
    /**
     * @return portal wlan settings
     * 
     */
    public GetWlansSiteWlanPortal portal() {
        return this.portal;
    }
    /**
     * @return list of hostnames without http(s):// (matched by substring)
     * 
     */
    public List<String> portalAllowedHostnames() {
        return this.portalAllowedHostnames;
    }
    /**
     * @return list of CIDRs
     * 
     */
    public List<String> portalAllowedSubnets() {
        return this.portalAllowedSubnets;
    }
    /**
     * @return api secret (auto-generated) that can be used to sign guest authorization requests
     * 
     */
    public String portalApiSecret() {
        return this.portalApiSecret;
    }
    /**
     * @return list of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames
     * 
     */
    public List<String> portalDeniedHostnames() {
        return this.portalDeniedHostnames;
    }
    /**
     * @return Url of portal background image
     * 
     */
    public String portalImage() {
        return this.portalImage;
    }
    public String portalSsoUrl() {
        return this.portalSsoUrl;
    }
    public GetWlansSiteWlanQos qos() {
        return this.qos;
    }
    /**
     * @return Radsec settings
     * 
     */
    public GetWlansSiteWlanRadsec radsec() {
        return this.radsec;
    }
    /**
     * @return Property key is the RF band. enum: `24`, `5`, `6`
     * 
     */
    public Map<String,GetWlansSiteWlanRateset> rateset() {
        return this.rateset;
    }
    /**
     * @return when different mxcluster is on different subnet, we&#39;d want to disconnect clients (so they&#39;ll reconnect and get new IPs)
     * 
     */
    public Boolean reconnectClientsWhenRoamingMxcluster() {
        return this.reconnectClientsWhenRoamingMxcluster;
    }
    /**
     * @return enum: `11r`, `OKC`, `NONE`
     * 
     */
    public String roamMode() {
        return this.roamMode;
    }
    /**
     * @return WLAN operating schedule, default is disabled
     * 
     */
    public GetWlansSiteWlanSchedule schedule() {
        return this.schedule;
    }
    public String siteId() {
        return this.siteId;
    }
    /**
     * @return whether to exclude this WLAN from SLE metrics
     * 
     */
    public Boolean sleExcluded() {
        return this.sleExcluded;
    }
    /**
     * @return the name of the SSID
     * 
     */
    public String ssid() {
        return this.ssid;
    }
    /**
     * @return if `auth.type`==’eap’ or ‘psk’, should only be set for legacy client, such as pre-2004, 802.11b devices
     * 
     */
    public Boolean useEapolV1() {
        return this.useEapolV1;
    }
    /**
     * @return if vlan tagging is enabled
     * 
     */
    public Boolean vlanEnabled() {
        return this.vlanEnabled;
    }
    public String vlanId() {
        return this.vlanId;
    }
    /**
     * @return if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool
     * 
     */
    public List<String> vlanIds() {
        return this.vlanIds;
    }
    /**
     * @return Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm
     * 
     */
    public Boolean vlanPooling() {
        return this.vlanPooling;
    }
    /**
     * @return kbps
     * 
     */
    public Integer wlanLimitDown() {
        return this.wlanLimitDown;
    }
    /**
     * @return if downlink limiting for whole wlan is enabled
     * 
     */
    public Boolean wlanLimitDownEnabled() {
        return this.wlanLimitDownEnabled;
    }
    /**
     * @return kbps
     * 
     */
    public Integer wlanLimitUp() {
        return this.wlanLimitUp;
    }
    /**
     * @return if uplink limiting for whole wlan is enabled
     * 
     */
    public Boolean wlanLimitUpEnabled() {
        return this.wlanLimitUpEnabled;
    }
    /**
     * @return list of wxtag_ids
     * 
     */
    public List<String> wxtagIds() {
        return this.wxtagIds;
    }
    /**
     * @return when `interface`=`wxtunnel`, id of the WXLAN Tunnel
     * 
     */
    public String wxtunnelId() {
        return this.wxtunnelId;
    }
    /**
     * @return when `interface`=`wxtunnel`, remote tunnel identifier
     * 
     */
    public String wxtunnelRemoteId() {
        return this.wxtunnelRemoteId;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetWlansSiteWlan defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean acctImmediateUpdate;
        private Integer acctInterimInterval;
        private List<GetWlansSiteWlanAcctServer> acctServers;
        private GetWlansSiteWlanAirwatch airwatch;
        private Boolean allowIpv6Ndp;
        private Boolean allowMdns;
        private Boolean allowSsdp;
        private List<String> apIds;
        private GetWlansSiteWlanAppLimit appLimit;
        private GetWlansSiteWlanAppQos appQos;
        private String applyTo;
        private Boolean arpFilter;
        private GetWlansSiteWlanAuth auth;
        private String authServerSelection;
        private List<GetWlansSiteWlanAuthServer> authServers;
        private String authServersNasId;
        private String authServersNasIp;
        private Integer authServersRetries;
        private Integer authServersTimeout;
        private Boolean bandSteer;
        private Boolean bandSteerForceBand5;
        private List<String> bands;
        private Boolean blockBlacklistClients;
        private GetWlansSiteWlanBonjour bonjour;
        private GetWlansSiteWlanCiscoCwa ciscoCwa;
        private Integer clientLimitDown;
        private Boolean clientLimitDownEnabled;
        private Integer clientLimitUp;
        private Boolean clientLimitUpEnabled;
        private List<GetWlansSiteWlanCoaServer> coaServers;
        private Double createdTime;
        private Boolean disable11ax;
        private Boolean disableHtVhtRates;
        private Boolean disableUapsd;
        private Boolean disableV1RoamNotify;
        private Boolean disableV2RoamNotify;
        private Boolean disableWhenGatewayUnreachable;
        private Boolean disableWhenMxtunnelDown;
        private Boolean disableWmm;
        private GetWlansSiteWlanDnsServerRewrite dnsServerRewrite;
        private Integer dtim;
        private GetWlansSiteWlanDynamicPsk dynamicPsk;
        private GetWlansSiteWlanDynamicVlan dynamicVlan;
        private Boolean enableLocalKeycaching;
        private Boolean enableWirelessBridging;
        private Boolean enableWirelessBridgingDhcpTracking;
        private Boolean enabled;
        private Boolean fastDot1xTimers;
        private Boolean hideSsid;
        private Boolean hostnameIe;
        private GetWlansSiteWlanHotspot20 hotspot20;
        private String id;
        private GetWlansSiteWlanInjectDhcpOption82 injectDhcpOption82;
        private String interface_;
        private Boolean isolation;
        private Boolean l2Isolation;
        private Boolean legacyOverds;
        private Boolean limitBcast;
        private Boolean limitProbeResponse;
        private Integer maxIdletime;
        private Integer maxNumClients;
        private GetWlansSiteWlanMistNac mistNac;
        private Double modifiedTime;
        private String mspId;
        private List<String> mxtunnelIds;
        private List<String> mxtunnelNames;
        private Boolean noStaticDns;
        private Boolean noStaticIp;
        private String orgId;
        private GetWlansSiteWlanPortal portal;
        private List<String> portalAllowedHostnames;
        private List<String> portalAllowedSubnets;
        private String portalApiSecret;
        private List<String> portalDeniedHostnames;
        private String portalImage;
        private String portalSsoUrl;
        private GetWlansSiteWlanQos qos;
        private GetWlansSiteWlanRadsec radsec;
        private Map<String,GetWlansSiteWlanRateset> rateset;
        private Boolean reconnectClientsWhenRoamingMxcluster;
        private String roamMode;
        private GetWlansSiteWlanSchedule schedule;
        private String siteId;
        private Boolean sleExcluded;
        private String ssid;
        private Boolean useEapolV1;
        private Boolean vlanEnabled;
        private String vlanId;
        private List<String> vlanIds;
        private Boolean vlanPooling;
        private Integer wlanLimitDown;
        private Boolean wlanLimitDownEnabled;
        private Integer wlanLimitUp;
        private Boolean wlanLimitUpEnabled;
        private List<String> wxtagIds;
        private String wxtunnelId;
        private String wxtunnelRemoteId;
        public Builder() {}
        public Builder(GetWlansSiteWlan defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.acctImmediateUpdate = defaults.acctImmediateUpdate;
    	      this.acctInterimInterval = defaults.acctInterimInterval;
    	      this.acctServers = defaults.acctServers;
    	      this.airwatch = defaults.airwatch;
    	      this.allowIpv6Ndp = defaults.allowIpv6Ndp;
    	      this.allowMdns = defaults.allowMdns;
    	      this.allowSsdp = defaults.allowSsdp;
    	      this.apIds = defaults.apIds;
    	      this.appLimit = defaults.appLimit;
    	      this.appQos = defaults.appQos;
    	      this.applyTo = defaults.applyTo;
    	      this.arpFilter = defaults.arpFilter;
    	      this.auth = defaults.auth;
    	      this.authServerSelection = defaults.authServerSelection;
    	      this.authServers = defaults.authServers;
    	      this.authServersNasId = defaults.authServersNasId;
    	      this.authServersNasIp = defaults.authServersNasIp;
    	      this.authServersRetries = defaults.authServersRetries;
    	      this.authServersTimeout = defaults.authServersTimeout;
    	      this.bandSteer = defaults.bandSteer;
    	      this.bandSteerForceBand5 = defaults.bandSteerForceBand5;
    	      this.bands = defaults.bands;
    	      this.blockBlacklistClients = defaults.blockBlacklistClients;
    	      this.bonjour = defaults.bonjour;
    	      this.ciscoCwa = defaults.ciscoCwa;
    	      this.clientLimitDown = defaults.clientLimitDown;
    	      this.clientLimitDownEnabled = defaults.clientLimitDownEnabled;
    	      this.clientLimitUp = defaults.clientLimitUp;
    	      this.clientLimitUpEnabled = defaults.clientLimitUpEnabled;
    	      this.coaServers = defaults.coaServers;
    	      this.createdTime = defaults.createdTime;
    	      this.disable11ax = defaults.disable11ax;
    	      this.disableHtVhtRates = defaults.disableHtVhtRates;
    	      this.disableUapsd = defaults.disableUapsd;
    	      this.disableV1RoamNotify = defaults.disableV1RoamNotify;
    	      this.disableV2RoamNotify = defaults.disableV2RoamNotify;
    	      this.disableWhenGatewayUnreachable = defaults.disableWhenGatewayUnreachable;
    	      this.disableWhenMxtunnelDown = defaults.disableWhenMxtunnelDown;
    	      this.disableWmm = defaults.disableWmm;
    	      this.dnsServerRewrite = defaults.dnsServerRewrite;
    	      this.dtim = defaults.dtim;
    	      this.dynamicPsk = defaults.dynamicPsk;
    	      this.dynamicVlan = defaults.dynamicVlan;
    	      this.enableLocalKeycaching = defaults.enableLocalKeycaching;
    	      this.enableWirelessBridging = defaults.enableWirelessBridging;
    	      this.enableWirelessBridgingDhcpTracking = defaults.enableWirelessBridgingDhcpTracking;
    	      this.enabled = defaults.enabled;
    	      this.fastDot1xTimers = defaults.fastDot1xTimers;
    	      this.hideSsid = defaults.hideSsid;
    	      this.hostnameIe = defaults.hostnameIe;
    	      this.hotspot20 = defaults.hotspot20;
    	      this.id = defaults.id;
    	      this.injectDhcpOption82 = defaults.injectDhcpOption82;
    	      this.interface_ = defaults.interface_;
    	      this.isolation = defaults.isolation;
    	      this.l2Isolation = defaults.l2Isolation;
    	      this.legacyOverds = defaults.legacyOverds;
    	      this.limitBcast = defaults.limitBcast;
    	      this.limitProbeResponse = defaults.limitProbeResponse;
    	      this.maxIdletime = defaults.maxIdletime;
    	      this.maxNumClients = defaults.maxNumClients;
    	      this.mistNac = defaults.mistNac;
    	      this.modifiedTime = defaults.modifiedTime;
    	      this.mspId = defaults.mspId;
    	      this.mxtunnelIds = defaults.mxtunnelIds;
    	      this.mxtunnelNames = defaults.mxtunnelNames;
    	      this.noStaticDns = defaults.noStaticDns;
    	      this.noStaticIp = defaults.noStaticIp;
    	      this.orgId = defaults.orgId;
    	      this.portal = defaults.portal;
    	      this.portalAllowedHostnames = defaults.portalAllowedHostnames;
    	      this.portalAllowedSubnets = defaults.portalAllowedSubnets;
    	      this.portalApiSecret = defaults.portalApiSecret;
    	      this.portalDeniedHostnames = defaults.portalDeniedHostnames;
    	      this.portalImage = defaults.portalImage;
    	      this.portalSsoUrl = defaults.portalSsoUrl;
    	      this.qos = defaults.qos;
    	      this.radsec = defaults.radsec;
    	      this.rateset = defaults.rateset;
    	      this.reconnectClientsWhenRoamingMxcluster = defaults.reconnectClientsWhenRoamingMxcluster;
    	      this.roamMode = defaults.roamMode;
    	      this.schedule = defaults.schedule;
    	      this.siteId = defaults.siteId;
    	      this.sleExcluded = defaults.sleExcluded;
    	      this.ssid = defaults.ssid;
    	      this.useEapolV1 = defaults.useEapolV1;
    	      this.vlanEnabled = defaults.vlanEnabled;
    	      this.vlanId = defaults.vlanId;
    	      this.vlanIds = defaults.vlanIds;
    	      this.vlanPooling = defaults.vlanPooling;
    	      this.wlanLimitDown = defaults.wlanLimitDown;
    	      this.wlanLimitDownEnabled = defaults.wlanLimitDownEnabled;
    	      this.wlanLimitUp = defaults.wlanLimitUp;
    	      this.wlanLimitUpEnabled = defaults.wlanLimitUpEnabled;
    	      this.wxtagIds = defaults.wxtagIds;
    	      this.wxtunnelId = defaults.wxtunnelId;
    	      this.wxtunnelRemoteId = defaults.wxtunnelRemoteId;
        }

        @CustomType.Setter
        public Builder acctImmediateUpdate(Boolean acctImmediateUpdate) {
            if (acctImmediateUpdate == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "acctImmediateUpdate");
            }
            this.acctImmediateUpdate = acctImmediateUpdate;
            return this;
        }
        @CustomType.Setter
        public Builder acctInterimInterval(Integer acctInterimInterval) {
            if (acctInterimInterval == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "acctInterimInterval");
            }
            this.acctInterimInterval = acctInterimInterval;
            return this;
        }
        @CustomType.Setter
        public Builder acctServers(List<GetWlansSiteWlanAcctServer> acctServers) {
            if (acctServers == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "acctServers");
            }
            this.acctServers = acctServers;
            return this;
        }
        public Builder acctServers(GetWlansSiteWlanAcctServer... acctServers) {
            return acctServers(List.of(acctServers));
        }
        @CustomType.Setter
        public Builder airwatch(GetWlansSiteWlanAirwatch airwatch) {
            if (airwatch == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "airwatch");
            }
            this.airwatch = airwatch;
            return this;
        }
        @CustomType.Setter
        public Builder allowIpv6Ndp(Boolean allowIpv6Ndp) {
            if (allowIpv6Ndp == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "allowIpv6Ndp");
            }
            this.allowIpv6Ndp = allowIpv6Ndp;
            return this;
        }
        @CustomType.Setter
        public Builder allowMdns(Boolean allowMdns) {
            if (allowMdns == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "allowMdns");
            }
            this.allowMdns = allowMdns;
            return this;
        }
        @CustomType.Setter
        public Builder allowSsdp(Boolean allowSsdp) {
            if (allowSsdp == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "allowSsdp");
            }
            this.allowSsdp = allowSsdp;
            return this;
        }
        @CustomType.Setter
        public Builder apIds(List<String> apIds) {
            if (apIds == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "apIds");
            }
            this.apIds = apIds;
            return this;
        }
        public Builder apIds(String... apIds) {
            return apIds(List.of(apIds));
        }
        @CustomType.Setter
        public Builder appLimit(GetWlansSiteWlanAppLimit appLimit) {
            if (appLimit == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "appLimit");
            }
            this.appLimit = appLimit;
            return this;
        }
        @CustomType.Setter
        public Builder appQos(GetWlansSiteWlanAppQos appQos) {
            if (appQos == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "appQos");
            }
            this.appQos = appQos;
            return this;
        }
        @CustomType.Setter
        public Builder applyTo(String applyTo) {
            if (applyTo == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "applyTo");
            }
            this.applyTo = applyTo;
            return this;
        }
        @CustomType.Setter
        public Builder arpFilter(Boolean arpFilter) {
            if (arpFilter == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "arpFilter");
            }
            this.arpFilter = arpFilter;
            return this;
        }
        @CustomType.Setter
        public Builder auth(GetWlansSiteWlanAuth auth) {
            if (auth == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "auth");
            }
            this.auth = auth;
            return this;
        }
        @CustomType.Setter
        public Builder authServerSelection(String authServerSelection) {
            if (authServerSelection == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "authServerSelection");
            }
            this.authServerSelection = authServerSelection;
            return this;
        }
        @CustomType.Setter
        public Builder authServers(List<GetWlansSiteWlanAuthServer> authServers) {
            if (authServers == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "authServers");
            }
            this.authServers = authServers;
            return this;
        }
        public Builder authServers(GetWlansSiteWlanAuthServer... authServers) {
            return authServers(List.of(authServers));
        }
        @CustomType.Setter
        public Builder authServersNasId(String authServersNasId) {
            if (authServersNasId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "authServersNasId");
            }
            this.authServersNasId = authServersNasId;
            return this;
        }
        @CustomType.Setter
        public Builder authServersNasIp(String authServersNasIp) {
            if (authServersNasIp == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "authServersNasIp");
            }
            this.authServersNasIp = authServersNasIp;
            return this;
        }
        @CustomType.Setter
        public Builder authServersRetries(Integer authServersRetries) {
            if (authServersRetries == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "authServersRetries");
            }
            this.authServersRetries = authServersRetries;
            return this;
        }
        @CustomType.Setter
        public Builder authServersTimeout(Integer authServersTimeout) {
            if (authServersTimeout == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "authServersTimeout");
            }
            this.authServersTimeout = authServersTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder bandSteer(Boolean bandSteer) {
            if (bandSteer == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "bandSteer");
            }
            this.bandSteer = bandSteer;
            return this;
        }
        @CustomType.Setter
        public Builder bandSteerForceBand5(Boolean bandSteerForceBand5) {
            if (bandSteerForceBand5 == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "bandSteerForceBand5");
            }
            this.bandSteerForceBand5 = bandSteerForceBand5;
            return this;
        }
        @CustomType.Setter
        public Builder bands(List<String> bands) {
            if (bands == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "bands");
            }
            this.bands = bands;
            return this;
        }
        public Builder bands(String... bands) {
            return bands(List.of(bands));
        }
        @CustomType.Setter
        public Builder blockBlacklistClients(Boolean blockBlacklistClients) {
            if (blockBlacklistClients == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "blockBlacklistClients");
            }
            this.blockBlacklistClients = blockBlacklistClients;
            return this;
        }
        @CustomType.Setter
        public Builder bonjour(GetWlansSiteWlanBonjour bonjour) {
            if (bonjour == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "bonjour");
            }
            this.bonjour = bonjour;
            return this;
        }
        @CustomType.Setter
        public Builder ciscoCwa(GetWlansSiteWlanCiscoCwa ciscoCwa) {
            if (ciscoCwa == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "ciscoCwa");
            }
            this.ciscoCwa = ciscoCwa;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitDown(Integer clientLimitDown) {
            if (clientLimitDown == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "clientLimitDown");
            }
            this.clientLimitDown = clientLimitDown;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitDownEnabled(Boolean clientLimitDownEnabled) {
            if (clientLimitDownEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "clientLimitDownEnabled");
            }
            this.clientLimitDownEnabled = clientLimitDownEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitUp(Integer clientLimitUp) {
            if (clientLimitUp == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "clientLimitUp");
            }
            this.clientLimitUp = clientLimitUp;
            return this;
        }
        @CustomType.Setter
        public Builder clientLimitUpEnabled(Boolean clientLimitUpEnabled) {
            if (clientLimitUpEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "clientLimitUpEnabled");
            }
            this.clientLimitUpEnabled = clientLimitUpEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder coaServers(List<GetWlansSiteWlanCoaServer> coaServers) {
            if (coaServers == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "coaServers");
            }
            this.coaServers = coaServers;
            return this;
        }
        public Builder coaServers(GetWlansSiteWlanCoaServer... coaServers) {
            return coaServers(List.of(coaServers));
        }
        @CustomType.Setter
        public Builder createdTime(Double createdTime) {
            if (createdTime == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "createdTime");
            }
            this.createdTime = createdTime;
            return this;
        }
        @CustomType.Setter
        public Builder disable11ax(Boolean disable11ax) {
            if (disable11ax == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disable11ax");
            }
            this.disable11ax = disable11ax;
            return this;
        }
        @CustomType.Setter
        public Builder disableHtVhtRates(Boolean disableHtVhtRates) {
            if (disableHtVhtRates == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableHtVhtRates");
            }
            this.disableHtVhtRates = disableHtVhtRates;
            return this;
        }
        @CustomType.Setter
        public Builder disableUapsd(Boolean disableUapsd) {
            if (disableUapsd == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableUapsd");
            }
            this.disableUapsd = disableUapsd;
            return this;
        }
        @CustomType.Setter
        public Builder disableV1RoamNotify(Boolean disableV1RoamNotify) {
            if (disableV1RoamNotify == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableV1RoamNotify");
            }
            this.disableV1RoamNotify = disableV1RoamNotify;
            return this;
        }
        @CustomType.Setter
        public Builder disableV2RoamNotify(Boolean disableV2RoamNotify) {
            if (disableV2RoamNotify == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableV2RoamNotify");
            }
            this.disableV2RoamNotify = disableV2RoamNotify;
            return this;
        }
        @CustomType.Setter
        public Builder disableWhenGatewayUnreachable(Boolean disableWhenGatewayUnreachable) {
            if (disableWhenGatewayUnreachable == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableWhenGatewayUnreachable");
            }
            this.disableWhenGatewayUnreachable = disableWhenGatewayUnreachable;
            return this;
        }
        @CustomType.Setter
        public Builder disableWhenMxtunnelDown(Boolean disableWhenMxtunnelDown) {
            if (disableWhenMxtunnelDown == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableWhenMxtunnelDown");
            }
            this.disableWhenMxtunnelDown = disableWhenMxtunnelDown;
            return this;
        }
        @CustomType.Setter
        public Builder disableWmm(Boolean disableWmm) {
            if (disableWmm == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "disableWmm");
            }
            this.disableWmm = disableWmm;
            return this;
        }
        @CustomType.Setter
        public Builder dnsServerRewrite(GetWlansSiteWlanDnsServerRewrite dnsServerRewrite) {
            if (dnsServerRewrite == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "dnsServerRewrite");
            }
            this.dnsServerRewrite = dnsServerRewrite;
            return this;
        }
        @CustomType.Setter
        public Builder dtim(Integer dtim) {
            if (dtim == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "dtim");
            }
            this.dtim = dtim;
            return this;
        }
        @CustomType.Setter
        public Builder dynamicPsk(GetWlansSiteWlanDynamicPsk dynamicPsk) {
            if (dynamicPsk == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "dynamicPsk");
            }
            this.dynamicPsk = dynamicPsk;
            return this;
        }
        @CustomType.Setter
        public Builder dynamicVlan(GetWlansSiteWlanDynamicVlan dynamicVlan) {
            if (dynamicVlan == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "dynamicVlan");
            }
            this.dynamicVlan = dynamicVlan;
            return this;
        }
        @CustomType.Setter
        public Builder enableLocalKeycaching(Boolean enableLocalKeycaching) {
            if (enableLocalKeycaching == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "enableLocalKeycaching");
            }
            this.enableLocalKeycaching = enableLocalKeycaching;
            return this;
        }
        @CustomType.Setter
        public Builder enableWirelessBridging(Boolean enableWirelessBridging) {
            if (enableWirelessBridging == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "enableWirelessBridging");
            }
            this.enableWirelessBridging = enableWirelessBridging;
            return this;
        }
        @CustomType.Setter
        public Builder enableWirelessBridgingDhcpTracking(Boolean enableWirelessBridgingDhcpTracking) {
            if (enableWirelessBridgingDhcpTracking == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "enableWirelessBridgingDhcpTracking");
            }
            this.enableWirelessBridgingDhcpTracking = enableWirelessBridgingDhcpTracking;
            return this;
        }
        @CustomType.Setter
        public Builder enabled(Boolean enabled) {
            if (enabled == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "enabled");
            }
            this.enabled = enabled;
            return this;
        }
        @CustomType.Setter
        public Builder fastDot1xTimers(Boolean fastDot1xTimers) {
            if (fastDot1xTimers == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "fastDot1xTimers");
            }
            this.fastDot1xTimers = fastDot1xTimers;
            return this;
        }
        @CustomType.Setter
        public Builder hideSsid(Boolean hideSsid) {
            if (hideSsid == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "hideSsid");
            }
            this.hideSsid = hideSsid;
            return this;
        }
        @CustomType.Setter
        public Builder hostnameIe(Boolean hostnameIe) {
            if (hostnameIe == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "hostnameIe");
            }
            this.hostnameIe = hostnameIe;
            return this;
        }
        @CustomType.Setter
        public Builder hotspot20(GetWlansSiteWlanHotspot20 hotspot20) {
            if (hotspot20 == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "hotspot20");
            }
            this.hotspot20 = hotspot20;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder injectDhcpOption82(GetWlansSiteWlanInjectDhcpOption82 injectDhcpOption82) {
            if (injectDhcpOption82 == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "injectDhcpOption82");
            }
            this.injectDhcpOption82 = injectDhcpOption82;
            return this;
        }
        @CustomType.Setter("interface")
        public Builder interface_(String interface_) {
            if (interface_ == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "interface_");
            }
            this.interface_ = interface_;
            return this;
        }
        @CustomType.Setter
        public Builder isolation(Boolean isolation) {
            if (isolation == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "isolation");
            }
            this.isolation = isolation;
            return this;
        }
        @CustomType.Setter
        public Builder l2Isolation(Boolean l2Isolation) {
            if (l2Isolation == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "l2Isolation");
            }
            this.l2Isolation = l2Isolation;
            return this;
        }
        @CustomType.Setter
        public Builder legacyOverds(Boolean legacyOverds) {
            if (legacyOverds == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "legacyOverds");
            }
            this.legacyOverds = legacyOverds;
            return this;
        }
        @CustomType.Setter
        public Builder limitBcast(Boolean limitBcast) {
            if (limitBcast == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "limitBcast");
            }
            this.limitBcast = limitBcast;
            return this;
        }
        @CustomType.Setter
        public Builder limitProbeResponse(Boolean limitProbeResponse) {
            if (limitProbeResponse == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "limitProbeResponse");
            }
            this.limitProbeResponse = limitProbeResponse;
            return this;
        }
        @CustomType.Setter
        public Builder maxIdletime(Integer maxIdletime) {
            if (maxIdletime == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "maxIdletime");
            }
            this.maxIdletime = maxIdletime;
            return this;
        }
        @CustomType.Setter
        public Builder maxNumClients(Integer maxNumClients) {
            if (maxNumClients == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "maxNumClients");
            }
            this.maxNumClients = maxNumClients;
            return this;
        }
        @CustomType.Setter
        public Builder mistNac(GetWlansSiteWlanMistNac mistNac) {
            if (mistNac == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "mistNac");
            }
            this.mistNac = mistNac;
            return this;
        }
        @CustomType.Setter
        public Builder modifiedTime(Double modifiedTime) {
            if (modifiedTime == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "modifiedTime");
            }
            this.modifiedTime = modifiedTime;
            return this;
        }
        @CustomType.Setter
        public Builder mspId(String mspId) {
            if (mspId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "mspId");
            }
            this.mspId = mspId;
            return this;
        }
        @CustomType.Setter
        public Builder mxtunnelIds(List<String> mxtunnelIds) {
            if (mxtunnelIds == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "mxtunnelIds");
            }
            this.mxtunnelIds = mxtunnelIds;
            return this;
        }
        public Builder mxtunnelIds(String... mxtunnelIds) {
            return mxtunnelIds(List.of(mxtunnelIds));
        }
        @CustomType.Setter
        public Builder mxtunnelNames(List<String> mxtunnelNames) {
            if (mxtunnelNames == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "mxtunnelNames");
            }
            this.mxtunnelNames = mxtunnelNames;
            return this;
        }
        public Builder mxtunnelNames(String... mxtunnelNames) {
            return mxtunnelNames(List.of(mxtunnelNames));
        }
        @CustomType.Setter
        public Builder noStaticDns(Boolean noStaticDns) {
            if (noStaticDns == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "noStaticDns");
            }
            this.noStaticDns = noStaticDns;
            return this;
        }
        @CustomType.Setter
        public Builder noStaticIp(Boolean noStaticIp) {
            if (noStaticIp == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "noStaticIp");
            }
            this.noStaticIp = noStaticIp;
            return this;
        }
        @CustomType.Setter
        public Builder orgId(String orgId) {
            if (orgId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "orgId");
            }
            this.orgId = orgId;
            return this;
        }
        @CustomType.Setter
        public Builder portal(GetWlansSiteWlanPortal portal) {
            if (portal == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portal");
            }
            this.portal = portal;
            return this;
        }
        @CustomType.Setter
        public Builder portalAllowedHostnames(List<String> portalAllowedHostnames) {
            if (portalAllowedHostnames == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portalAllowedHostnames");
            }
            this.portalAllowedHostnames = portalAllowedHostnames;
            return this;
        }
        public Builder portalAllowedHostnames(String... portalAllowedHostnames) {
            return portalAllowedHostnames(List.of(portalAllowedHostnames));
        }
        @CustomType.Setter
        public Builder portalAllowedSubnets(List<String> portalAllowedSubnets) {
            if (portalAllowedSubnets == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portalAllowedSubnets");
            }
            this.portalAllowedSubnets = portalAllowedSubnets;
            return this;
        }
        public Builder portalAllowedSubnets(String... portalAllowedSubnets) {
            return portalAllowedSubnets(List.of(portalAllowedSubnets));
        }
        @CustomType.Setter
        public Builder portalApiSecret(String portalApiSecret) {
            if (portalApiSecret == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portalApiSecret");
            }
            this.portalApiSecret = portalApiSecret;
            return this;
        }
        @CustomType.Setter
        public Builder portalDeniedHostnames(List<String> portalDeniedHostnames) {
            if (portalDeniedHostnames == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portalDeniedHostnames");
            }
            this.portalDeniedHostnames = portalDeniedHostnames;
            return this;
        }
        public Builder portalDeniedHostnames(String... portalDeniedHostnames) {
            return portalDeniedHostnames(List.of(portalDeniedHostnames));
        }
        @CustomType.Setter
        public Builder portalImage(String portalImage) {
            if (portalImage == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portalImage");
            }
            this.portalImage = portalImage;
            return this;
        }
        @CustomType.Setter
        public Builder portalSsoUrl(String portalSsoUrl) {
            if (portalSsoUrl == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "portalSsoUrl");
            }
            this.portalSsoUrl = portalSsoUrl;
            return this;
        }
        @CustomType.Setter
        public Builder qos(GetWlansSiteWlanQos qos) {
            if (qos == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "qos");
            }
            this.qos = qos;
            return this;
        }
        @CustomType.Setter
        public Builder radsec(GetWlansSiteWlanRadsec radsec) {
            if (radsec == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "radsec");
            }
            this.radsec = radsec;
            return this;
        }
        @CustomType.Setter
        public Builder rateset(Map<String,GetWlansSiteWlanRateset> rateset) {
            if (rateset == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "rateset");
            }
            this.rateset = rateset;
            return this;
        }
        @CustomType.Setter
        public Builder reconnectClientsWhenRoamingMxcluster(Boolean reconnectClientsWhenRoamingMxcluster) {
            if (reconnectClientsWhenRoamingMxcluster == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "reconnectClientsWhenRoamingMxcluster");
            }
            this.reconnectClientsWhenRoamingMxcluster = reconnectClientsWhenRoamingMxcluster;
            return this;
        }
        @CustomType.Setter
        public Builder roamMode(String roamMode) {
            if (roamMode == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "roamMode");
            }
            this.roamMode = roamMode;
            return this;
        }
        @CustomType.Setter
        public Builder schedule(GetWlansSiteWlanSchedule schedule) {
            if (schedule == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "schedule");
            }
            this.schedule = schedule;
            return this;
        }
        @CustomType.Setter
        public Builder siteId(String siteId) {
            if (siteId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "siteId");
            }
            this.siteId = siteId;
            return this;
        }
        @CustomType.Setter
        public Builder sleExcluded(Boolean sleExcluded) {
            if (sleExcluded == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "sleExcluded");
            }
            this.sleExcluded = sleExcluded;
            return this;
        }
        @CustomType.Setter
        public Builder ssid(String ssid) {
            if (ssid == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "ssid");
            }
            this.ssid = ssid;
            return this;
        }
        @CustomType.Setter
        public Builder useEapolV1(Boolean useEapolV1) {
            if (useEapolV1 == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "useEapolV1");
            }
            this.useEapolV1 = useEapolV1;
            return this;
        }
        @CustomType.Setter
        public Builder vlanEnabled(Boolean vlanEnabled) {
            if (vlanEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "vlanEnabled");
            }
            this.vlanEnabled = vlanEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder vlanId(String vlanId) {
            if (vlanId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "vlanId");
            }
            this.vlanId = vlanId;
            return this;
        }
        @CustomType.Setter
        public Builder vlanIds(List<String> vlanIds) {
            if (vlanIds == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "vlanIds");
            }
            this.vlanIds = vlanIds;
            return this;
        }
        public Builder vlanIds(String... vlanIds) {
            return vlanIds(List.of(vlanIds));
        }
        @CustomType.Setter
        public Builder vlanPooling(Boolean vlanPooling) {
            if (vlanPooling == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "vlanPooling");
            }
            this.vlanPooling = vlanPooling;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitDown(Integer wlanLimitDown) {
            if (wlanLimitDown == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wlanLimitDown");
            }
            this.wlanLimitDown = wlanLimitDown;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitDownEnabled(Boolean wlanLimitDownEnabled) {
            if (wlanLimitDownEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wlanLimitDownEnabled");
            }
            this.wlanLimitDownEnabled = wlanLimitDownEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitUp(Integer wlanLimitUp) {
            if (wlanLimitUp == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wlanLimitUp");
            }
            this.wlanLimitUp = wlanLimitUp;
            return this;
        }
        @CustomType.Setter
        public Builder wlanLimitUpEnabled(Boolean wlanLimitUpEnabled) {
            if (wlanLimitUpEnabled == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wlanLimitUpEnabled");
            }
            this.wlanLimitUpEnabled = wlanLimitUpEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder wxtagIds(List<String> wxtagIds) {
            if (wxtagIds == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wxtagIds");
            }
            this.wxtagIds = wxtagIds;
            return this;
        }
        public Builder wxtagIds(String... wxtagIds) {
            return wxtagIds(List.of(wxtagIds));
        }
        @CustomType.Setter
        public Builder wxtunnelId(String wxtunnelId) {
            if (wxtunnelId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wxtunnelId");
            }
            this.wxtunnelId = wxtunnelId;
            return this;
        }
        @CustomType.Setter
        public Builder wxtunnelRemoteId(String wxtunnelRemoteId) {
            if (wxtunnelRemoteId == null) {
              throw new MissingRequiredPropertyException("GetWlansSiteWlan", "wxtunnelRemoteId");
            }
            this.wxtunnelRemoteId = wxtunnelRemoteId;
            return this;
        }
        public GetWlansSiteWlan build() {
            final var _resultValue = new GetWlansSiteWlan();
            _resultValue.acctImmediateUpdate = acctImmediateUpdate;
            _resultValue.acctInterimInterval = acctInterimInterval;
            _resultValue.acctServers = acctServers;
            _resultValue.airwatch = airwatch;
            _resultValue.allowIpv6Ndp = allowIpv6Ndp;
            _resultValue.allowMdns = allowMdns;
            _resultValue.allowSsdp = allowSsdp;
            _resultValue.apIds = apIds;
            _resultValue.appLimit = appLimit;
            _resultValue.appQos = appQos;
            _resultValue.applyTo = applyTo;
            _resultValue.arpFilter = arpFilter;
            _resultValue.auth = auth;
            _resultValue.authServerSelection = authServerSelection;
            _resultValue.authServers = authServers;
            _resultValue.authServersNasId = authServersNasId;
            _resultValue.authServersNasIp = authServersNasIp;
            _resultValue.authServersRetries = authServersRetries;
            _resultValue.authServersTimeout = authServersTimeout;
            _resultValue.bandSteer = bandSteer;
            _resultValue.bandSteerForceBand5 = bandSteerForceBand5;
            _resultValue.bands = bands;
            _resultValue.blockBlacklistClients = blockBlacklistClients;
            _resultValue.bonjour = bonjour;
            _resultValue.ciscoCwa = ciscoCwa;
            _resultValue.clientLimitDown = clientLimitDown;
            _resultValue.clientLimitDownEnabled = clientLimitDownEnabled;
            _resultValue.clientLimitUp = clientLimitUp;
            _resultValue.clientLimitUpEnabled = clientLimitUpEnabled;
            _resultValue.coaServers = coaServers;
            _resultValue.createdTime = createdTime;
            _resultValue.disable11ax = disable11ax;
            _resultValue.disableHtVhtRates = disableHtVhtRates;
            _resultValue.disableUapsd = disableUapsd;
            _resultValue.disableV1RoamNotify = disableV1RoamNotify;
            _resultValue.disableV2RoamNotify = disableV2RoamNotify;
            _resultValue.disableWhenGatewayUnreachable = disableWhenGatewayUnreachable;
            _resultValue.disableWhenMxtunnelDown = disableWhenMxtunnelDown;
            _resultValue.disableWmm = disableWmm;
            _resultValue.dnsServerRewrite = dnsServerRewrite;
            _resultValue.dtim = dtim;
            _resultValue.dynamicPsk = dynamicPsk;
            _resultValue.dynamicVlan = dynamicVlan;
            _resultValue.enableLocalKeycaching = enableLocalKeycaching;
            _resultValue.enableWirelessBridging = enableWirelessBridging;
            _resultValue.enableWirelessBridgingDhcpTracking = enableWirelessBridgingDhcpTracking;
            _resultValue.enabled = enabled;
            _resultValue.fastDot1xTimers = fastDot1xTimers;
            _resultValue.hideSsid = hideSsid;
            _resultValue.hostnameIe = hostnameIe;
            _resultValue.hotspot20 = hotspot20;
            _resultValue.id = id;
            _resultValue.injectDhcpOption82 = injectDhcpOption82;
            _resultValue.interface_ = interface_;
            _resultValue.isolation = isolation;
            _resultValue.l2Isolation = l2Isolation;
            _resultValue.legacyOverds = legacyOverds;
            _resultValue.limitBcast = limitBcast;
            _resultValue.limitProbeResponse = limitProbeResponse;
            _resultValue.maxIdletime = maxIdletime;
            _resultValue.maxNumClients = maxNumClients;
            _resultValue.mistNac = mistNac;
            _resultValue.modifiedTime = modifiedTime;
            _resultValue.mspId = mspId;
            _resultValue.mxtunnelIds = mxtunnelIds;
            _resultValue.mxtunnelNames = mxtunnelNames;
            _resultValue.noStaticDns = noStaticDns;
            _resultValue.noStaticIp = noStaticIp;
            _resultValue.orgId = orgId;
            _resultValue.portal = portal;
            _resultValue.portalAllowedHostnames = portalAllowedHostnames;
            _resultValue.portalAllowedSubnets = portalAllowedSubnets;
            _resultValue.portalApiSecret = portalApiSecret;
            _resultValue.portalDeniedHostnames = portalDeniedHostnames;
            _resultValue.portalImage = portalImage;
            _resultValue.portalSsoUrl = portalSsoUrl;
            _resultValue.qos = qos;
            _resultValue.radsec = radsec;
            _resultValue.rateset = rateset;
            _resultValue.reconnectClientsWhenRoamingMxcluster = reconnectClientsWhenRoamingMxcluster;
            _resultValue.roamMode = roamMode;
            _resultValue.schedule = schedule;
            _resultValue.siteId = siteId;
            _resultValue.sleExcluded = sleExcluded;
            _resultValue.ssid = ssid;
            _resultValue.useEapolV1 = useEapolV1;
            _resultValue.vlanEnabled = vlanEnabled;
            _resultValue.vlanId = vlanId;
            _resultValue.vlanIds = vlanIds;
            _resultValue.vlanPooling = vlanPooling;
            _resultValue.wlanLimitDown = wlanLimitDown;
            _resultValue.wlanLimitDownEnabled = wlanLimitDownEnabled;
            _resultValue.wlanLimitUp = wlanLimitUp;
            _resultValue.wlanLimitUpEnabled = wlanLimitUpEnabled;
            _resultValue.wxtagIds = wxtagIds;
            _resultValue.wxtunnelId = wxtunnelId;
            _resultValue.wxtunnelRemoteId = wxtunnelRemoteId;
            return _resultValue;
        }
    }
}
